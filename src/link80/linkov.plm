$xref
/*	Copyright (c) 2012 by Mark Ogden
	Released into the public domain for academic historic interest
	only and not for commercial gain. */
linkovl: DO;
$include(linkov.ipx)

DECLARE COPYRIGHT(*) BYTE DATA('(C) 1976, 1977, 1979 INTEL CORP');
DECLARE OVERLAYVERSION(*) BYTE PUBLIC DATA('V3.0');
DECLARE zero ADDRESS DATA(0);
DECLARE fakeModhdr(1) BYTE DATA(6);
DECLARE space BYTE DATA(' ');

DECLARE msgrefin(*) BYTE PUBLIC INITIAL(' - REFERENCED IN ');

DECLARE modName(32) BYTE PUBLIC,
	ancestorNameNotSet BYTE,
	fixType BYTE,
	segIdx BYTE,
	pad(3) BYTE,
	segId ADDRESS,
	outRelocOffset ADDRESS,
	extMap$p ADDRESS INITIAL(0),
	externsCount ADDRESS INITIAL(0),
	externsBase ADDRESS INITIAL(0),
	externsEnd ADDRESS INITIAL(0),
	haveTmpFile BYTE INITIAL(0),
	outRecord$p ADDRESS PUBLIC;

/* based types to get to input and output record start info */
DECLARE	inRecord BASED inRecord$p STRUCTURE (type BYTE, len ADDRESS, rec(1) BYTE);
DECLARE outRecord BASED outRecord$p STRUCTURE(type BYTE, len ADDRESS, rec(1) BYTE);
/* generic based type to map to OMF style name at current location in input and output records */
DECLARE inOMFName BASED in$p STRUCTURE (len BYTE, name(1) BYTE);
DECLARE outOMFName BASED out$p STRUCTURE (len BYTE, name(1) BYTE);


seekExtMap: PROCEDURE PUBLIC;
	DECLARE blk ADDRESS;

	blk = SHR(externsBase, 6);	/* divide 64 as each entry is a word */
	CALL seek(tmpfilefd, 2, .blk, .zero, .statusIO);
	CALL errChkReport(statusIO, .linkTmpFile(1), TRUE);
END seekExtMap;

pageOutExtMap: PROCEDURE PUBLIC;
	IF externsBase >= externsEnd THEN	/* update end boundary in case of partial page */
		externsEnd = externsEnd + 128;
	CALL seekExtMap;
	CALL write(tmpfilefd, extMap$p, 256, .statusIO);
	CALL errChkReport(statusIO, .linkTmpFile(1), TRUE);
END pageOutExtMap;

pageInExtMap: PROCEDURE PUBLIC;
	CALL seekExtMap;
	CALL read(tmpfilefd, extMap$p, 256, .actRead, .statusIO);
	CALL errChkReport(statusIO, .linkTmpFile(1), TRUE);
	IF actRead <> 256 THEN
		CALL errChkReport(ERR204, .linkTmpFile(1), TRUE);
END pageInExtMap;

addExtMap: PROCEDURE(sym$p) PUBLIC;
	DECLARE sym$p ADDRESS;
	DECLARE extMap BASED extMap$p(1) ADDRESS;

	IF (externsCount AND 0FF80H) <> externsBase THEN	/* memory cache full */
	DO;
		IF NOT haveTmpFile THEN				/* if no tmp file create it */
		DO;
			CALL delete(.linkTmpFile(1), .statusIO);
			CALL open(.tmpfilefd, .linkTmpFile(1), 3, 0, .statusIO);
			CALL errChkReport(statusIO, .linkTmpFile(1), TRUE);
			haveTmpFile = TRUE;
		END;
		CALL pageOutExtMap;
		IF (externsBase := externsCount AND 0FF80H) < externsEnd THEN
			CALL pageInExtMap;			/* if the page exists get it from disk */
	END;
	extMap(externsCount - externsBase) = sym$p;	/* record the symbol mapping */
	externsCount = externsCount + 1;
END addExtMap;

getSymbol$p: PROCEDURE(symId) ADDRESS PUBLIC;
	DECLARE symId ADDRESS;
	DECLARE extMap BASED extMap$p (1) ADDRESS;

	IF symId >= externsCount THEN	/* out of range */
		CALL illegalRecord;
	IF (symId AND 0FF80H) <> externsBase THEN	/* not in memory */
	DO;
		CALL pageOutExtMap;			/* write out current */
		externsBase = symId AND 0FF80H;		/* set new base */
		CALL pageInExtMap;			/* get relevant page */
	END;
	RETURN extMap(symId - externsBase);		/* return the symbol$p */
END getSymbol$p;

initExternsMap: PROCEDURE PUBLIC;
	IF extMap$p = 0 THEN	/* not already allocated */
	DO;
		IF maxExternCnt > 128 THEN	/* max 128 extern entries in memory */
			extMap$p = allocdown(100H);
		ELSE
			extMap$p = allocdown(maxExternCnt * 2);
	END;
	externsCount, externsBase, externsEnd = 0;
END initExternsMap;

flushTo: PROCEDURE PUBLIC;
	CALL write(tofilefd, sout$p, out$p - sout$p, .statusIO);
	CALL errChkReport(statusIO, .toFileName(1), TRUE);
	out$p = sout$p;
END flushTo;

initRecord: PROCEDURE(type) PUBLIC;
	DECLARE type BYTE;

	IF eout$p - out$p < 1028 THEN
		CALL flushTo;
	outRecord$p = out$p;
	outRecord.type = type;
	out$p = out$p + 3;
END initRecord;

endRecord: PROCEDURE PUBLIC;
	DECLARE crc BYTE;
	DECLARE pch ADDRESS;
	DECLARE ch BASED pch BYTE;
	DECLARE crcCH BASED out$p BYTE;

	IF (outRecord.len := out$p - .outRecord.type - 2) > 1025 THEN
		CALL errChkReport(ERR211, .toFileName(1), TRUE);	/* Record to long */
	crc = 0;
	DO pch = .outRecord.type TO out$p - 1;	/* calculate and insert crc */
		crc = crc + ch;
	END;
	crcCH = -crc;
	out$p = out$p + 1;
END endRecord;

extendRec: PROCEDURE(cnt) BYTE PUBLIC;
	DECLARE cnt ADDRESS;
	DECLARE type BYTE;

	IF out$p + cnt - .outRecord.type < 1028 THEN	/* room in buffer */
		RETURN FALSE;
	type = outRecord.type;	/* type for extension record */
	CALL endRecord;		/* close off the current record */
	CALL initRecord(type);	/* and prepare another */
	RETURN TRUE;
END extendRec;

emitMODHDR: PROCEDURE PUBLIC;
	DECLARE reserved BASED out$p STRUCTURE (x1 BYTE, x2 BYTE);
	DECLARE sdef BASED out$p STRUCTURE (segid BYTE, len ADDRESS, combine BYTE);

	emitMODHDR$comSegInfo: PROCEDURE(segid, len, combine);
		DECLARE (segid, combine) BYTE, len ADDRESS;

		IF extendRec(size(sdef)) THEN	/* make sure enough room */
			CALL errChkReport(ERR226, .toFileName(1), TRUE);	/* mod hdr too long */
		sdef.segid = segid;		/* emit segid, name, combine and size */
		sdef.len = len;
		sdef.combine = combine;
		out$p = out$p + size(sdef);
	END emitMODHDR$comSegInfo;

	CALL initRecord(R$MODHDR);
	CALL pstrcpy(.moduleName, .outOMFName);	/* copy the module name */
	out$p = out$p + moduleName(0) + 1;
	reserved.x1 = modhdr$x1;		/* the two reserved bytes */
	reserved.x2 = modhdr$x2;
	out$p = out$p + 2;
	DO segIdx = SEG$CODE TO SEG$MEMORY;	/* regular segments */
		IF segLen(segIdx) > 0 THEN
			CALL emitMODHDR$comSegInfo(segIdx, segLen(segIdx), alignType(segIdx));
	END;
	IF segLen(0) > 0 THEN		/* unamed common segment */
		CALL emitMODHDR$comSegInfo(SEG$BLANK, segLen(0), alignType(0));
	comdefInfo$p = headSegOrderLink;
	DO WHILE comdefInfo$p > 0;		/* named common segments */
		CALL emitMODHDR$comSegInfo(comdefInfo.linkedSeg, comdefInfo.len, comdefInfo.flags);
		comdefInfo$p = comdefInfo.segOrderLink;
	END;
	CALL endRecord;
END emitMODHDR;

emitEnding: PROCEDURE PUBLIC;
	DECLARE	outModend BASED out$p STRUCTURE (modtype BYTE, segid BYTE, offset ADDRESS);
	CALL initRecord(R$MODEND);	/* init the record */
	outModend.modtype = modtype;	/* fill in the mod type, start seg and offset */
	outModend.segid = entrySeg;
	outModend.offset = entryAddr;
	out$p = out$p + size(outModend);	/* advance past the data inserted */
	CALL endRecord;			/* finalise */
	CALL initRecord(R$EOF);		/* emit and EOF record as well */
	CALL endRecord;
	CALL flushTo;			/* make sure all on disk */
END emitEnding;

emitCOMDEF: PROCEDURE PUBLIC;
	DECLARE	outComdef BASED out$p STRUCTURE (seg BYTE, name(1) BYTE);
	IF headSegOrderLink = 0 THEN	/* no named common */
		RETURN;
	CALL initRecord(R$COMDEF);	/* prep the record */
	comdefInfo$p = headSegOrderLink;	/* chase down the definitions in seg order */
	DO WHILE comdefInfo$p > 0;
		IF extendRec(DOUBLE(2) + comdefInfo.name(0)) THEN	/* overflow to another record if needed */
			;		/* IF really not needed here as there are no issues with overflowing */
		outComdef.seg = comdefInfo.linkedSeg;	/* copy the seg and name */
		CALL pstrcpy(.comdefInfo.name, out$p + 1);
		out$p = out$p + size(outComdef) + comdefInfo.name(0);	/* advance output pointer */
		comdefInfo$p = comdefInfo.segOrderLink;	/* pickup next entry */
	END;
	CALL endRecord;		/* finalise */
END emitCOMDEF;

emitPUBLICS: PROCEDURE PUBLIC;
	DECLARE obuf BASED out$p (1) BYTE;
	DECLARE outSegId BASED out$p STRUCTURE (seg BYTE);
	DECLARE outPubdef  BASED out$p STRUCTURE (offset ADDRESS, name(1) BYTE /*, 0 */);

	DO segIdx = 0 TO 255;			/* scan all segs */
		IF segmap(segIdx) THEN		/* seg used */
		DO;
			CALL initRecord(R$PUBLICS);	/* init the record */
			outSegId.seg = segIdx;		/* seg needed */
			out$p = out$p + 1;
			curObjFile = objFileHead;	/* scan all files */
			DO WHILE curObjFile > 0;
				curModule = objFile.modlist;
				DO WHILE curModule > 0;	/* and all modules */
					symbol$p = module.symlist;
					DO WHILE symbol$p > 0;	/* and all symbols */
						IF symbol.linkedSeg = segIdx THEN	/* this symbol in the right seg */
						DO;
							IF extendRec(DOUBLE(4) + symbol.name(0)) THEN	/* makes sure enough room in record */
							DO;
								outSegId.seg = segIdx;	/* overflowed to new record so add the segid */
								out$p = out$p + 1;
							END;
							outPubdef.offset = symbol.offsetOrSym;	/* write the offset */
							CALL pstrcpy(.symbol.name, .outPubdef.name);	/* and the name */
							obuf(symbol.name(0) + 3) = 0;		/* add the extra 0 reserved byte */
							out$p = out$p + 4 + symbol.name(0);	/* account for data added */
						END;
						symbol$p = symbol.nxtSymbol;	/* loop to next symbol */
					END;
					curModule = module.link;	/* next module*/
				END;
				curObjFile = objFile.link;	/* next file */
			END;
			CALL endRecord;				/* finish any open record */
		END;
	END;
END emitPUBLICS;

emitEXTNAMES: PROCEDURE PUBLIC;
	DECLARE buf BASED out$p(1) BYTE;

	IF headUnresolved = 0 THEN		/* no unresolved */
		RETURN;
	CALL initRecord(R$EXTNAMES);		/* init the record */
	unresolved = 0;
	symbol$p = headUnresolved;
	DO WHILE symbol$p > 0;
		IF extendRec(DOUBLE(2) + symbol.name(0)) THEN	/* check room for len, symbol and 0 */
			;					/* no need for special action on extend */
		CALL pstrcpy(.symbol.name, .outOMFName);	/* copy the len + symbol */
		buf(symbol.name(0) + 1) = 0;			/* add a 0 */
		out$p = out$p + 2 + symbol.name(0);		/* advance past inserted data */
		symbol.offsetOrSym = unresolved;		/* record the final ext sym id */
		unresolved = unresolved + 1;			/* for next symbol */
		symbol$p = symbol.nxtSymbol;
	END;
	CALL endRecord;						/* clean closure of record */
END emitEXTNAMES;

emit$ANCESTOR: PROCEDURE PUBLIC;
	IF ancestorNameNotSet THEN					/* we have a module name to use */
	DO;
		CALL initRecord(R$ANCESTOR);			/* init the record */
		CALL pstrcpy(.modName, .outOMFName);		/* copy name */
		out$p = out$p + modName(0) + 1;
		CALL endRecord;
		ancestorNameNotSet = 0;				/* it is now set */
	END;
END emit$ANCESTOR;

selectOutSeg: PROCEDURE(seg) BYTE PUBLIC;
	DECLARE seg BYTE;
	outRelocOffset = 0;		/* only code and data modules are relative to module location */
	IF seg = SEG$CODE THEN
		outRelocOffset = module.scode;
	ELSE IF seg = SEG$DATA THEN
		outRelocOffset = module.sdata;
	return segmap(seg);		/* return seg mapping */
END selectOutSeg;

pass2MODHDR: PROCEDURE PUBLIC;
	CALL pstrcpy(.inOMFName, .modName);	/* read in the module name */
	ancestorNameNotSet = TRUE;		/* note the ancestor record has not been written */
	DO segId = 0 TO 255;			/* init the segment mapping */
		segmap(segId) = segId;
	END;
	CALL getRecord;
END pass2MODHDR;

pass2COMDEF: PROCEDURE PUBLIC;
	DECLARE	inComdef BASED in$p STRUCTURE (seg BYTE, name(1) BYTE);
	DO WHILE in$p < .erec;		/* while more common definitions */
		IF NOT find(.inComdef.name, .comdefInfo$p, F$ALNMASK) THEN	/* check found */
			CALL fatalErr(ERR219);	/* Phase error */
		segmap(inComdef.seg) = comdefInfo.linkedSeg;			/* record the final linked seg where this goes */
		in$p = in$p + 2 + inComdef.name(0);				/* past this def */
	END;
	CALL getRecord;	
END pass2COMDEF;

pass2EXTNAMES: PROCEDURE PUBLIC;
	DO WHILE in$p < .erec;		/* while more external definitions */
		IF NOT find(in$p, .symbol$p, F$SCOPEMASK) THEN	/* get the name */
			CALL fatalErr(ERR219);	/* phase error - didn't find !!! */
		CALL addExtMap(symbol$p);
		IF symbol.flags = F$EXTERN THEN	/* still an extern */
		DO;				/* write the unresolved reference info */
			CALL writeAndEcho(.space, 1);
			CALL writeAndEcho(.symbol.name(1), symbol.name(0));
			CALL wAEFnAndMod(.msgrefin, 17);	/* ' - REFERENCED IN ' */
		END;
		in$p = in$p + 2 + inOMFName.len;	/* 2 for len and extra 0 */
	END;
	CALL getRecord;
END pass2EXTNAMES;

pass2CONTENT: PROCEDURE PUBLIC;
	DECLARE (outContentSeg, crc) BYTE;
	DECLARE (savedOut$p, savedRecLen, outContentRelocOffset, inContentStart, inContentEnd, bytes2Read, p) ADDRESS;
	DECLARE (headextern$p, headReloc$p, fixup$p, reloc$p, markheap) ADDRESS;
	DECLARE bfixup BASED p BYTE;
	DECLARE wfixup BASED p ADDRESS;
	DECLARE ch BASED p BYTE;
	DECLARE fixup BASED fixup$p STRUCTURE(link ADDRESS, typeAndSeg ADDRESS, relocList ADDRESS);
	DECLARE extFixup BASED reloc$p STRUCTURE(link ADDRESS, offset ADDRESS, sym ADDRESS);
	DECLARE reloc BASED reloc$p STRUCTURE(link ADDRESS, offset ADDRESS);
	DECLARE	outContent BASED out$p STRUCTURE (seg BYTE, offset ADDRESS, bytes(1) BYTE);
	DECLARE	inFixtype BASED in$p BYTE;
	DECLARE	inExtref BASED in$p STRUCTURE (sym ADDRESS, offset ADDRESS);
	DECLARE	outFixtype BASED out$p BYTE;
	DECLARE	outExtref BASED out$p STRUCTURE (sym ADDRESS, offset ADDRESS);
	DECLARE	inOffset BASED in$p ADDRESS;
	DECLARE	inSegId BASED in$p BYTE;
	DECLARE	outInterseg BASED out$p STRUCTURE (seg BYTE, fixType BYTE); 
	DECLARE	outOffset BASED out$p Address;

	boundsChk: PROCEDURE(addr);
		DECLARE addr ADDRESS;
		IF addr < inContentStart OR inContentEnd < addr THEN
			CALL fatalErr(ERR213);	/* fixup bounds error */
	END boundsChk;

	getTypeAndSegHead: PROCEDURE(afixup$p, typeAndSeg);
		DECLARE afixup$p ADDRESS;
		DECLARE typeAndSeg ADDRESS;
		DECLARE afixup BASED afixup$p STRUCTURE(link ADDRESS, typeAndSeg ADDRESS, relocList ADDRESS);

		fixup$p = afixup.link;	/* chase down the fixup chain matching seg and fixup type */
		DO WHILE fixup$p > 0;
			IF fixup.typeAndSeg = typeAndSeg THEN	/* found existing list */
				RETURN;
			afixup$p = .fixup.link;			/* step along */
			fixup$p = fixup.link;
		END;
		fixup$p = allocUp(size(afixup));			/* add to the list */
		fixup.link = afixup.link;
		afixup.link = fixup$p;
		fixup.typeAndSeg = typeAndSeg;			/* save the typeAndSeg */
		fixup.relocList = 0;
	END getTypeAndSegHead;


	addRelocFixup: PROCEDURE(seg, addr);
		DECLARE seg BYTE, addr ADDRESS;
		CALL getTypeAndSegHead(.headReloc$p, seg * 256 + fixType);	/* add to reloc list */
		reloc$p = allocUp(size(reloc));
		reloc.link = fixup.relocList;
		fixup.relocList = reloc$p;
		reloc.offset = addr + outContentRelocOffset;
	END addRelocFixup;

	inRecord$p = .fakeModhdr;	/* keep inRecord$p pointing to a modhdr */
	CALL initRecord(R$CONTENT);	/* init record */
	outRecord.len, savedRecLen = recLen;	/* output length same as input length */
	savedOut$p = out$p;		/* saved start of record */
	crc = HIGH(recLen) + R$CONTENT + LOW(recLen);	/* initialise crc */
	buf$p = in$p;

	DO WHILE recLen > 0;		/* process all of the record */
		IF savedRecLen > 1025 THEN	/* flush current output buf */
			CALL flushTo;
		IF (bytes2Read := recLen) > npbuf THEN	/* read in at most npbuf bytes */
			bytes2Read = npbuf;
		CALL chkRead(bytes2Read);	/* load them into memory */
		CALL memmov(bytes2Read, buf$p, out$p);	/* copy to the output buf */
		DO p = out$p TO out$p + bytes2Read - 1;	/* update the CRC */
			crc = crc + ch;
		END;
		buf$p = buf$p + bytes2Read;	/* advance the pointers */
		out$p = out$p + bytes2Read;
		recLen = recLen - bytes2Read;
	END;
	IF crc <> 0 THEN
		CALL fatalErr(ERR208);	/* Checksum error */
	CALL getRecord;			/* prime next record */
	IF savedRecLen > 1025 THEN	/* we can't fix up a big record */
		RETURN;

	headextern$p, headReloc$p = 0;	/* initialise the fixup chains */
	savedOut$p = (out$p := savedOut$p) + 3;		/* skip seg and offset */
	outContentSeg = selectOutSeg(outContent.seg);	/* get the mapped link segment */
	outContentRelocOffset = outRelocOffset;		/* and the content reloc base */
	inContentEnd = (inContentStart := outContent.offset) + savedRecLen - 5;	/* the address range */
	outContent.seg = outContentSeg;			/* update the out seg & address values */
	outContent.offset = inContentStart + outContentRelocOffset;
	markheap = allocUp(0);				/* get heap marker */

	/* process the relocate records */
	DO WHILE inRecord.type = R$EXTREF OR inRecord.type = R$RELOC OR inRecord.type = R$INTERSEG;
		IF inRecord.type = R$EXTREF THEN
		DO;
			IF (fixType := inFixtype) - 1 > 2 THEN	/* make sure combine is valid */
				CALL illegalRecord;
			in$p = in$p + 1;		/* past the record byte */
			DO WHILE in$p < .erec;		/* process all of the extref fixups */
				CALL boundsChk(inExtref.offset);	/* check fixup valid */
				IF fixType = FIX$BOTH THEN
					CALL boundsChk(inExtref.offset + 1);	/* check upper byte also in range */
				symbol$p = getSymbol$p(inExtref.sym);		/* get symbol entry for the ext symid */
				IF symbol.flags = F$PUBLIC THEN			/* is a PUBLIC so resolved */
				DO;
					p = inExtref.offset - inContentStart + savedOut$p;	/* find fixup address in buffer */
					DO CASE fixType - 1;			/* relocate to segs current base */
					bfixup = bfixup + LOW(symbol.offsetOrSym);
					bfixup = bfixup + HIGH(symbol.offsetOrSym);
					wfixup = wfixup + symbol.offsetOrSym;
					END;
					IF symbol.linkedSeg <> SEG$ABS THEN		/* if not ABS add a fixup entry */
						CALL addRelocFixup(symbol.linkedSeg, inExtref.offset);
				END;
				ELSE						/* is an extern still */
				DO;
					CALL getTypeAndSegHead(.headextern$p, fixType);	/* add to extern list, seg not needed */
					reloc$p = allocUp(size(extFixup));	/* allocate the extFixup descriptor */
					extFixup.link = fixup.relocList;		/* chain it in */
					fixup.relocList = reloc$p;
					extFixup.offset = inExtref.offset + outContentRelocOffset;	/* add in the location */
					extFixup.sym = symbol.offsetOrSym;	/* and the symbol id */
				END;
				in$p = in$p + 4;
			END;
		END;
		ELSE	/* reloc or interseg */
		DO;
			segIdx = outContentSeg;			/* get default reloc seg */
			outRelocOffset = outContentRelocOffset;	/* and reloc base to that of the content record */
			IF inRecord.type = R$INTERSEG THEN	/* if we are interseg then update the reloc seg */
			DO;
				segIdx = selectOutSeg(inSegId);	/* also updates the outRelocOffset */
				in$p = in$p + 1;
			END;
			IF segIdx = 0 THEN			/* ABS is illegal */
				CALL illegalRecord;
			IF (fixType := inFixtype) - 1 > 2 THEN	/* bad fix up type ? */
				CALL illegalRecord;
			in$p = in$p + 1;			/* past fixup */
			DO WHILE in$p < .erec;			/* process all of the relocates */
				CALL boundsChk(inOffset);	/* fixup in range */
				IF fixType = FIX$BOTH THEN	/* and 2nd byte for both byte fixup */
					CALL boundsChk(inOffset + 1);
				p = inOffset - inContentStart + savedOut$p;	/* location of fixup */
				DO CASE fixType - 1;		/* relocate to seg current base */
				bfixup = bfixup + LOW(outRelocOffset);
				bfixup = bfixup + HIGH(outRelocOffset);
				wfixup = wfixup + outRelocOffset;
				END;
				CALL addRelocFixup(segIdx, inOffset);	/* add a new reloc fixup */
				in$p = in$p + 2;
			END;
		END;
		CALL getRecord;	/* next record */
	END;
	out$p = out$p + savedRecLen - 1;
	CALL endRecord;				/* finish the content record */
	fixup$p = headextern$p;			/* process the extern lists */
	DO WHILE fixup$p > 0;
		CALL initRecord(R$EXTREF);	/* create a extref record */
		outFixtype = LOW(fixup.typeAndSeg);	/* set the fix type */
		out$p = out$p + 1;
		reloc$p = fixup.relocList;	/* process all of the extref of this fixtype */
		DO WHILE reloc$p > 0;
			IF extendRec(4) THEN	/* make sure we have room */
			DO;			/* if not add the fixtype to the newly created follow on record */
				outFixtype = LOW(fixup.typeAndSeg);
				out$p = out$p + 1;
			END;
			outExtref.sym = extFixup.sym;	/* put the sym number */
			outExtref.offset = extFixup.offset;	/* and the fixup location */
			out$p = out$p + 4;		/* update to reflect 4 bytes written */
			reloc$p = extFixup.link;	/* chase the list */
		END;
		CALL endRecord;			/* close any open record */
		fixup$p = fixup.link;		/* look for next fixtype list */
	END;
	fixup$p = headReloc$p;			/* now do the relocates */
	DO WHILE fixup$p > 0;
		CALL initRecord(R$INTERSEG);	/* interseg record */
		outInterseg.seg = HIGH(fixup.typeAndSeg);	/* fill in segment */
		outInterseg.fixtype = LOW(fixup.typeAndSeg);	/* and fixtype */
		out$p = out$p + 2;
		reloc$p = fixup.relocList;	/* chase down the references */
		DO WHILE reloc$p > 0;
			IF extendRec(2) THEN	/* two bytes or create follow on record */
			DO;			/* fill in follow on record */
				outInterseg.seg = HIGH(fixup.typeAndSeg);
				outInterseg.fixtype = LOW(fixup.typeAndSeg);
				out$p = out$p + 2;
			END;
			outOffset = extFixup.offset;	/* set the fill the offset */
			out$p = out$p + 2;
			reloc$p = extFixup.link;	/* next record */
		END;
		CALL endRecord;
		fixup$p = fixup.link;
	END;
	baseHeap = markheap;		/* return heap */

END pass2CONTENT;

pass2LINENO: PROCEDURE PUBLIC;
	DECLARE	inSegId BASED in$p BYTE;
	DECLARE	inLineno BASED in$p STRUCTURE (offset ADDRESS, linnum ADDRESS);
	DECLARE	outSegId BASED out$p BYTE;
	DECLARE	outLineno BASED out$p STRUCTURE (offset ADDRESS, linnum ADDRESS);

	CALL emit$ANCESTOR;		/* make sure we have a valid ancestor record */
	CALL initRecord(R$LINENO);
	outSegId = selectOutSeg(inSegId);	/* add the seg id info */
	out$p = out$p + 1;
	in$p = in$p + 1;
	DO WHILE in$p < .erec;		/* while more public definitions */
		outLineno.offset = outRelocOffset + inLineno.offset;	/* relocate the offset */
		outLineno.linnum = inLineno.linnum;			/* copy the line number */
		out$p = out$p + 4;
		in$p = in$p + 4;
	END;
	CALL endRecord;
	CALL getRecord;
END pass2LINENO;

pass2ANCESTOR: PROCEDURE PUBLIC;
	CALL pstrcpy(.inOMFName, .modName);	/* copy the module name over and mark as valid */
	ancestorNameNotSet = TRUE;		/* note it isn't written yet */
	CALL getRecord;
END pass2ANCESTOR;

pass2LOCALS: PROCEDURE PUBLIC;
	DECLARE inSegId BASED in$p BYTE;
	DECLARE inLocals BASED in$p STRUCTURE (offset ADDRESS, name(1) BYTE /*, 0 */);
	DECLARE outSegId BASED out$p BYTE;
	DECLARE outLocals BASED out$p STRUCTURE (offset ADDRESS, name(1) BYTE /*, 0 */);

	CALL emit$ANCESTOR;			/* emit ancestor if needed */
	CALL initRecord(R$LOCALS);		/* init locals record */
	outSegId = selectOutSeg(inSegId);	/* map the segment and set up relocation base */
	out$p = out$p + 1;
	in$p = in$p + 1;
	/* note the code below relies on the source file having records <1025 */
	DO WHILE in$p < .erec;		/* while more local definitions */
		outLocals.offset = outRelocOffset + inLocals.offset;	/* write offset and symbol */
		CALL pstrcpy(.inLocals.name, .outLocals.name);
		outLocals.name(inLocals.name(0) + 1) = 0;
		out$p = out$p + 4 + inLocals.name(0);			/* advance out and in pointers */
		in$p = in$p + 4 + inLocals.name(0);
	END;
	CALL endRecord;			/* clean end */
	CALL getRecord;			/* next record */
END pass2LOCALS;

/* process pass 2 records */
phase2: PROCEDURE PUBLIC;
	IF (baseHeap := .MEMORY) > topHeap THEN				/* check that memory still ok after overlay */
		CALL errChkReport(ERR210, .toFileName(1), TRUE);	/* insufficient memory */
	sout$p, out$p = allocdown(npbuf);				/* reserve the output buffer */
	eout$p = sout$p + npbuf;
	CALL initExternsMap;
	CALL open(.tofilefd, .toFileName(1), 2, 0, .statusIO);		/* target file */
	CALL errChkReport(statusIO, .toFileName(1), TRUE);
	CALL emitMODHDR;						/* process the simple records */
	CALL emitCOMDEF;
	CALL emitPUBLICS;
	CALL emitEXTNAMES;
	curObjFile = objFileHead;					/* process all files */
	DO WHILE curObjFile > 0;
		IF objfile.publicsOnly THEN				/* don't need to do anything more for publics only file */
			curObjFile = objfile.link;
		ELSE
		DO;
			CALL openObjFile;				/* open file */
			curModule = objfile.modlist;			/* for each module in the file */
			DO WHILE curModule > 0;
				CALL getRecord;				/* read modhdr */
				IF objfile.hasmodules THEN		/* if we have modules seek to the current module's location */
				DO;
					CALL objSeek(module.blk, module.byt);
					CALL getRecord;			/* and load its modhdr */
				END;
				IF inRecord.type <> R$MODHDR THEN
					CALL fatalErr(ERR219); /* phase error */
				CALL initExternsMap;			/* prepare for processing this module's extdef records */
				DO WHILE inRecord.type <> R$MODEND;	/* run through the whole module */
					DO CASE SHR(inRecord.type, 1);
					CALL illegalRelo;
					CALL pass2MODHDR;	/* R$MODHDR */
					;			/* R$MODEND */
					CALL pass2CONTENT;	/* R$CONTENT */
					CALL pass2LINENO;
					CALL illegalRelo;
					CALL illegalRelo;
					CALL errChkReport(ERR204, .inFileName(1), TRUE); /* 0E Premature EOF */
					CALL pass2ANCESTOR;
					CALL pass2LOCALS;
					CALL illegalRelo;
					CALL getRecord;
					CALL pass2EXTNAMES;
					CALL illegalRelo;
					CALL illegalRelo;
					CALL illegalRelo;
					CALL badRecordSeq;
					CALL badRecordSeq;
					CALL badRecordSeq;
					CALL badRecordSeq;
					CALL badRecordSeq;
					CALL badRecordSeq;
					CALL badRecordSeq;
					CALL pass2COMDEF;		/* 2E */
					END;
				END;
				curModule = module.link;
			END;
			CALL closeObjFile;
		END; /* of else */
	END;	/* of do while */
	CALL emitEnding;	/* write final modend and EOF record */
	CALL close(tofilefd, .statusIO);
	CALL errChkReport(statusIO, .toFileName(1), TRUE);
	IF haveTmpFile THEN		/* clean any tmp file up */
	DO;
		CALL close(tmpfilefd, .statusIO);
		CALL errChkReport(statusIO, .linkTmpFile(1), TRUE);
		CALL delete(.linkTmpFile(1), .statusIO);
	END;
END phase2;

END linkovl;
