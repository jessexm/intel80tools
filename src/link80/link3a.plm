$xref
/*	Copyright (c) 2012 by Mark Ogden
	Released into the public domain for academic historic interest
	only and not for commercial gain. */
link3a:
DO;
$INCLUDE(LINK.EXT)
/* from ISIS.EXT */

open: procedure (conn$p, path$p, access, echo, status$p) external;
    declare (conn$p, path$p, access, echo, status$p) address;
end open;

read: procedure (conn, buff$p, count, actual$p, status$p) external;
    declare (conn, buff$p, count, actual$p, status$p) address;
end read;

exit: procedure external;
end exit;

spath: procedure (path$p, info$p, status$p) external;
    declare (path$p, info$p, status$p) address;
end spath;

rescan: procedure (conn, status$p) external;
    declare (conn, status$p) address;
end rescan;

memck: procedure address external;
end memck;



DECLARE controls(*) BYTE PUBLIC DATA(1, 3, 'MAP', 2, 4, 'NAME', 3, 5, 'PRINT');
DECLARE cin(*) BYTE DATA(':CI: ');
DECLARE cout(*) BYTE DATA(5, ':CO: ');

DECLARE info SPATH$T,
	login(*) BYTE INITIAL(0CH, 'ISIS-II OBJECT LINKER '),
	msgInvoked(*) BYTE INITIAL(' INVOKED BY:', 0DH, 0AH),
	msgtailerror(*) BYTE INITIAL('COMMAND TAIL ERROR NEAR #:'),
	linkTmpTemplate(*) BYTE INITIAL(0,'LINK', 0, 0,'TMP'),
	scmd$p ADDRESS,
	cmd$p ADDRESS;

DECLARE	cmdch BASED cmd$p BYTE;
DECLARE	cmdbuf BASED cmd$p (1) BYTE;

DECLARE	CRLF (2) BYTE EXTERNAL,
	objFileHead ADDRESS EXTERNAL,
	curObjFile ADDRESS EXTERNAL,
	curModule ADDRESS EXTERNAL,
	doMap BYTE EXTERNAL,
	moduleName(32) BYTE EXTERNAL,
	printFileNo ADDRESS EXTERNAL,
	printFileName(16) BYTE EXTERNAL,
	inFileName(16) BYTE EXTERNAL,
	actRead ADDRESS EXTERNAL,
	baseHeap ADDRESS EXTERNAL,
	topHeap ADDRESS EXTERNAL,
	npbuf ADDRESS EXTERNAL,
	sibuf$p ADDRESS EXTERNAL,
	ibuf$p ADDRESS EXTERNAL,
	eibuf$p ADDRESS EXTERNAL,
	filePath(16) BYTE EXTERNAL,
	toFileName(16) BYTE EXTERNAL,
	linkTmpFile(16) BYTE EXTERNAL,
	hashChains(128) ADDRESS EXTERNAL,
	alignType(6) BYTE EXTERNAL,
	segmap(256) BYTE EXTERNAL,
	modhdr$x1 BYTE EXTERNAL,
	modhdr$x2 BYTE EXTERNAL,
	segSizes(6) ADDRESS EXTERNAL,
	entrySeg BYTE EXTERNAL,
	entryAddr ADDRESS EXTERNAL,
	maxExternCnt ADDRESS EXTERNAL,
	headunres ADDRESS EXTERNAL,
	headcitem ADDRESS EXTERNAL,
	isMain BYTE EXTERNAL,
	unresolved ADDRESS EXTERNAL,
	statusIO ADDRESS EXTERNAL;

DECLARE VERSION(4) BYTE EXTERNAL;

DECLARE objFile BASED curObjFile LIBRARY$T;
DECLARE module BASED curModule MODULE$T;


pastFileName: PROCEDURE(pch) ADDRESS EXTERNAL;
	DECLARE pch ADDRESS;
END pastFileName;

conOutStr: PROCEDURE(pstr, count) EXTERNAL;
	DECLARE pstr ADDRESS;
	DECLARE count ADDRESS;
END conOutStr;

writeErrStr: PROCEDURE(errcode) EXTERNAL;
	DECLARE errcode ADDRESS;
END writeErrStr;

skipSpc: PROCEDURE(pch) ADDRESS EXTERNAL;
	DECLARE pch ADDRESS;
END skipSpc;

makeFullName: PROCEDURE(pinfo, pstr) EXTERNAL;
	DECLARE (pinfo, pstr) ADDRESS;
END makeFullName;

errChkReport: PROCEDURE(errCode, file, errExit) EXTERNAL;
	DECLARE errCode ADDRESS;
	DECLARE file ADDRESS;
	DECLARE errExit BYTE;
END errChkReport;

allocUp: PROCEDURE(count) ADDRESS EXTERNAL;
	DECLARE count ADDRESS;
END allocUp;


allocdown: PROCEDURE(count) ADDRESS EXTERNAL;
	DECLARE count ADDRESS;
END allocdown;

pstrcpy: PROCEDURE(psrc, pdst) EXTERNAL;
	DECLARE psrc ADDRESS;
	DECLARE pdst ADDRESS;
END pstrcpy;

strequ: PROCEDURE(str1p, str2p, cnt) BYTE EXTERNAL;
	DECLARE (str1p, str2p) ADDRESS;
	DECLARE cnt BYTE;
END strequ;

crStrUpper: PROCEDURE(PCH) EXTERNAL;
	DECLARE PCH ADDRESS;
END crStrUpper;

writeBytes: PROCEDURE(buf$p, count) EXTERNAL;
	DECLARE buf$p ADDRESS;
	DECLARE count ADDRESS;
END writeBytes;


fatalCmdLineErr: PROCEDURE(errCode) PUBLIC;
	DECLARE errCode ADDRESS;
	DECLARE scmd BASED scmd$p (1) BYTE;

	IF pastFileName(cmd$p) = cmd$p THEN
	DO;				/* isn't a filename so a single char */
		IF cmdch <> 0DH THEN	/* don't skip past the EOL */
			cmd$p = cmd$p + 1;
	END;
	ELSE
		cmd$p = pastFileName(cmd$p);
	cmdch = '#';	/* mark after error */
	CALL conOutStr(.msgtailerror, 26);
	CALL writeErrStr(errCode);
	CALL conOutStr(.scmd, cmd$p - .scmd + 1);
	CALL conOutStr(.CRLF, 2);
	CALL exit;
END fatalCmdLineErr;


skipNonArgChars: PROCEDURE(arg1w) PUBLIC;
	DECLARE arg1w ADDRESS;

	cmd$p = skipSpc(arg1w);
	DO WHILE cmdch = '&';		/* skip continuation lines */
		cmd$p = skipSpc(cmd$p + 5);
	END;
END skipNonArgChars;


expectChar: PROCEDURE(ch, errCode) PUBLIC;
	DECLARE ch BYTE;
	DECLARE errCode BYTE;

	CALL skipNonArgChars(cmd$p);
	IF cmdch = ch THEN
		CALL skipNonArgChars(cmd$p+1);
	ELSE
		CALL fatalCmdLineErr(errCode);
END expectChar;


chkLP: PROCEDURE PUBLIC;
	CALL expectChar('(', ERR227);	/* left parenthesis expected */
END chkLP;


chkRP: PROCEDURE PUBLIC;
	CALL expectChar(')', ERR228);	/* right parenthesis expected */
END chkRP;


expectComma: PROCEDURE PUBLIC;
	CALL expectChar(',', ERR203);	/* Invalid syntax */
END expectComma;


checkFile: PROCEDURE PUBLIC;
	CALL spath(cmd$p, .info, .statusIO);
	IF statusIO > 0 THEN
		CALL fatalCmdLineErr(statusIO);
	CALL skipNonArgChars(pastFileName(cmd$p));
END checkFile;


errNotDiscFile: PROCEDURE PUBLIC;
	CALL makeFullName(.info, .inFileName(1));
	CALL errChkReport(ERR17, .inFileName(1), 0FFH);	/* not a disk file */
END errNotDiscFile;


getModuleName: PROCEDURE(pstr) PUBLIC;
	DECLARE pstr ADDRESS;
	DECLARE str BASED pstr (1) BYTE;

	IF cmdch < '?' OR cmdch > 'Z' THEN
		CALL fatalCmdLineErr(ERR225);	/* invalid name */
	str(0) = 0;

	DO WHILE '0' <= cmdch AND cmdch <= '9' OR '?' <= cmdch AND cmdch <= 'Z';
		str(0) = str(0) + 1;
		IF str(0) > 31 THEN
			CALL fatalCmdLineERR(ERR226);	/* name too long */
		str(str(0)) = cmdch;	
		cmd$p = cmd$p + 1;
	END;
END getModuleName;


addFileToInputList: PROCEDURE PUBLIC;
	CALL makeFullName(.info, .inFileNAme(1));
	inFileName(0) = pastFileName(.inFileName(1)) - .inFileName(1);
	IF objFileHead = 0 THEN
		objFileHead, curObjFile = allocdown(size(objFile) + inFileName(0));
	ELSE
	DO;
		objFile.link = allocdown(size(objFile) + inFileName(0));
		curObjFile = objFile.link;	
	END;
	objFile.link, objFile.modlist = 0;
	objFile.publicsOnly = 0;
	objFile.hasModules = 0;
	CALL pstrcpy(.inFileName, .objFile.name);
END addFileToInputList;


getInputListItem: PROCEDURE PUBLIC;
	DECLARE curModuleName(32) BYTE;
	IF strequ(cmd$p, .('PUBLICS'), 7) THEN
	DO;
		cmd$p = pastFileName(cmd$p);	/* past the PUBLICS */
		CALL chkLP;			/* (file */
		CALL checkFile;
		IF info.deviceType <> 3 THEN	/* must be disk file */
			CALL errNotDiscFile;
		CALL addFileToInputList;
		objFile.publicsOnly = 0FFH;	/* record PUBLICS */
		DO WHILE cmdCh = ',';		/* process any more PUBLICS files */
			CALL expectComma;
			CALL checkFile;
			IF info.deviceType <> 3 THEN
				CALL errNotDiscFile;
			CALL addFileToInputList;
			objFile.publicsOnly = 0FFH;
		END;
		CALL chkRP;			/* close with ) */
	END;
	ELSE
	DO;
		CALL checkFile;			/* check we have a disk file */
		IF info.deviceType <> 3 THEN
			CALL errNotDiscFile;
		CALL addFileToInputList;
		IF cmdCh = '(' THEN		/* check if we have a module list */
		DO;
			CALL chkLP;		/* gobble up the ( */
			objFile.hasModules = 0FFH;	/* note have module list */
			CALL getModuleName(.curModuleName);
			curModule = (objFile.modList := allocDown(size(module) + curModuleName(0)));
			module.link, module.symlist, module.scode = 0;
			CALL pstrcpy(.curModuleName, .module.name);
			CALL skipNonArgChars(cmd$p);
			DO WHILE cmdch = ',';		/* get more modules if specified */
				CALL expectComma;
				CALL getModuleName(.curModuleName);
				module.link = allocdown(size(module) + curModuleName(0));
				curModule = module.link;
				module.link, module.symlist, module.scode = 0;
				CALL pstrcpy(.curModuleName, .module.name);
				CALL skipNonArgChars(cmd$p);
			END;
			CALL chkRP;
		END;
	END;
END getInputListItem;


parseControl: PROCEDURE PUBLIC;
	DECLARE (i, j, k) BYTE;
	/* a controls item has format
		index, strlen, string
	*/
	k = pastFileName(cmd$p) - cmd$p;	/* control string len */
	i= 0;
	j= 0;
	IF k > 0 THEN		/* there is a control */
		DO WHILE i < 18;	/* size of the controls table */
			IF k = controls(i+1) AND strequ(cmd$p, .controls(i + 2), k) THEN
			DO;	/* found */
				j = controls(i);
				i = 18;	/* force exit */
			END;
			ELSE
				i = i + controls(i+1) + 2;
		END;

	IF j = 0 THEN		/* not found */
		CALL fatalCmdLineErr(ERR229);	/* Unrecognised control */
	CALL skipNonArgChars(cmd$p + k);	/* past the control */
	DO CASE j - 1;
		doMap = 0FFH;	/* MAP */
		DO;		/* NAME(modulename) */
			CALL chkLP;
			CALL getModuleName(.moduleName);
			CALL chkRP;
		END;
		DO;		/* PRINT(file) */
			CALL chkLP;
			CALL checkFile;
			CALL makeFullName(.info, .printFileName(1));
			printFileName(0) = pastFileName(.printFileName(1)) - .printFileName(1);
			CALL chkRP;
		END;
	END;
END parseControl;


readCmdLine: PROCEDURE PUBLIC;
	CALL read(1, cmd$p, 128, .actRead, .statusIO);
	CALL errChkReport(statusIO, .cin, 0FFH);
	cmdbuf(actRead) = 0DH;
	CALL crStrUpper(cmd$p);
END readCmdLine;


parseCmdLine: PROCEDURE PUBLIC;
	DECLARE scmdch BASED scmd$p BYTE;
	DECLARE (p, q) ADDRESS;

	baseHeap = .MEMORY;
	topHeap = memck;
	IF HIGH(memck - .MEMORY) - 1 >= 40H THEN
		npbuf = 3072;
	ELSE
		npbuf = 1056;
	sibuf$p = allocdown(npbuf);
	eibuf$p, ibuf$p = sibuf$p + npbuf;
	scmd$p = allocUp(0);	/* alloc 0 length buffer below heap. Will fix later */
	scmdch = '-';		/* put - at start of command buf */
	CALL rescan(1, .statusIO);	/* rescan the command line */
	cmd$p = scmd$p + 1;	/* insert point */
	CALL readCmdLine;	/* read the command line */
	cmd$p = skipSpc(cmd$p);	/* skip space and any DEBUG prefix */
	IF strequ(cmd$p, .('DEBUG '), 6) THEN
		cmd$p = skipSpc(cmd$p + 6);
	q = cmd$p;
	CALL checkFile;		/* reads the invoking filename */
	info.ext(0) = 'O';	/* generate the overlay name */
	info.ext(1) = 'V';
	info.ext(2) = 'L';
	CALL makeFullName(.info, .filePath(1));	/* make into a normalised file name */
	filePath(0) = pastFileName(.filePath(1)) - .filePath(1);	/* add the pascal style string len */
	cmd$p = q;		/* back to the start of the invoking command to keep for listing */

	DO WHILE cmdch <> 0DH;		/* collect until end of a non continued line */
		IF cmdch = '&' THEN
		DO;
			p = cmd$p;	/* mark where the & is */
			cmd$p = skipSpc(cmd$p + 1);
			IF cmdch <> 0DH THEN
				CALL fatalCmdLineErr(ERR203);	/* invalid syntax */
			cmd$p = p;	/* back to the & */
			CALL conOutStr(.('**'), 2);	/* prompt user for more */
			cmdbuf(1) = 0DH; 	/* put the \r\n** in the buffer */
			cmdbuf(2) = 0AH;
			cmdbuf(3) = '*';
			cmdbuf(4) = '*';
			cmd$p = cmd$p + 5;	/* point to insert next line */
			CALL readCmdLine;	/* get the line */
		END;
		ELSE
			cmd$p = cmd$p + 1;	/* next char */
	END;	/* DO WHILE */

	CALL conOutStr(.login(1), size(login) - 1);	/* put login message minus form feed */
	CALL conOutStr(.VERSION, 4);
	CALL conOutStr(.CRLF, 2);
	p =  allocup(cmd$p - .scmdch + 2);		/* formally allocate the memory for the command line */
	CALL skipNonArgChars(pastFileName(q));		/* skip the invoking app name */
	objFileHead = 0;				/* end of link file list marker */
	CALL getInputListItem;				/* get the first file to link */
	DO WHILE cmdch = ',';				/* get any more in the list */
		CALL expectComma;
		CALL getInputListItem;
	END;

	IF strequ(cmd$p, .('TO '), 3) OR strequ(cmd$p, .('TO&'), 3) THEN	/* need TO or TO& */
	DO;
		CALL skipNonArgChars(cmd$p + 2);	/* past the TO */
		q = cmd$p;				/* start of filename */
		CALL checkFile;				/* target must be a disk file or :BB: */
		IF info.deviceType <> 3 AND info.deviceId <> 22 THEN /* file or :BB: */
			CALL errNotDiscFile;
		cmd$p = q;				/* reset */
		CALL makeFullName(.info, .toFileName(1));	/* get the full filename */
		toFileName(0) = pastFileName(.toFileName(1)) - .toFileName(1);
		curObjFile = objFileHead;		/* check target isn't a file we are linking from */
		DO WHILE curObjFile > 0;
			IF strequ(.toFileName, .objFile.name, toFileName(0) + 1) AND NOT objFile.publicsOnly THEN
				CALL fatalCmdLineERr(ERR234);	/* Duplicate file name */
			curObjFile = objFile.link;
		END;
		CALL skipNonArgChars(pastFileName(cmd$p));
	END;
	ELSE
		CALL fatalCmdLineErr(ERR233);	/* 'TO' expected */

	/* put the temp file on the same disk as the target (or :BB:) */
	linkTmpTemplate(0) = info.deviceId;
	CALL makeFullName(.linkTmpTemplate, .linkTmpFile(1));
	linkTmpFile(0) = pastFileName(.linkTmpFile(1)) - .linkTmpFile(1);
	/* at this point we have the input and output files so process the options */
	/* create a default module name from the target file name */
	moduleName(0) = 0;
	DO WHILE info.name(moduleName(0)) <> 0 AND moduleName(0) < 6;
		moduleName(0) = moduleName(0) + 1;
		moduleName(moduleName(0)) = info.name(moduleName(0)-1);
	END;
	/* print to :CO: if not specified */
	CALL pstrcpy(.cout, .printFileName);
	doMap = 0;	/* default is no map file */
	DO WHILE cmdCh <> 0DH;	/* while there are controls */
		CALL parseControl;
	END;
	DO p = 0 TO 127;
		hashChains(p) = 0;
	END;
	DO p = SEG$ABS TO SEG$RESERVE;
		segSizes(p) = 0;
		alignType(p) = 0;
	END;
	DO p = 0 TO 255;
		segmap(p) = 0;		/* mark seg as unused */
	END;
	modhdr$x1 = 0;
	modhdr$x2 = 0;
	isMain = 0;
	entrySeg = 0;
	entryAddr, headcitem, unresolved, maxExternCnt, headunres = 0;
	/* open print file (could be console) */
	CALL open(.printFileNo, .printFileName(1), 2, 0, .statusIO);
	CALL errChkReport(statusIO, .printFileName(1), 0FFH);
	/* if printing to other than console, log the login & command line */
	IF printFileNo > 0 THEN
	DO;
		CALL writeBytes(.login, size(login));
		CALL writeBytes(.VERSION, 4);
		CALL writeBytes(.msgInvoked, 14);
		CALL writeBytes(.scmdch, cmd$p - .scmdch + 2);
	END;
END parseCmdLine;

END link3a;
