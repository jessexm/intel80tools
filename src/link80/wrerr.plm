wrerr:
DO;

/* from ISIS.EXT */
write: procedure (conn, buff$p, count, status$p) external;
    declare (conn, buff$p, count, status$p) address;
end write;
error: procedure (error$num) external;
    declare (error$num) address;
end error;

DECLARE errStrTable(*) BYTE DATA (
	2,'ILLEGAL AFTN ARGUMENT',0,
	3,'TOO MANY OPEN FILES',0,
	4,'INCORRECTLY SPECIFIED FILE',0,
	5,'UNRECOGNIZED DEVICE NAME',0,
	9,'DISK DIRECTORY FULL',0,
	12,'FILE IS ALREADY OPEN',0,
	13,'NO SUCH FILE',0,
	14,'WRITE PROTECTED',0,
	17,'NOT A DISK FILE',0,
	19,'ATTEMPTED SEEK ON NON-DISK FILE',0,
	20,'ATTEMPTED BACK SEEK TOO FAR',0,
	21,'CAN''T RESCAN',0,
	22,'ILLEGAL ACCESS MODE TO OPEN',0,
	23,'MISSING FILENAME',0,
	27,'ILLEGAL SEEK COMMAND',0,
	28,'MISSING EXTENSION',0,
	31,'CAN''T SEEK ON WRITE ONLY FILE',0,
	32,'CAN''T DELETE OPEN FILE',0,
	34,'ILLEGAL LOAD COMMAND',0,
	35,'SEEK PAST EOF',0,
	203,'INVALID SYNTAX',0,
	204,'PREMATURE EOF',0,
	208,'CHECKSUM ERROR',0,
	210,'INSUFFICIENT MEMORY',0,
	211,'RECORD TOO LONG',0,
	212,'ILLEGAL RELO RECORD',0,
	213,'FIXUP BOUNDS ERROR',0,
	218,'ILLEGAL RECORD FORMAT',0,
	219,'PHASE ERROR',0,
	220,'NO EOF',0,
	221,'SEGMENT TOO LARGE',0,
	224,'BAD RECORD SEQUENCE',0,
	225,'INVALID NAME',0,
	226,'NAME TOO LONG',0,
	227,'LEFT PARENTHESIS EXPECTED',0,
	228,'RIGHT PARENTHESIS EXPECTED',0,
	229,'UNRECOGNIZED CONTROL',0,
	233,'''TO'' EXPECTED',0,
	234,'DUPLICATE FILE NAME',0,
	235,'NOT A LIBRARY',0,
	236,'TOO MANY COMMON SEGMENTS',0,
	238,'ILLEGAL STACK CONTENT RECORD',0,
	239,'NO MODULE HEADER RECORD',0,
	0);


writeErrStr: PROCEDURE(errCode) PUBLIC;
	DECLARE errCode ADDRESS;
	DECLARE i ADDRESS;
	DECLARE status ADDRESS;

	IF LOW(errCode) <> 0 THEN
	DO;
	    i = 0;
	    DO WHILE i < LENGTH(errStrTable);
		IF LOW(errCode) = errStrTable(i) THEN
		DO;
			CALL write(0, .(' '), 1, .status);
			DO WHILE errStrTable(i := i + 1) <> 0;
				CALL write(0, .errStrTable(i), 1, .status);
			END;
			CALL write(0, .(0DH, 0AH), 2, .status);
			RETURN;
		END;
		ELSE DO;
			DO WHILE errStrTable(i := i + 1) <> 0;
			END;
			i = i + 1;
		END;
            END;
	    CALL error(errCode);	/* pass to ISIS */
	END;
END writeErrStr;



END;
