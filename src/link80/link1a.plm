$xref
/*	Copyright (c) 2012 by Mark Ogden
	Released into the public domain for academic historic interest
	only and not for commercial gain. */
link1a:
DO;
$include(link1a.ipx)

allocUp: PROCEDURE(count) ADDRESS PUBLIC;
	DECLARE count ADDRESS;

	IF topHeap - baseHeap >= count THEN
		RETURN (baseHeap := baseHeap + count) - count;
	CALL errChkReport(ERR210, .toFilename(1), TRUE);	/* Insufficient memory */
END allocUp;

allocdown: PROCEDURE(count) ADDRESS PUBLIC;
	DECLARE count ADDRESS;
	IF topHeap - baseHeap >= count THEN
		RETURN (topHeap := topHeap - count);
	CALL errChkReport(ERR210, .toFilename(1), TRUE);	/* Insufficient memory */
END allocdown;

chkRead: PROCEDURE(cnt) PUBLIC;	/* make sure next cnt bytes are in the input buffer */
	DECLARE cnt ADDRESS;
	DECLARE bcnt ADDRESS;
	
	/* see if enough bytes in the i/o buf. if not shuffle down and reload more */
	IF (bcnt := ebuf$p - buf$p) < cnt THEN
	DO;
		CALL memmov(bcnt, buf$p, sbuf$p);
		CALL read(readfd, sbuf$p + bcnt, npbuf - bcnt, .actRead, .statusIO);
		CALL errChkReport(statusIO, .inFileName(1), TRUE);
		/* calculare new inBlk and inByt */
		inBlk = inBlk + (inByt + buf$p - sbuf$p) / 128;
		inByt = (inByt + buf$p - sbuf$p) MOD 128;
		IF (bcnt := bcnt + actRead) < cnt THEN
			CALL errChkReport(ERR204, .inFileName(1), TRUE);    /* Premature EOF */
		/* mark the new end */
		ebuf$p = (buf$p := sbuf$p) + bcnt;
	END;
END chkRead;

getRecord: PROCEDURE PUBLIC;
	DECLARE ch BASED inb$p BYTE;
	DECLARE bcnt ADDRESS;
	DECLARE erec BASED erec$p BYTE;
	DECLARE (s, e) ADDRESS AT(.inRecord$p);

	IF (bcnt := ebuf$p - buf$p) >= 4 THEN
	DO;
		inRecord$p = buf$p;
		/*erec$p = inRecord$p + inRecord.len + 2;	/* type + data + crc */
		e = s + inRecord.len + 2;	/* type + data + crc */
	END;
	ELSE
	DO;
		inRecord$p = .DUMMYREC;
		erec$p = 0FFFFH;
	END;
	IF erec$p >= ebuf$p THEN
		IF inRecord.len <= 1025 THEN	/* should be able to get all of record in buffer */
		DO;
			CALL chkRead(bcnt + 1);
			inRecord$p = buf$p;
			IF (e := s + inRecord.len + 2) >= ebuf$p THEN /* redundant - done in chkRead */
				CALL errChkReport(ERR204, .inFileName(1), TRUE);	/* premature EOF */
		END;
	recLen = inRecord.len;
	in$p =  inRecord$p + 3;
	buf$p = erec$p + 1;
	recNum = recNum + 1;
	IF inRecord.type > R$COMDEF OR inRecord.type THEN	/* > 2EH or odd */
		CALL illegalRelo;
	IF inRecord.type = R$CONTENT THEN			/* content handled specially */
		RETURN;
	IF inRecord.type >= R$LIBLOCS  AND inRecord.type <= R$LIBDICT THEN
		return;						/* library records handled specially */
	IF recLen > 1025 THEN
		CALL fatalErr(ERR211);	/* record too long */
	inCRC = 0;					/* test checksum */
	DO inb$p = .inRecord.type TO .erec;
		inCRC = inCRC + ch;
	END;
	IF inCRC <> 0 THEN
		CALL fatalErr(ERR208);	/* checksum error */
END getRecord;

objSeek: PROCEDURE(blk, byt) PUBLIC;	/* seek in input buffer */
	DECLARE (blk, byt) ADDRESS;

	/* check if already in memory, if so update buf$p only */
	IF inBlk <= blk AND blk <= (inByt + (ebuf$p - sbuf$p))  / 128 + inBlk THEN
	DO;
		IF (buf$p := sbuf$p + (blk - inBlk) * 128 + (byt - inByt))
		    >= sbuf$p AND buf$p < ebuf$p THEN
			RETURN;
	END;
	CALL seek(readfd, 2, .blk, .byt, .statusIO);		/* seek on disk */
	CALL errChkReport(statusIO, .inFileName(1), TRUE);
	recNum = 0;						/* reset vars and read at least 1 byte */
	buf$p = ebuf$p;
	CALL chkRead(1);
	inBlk = blk;
	inByt = byt;
END objSeek;

openObjFile: PROCEDURE PUBLIC;
	CALL pstrcpy(.objfile.name(0), .inFilename(0));		/* copy the user supplied file name */
	inFileName(inFileName(0)+1) = ' ';			/* terminate with a space */
	CALL open(.readfd, .inFileName(1), 1, 0, .statusIO);	/* open the file */
	CALL errChkReport(statusIO, .inFileName(1), TRUE);
	recNum, curModule = 0;					/* reset vars and read at least 1 byte */
	buf$p = ebuf$p;
	CALL chkRead(1);
	inBlk, inByt = 0;
END openObjFile;

closeObjFile: PROCEDURE PUBLIC;					/* close file and link to next one */
	CALL close(readfd, .statusIO);
	CALL errChkReport(statusIO, .inFileName(1), TRUE);
	curObjFile = objFile.link;
END closeObjFile;

END link1a;
