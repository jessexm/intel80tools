link1a:
DO;
$INCLUDE(LINK.EXT)
/* from ISIS.EXT */
close: procedure (conn, status$p) external;
    declare (conn, status$p) address;
end close;

read: procedure (conn, buff$p, count, actual$p, status$p) external;
    declare (conn, buff$p, count, actual$p, status$p) address;
end read;

open: procedure (conn$p, path$p, access, echo, status$p) external;
    declare (conn$p, path$p, access, echo, status$p) address;
end open;

seek: procedure (conn, mode, block$p, byte$p, status$p) external;
    declare (conn, mode, block$p, byte$p, status$p) address;
end seek;

DECLARE readfd ADDRESS EXTERNAL,
	statusIO ADDRESS EXTERNAL,
	actRead ADDRESS EXTERNAL,
	inFileName(16) BYTE EXTERNAL,
	toFileName(16) BYTE EXTERNAL,
	baseHeap ADDRESS EXTERNAL,
	topHeap ADDRESS EXTERNAL,
	(srec$p, erec$p) ADDRESS EXTERNAL,
	rec$p ADDRESS EXTERNAL,
	recNum ADDRESS EXTERNAL,
	recLen ADDRESS EXTERNAL,	
	npbuf ADDRESS EXTERNAL,
	sibuf$p ADDRESS EXTERNAL,
	ibuf$p ADDRESS EXTERNAL,
	eibuf$p ADDRESS EXTERNAL,
	objFileHead ADDRESS EXTERNAL,
	curObjFile ADDRESS EXTERNAL,
	curModule ADDRESS EXTERNAL,
	inBlk ADDRESS EXTERNAL,
	inByt ADDRESS EXTERNAL,
	inb$p ADDRESS EXTERNAL,
	inCRC BYTE EXTERNAL;

DECLARE DUMMYREC(1) BYTE EXTERNAL;


DECLARE	srec BASED srec$p STRUCTURE (type BYTE, len ADDRESS, rec(1) BYTE);
DECLARE objFile BASED curObjFile LIBRARY$T;

errChkReport: PROCEDURE(errCode, file, errExit) EXTERNAL;
	DECLARE errCode ADDRESS;
	DECLARE file ADDRESS;
	DECLARE errExit BYTE;
END errChkReport;

memmov: PROCEDURE(cnt, srcp, dstp) EXTERNAL;
	DECLARE (cnt, srcp, dstp) ADDRESS;
END memmov;

illegalRelo: PROCEDURE EXTERNAL;
END illegalRelo;

fatalErr: PROCEDURE(errCode) EXTERNAL;
	DECLARE errCode BYTE;
END fatalErr;

pstrcpy: PROCEDURE(psrc, pdst) EXTERNAL;
	DECLARE psrc ADDRESS;
	DECLARE pdst ADDRESS;
END pstrcpy;


allocUp: PROCEDURE(count) ADDRESS PUBLIC;
	DECLARE count ADDRESS;

	IF topHeap - baseHeap >= count THEN
		RETURN (baseHeap := baseHeap + count) - count;
	CALL errChkReport(ERR210, .toFilename(1), 0FFH);	/* Insufficient memory */
END allocUp;


allocdown: PROCEDURE(count) ADDRESS PUBLIC;
	DECLARE count ADDRESS;
	IF topHeap - baseHeap >= count THEN
		RETURN (topHeap := topHeap - count);
	CALL errChkReport(ERR210, .toFilename(1), 0FFH);	/* Insufficient memory */
END allocdown;


chkRead: PROCEDURE(cnt) PUBLIC;
	DECLARE cnt ADDRESS;
	DECLARE bcnt ADDRESS;
	
	IF (bcnt := eibuf$p - ibuf$p) < cnt THEN
	DO;
		CALL memmov(bcnt, ibuf$p, sibuf$p);
		CALL read(readfd, sibuf$p + bcnt, npbuf - bcnt, .actRead, .statusIO);
		CALL errChkReport(statusIO, .inFileName(1), 0FFH);
		inBlk = inBlk + (inByt + ibuf$p - sibuf$p) / 128;
		inByt = (inByt + ibuf$p - sibuf$p) MOD 128;
		IF (bcnt := bcnt + actRead) < cnt THEN
			CALL errChkReport(ERR204, .inFileName(1), 0FFH);    /* Premature EOF */

		eibuf$p = (ibuf$p := sibuf$p) + bcnt;
	END;
END chkRead;


getRecord: PROCEDURE PUBLIC;
	DECLARE ch BASED inb$p BYTE;
	DECLARE bcnt ADDRESS;
	DECLARE erec BASED erec$p BYTE;
	DECLARE (s, e) ADDRESS AT(.srec$p);

	IF (bcnt := eibuf$p - ibuf$p) >= 4 THEN
	DO;
		srec$p = ibuf$p;
		/*erec$p = srec$p + srec.len + 2;	/* type + data + crc */
		e = s + srec.len + 2;	/* type + data + crc */
	END;
	ELSE
	DO;
		srec$p = .DUMMYREC;
		erec$p = 0FFFFH;
	END;
	IF erec$p >= eibuf$p THEN
		IF srec.len <= 1025 THEN	/* should be able to get all of record in buffer */
		DO;
			CALL chkRead(bcnt + 1);
			srec$p = ibuf$p;
			IF (e := s + srec.len + 2) >= eibuf$p THEN
				CALL errChkReport(ERR204, .inFileName(1), 0FFH);	/* premature EOF */
		END;
	recLen = srec.len;
	rec$p =  srec$p + 3;
	ibuf$p = erec$p + 1;
	recNum = recNum + 1;
	IF srec.type > 2EH OR srec.type THEN	/* > 2EH or odd */
		CALL illegalRelo;
	IF srec.type = 6 THEN
		RETURN;
	IF srec.type >= 26H  AND srec.type <= 2AH THEN
		return;
	IF recLen > 1025 THEN
		CALL fatalErr(ERR211);	/* record too long */
	
	inCRC = 0;
	DO inb$p = .srec.type TO .erec;
		inCRC = inCRC + ch;
	END;
	IF inCRC <> 0 THEN
		CALL fatalErr(ERR208);	/* checksum error */
END getRecord;


iseek: PROCEDURE(blk, byt) PUBLIC;
	DECLARE (blk, byt) ADDRESS;

	IF inBlk <= blk AND blk <= (inByt + (eibuf$p - sibuf$p))  / 128 + inBlk THEN
	DO;
		IF (ibuf$p := sibuf$p + (blk - inBlk) * 128 + (byt - inByt))
		    >= sibuf$p AND ibuf$p < eibuf$p THEN
			RETURN;
	END;
	CALL seek(readfd, 2, .blk, .byt, .statusIO);
	CALL errChkReport(statusIO, .inFileName(1), 0FFH);
	recNum = 0;
	ibuf$p = eibuf$p;
	CALL chkRead(1);
	inBlk = blk;
	inByt = byt;
END iseek;


sub$3C5B: PROCEDURE PUBLIC;
	CALL pstrcpy(.objfile.name(0), .inFilename(0));
	inFileName(inFileName(0)+1) = ' ';
	CALL open(.readfd, .inFileName(1), 1, 0, .statusIO);
	CALL errChkReport(statusIO, .inFileName(1), 0FFH);
	recNum, curModule = 0;
	ibuf$p = eibuf$p;
	CALL chkRead(1);
	inBlk, inByt = 0;
END sub$3C5B;


closeObjFile: PROCEDURE PUBLIC;
	CALL close(readfd, .statusIO);
	CALL errChkReport(statusIO, .inFileName(1), 0FFH);
	curObjFile = objFile.link;
END closeObjFile;

END;
