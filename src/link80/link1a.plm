$xref
/*	Copyright (c) 2012 by Mark Ogden
	Released into the public domain for academic historic interest
	only and not for commercial gain. */
link1a:
DO;
$INCLUDE(LINK.EXT)
/* from ISIS.EXT */
close: procedure (conn, status$p) external;
    declare (conn, status$p) address;
end close;

read: procedure (conn, buff$p, count, actual$p, status$p) external;
    declare (conn, buff$p, count, actual$p, status$p) address;
end read;

open: procedure (conn$p, path$p, access, echo, status$p) external;
    declare (conn$p, path$p, access, echo, status$p) address;
end open;

seek: procedure (conn, mode, block$p, byte$p, status$p) external;
    declare (conn, mode, block$p, byte$p, status$p) address;
end seek;

DECLARE readfd ADDRESS EXTERNAL,
	statusIO ADDRESS EXTERNAL,
	actRead ADDRESS EXTERNAL,
	inFileName(16) BYTE EXTERNAL,
	toFileName(16) BYTE EXTERNAL,
	baseHeap ADDRESS EXTERNAL,
	topHeap ADDRESS EXTERNAL,
	(inRecord$p, erec$p) ADDRESS EXTERNAL,
	in$p ADDRESS EXTERNAL,
	recNum ADDRESS EXTERNAL,
	recLen ADDRESS EXTERNAL,	
	npbuf ADDRESS EXTERNAL,
	sbuf$p ADDRESS EXTERNAL,
	buf$p ADDRESS EXTERNAL,
	ebuf$p ADDRESS EXTERNAL,
	objFileHead ADDRESS EXTERNAL,
	curObjFile ADDRESS EXTERNAL,
	curModule ADDRESS EXTERNAL,
	inBlk ADDRESS EXTERNAL,
	inByt ADDRESS EXTERNAL,
	inb$p ADDRESS EXTERNAL,
	inCRC BYTE EXTERNAL;

DECLARE DUMMYREC(1) BYTE EXTERNAL;

DECLARE	inRecord BASED inRecord$p STRUCTURE (type BYTE, len ADDRESS, rec(1) BYTE);
DECLARE objFile BASED curObjFile LIBRARY$T;

errChkReport: PROCEDURE(errCode, file, errExit) EXTERNAL;
	DECLARE errCode ADDRESS;
	DECLARE file ADDRESS;
	DECLARE errExit BYTE;
END errChkReport;

memmov: PROCEDURE(cnt, srcp, dstp) EXTERNAL;
	DECLARE (cnt, srcp, dstp) ADDRESS;
END memmov;

illegalRelo: PROCEDURE EXTERNAL;
END illegalRelo;

fatalErr: PROCEDURE(errCode) EXTERNAL;
	DECLARE errCode BYTE;
END fatalErr;

pstrcpy: PROCEDURE(psrc, pdst) EXTERNAL;
	DECLARE psrc ADDRESS;
	DECLARE pdst ADDRESS;
END pstrcpy;

allocUp: PROCEDURE(count) ADDRESS PUBLIC;
	DECLARE count ADDRESS;

	IF topHeap - baseHeap >= count THEN
		RETURN (baseHeap := baseHeap + count) - count;
	CALL errChkReport(ERR210, .toFilename(1), TRUE);	/* Insufficient memory */
END allocUp;

allocdown: PROCEDURE(count) ADDRESS PUBLIC;
	DECLARE count ADDRESS;
	IF topHeap - baseHeap >= count THEN
		RETURN (topHeap := topHeap - count);
	CALL errChkReport(ERR210, .toFilename(1), TRUE);	/* Insufficient memory */
END allocdown;

chkRead: PROCEDURE(cnt) PUBLIC;	/* make sure next cnt bytes are in the input buffer */
	DECLARE cnt ADDRESS;
	DECLARE bcnt ADDRESS;
	
	/* see if enough bytes in the i/o buf. if not shuffle down and reload more */
	IF (bcnt := ebuf$p - buf$p) < cnt THEN
	DO;
		CALL memmov(bcnt, buf$p, sbuf$p);
		CALL read(readfd, sbuf$p + bcnt, npbuf - bcnt, .actRead, .statusIO);
		CALL errChkReport(statusIO, .inFileName(1), TRUE);
		/* calculare new inBlk and inByt */
		inBlk = inBlk + (inByt + buf$p - sbuf$p) / 128;
		inByt = (inByt + buf$p - sbuf$p) MOD 128;
		IF (bcnt := bcnt + actRead) < cnt THEN
			CALL errChkReport(ERR204, .inFileName(1), TRUE);    /* Premature EOF */
		/* mark the new end */
		ebuf$p = (buf$p := sbuf$p) + bcnt;
	END;
END chkRead;

getRecord: PROCEDURE PUBLIC;
	DECLARE ch BASED inb$p BYTE;
	DECLARE bcnt ADDRESS;
	DECLARE erec BASED erec$p BYTE;
	DECLARE (s, e) ADDRESS AT(.inRecord$p);

	IF (bcnt := ebuf$p - buf$p) >= 4 THEN
	DO;
		inRecord$p = buf$p;
		/*erec$p = inRecord$p + inRecord.len + 2;	/* type + data + crc */
		e = s + inRecord.len + 2;	/* type + data + crc */
	END;
	ELSE
	DO;
		inRecord$p = .DUMMYREC;
		erec$p = 0FFFFH;
	END;
	IF erec$p >= ebuf$p THEN
		IF inRecord.len <= 1025 THEN	/* should be able to get all of record in buffer */
		DO;
			CALL chkRead(bcnt + 1);
			inRecord$p = buf$p;
			IF (e := s + inRecord.len + 2) >= ebuf$p THEN /* redundant - done in chkRead */
				CALL errChkReport(ERR204, .inFileName(1), TRUE);	/* premature EOF */
		END;
	recLen = inRecord.len;
	in$p =  inRecord$p + 3;
	buf$p = erec$p + 1;
	recNum = recNum + 1;
	IF inRecord.type > R$COMDEF OR inRecord.type THEN	/* > 2EH or odd */
		CALL illegalRelo;
	IF inRecord.type = R$CONTENT THEN			/* content handled specially */
		RETURN;
	IF inRecord.type >= R$LIBLOCS  AND inRecord.type <= R$LIBDICT THEN
		return;						/* library records handled specially */
	IF recLen > 1025 THEN
		CALL fatalErr(ERR211);	/* record too long */
	inCRC = 0;					/* test checksum */
	DO inb$p = .inRecord.type TO .erec;
		inCRC = inCRC + ch;
	END;
	IF inCRC <> 0 THEN
		CALL fatalErr(ERR208);	/* checksum error */
END getRecord;

iseek: PROCEDURE(blk, byt) PUBLIC;	/* seek in input buffer */
	DECLARE (blk, byt) ADDRESS;

	/* check if already in memory, if so update buf$p only */
	IF inBlk <= blk AND blk <= (inByt + (ebuf$p - sbuf$p))  / 128 + inBlk THEN
	DO;
		IF (buf$p := sbuf$p + (blk - inBlk) * 128 + (byt - inByt))
		    >= sbuf$p AND buf$p < ebuf$p THEN
			RETURN;
	END;
	CALL seek(readfd, 2, .blk, .byt, .statusIO);		/* seek on disk */
	CALL errChkReport(statusIO, .inFileName(1), TRUE);
	recNum = 0;						/* reset vars and read at least 1 byte */
	buf$p = ebuf$p;
	CALL chkRead(1);
	inBlk = blk;
	inByt = byt;
END iseek;

openObjFile: PROCEDURE PUBLIC;
	CALL pstrcpy(.objfile.name(0), .inFilename(0));		/* copy the user supplied file name */
	inFileName(inFileName(0)+1) = ' ';			/* terminate with a space */
	CALL open(.readfd, .inFileName(1), 1, 0, .statusIO);	/* open the file */
	CALL errChkReport(statusIO, .inFileName(1), TRUE);
	recNum, curModule = 0;					/* reset vars and read at least 1 byte */
	buf$p = ebuf$p;
	CALL chkRead(1);
	inBlk, inByt = 0;
END openObjFile;

closeObjFile: PROCEDURE PUBLIC;					/* close file and link to next one */
	CALL close(readfd, .statusIO);
	CALL errChkReport(statusIO, .inFileName(1), TRUE);
	curObjFile = objFile.link;
END closeObjFile;

END link1a;
