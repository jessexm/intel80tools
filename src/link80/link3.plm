$xref
/*	Copyright (c) 2012 by Mark Ogden
	Released into the public domain for academic historic interest
	only and not for commercial gain. */
link3:
DO;
$INCLUDE(LINK.EXT)
DECLARE 
	actRead ADDRESS EXTERNAL,
	inFileName(16) BYTE EXTERNAL,
	toFileName(16) BYTE EXTERNAL,
	doMap BYTE EXTERNAL,
	moduleName(32) BYTE EXTERNAL,
	isMain BYTE EXTERNAL,
	type2x1 BYTE EXTERNAL,
	type2x2 BYTE EXTERNAL,
	entrySeg BYTE EXTERNAL,
	entryAddr ADDRESS EXTERNAL,
	segSizes(6) ADDRESS EXTERNAL,
	alignType(6) BYTE EXTERNAL,
	segmap(256) BYTE EXTERNAL,
	baseHeap ADDRESS EXTERNAL,
	topHeap ADDRESS EXTERNAL,
	srec$p ADDRESS EXTERNAL,
	erec$p ADDRESS EXTERNAL,
	rec$p ADDRESS EXTERNAL,
	recNum ADDRESS EXTERNAL,
	recLen ADDRESS EXTERNAL,
	npbuf ADDRESS EXTERNAL,
	sibuf$p ADDRESS EXTERNAL,
	ibuf$p ADDRESS EXTERNAL,
	eibuf$p ADDRESS EXTERNAL,
	objFileHead ADDRESS EXTERNAL,
	curObjFile ADDRESS EXTERNAL,
	curModule ADDRESS EXTERNAL,
	hashChains(128) ADDRESS EXTERNAL,
	headcitem ADDRESS EXTERNAL,
	citem$p ADDRESS EXTERNAL,
	symbol$p ADDRESS EXTERNAL,
	unresolved ADDRESS EXTERNAL,
	word$4820 ADDRESS EXTERNAL,
	headunres ADDRESS EXTERNAL;

DECLARE erec BASED erec$p BYTE;
DECLARE msgmultdef(*) BYTE INITIAL(' - MULTIPLELY DEFINED, DUPLICATE IN ');
DECLARE msgmore1main(*) BYTE INITIAL('MORE THAN 1 MAIN MODULE, CONFLICT IN ');
DECLARE msgmodnotinlib(*) BYTE INITIAL('MODULE NOT IN LIBRARY, LOOKING FOR ');
DECLARE msgbadcom(*) BYTE INITIAL('/ - UNEQUAL COMMON LENGTH, CONFLICT IN ');
DECLARE msglinkmap(*) BYTE INITIAL(0DH, 0AH, 'LINK MAP OF MODULE ');
DECLARE msgwrittento(*) BYTE INITIAL(0Dh, 0Ah, 'WRITTEN TO FILE ');
DECLARE msgismain(*) BYTE INITIAL(0Dh, 0Ah, 'MODULE IS A MAIN MODULE');
DECLARE msgnotmain(*) BYTE INITIAL(0Dh, 0Ah, 'MODULE IS NOT A MAIN MODULE');
DECLARE msgseginfo(*) BYTE INITIAL(0Dh, 0Ah, 0Ah, 'SEGMENT INFORMATION:',
			       0Dh, 0Ah, 'START   STOP LENGTH REL NAME', 0Dh, 0Ah);
DECLARE msgmodincluded(*) BYTE INITIAL(0Dh, 0Ah, 0Ah,'INPUT MODULES INCLUDED:', 0Dh, 0Ah);
DECLARE msgunresolved(*) BYTE INITIAL(0Dh, 0Ah, 'UNRESOLVED EXTERNAL NAMES:', 0Dh, 0Ah);
DECLARE spc14(*) BYTE INITIAL('              ');
DECLARE a$range(*) BYTE INITIAL ('XXXXH  XXXXH  ');
DECLARE	a$size(*) BYTE INITIAL('XXXXH  X  ');
DECLARE msgGap(*) BYTE INITIAL('  *GAP*');
DECLARE msgOverlap(*) BYTE INITIAL('  *OVERLAP*');
DECLARE aInpageSegment(*) BYTE INITIAL('  *INPAGE SEGMENT > 256 BYTES*');
DECLARE msgPublics(*) BYTE INITIAL(' (PUBLICS)');
DECLARE slash2 (2) BYTE INITIAL ('//');
DECLARE aAbsolute(*) BYTE INITIAL('ABSOLUTE', 'CODE    ', 'DATA    ', 'STACK   ', 'MEMORY  ');
DECLARE	a$types(*) BYTE INITIAL(' AIPB');

DECLARE segUsed(6) BYTE,
	segToUse BYTE INITIAL(254),
	byte$623F BYTE INITIAL(0FFH),
	x1b2notset BYTE INITIAL(0FFH),
	segInfo$p ADDRESS INITIAL(0),
	segLists(6) ADDRESS,
	block$p ADDRESS,
	(slp, slq) ADDRESS,
	word$6255 ADDRESS,
	word6257 ADDRESS,
	hmodule$p ADDRESS,
	isPublics BYTE,
	moreRecords BYTE,
	haveModuleHdr BYTE,
	byte$625E BYTE,
	curseg BYTE,
	dummyrec BYTE,
	word$6261 ADDRESS,
	seg$i ADDRESS,
	symcnt ADDRESS,
	word$6267 ADDRESS,
	word$6269 ADDRESS,
	curSegOffset ADDRESS;

/* DECLARE	pageTab1 BASED pageTab1$p (1) STRUCTURE (state BYTE, mpage BYTE);
DECLARE	pageTab2 BASED pageTab2$p (1) STRUCTURE (state BYTE, fpage BYTE);
*/
DECLARE	srec BASED srec$p STRUCTURE (type BYTE, len ADDRESS, rec(1) BYTE);
/*DECLARE	sout BASED sout$p STRUCTURE (type BYTE, len ADDRESS, rec(1) BYTE); */
DECLARE t02arec BASED rec$p STRUCTURE (name(1) BYTE);
DECLARE t02brec BASED rec$p STRUCTURE (x1 BYTE, x2 BYTE);
DECLARE t02crec BASED rec$p STRUCTURE (seg BYTE, segsize ADDRESS, align BYTE);
DECLARE	t4rec BASED rec$p STRUCTURE (modtype BYTE, segid BYTE, offset ADDRESS);
/* DECLARE	t4out BASED out$p STRUCTURE (modtype BYTE, segid BYTE, offset ADDRESS); */
DECLARE	t6rec BASED rec$p STRUCTURE (seg BYTE, addr ADDRESS, bytes(1) BYTE);
/* DECLARE	t6out BASED out$p STRUCTURE (seg BYTE, addr ADDRESS, bytes(1) BYTE); */
DECLARE	t8arec BASED rec$p STRUCTURE (seg BYTE);
DECLARE	t8brec BASED rec$p STRUCTURE (addr ADDRESS, line ADDRESS);
/* DECLARE	t8aout BASED out$p STRUCTURE (seg BYTE); */
/* DECLARE	t8bout BASED out$p STRUCTURE (addr ADDRESS, line ADDRESS); */
DECLARE t10rec BASED rec$p STRUCTURE (name(1) BYTE);
/* DECLARE t10out BASED out$p STRUCTURE (name(1) BYTE); */
DECLARE t12arec BASED rec$p STRUCTURE (seg BYTE);
DECLARE t12brec BASED rec$p STRUCTURE (offset ADDRESS, name(1) BYTE /*, 0 */);
/* DECLARE t12aout BASED out$p STRUCTURE (seg BYTE); */
/* DECLARE t12bout BASED out$p STRUCTURE (offset ADDRESS, name(1) BYTE); */
DECLARE t16arec LITERALLY 't12arec';
DECLARE t16brec LITERALLY 't12brec';
DECLARE t16aout LITERALLY 't12aout';
DECLARE t16bout LITERALLY 't12bout';
DECLARE t18rec BASED rec$p STRUCTURE (name(1) BYTE /*, 0 */);
/* DECLARE t18out BASED out$p STRUCTURE (name(1) BYTE); */
DECLARE	t20arec BASED rec$p STRUCTURE (fixType BYTE);
/* DECLARE	t20aout BASED out$p STRUCTURE (fixType BYTE); */
DECLARE	t20brec BASED rec$p STRUCTURE (sym ADDRESS, addr ADDRESS);
/* DECLARE	t20bout BASED out$p STRUCTURE (sym ADDRESS, addr ADDRESS); */
DECLARE	t22arec BASED rec$p STRUCTURE (fixType BYTE);
DECLARE	t22brec BASED rec$p STRUCTURE (addr ADDRESS);
DECLARE	t24arec BASED rec$p STRUCTURE (seg BYTE);
/* DECLARE	t24aout BASED out$p STRUCTURE (seg BYTE, fixType BYTE); */
/* DECLARE	t24bout BASED out$p STRUCTURE (addr ADDRESS); */
DECLARE t26rec BASED rec$p STRUCTURE (blk ADDRESS, byt ADDRESS);
DECLARE t28rec BASED rec$p STRUCTURE (modname(1) BYTE);	/* repeated */
DECLARE t2Arec BASED rec$p STRUCTURE (pubname(1) BYTE);	/* repeated 0 length end of sub list */
DECLARE t2Crec BASED rec$p STRUCTURE (unk ADDRESS, blk ADDRESS, byt ADDRESS);
DECLARE	t2Erec BASED rec$p STRUCTURE (seg BYTE, name(1) BYTE);

DECLARE segInfo BASED segInfo$p(1) STRUCTURE (flag BYTE, segsize ADDRESS);
DECLARE symbol BASED symbol$p
	STRUCTURE (link ADDRESS, flag BYTE, seg BYTE, offset ADDRESS, nxtUnres ADDRESS, name(1) BYTE);
DECLARE citem BASED citem$p
	STRUCTURE (link ADDRESS, align BYTE, seg BYTE, csize ADDRESS, link2 ADDRESS, name(8) BYTE);
DECLARE block BASED block$p STRUCTURE (link ADDRESS, bot ADDRESS, top ADDRESS);

DECLARE rbytes BASED rec$p (1) BYTE;
DECLARE rwords BASED rec$p (1) ADDRESS;
DECLARE objFile BASED curObjFile LIBRARY$T;
DECLARE module BASED curModule MODULE$T;
DECLARE hmodule BASED hmodule$p MODULE$T;

/* EXTERNALS */
chkRead: PROCEDURE(cnt) EXTERNAL;
	DECLARE cnt ADDRESS;
END chkRead;

iseek: PROCEDURE(blk, byt) EXTERNAL;
	DECLARE (blk, byt) ADDRESS;
END iseek;

illegalRecord: PROCEDURE EXTERNAL;
END illegalRecord;

illegalRelo: PROCEDURE EXTERNAL;
END illegalRelo;

badRecordSeq: PROCEDURE EXTERNAL;
END badRecordSeq;

getRecord: PROCEDURE EXTERNAL;
END getRecord;

writeCRLF: PROCEDURE EXTERNAL;
END writeCRLF;

openObjFile: PROCEDURE EXTERNAL;
END openObjFile;

binasc: PROCEDURE(num, base, padch, bufp, width) EXTERNAL;
	DECLARE num ADDRESS, (base, padch) BYTE, bufp ADDRESS, width BYTE;
END binasc;

writeBytes: PROCEDURE(buf$p, count) EXTERNAL;
	DECLARE buf$p ADDRESS;
	DECLARE count ADDRESS;
END writeBytes;

writeAndEcho: PROCEDURE(buff$p, count) EXTERNAL;
	DECLARE buff$p ADDRESS;
	DECLARE count ADDRESS;
END writeAndEcho;

allocUp: PROCEDURE(count) ADDRESS EXTERNAL;
	DECLARE count ADDRESS;
END allocUp;

allocdown: PROCEDURE(count) ADDRESS EXTERNAL;
	DECLARE count ADDRESS;
END allocdown;

fatalErr: PROCEDURE(errCode) EXTERNAL;
	DECLARE errCode BYTE;
END fatalErr;

wAEFnAndMod: PROCEDURE(buff$p, count) EXTERNAL;
	DECLARE buff$p ADDRESS;
	DECLARE count ADDRESS;
END wAEFnAndMod;

find: PROCEDURE(pstr, ppitem, arg3b) BYTE EXTERNAL;
	DECLARE (pstr, ppitem) ADDRESS, arg3b BYTE;
END find;

pstrcpy: PROCEDURE(psrc, pdst) EXTERNAL;
	DECLARE psrc ADDRESS;
	DECLARE pdst ADDRESS;
END pstrcpy;

strequ: PROCEDURE(str1p, str2p, cnt) BYTE EXTERNAL;
	DECLARE (str1p, str2p) ADDRESS;
	DECLARE cnt BYTE;
END strequ;

errChkReport: PROCEDURE(errCode, file, errExit) EXTERNAL;
	DECLARE errCode ADDRESS;
	DECLARE file ADDRESS;
	DECLARE errExit BYTE;
END errChkReport;

closeObjFile: PROCEDURE EXTERNAL;
END closeObjFile;

/* saving pointers? */
sub$48E1: PROCEDURE PUBLIC;
	dummyrec = srec.type;
	srec$p = .dummyrec;
	ibuf$p = rec$p;
END sub$48E1;

/* copy next record? */
sub$48F5: PROCEDURE PUBLIC;
	DO WHILE eibuf$p - ibuf$p < recLen;
		recLen = recLen - (eibuf$p - ibuf$p);
		ibuf$p = eibuf$p;
		CALL chkRead(1);
	END;
	ibuf$p = ibuf$p + recLen;
END sub$48F5;

skipName: PROCEDURE BYTE PUBLIC;
	DECLARE str BASED rec$p(1) BYTE;

	CALL chkRead(1);
	rec$p = ibuf$p;
	IF recLen < 2 THEN
	DO;
		ibuf$p = ibuf$p + recLen;
		RETURN recLen := 0;
	END;
	CALL chkRead(str(0) + 1);
	rec$p = ibuf$p;
	IF recLen < str(0) + 1 THEN
		CALL illegalRecord;
	ibuf$p = ibuf$p + str(0) + 1;
	recLen = recLen - (str(0) + 1);
	RETURN 0FFH;
END skipName;

/* eat 4 bytes of record (block num and byte num)*/
eat4: PROCEDURE PUBLIC;
	IF recLen < DOUBLE(4) THEN
		CALL illegalRecord;
	CALL chkRead(4);
	ibuf$p = (rec$p := ibuf$p) + DOUBLE(4);
	recLen = recLen - DOUBLE(4);
END eat4;

/* get next record, test type, and error if not as expected */
expectType: PROCEDURE(type) PUBLIC;
	DECLARE type BYTE;

	CALL getRecord;
	recNum = 0;
	IF type <> srec.type THEN
		CALL badRecordSeq;
END expectType;

/* print segment base, size and alignment */
writeBaseSizeAlign: PROCEDURE(baddr, bsize, align) PUBLIC;
	DECLARE baddr ADDRESS;
	DECLARE bsize ADDRESS;
	DECLARE align BYTE;

	CALL writeCRLF;
	IF (align := align + 1) <= 1 THEN
	DO;
		CALL binasc(baddr, 16, '0', .a$range, 4);
		CALL binasc(baddr + bsize - 1, 16, '0', .a$range(7), 4);
		CALL writeBytes(.a$range, 14);
	END;
	ELSE
		CALL writeBytes(.spc14, LENGTH(spc14));
	CALL binasc(bsize, 16, ' ', .a$size, 4);
	a$size(7) = a$types(align);
	CALL writeBytes(.a$size, 10);
END writeBaseSizeAlign;

/* wrtie module statistics */
writeStats: PROCEDURE PUBLIC;
	DECLARE i BYTE;

	IF NOT doMap THEN
		RETURN;
	CALL writeBytes(.msglinkmap, LENGTH(msglinkmap));
	CALL writeBytes(.moduleName(1), moduleName(0));
	CALL writeBytes(.msgwrittento, LENGTH(msgwrittento));
	CALL writeBytes(.toFileName(1), toFileName(0));
	IF isMain = 0 THEN
		CALL writeBytes(.msgnotmain, LENGTH(msgnotmain));
	ELSE
		CALL writeBytes(.msgismain, LENGTH(msgismain));
	CALL writeBytes(.msgseginfo, LENGTH(msgseginfo));
	DO curseg = SEG$CODE TO SEG$MEMORY;	/* regular segments */
		IF segSizes(curseg) > 0 THEN	/* segment is used */
		DO;
			CALL writeBaseSizeAlign(0, segSizes(curseg), alignType(curseg));
			CALL writeBytes(.aAbsolute(SHL(curseg, 3)), 8);
			IF alignType(curseg) = 1 AND segSizes(curseg) > 256 THEN
				CALL writeBytes(.aInPageSegment, LENGTH(aInPageSegment));	/* inpage segment > 256 bytes */
			block$p = segLists(curseg);
			DO WHILE block$p > 0;
				CALL writeBaseSizeAlign(block.bot, block.top - block.bot + 1, 0FFH); 
				CALL writeBytes(.aAbsolute(SHL(curseg, 3)), 8);
				CALL writeBytes(.msgGap, LENGTH(msgGap));
				block$p = block.link;
			END;
		END;
	END;
	citem$p = headcitem;				/* common block segments */
	DO WHILE citem$p > 0;
		CALL writeBaseSizeAlign(0, citem.csize, citem.align);
		CALL writeBytes(.slash2, 1);
		CALL writeBytes(.citem.name(1), citem.name(0));
		CALL writeBytes(.slash2, 1);
		IF citem.align = 1 AND citem.csize > 256 THEN
			CALL writeBytes(.aInpageSegment, LENGTH(aInPageSegment));	/* inpage segment > 256 bytes */
		citem$p = citem.link2;
	END;
	IF segSizes(0) > 0 THEN
	DO;
		CALL writeBaseSizeAlign(0, segSizes(0), alignType(0));
		CALL writeBytes(.slash2, 2);
		IF alignType(0) = 1 AND segSizes(0) > 256 THEN
			CALL writeBytes(.aInpageSegment, LENGTH(aInPageSegment));	/* inpage segment > 256 bytes */
	END;
	seg$i = 0;
	block$p = segLists(0);
	DO WHILE block$p > 0;
		CALL writeBaseSizeAlign(block.bot, block.top - block.bot + 1, 0);
		CALL writeBytes(.aAbsolute, 8);
		IF block.bot < seg$i THEN
			CALL writeBytes(.msgOverlap, LENGTH(msgOverlap));
		IF block.top >= seg$i THEN
			seg$i = block.top + 1;
		block$p = block.link;
	END;	/* do while */
	CALL writeBytes(.msgmodincluded, LENGTH(msgmodincluded));
	curObjFile = objFileHead;
	DO WHILE curObjFile > 0;
		curModule = objFile.modlist;
		DO WHILE curmodule > 0;
			IF NOT objFile.ispublics OR module.symlist > 0 THEN
			DO;
				CALL writeBytes(.(' '), 1);
				CALL writeBytes(.objFile.name(1), objFile.name(0));
				CALL writeBytes(.('('), 1);
				CALl writeBytes(.module.name(1), module.name(0));
				CALL writeBytes(.(')'), 1);
				IF objFile.ispublics THEN
					CALL writeBytes(.msgPublics, LENGTH(msgPublics));
				CALL writeCRLF;
			END;
			curModule = module.link;
		END;
		curObjFile = objFile.link;
	END;
END writeStats;

writeUnresolved: PROCEDURE PUBLIC;
	DECLARE (p, q) ADDRESS;
	DECLARE symbola BASED p STRUCTURE (link ADDRESS, flag BYTE, seg BYTE, offset ADDRESS, nxtUnres ADDRESS, name(1) BYTE);
	DECLARE wrd BASED word6257 ADDRESS;

	IF unresolved = 0 THEN
		RETURN;
	CALL writeAndEcho(.msgunresolved, LENGTH(msgunresolved));
	q = unresolved;
	DO seg$i = 0 TO 127;
		symbol$p = hashChains(seg$i);
		DO WHILE symbol$p > 0;
			IF symbol.flag = 40h THEN
			DO;
				word6257 = .headunres;
				p = headunres;
				DO WHILE p > 0;
					IF symbola.offset > symbol.offset THEN
						goto loc$4E78;
					word6257 = .symbola.nxtUnres;
					p = symbola.nxtUnres;
				END;
			loc$4E78:
				symbol.nxtUnres = wrd;
				wrd = .symbol.link;
				IF (q := q - 1) = 0 THEN
					RETURN;
			END;
			symbol$p = symbol.link;
		END; /* DO WHILE */
	END;	/* DO .. TO */
END writeUnresolved;

/* inserts a block of data into segment list at proper address */
sub$4EC2: PROCEDURE(seg, bot, top) PUBLIC;
	DECLARE seg BYTE;
	DECLARE (bot, top) ADDRESS;
	DECLARE pblk BASED slp STRUCTURE (link ADDRESS, bot ADDRESS, top ADDRESS);
	DECLARE wrd BASED slq ADDRESS;

	IF NOT doMAP THEN
		RETURN;
	block$p = allocUp(6);
	block.bot = bot;
	block.top = top;
	slq = .segLists(seg);
	slp = segLists(seg);
	DO WHILE slp > 0;
		IF pblk.bot > bot THEN
			goto loc$4F4A;
		slq = .pblk.link;
		slp = pblk.link;
	END;
loc$4F4A:
	block.link = wrd;
	wrd = .block.link;
END sub$4EC2;

sub$4F65: PROCEDURE PUBLIC;
	IF curseg = 0FFH THEN
	DO;
		IF segUsed(0) THEN
			CALL illegalRecord;
		segUsed(0) = 0FFH;
		IF word$6261 > segSizes(0) THEN
			segSizes(0) = word$6261;
		IF alignType(0) = 0 THEN
			alignType(0) = byte$625E;
		ELSE IF alignType(0) <> ALN$BYTE OR byte$625E <> ALN$BYTE THEN
			alignType(0) = ALN$PAGE;
	END;
	ELSE
	DO;
		IF byte$623F THEN
		DO;
			IF seginfo$p = 0 THEN
				segInfo$p = allocUp(300H);
			DO seg$i = 0 TO 255;
				segInfo(seg$i).flag = 0;
			END;
			byte$623F = 0;
		END;
		IF segInfo(curseg).flag <> 0 THEN
			CALL illegalRecord;
		segInfo(curseg).flag = byte$625E;
		segInfo(curseg).segsize = word$6261;
	END;
END sub$4F65;

sub$5059: PROCEDURE PUBLIC;
	DECLARE (p, q) ADDRESS;

	IF segUsed(curseg) THEN
		CALL illegalRecord;
	segUsed(curseg) = 0FFH;
	IF curseg = SEG$ABS OR curseg > SEG$MEMORY THEN
		CALL illegalRecord;
	IF word$6261 = 0 THEN
		RETURN;
	IF curseg = SEG$CODE OR curseg = SEG$DATA THEN
	DO;
		IF alignType(curseg) = ALN$UNDEF THEN
		DO;
			alignType(curseg) = byte$625E;
			segSizes(curseg) = word$6261;
			q = 0;
		END;
		ELSE
		DO;
			p = segSizes(curseg);
			DO CASE byte$625E - 1;
				DO;
					IF LOW(p) + word$6261 <= 100H THEN
						q = p + word$6261;
					ELSE
						q = ((p + 0FFH) AND 0FF00H) + word$6261;

					IF alignType(curseg) <> ALN$INPAGE OR q > 100H THEN
						alignType(curseg) = ALN$PAGE;
				END;
				DO;
					alignType(curseg) = ALN$PAGE;
					q = ((p + 0FFH) AND 0FF00H) + word$6261;
				END;
				DO;
					IF alignType(curseg) = ALN$INPAGE THEN
						alignType(curseg) = ALN$PAGE;
					q = p + word$6261;
				END;
			END;
			segSizes(curseg) = q;
			IF (q := q - word$6261) > p THEN
				CALL sub$4EC2(curseg, p, q - 1);
			IF segSizes(curseg) < q THEN
				CALL fatalErr(ERR221);	/* segment too large */
		END;
		IF curseg = SEG$CODE THEN
			module.scode = q;
		ELSE
			module.sdata = q;
	END;
	ELSE
	DO;
		IF alignType(curseg) = ALN$UNDEF THEN
			alignType(curseg) = byte$625E;
		ELSE IF alignType(curseg) <> ALN$BYTE OR byte$625E <> ALN$BYTE THEN
			alignType(curseg) = ALN$PAGE;
		segSizes(curseg) = segSizes(curseg) + word$6261;
	END;
END sub$5059;

sub52A9: PROCEDURE(seg) BYTE PUBLIC;
	DECLARE seg BYTE;

	curSegOffset = 0;
	IF seg = SEG$CODE THEN
		curSegOffset = module.scode;
	ELSE IF seg = SEG$DATA THEN
		curSegOffset = module.sdata;
	ELSE IF seg >= SEG$NAMCOM AND seg <> SEG$UNACOM THEN
	DO;
		IF byte$623F THEN
			CALL illegalRecord;
		IF segInfo(seg).flag = 255 THEN
			RETURN segInfo(seg).segsize;
		IF segInfo(seg).flag <> 0 THEN
			CALL badRecordSeq;
		CALL illegalRecord;
	END;
	RETURN seg;
END sub52A9;

pass1MODHDR: PROCEDURE PUBLIC;
	IF haveModuleHdr THEN
		CALL badRecordSeq;
	haveModuleHdr = 0FFH;
	word6257 = .module.symlist;
	IF isPublics THEN
		RETURN;
	rec$p = rec$p + t02arec.name(0) + 1;	/* past module name */
	IF x1b2notset THEN
	DO;
		x1b2notset = 0;
		type2x1 = t02brec.x1;
		type2x2 = t02brec.x2;
	END;
	IF t02brec.x1 <> type2x1 THEN
		type2x1 = 0;
	IF t02brec.x2 <> type2x2 THEN
		type2x2 = 0;
	rec$p = rec$p + 2;
	module.scode = segSizes(1);
	module.sdata = segSizes(2);
	byte$623F = 0FFH;			/* first call */
	DO seg$i = SEG$ABS TO SEG$RESERVE;
		segUsed(seg$i) = 0;
	END;
	DO WHILE rec$p < .erec;		/* while more segments */
		IF (byte$625E := t02crec.align) - 1 > 2 THEN
			CALL illegalRecord;
		word$6261 = t02crec.segsize;
		IF (curseg := t02crec.seg) >= SEG$NAMCOM THEN
			CALL sub$4F65;
		ELSE
			CALL sub$5059;
		rec$p = rec$p + 4;
	END;
END pass1MODHDR;

pass1MODEND: PROCEDURE PUBLIC;
	moreRecords = 0;
	IF isPublics THEN
		RETURN;
	IF t4rec.modtype = MT$MAIN THEN
		IF isMain <> MT$NOTMAIN THEN
			CALL wAEFnAndMod(.msgmore1main, LENGTH(msgmore1main));
		ELSE
		DO;
			isMain = MT$MAIN;
			entrySeg = sub52A9(t4rec.segid);
			entryAddr = curSegOffset + t4rec.offset;
		END;
	IF NOT byte623F THEN
		DO seg$i = 0 TO 255;
			IF seginfo(seg$i).flag + 1 > 1 THEN
				CALL badRecordSeq;
		END;
END pass1MODEND;

pass1CONTENT: PROCEDURE PUBLIC;		/* type 6 data */
	CALL sub$48E1;
	CALL chkRead(3);
	rec$p = ibuf$p;
	IF NOT isPublics THEN
	DO;
		IF (curseg := t6rec.seg) = 0 THEN	/* absolute record */
			CALL sub$4EC2(0, t6rec.addr, t6rec.addr + recLen - 5);
		ELSE						/* relocatable record */
		DO;
			IF recLen > 1025 THEN
				CALL fatalErr(ERR211);	/* record too long */
			IF curseg = 3 THEN
				CALL fatalErr(ERR238);	/* illegal stack content record */
			IF curseg < 6 THEN
			DO;
				IF NOT segUsed(curseg) THEN
					CALL illegalRecord;
			END;
			ELSE
			DO;
				IF curseg = 0FFH THEN
				DO;
					IF NOT segUsed(0) THEN
						CALL illegalRecord;
				END;
				ELSE
					curseg = sub52A9(curseg);
			END;
		END;
	END;
	CALL sub$48F5;
END pass1CONTENT;

pass1COMDEF: PROCEDURE PUBLIC;
	DECLARE wrd BASED word$6255 ADDRESS;

	IF isPublics THEN
		RETURN;
	IF byte$623F THEN
		CALL badRecordSeq;
	DO WHILE rec$p < .erec;
		IF (curseg := t2Erec.seg) < 6 OR curseg = 255 THEN
			CALL illegalRecord;
		IF segInfo(curseg).flag + 1 < 2 THEN
			CALL illegalRecord;
		IF find(.t2Erec.name, .citem$p, 0FH) THEN
		DO;
			IF citem.align <> 3 OR segInfo(curSeg).flag <> 3 THEN
				citem.align = 2;
			IF citem.csize <> segInfo(curseg).segsize THEN
			DO;
				IF segInfo(curseg).segsize > citem.csize THEN
					citem.csize = segInfo(curseg).segsize;
				CALL writeAndEcho(.slash2, 1);
				CALL writeAndEcho(.citem.name(1), citem.name(0));
				CALL wAEFnAndMod(.msgbadcom, 27H);
			END;
		END;
		ELSE
		DO;
			citem.link = allocdown(DOUBLE(9) + t2Erec.name(0));
			citem$p = citem.link;
			citem.link = 0;
			citem.align = segInfo(curseg).flag;
			IF segToUse < 6 THEN
				CALL fatalERR(ERR236);	/* too many common segments */
			citem.seg = segToUse;
			segToUse = segToUse - 1;
			CALL pstrcpy(.t2Erec.name, .citem.name);
			citem.csize = segInfo(curseg).segsize;
			citem.link2 = wrd;
			wrd = .citem.link;
			word$6255 = .citem.link2;
		END; /* ELSE */
		segInfo(curseg).flag = 0FFH;
		segInfo(curseg).segsize = citem.seg;
		rec$p = rec$p + 2 + t2Erec.name(0);
	END;	/* DO WHILE */
END pass1COMDEF;

pass1PUBNAMES: PROCEDURE PUBLIC;

	sub$58C2: PROCEDURE;
		DECLARE wrd BASED word6257 ADDRESS;

		symbol.flag = 80H;
		symbol.seg = curseg;
		symbol.offset = curSegOffset + t16brec.offset;
		segmap(curseg) = 0FFH;		/* flag as used seg */
		symbol.nxtUnres = wrd;
		wrd = .symbol.link;
		word6257 = .symbol.nxtUnres;
	END sub$58C2;

	IF (curseg := t16arec.seg) <> 0 AND isPublics THEN
		RETURN;
	curseg = sub52A9(curseg);
	rec$p = rec$p + 1;
	DO WHILE rec$p < .erec;		/* while more public definitions */
		IF find(.t16brec.name, .symbol$p, 0F0H) THEN
		DO;
			IF symbol.flag = 80H THEN
			DO;
				IF curseg <> 0 OR symbol.seg <> curseg or symbol.offset <> t16brec.offset THEN
				DO;
					CALL writeAndEcho(.symbol.name(1), symbol.name(0));
					CALL wAEFnAndMod(.msgmultdef, LENGTH(msgmultdef));
				END;
			END;
			ELSE
			DO;
				unresolved = unresolved - 1;
				CALL sub$58C2;
			END;
		END;
		ELSE
		DO;
			symbol.link = allocdown(DOUBLE(9) + t16brec.name(0));
			symbol$p = symbol.link;
			symbol.link = 0;
			CALL pstrcpy(.t16brec.name, .symbol.name);
			CALL sub$58C2;
		END;
		rec$p = rec$p + 4 + t16brec.name(0);
	END;	/* do while */
END pass1PUBNAMES;

pass1EXTNAMES: PROCEDURE PUBLIC;
	IF isPublics THEN
		RETURN;
	DO WHILE .erec > rec$p;		/* while more external definitions */
		word$6269 = word$6269 + 1;
		IF NOT find(rec$p, .symbol$p, 0F0H) THEN
		DO;
			symbol.link = allocdown(DOUBLE(9) + t18rec.name(0));
			symbol$p = symbol.link;
			symbol.link = 0;
			symbol.flag = 40H;
			symbol.offset = (symcnt := symcnt + 1);
			CALL pstrcpy(.t18rec.name, .symbol.name);
			unresolved = unresolved + 1;
			word$6267 = word$6267 + 1;
		END;
		rec$p = rec$p + 2 + t18rec.name(0);
	END;
END pass1EXTNAMES;

/* process pass 1 records */
procPas1Recs: PROCEDURE(flag) PUBLIC;
	DECLARE flag BYTE;

	IF flag THEN
	DO;
		hmodule.link = (curModule := allocDown(DOUBLE(13) + t02arec.name(0)));
		module.link, module.symlist = 0;
		CALL pstrcpy(.t02arec.name, .module.name);
		hmodule$p = curModule;
	END;
	word$6269 = 0;
	recNum = 1;
	haveModuleHdr = 0;
	moreRecords = 0FFH;
	DO WHILE moreRecords;
		DO CASE SHR(srec.type, 1);
			CALL illegalRelo;	/* 0 */
			CALL pass1MODHDR;	/* R$MODHDR */
			CALL pass1MODEND;	/* R$MODEND */
			CALL pass1CONTENT;	/* R$CONTENT */
			;					/* R$LINENO */
			CALL illegalRelo;	/* 0A */
			CALL illegalRelo;	/* 0C */
			CALL errChkReport(ERR204, .inFileName(1), 0FFH);	/* Premature R$EOF */
			;			/* R$ANCESTOR */
			;			/* R$LOCALS */
			CALL illegalRelo;	/* 14 */
			CALL pass1PUBNAMES;	/* R$PUBLICS */
			CALL pass1EXTNAMES;	/* R$EXTNAMES */
			CALL illegalRelo;	/* 1A */
			CALL illegalRelo;	/* 1C */
			CALL illegalRelo;	/* 1E */
			;			/* R$EXTREF */
			;			/* R$RELOC */
			;			/* R$INTERSEG */
			CALL badRecordSeq;	/* R$LIBLOCS */
			CALL badRecordSeq;	/* R$LIBNAMES */
			CALL badRecordSeq;	/* R$LIBDICT */
			CALL badRecordSeq;	/* R$LIBHDR */
			CALL pass1COMDEF;	/* R$COMDEF */
		END;
		CALL getRecord;
	END;
	IF word$6269 > word$4820 THEN
		word$4820 = word$6269;
	IF srec.type <> R$EOF AND srec.type <> R$MODHDR AND srec.type <> R$LIBNAMES THEN
		CALL fatalErr(ERR220);	/* no EOF */
END procPas1Recs;

sub$5B2F: PROCEDURE PUBLIC;
	DECLARE pad(3) BYTE;
	DECLARE (blk, byt, blk2A, byt2A, modId, toResolve, i, modcnt , modlocs$p) ADDRESS;
	DECLARE modlocs BASED modlocs$p (1) STRUCTURE (blk ADDRESS, byt ADDRESS);

	objFile.hasModules = 0FFH;
	IF unresolved > 0 THEN
	DO;
		hmodule$p = .objFile.modlist;
		blk = t2Crec.blk;		/* library header block */
		byt = t2Crec.byt;		/* library header byte */
		CALL iseek(blk, byt);	/* seek to library module names record */
		CALL expectType(R$LIBNAMES);	/* get rec and validate type */ 
		CALL sub$48E1;			/* save pointers */
		blk = (byt + recLen + 3) / 128 + blk; /* step past library module names rec */
		byt = (byt + recLen + 3) MOD 128;
		CALL sub$48F5;
		CALL expectType(R$LIBLOCS);
		blk2A = blk + (byt + recLen + 3) / 128;
		byt2A = (byt + recLen + 3) MOD 128;
		word$6267 = unresolved;
		DO WHILE word$6267 > 0;
			modcnt = 0;
			modlocs$p = allocUp(0);
			CALL iseek(blk2A, byt2A);
			CALL expectType(R$LIBDICT);
			CALL sub$48E1;
			modId = 1;
			toResolve = word$6267;
			word$6267 = 0;
			DO WHILE skipName AND toResolve > 0;
				IF t2Arec.pubname(0) = 0 THEN
					modId = modId + 1;
				ELSE IF find(rec$p, .symbol$p, 40H) THEN
				DO;
					i = allocUp(4);		/* junk return address */
					modlocs(modcnt).blk = modId;
					modcnt = modcnt + 1;
					toResolve = toResolve - 1;
					DO WHILE skipName AND t2Arec.pubname(0) <> 0;
					END;
					modId = modId + 1;
				END;
			END; /* DO WHILE */
			IF modcnt > 0 THEN	/* found a module to load */
			DO;
				CALL iseek(blk, byt);
				CALL expectType(R$LIBLOCS);
				CALL sub$48E1;
				modId = 0;
				DO i = 0 TO modcnt - 1;			/* for each module */
					DO WHILE modlocs(i).blk > modId;	/* step to the i'th module */
						modId = modId + 1;
						CALL eat4;
					END;
					modlocs(i).blk = t26rec.blk;	/* save pointers to i'th module */
					modlocs(i).byt = t26rec.byt;
				END;
				DO i = 0 TO modcnt - 1;			/* for each module */
					CALL iseek(modlocs(i).blk, modlocs(i).byt);		/* seek module location in library */
					CALL expectType(R$MODHDR);
					CALL procPas1Recs(0FFH);
					module.blk = modlocs(i).blk;
					module.byt = modlocs(i).byt;
				END;
			END;
		END;	/* DO WHILE */
	END;
END sub$5B2F;

sub$5DA8: PROCEDURE PUBLIC;
	DECLARE (p, q) ADDRESS, i BYTE;

	CALL iseek(t2Crec.blk, t2Crec.byt);
	CALL expectType(R$LIBNAMES);
	CALL sub$48E1;
	p = 0;
	i = 0FFH;
	DO WHILE skipName AND i;
		p = p + 1;
		i = 0;
		curModule = objFile.modlist;
		DO WHILE curModule > 0;
			IF module.scode = 0 THEN
			DO;
				IF strequ(rec$p, .module.name, module.name(0) + 1) THEN
					module.scode = p;
				ELSE
					i = 0FFH;
			END;
			curModule = module.link;
		END;
	END;
	CALL sub$48F5;
	CALL expectType(R$LIBLOCS);
	CALL sub$48E1;
	DO q = 1 TO p;	
		CALL eat4;
		curModule = objFile.modlist;
		DO WHILE curModule > 0;
			IF q = module.scode THEN
			DO;
				module.blk = t26rec.blk;
				module.byt = t26rec.byt;
			END;
			curModule = module.link;
		END;
	END;
	hmodule$p = .objFile.modlist;
	curModule = objFile.modlist;
	DO WHILE curModule > 0;
		IF module.scode = 0 THEN
		DO;
			CALL wAEFnAndMod(.msgmodnotinlib, LENGTH(msgmodnotinlib));	/* Module not in library, looking for */
			hmodule.link = module.link;
		END;
		ELSE
		DO;
			CALL iseek(module.blk, module.byt);
			CALL expectType(R$MODHDR);
			CALL procPas1Recs(0);
			hmodule$p = curModule;
		END;
		curModule = module.link;
	END;
END sub$5DA8;

DECLARE controls BYTE EXTERNAL;

phase1: PROCEDURE PUBLIC;
	baseHeap = .controls;
	DO seg$i = SEG$ABS TO SEG$RESERVE;
		segLists(seg$i) = 0;
	END;
	symcnt = 0;
	word6255 = .headcitem;
	curObjFile = objFileHead;
	DO WHILE curObjFile > 0;
		CALL openObjFile;
		isPublics = objFile.ispublics;
		CALL getRecord;
		IF srec.type = R$LIBHDR THEN	/* library */	
		DO;
			IF objFile.hasModules THEN
				CALL sub5DA8;
			ELSE
				CALL sub5B2F;
		END;
		ELSE
		DO;
			IF srec.type = R$MODHDR THEN
			DO;
				IF objFile.hasModules THEN
					CALL fatalErr(ERR235);	/* not a library */
				hmodule$p = .objFile.modlist;
				DO WHILE srec.type = R$MODHDR;
					CALL procPas1Recs(0FFH);
				END;
				IF srec.type <> R$EOF THEN
					CALL fatalErr(ERR220);	/* no EOF */
			END;
			ELSE
				CALL fatalErr(ERR239);	/* no module header record */
		END;
		CALL closeObjFile;
	END;
	CALL writeStats;
	CALL writeUnresolved;
END phase1;

END link3;
