$xref
/*	Copyright (c) 2012 by Mark Ogden
	Released into the public domain for academic historic interest
	only and not for commercial gain. */
link3:
DO;
$INCLUDE(LINK.EXT)
DECLARE 
	actRead ADDRESS EXTERNAL,
	inFileName(16) BYTE EXTERNAL,
	toFileName(16) BYTE EXTERNAL,
	doMap BYTE EXTERNAL,
	moduleName(32) BYTE EXTERNAL,
	modtype BYTE EXTERNAL,
	modhdr$x1 BYTE EXTERNAL,
	modhdr$x2 BYTE EXTERNAL,
	entrySeg BYTE EXTERNAL,
	entryAddr ADDRESS EXTERNAL,
	segLen(6) ADDRESS EXTERNAL,
	alignType(6) BYTE EXTERNAL,
	segmap(256) BYTE EXTERNAL,
	baseHeap ADDRESS EXTERNAL,
	topHeap ADDRESS EXTERNAL,
	inRecord$p ADDRESS EXTERNAL,
	erec$p ADDRESS EXTERNAL,
	in$p ADDRESS EXTERNAL,
	recNum ADDRESS EXTERNAL,
	recLen ADDRESS EXTERNAL,
	npbuf ADDRESS EXTERNAL,
	sbuf$p ADDRESS EXTERNAL,
	buf$p ADDRESS EXTERNAL,
	ebuf$p ADDRESS EXTERNAL,
	objFileHead ADDRESS EXTERNAL,
	curObjFile ADDRESS EXTERNAL,
	curModule ADDRESS EXTERNAL,
	hashChains(128) ADDRESS EXTERNAL,
	headSegOrderLink ADDRESS EXTERNAL,
	comdefInfo$p ADDRESS EXTERNAL,
	symbol$p ADDRESS EXTERNAL,
	unresolved ADDRESS EXTERNAL,
	maxExternCnt ADDRESS EXTERNAL,
	headUnresolved ADDRESS EXTERNAL;

DECLARE erec BASED erec$p BYTE;
DECLARE msgmultdef(*) BYTE INITIAL(' - MULTIPLELY DEFINED, DUPLICATE IN ');
DECLARE msgmore1main(*) BYTE INITIAL('MORE THAN 1 MAIN MODULE, CONFLICT IN ');
DECLARE msgmodnotinlib(*) BYTE INITIAL('MODULE NOT IN LIBRARY, LOOKING FOR ');
DECLARE msgbadcom(*) BYTE INITIAL('/ - UNEQUAL COMMON LENGTH, CONFLICT IN ');
DECLARE msglinkmap(*) BYTE INITIAL(0DH, 0AH, 'LINK MAP OF MODULE ');
DECLARE msgwrittento(*) BYTE INITIAL(0Dh, 0Ah, 'WRITTEN TO FILE ');
DECLARE msgmodtype(*) BYTE INITIAL(0Dh, 0Ah, 'MODULE IS A MAIN MODULE');
DECLARE msgnotmain(*) BYTE INITIAL(0Dh, 0Ah, 'MODULE IS NOT A MAIN MODULE');
DECLARE msgcomSegInfo(*) BYTE INITIAL(0Dh, 0Ah, 0Ah, 'SEGMENT INFORMATION:',
			       0Dh, 0Ah, 'START   STOP LENGTH REL NAME', 0Dh, 0Ah);
DECLARE msgmodincluded(*) BYTE INITIAL(0Dh, 0Ah, 0Ah,'INPUT MODULES INCLUDED:', 0Dh, 0Ah);
DECLARE msgunresolved(*) BYTE INITIAL(0Dh, 0Ah, 'UNRESOLVED EXTERNAL NAMES:', 0Dh, 0Ah);
DECLARE spc14(*) BYTE INITIAL('              ');
DECLARE a$range(*) BYTE INITIAL ('XXXXH  XXXXH  ');
DECLARE	a$size(*) BYTE INITIAL('XXXXH  X  ');
DECLARE msgGap(*) BYTE INITIAL('  *GAP*');
DECLARE msgOverlap(*) BYTE INITIAL('  *OVERLAP*');
DECLARE aInpageSegment(*) BYTE INITIAL('  *INPAGE SEGMENT > 256 BYTES*');
DECLARE msgPublics(*) BYTE INITIAL(' (PUBLICS)');
DECLARE slash2 (2) BYTE INITIAL ('//');
DECLARE aAbsolute(*) BYTE INITIAL('ABSOLUTE', 'CODE    ', 'DATA    ', 'STACK   ', 'MEMORY  ');
DECLARE	a$types(*) BYTE INITIAL(' AIPB');

DECLARE segUsed(6) BYTE,
	segToUse BYTE INITIAL(SEG$BLANK - 1),
	noCommonSeen BYTE INITIAL(TRUE),
	x1x2notset BYTE INITIAL(TRUE),
	comSegInfo$p ADDRESS INITIAL(0),
	segFrags(6) ADDRESS,
	segFrag$p ADDRESS,
	(curSegFrag$p, prevSegFrag$p) ADDRESS,
	tailSegOrderLink ADDRESS,
	nxtSymbol$p ADDRESS,
	hmodule$p ADDRESS,
	publicsOnly BYTE,
	moreRecords BYTE,
	haveModuleHdr BYTE,
	inSegCombine BYTE,
	curseg BYTE,
	dummyrec BYTE,
	inSegLen ADDRESS,
	seg$i ADDRESS,
	symcnt ADDRESS,
	newUnresolved ADDRESS,
	externCnt ADDRESS,
	inSegOffset ADDRESS;

/* DECLARE pageTab1 BASED pageTab1$p (1) STRUCTURE (state BYTE, mpage BYTE);
DECLARE	pageTab2 BASED pageTab2$p (1) STRUCTURE (state BYTE, fpage BYTE);
*/
/* based type representing structure at start of an input record */
DECLARE	inRecord BASED inRecord$p STRUCTURE (type BYTE, len ADDRESS, rec(1) BYTE);
/* generic based type to map to OMF style name at in$p in input file */
DECLARE inOMFName BASED in$p STRUCTURE (len BYTE, name(1) BYTE);

DECLARE comSegInfo BASED comSegInfo$p(256) STRUCTURE (combine BYTE, lenOrLinkedSeg ADDRESS);
DECLARE symbol BASED symbol$p SYMBOL$T;
DECLARE comdefInfo BASED comdefInfo$p COMINFO$T;
DECLARE segFrag BASED segFrag$p STRUCTURE (link ADDRESS, bot ADDRESS, top ADDRESS);

DECLARE rbytes BASED in$p (1) BYTE;
DECLARE rwords BASED in$p (1) ADDRESS;
DECLARE objFile BASED curObjFile LIBRARY$T;
DECLARE module BASED curModule MODULE$T;
DECLARE hmodule BASED hmodule$p MODULE$T;

/* EXTERNALS */
chkRead: PROCEDURE(cnt) EXTERNAL;
	DECLARE cnt ADDRESS;
END chkRead;

iseek: PROCEDURE(blk, byt) EXTERNAL;
	DECLARE (blk, byt) ADDRESS;
END iseek;

illegalRecord: PROCEDURE EXTERNAL;
END illegalRecord;

illegalRelo: PROCEDURE EXTERNAL;
END illegalRelo;

badRecordSeq: PROCEDURE EXTERNAL;
END badRecordSeq;

getRecord: PROCEDURE EXTERNAL;
END getRecord;

writeCRLF: PROCEDURE EXTERNAL;
END writeCRLF;

openObjFile: PROCEDURE EXTERNAL;
END openObjFile;

binasc: PROCEDURE(num, base, padch, bufp, width) EXTERNAL;
	DECLARE num ADDRESS, (base, padch) BYTE, bufp ADDRESS, width BYTE;
END binasc;

writeBytes: PROCEDURE(buf$p, count) EXTERNAL;
	DECLARE buf$p ADDRESS;
	DECLARE count ADDRESS;
END writeBytes;

writeAndEcho: PROCEDURE(buff$p, count) EXTERNAL;
	DECLARE buff$p ADDRESS;
	DECLARE count ADDRESS;
END writeAndEcho;

allocUp: PROCEDURE(count) ADDRESS EXTERNAL;
	DECLARE count ADDRESS;
END allocUp;

allocdown: PROCEDURE(count) ADDRESS EXTERNAL;
	DECLARE count ADDRESS;
END allocdown;

fatalErr: PROCEDURE(errCode) EXTERNAL;
	DECLARE errCode BYTE;
END fatalErr;

wAEFnAndMod: PROCEDURE(buff$p, count) EXTERNAL;
	DECLARE buff$p ADDRESS;
	DECLARE count ADDRESS;
END wAEFnAndMod;

find: PROCEDURE(pstr, ppitem, arg3b) BYTE EXTERNAL;
	DECLARE (pstr, ppitem) ADDRESS, arg3b BYTE;
END find;

pstrcpy: PROCEDURE(psrc, pdst) EXTERNAL;
	DECLARE psrc ADDRESS;
	DECLARE pdst ADDRESS;
END pstrcpy;

strequ: PROCEDURE(str1p, str2p, cnt) BYTE EXTERNAL;
	DECLARE (str1p, str2p) ADDRESS;
	DECLARE cnt BYTE;
END strequ;

errChkReport: PROCEDURE(errCode, file, errExit) EXTERNAL;
	DECLARE errCode ADDRESS;
	DECLARE file ADDRESS;
	DECLARE errExit BYTE;
END errChkReport;

closeObjFile: PROCEDURE EXTERNAL;
END closeObjFile;

primeRecord: PROCEDURE PUBLIC;
	/* save the record type and con inRecord to believe it is a real record */
	dummyrec = inRecord.type;
	inRecord$p = .dummyrec;
	/* set live buf$p to where we have procssed to - keeps in buffer */
	buf$p = in$p;
END primeRecord;

skipRecord: PROCEDURE PUBLIC;
	DO WHILE ebuf$p - buf$p < recLen;		/* read in off disk if needed */
		recLen = recLen - (ebuf$p - buf$p);
		buf$p = ebuf$p;
		CALL chkRead(1);
	END;
	buf$p = buf$p + recLen;				/* update buf$p to start of next record */
END skipRecord;

readName: PROCEDURE BYTE PUBLIC;
	DECLARE len BASED in$p BYTE;	/* string length byte */

	CALL chkRead(1);		/* make sure 1 char there */
	in$p = buf$p;			/* set to start of name */
	IF recLen < 2 THEN		/* only CRC left ? */
	DO;
		buf$p = buf$p + recLen;	/* advance and flag no more */
		RETURN recLen := 0;
	END;
	CALL chkRead(len + 1);		/* check all of the name is there */
	in$p = buf$p;			/* in case it has moved */
	IF recLen < len + 1 THEN	/* overran */
		CALL illegalRecord;
	buf$p = buf$p + len + 1;	/* past name */
	recLen = recLen - (len + 1);	/* account for name */
					/* in$p points to the name */
	RETURN TRUE;			/* read a name */
END readName;

/* read in 4 byte block num and byte num in$p points to the data, buf$p beyond it */
readBlkByt: PROCEDURE PUBLIC;
	IF recLen < DOUBLE(4) THEN
		CALL illegalRecord;
	CALL chkRead(4);
	buf$p = (in$p := buf$p) + DOUBLE(4);
	recLen = recLen - DOUBLE(4);
END readBlkByt;

/* get next record, test type, and error if not as expected */
expectType: PROCEDURE(type) PUBLIC;
	DECLARE type BYTE;

	CALL getRecord;
	recNum = 0;
	IF type <> inRecord.type THEN
		CALL badRecordSeq;
END expectType;

/* print segment base, size and alignment */
writeBaseSizeAlign: PROCEDURE(baddr, bsize, align) PUBLIC;
	DECLARE baddr ADDRESS;
	DECLARE bsize ADDRESS;
	DECLARE align BYTE;

	CALL writeCRLF;
	IF (align := align + 1) <= 1 THEN	/* ALN$NONE or ALN$UNDEF */
	DO;	/* insert start and stop in hex */
		CALL binasc(baddr, 16, '0', .a$range, 4);	/* 'XXXXH  XXXXH  ' */
		CALL binasc(baddr + bsize - 1, 16, '0', .a$range(7), 4);
		CALL writeBytes(.a$range, 14);	/* print start and stop */
	END;
	ELSE	/* replace start / stop with spaces */
		CALL writeBytes(.spc14, LENGTH(spc14));
	/* format the size in hex */
	CALL binasc(bsize, 16, ' ', .a$size, 4);
	/* insert the align type ' AIPB' */
	a$size(7) = a$types(align);
	CALL writeBytes(.a$size, 10);	/* print the size */
END writeBaseSizeAlign;

/* wrtie module statistics */
writeStats: PROCEDURE PUBLIC;
	DECLARE i BYTE;

	IF NOT doMap THEN	/* user doesn't want */
		RETURN;
	CALL writeBytes(.msglinkmap, LENGTH(msglinkmap));	/* '\r\nLINK MAP OF MODULE ' */
	CALL writeBytes(.moduleName(1), moduleName(0));		/* module name */
	CALL writeBytes(.msgwrittento, LENGTH(msgwrittento));	/* '\r\nWRITTEN TO FILE ' */
	CALL writeBytes(.toFileName(1), toFileName(0));		/* file name */
	IF modtype = MT$NOTMAIN THEN
		CALL writeBytes(.msgnotmain, LENGTH(msgnotmain));	/* '\r\nMODULE IS NOT A MAIN MODULE' */
	ELSE
		CALL writeBytes(.msgmodtype, LENGTH(msgmodtype));	/* '\r\nMODULE IS A MAIN MODULE' */
	CALL writeBytes(.msgcomSegInfo, LENGTH(msgcomSegInfo));		/* '\r\n\nSEGMENT INFORMATION\r\n' */
									/* 'START   STOP LENGTH REL NAME\r\n */
	DO curseg = SEG$CODE TO SEG$MEMORY;	/* regular segments */
		IF segLen(curseg) > 0 THEN	/* segment is used */
		DO;
			CALL writeBaseSizeAlign(0, segLen(curseg), alignType(curseg));
			CALL writeBytes(.aAbsolute(SHL(curseg, 3)), 8);	/* print 8 character seg name shl(3) is *8 */
			IF alignType(curseg) = ALN$INPAGE AND segLen(curseg) > 256 THEN
				CALL writeBytes(.aInPageSegment, LENGTH(aInPageSegment));	/* '  *INPAGE SEGMENT > 256 BYTES*' */
			segFrag$p = segFrags(curseg);
			DO WHILE segFrag$p > 0;				/* print the details for any gap fragments */
				CALL writeBaseSizeAlign(segFrag.bot, segFrag.top - segFrag.bot + 1, ALN$NONE); 
				CALL writeBytes(.aAbsolute(SHL(curseg, 3)), 8);
				CALL writeBytes(.msgGap, LENGTH(msgGap));	/* note the gap */
				segFrag$p = segFrag.link;		/* loop till done */
			END;
		END;
	END;
	comdefInfo$p = headSegOrderLink;				/* common block segments */
	DO WHILE comdefInfo$p > 0;
		CALL writeBaseSizeAlign(0, comdefInfo.len, comdefInfo.flags);		/* print size info */
		CALL writeBytes(.slash2, 1);						/* add the name at the end */
		CALL writeBytes(.comdefInfo.name(1), comdefInfo.name(0));
		CALL writeBytes(.slash2, 1);
		IF comdefInfo.flags = ALN$INPAGE AND comdefInfo.len > 256 THEN		/* warn of problems */
			CALL writeBytes(.aInpageSegment, LENGTH(aInPageSegment));	/* inpage segment > 256 bytes */
		comdefInfo$p = comdefInfo.segOrderLink;
	END;
	IF segLen(0) > 0 THEN								/* handle blank common */
	DO;
		CALL writeBaseSizeAlign(0, segLen(0), alignType(0));
		CALL writeBytes(.slash2, 2);						/* // */
		IF alignType(0) = 1 AND segLen(0) > 256 THEN
			CALL writeBytes(.aInpageSegment, LENGTH(aInPageSegment));	/* inpage segment > 256 bytes */
	END;
	seg$i = 0;			/* seg$i used high water mark for over lap detection - start at address 0 */
	segFrag$p = segFrags(0);	/* frags for SEG$ABS are real data blocks */
	DO WHILE segFrag$p > 0;		/* go throught them */
		CALL writeBaseSizeAlign(segFrag.bot, segFrag.top - segFrag.bot + 1, 0);	/* print the sizes and segment */
		CALL writeBytes(.aAbsolute, 8);
		IF segFrag.bot < seg$i THEN				/* check for overlap */
			CALL writeBytes(.msgOverlap, LENGTH(msgOverlap));
		IF segFrag.top >= seg$i THEN				/* update the high water mark for next block */
			seg$i = segFrag.top + 1;
		segFrag$p = segFrag.link;		/* to next fragment */
	END;	/* do while */
	CALL writeBytes(.msgmodincluded, LENGTH(msgmodincluded));	/* '\r\n\nINPUT MODULES INCLUDED:\r\n' */ 
	curObjFile = objFileHead;					/* go over each file processed */
	DO WHILE curObjFile > 0;
		curModule = objFile.modlist;				/* and each module processed */
		DO WHILE curmodule > 0;
			IF NOT objFile.publicsOnly OR module.symlist > 0 THEN	/* ignore if publics only and nothing loaded */
			DO;
				CALL writeBytes(.(' '), 1);			/* ' filename(modulename)' */
				CALL writeBytes(.objFile.name(1), objFile.name(0));
				CALL writeBytes(.('('), 1);
				CALl writeBytes(.module.name(1), module.name(0));
				CALL writeBytes(.(')'), 1);
				IF objFile.publicsOnly THEN			/* note publics only */
					CALL writeBytes(.msgPublics, LENGTH(msgPublics));
				CALL writeCRLF;
			END;
			curModule = module.link;
		END;
		curObjFile = objFile.link;
	END;
END writeStats;

chainUnresolved: PROCEDURE PUBLIC;	/* creates a chain of unresolved externals */
	DECLARE (p, toChain) ADDRESS;
	DECLARE symbola BASED p SYMBOL$T;
	DECLARE link BASED nxtSymbol$p ADDRESS;

	IF unresolved = 0 THEN		/* nothing to write */
		RETURN;
	CALL writeAndEcho(.msgunresolved, LENGTH(msgunresolved));	/* '\r\nUNRESOLVED EXTERNAL NAMES:\r\n' */
	toChain = unresolved;
	DO seg$i = 0 TO 127;		/* traverse all of the hash chains */
		symbol$p = hashChains(seg$i);
		DO WHILE symbol$p > 0;	/* traverse the single hash chain */
			IF symbol.flags = F$EXTERN THEN		/* we have an extern */
			DO;
				nxtSymbol$p = .headUnresolved;	/* find where to insert this symbol on the list */
				p = headUnresolved;
				DO WHILE p > 0;			/* scan whole list if necessary */
					IF symbola.offsetOrSym > symbol.offsetOrSym THEN
						goto insert;	/* passed insert point using sym num */
					nxtSymbol$p = .symbola.nxtSymbol;
					p = symbola.nxtSymbol;
				END;
			insert:
				symbol.nxtSymbol = link;	/* add to the unresolved chain */
				link = .symbol.hashLink;
				IF (toChain := toChain - 1) = 0 THEN		/* done */
					RETURN;
			END;
			symbol$p = symbol.hashLink;
		END; /* DO WHILE */
	END;	/* DO .. TO */
END chainUnresolved;

/* inserts a block of data into segment list at proper address */
createFragment: PROCEDURE(seg, bot, top) PUBLIC;
	DECLARE seg BYTE;
	DECLARE (bot, top) ADDRESS;
	DECLARE curSegFrag BASED curSegFrag$p STRUCTURE (link ADDRESS, bot ADDRESS, top ADDRESS);
	DECLARE prevSegFrag BASED prevSegFrag$p STRUCTURE (link ADDRESS, bot ADDRESS, top ADDRESS);
	DECLARE link BASED prevSegFrag$p ADDRESS;

	IF NOT doMAP THEN		/* we are not creating a map so ignore */
		RETURN;
	segFrag$p = allocUp(size(curSegFrag));	/* allocate and initialise the fragment */
	segFrag.bot = bot;
	segFrag.top = top;
	prevSegFrag$p = .segFrags(seg);		/* separate lists for each segment */
	curSegFrag$p = segFrags(seg);
	/* look for insert point or reach the end */
	DO WHILE curSegFrag$p > 0;
		IF curSegFrag.bot > bot THEN
			goto insert;
		prevSegFrag$p = .curSegFrag.link;	/* next */
		curSegFrag$p = curSegFrag.link;
	END;
insert:
	segFrag.link = prevSegFrag.link;		/* insert this fragment */
	prevSegFrag.link = .segFrag.link;
END createFragment;

p1CommonSegments: PROCEDURE PUBLIC;
	IF curseg = SEG$BLANK THEN	/* blank common */
	DO;
		IF segUsed(0) THEN	/* record seen in slot 0 */
			CALL illegalRecord;
		segUsed(0) = TRUE;
		IF inSegLen > segLen(0) THEN	/* record max size */
			segLen(0) = inSegLen;
		IF alignType(0) = ALN$UNDEF THEN
			alignType(0) = inSegCombine;
		ELSE IF alignType(0) <> ALN$BYTE OR inSegCombine <> ALN$BYTE THEN
			alignType(0) = ALN$PAGE;	/* if not both byte align make page align */
	END;
	ELSE
	DO;
		IF noCommonSeen THEN	/* we have commons so far so allocate mapping table */
		DO;
			IF comSegInfo$p = 0 THEN	/* no table allocated so allocate one */
				comSegInfo$p = allocUp(size(comSegInfo));
			DO seg$i = 0 TO last(comSegInfo);	/* initialise */
				comSegInfo(seg$i).combine = ALN$UNDEF;
			END;
			noCommonSeen = 0;
		END;
		IF comSegInfo(curseg).combine <> ALN$UNDEF THEN	/* duplicate */
			CALL illegalRecord;
		comSegInfo(curseg).combine = inSegCombine;	/* save combine and size */
		comSegInfo(curseg).lenOrLinkedSeg = inSegLen;
	END;
END p1CommonSegments;

p1StdSegments: PROCEDURE PUBLIC;
	DECLARE (prevLen, segLoadBase) ADDRESS;

	IF segUsed(curseg) THEN		/* duplicate seg size info */
		CALL illegalRecord;
	segUsed(curseg) = 0FFH;		/* note seen */
	IF curseg = SEG$ABS OR curseg > SEG$MEMORY THEN
		CALL illegalRecord;
	IF inSegLen = 0 THEN		/* nothing to do */
		RETURN;
	IF curseg = SEG$CODE OR curseg = SEG$DATA THEN
	DO;
		IF alignType(curseg) = ALN$UNDEF THEN	/* first seg */
		DO;
			alignType(curseg) = inSegCombine;
			segLen(curseg) = inSegLen;
			segLoadBase = 0;
		END;
		ELSE
		DO;
			prevLen = segLen(curseg);
			DO CASE inSegCombine - 1;
				DO;	/* IN PAGE */
					IF LOW(prevLen) + inSegLen <= 100H THEN		/* if fits in current page */
						segLoadBase = prevLen + inSegLen;	/* calculate the base */
					ELSE						/* else start new page */
						segLoadBase = ((prevLen + 0FFH) AND 0FF00H) + inSegLen;

					IF alignType(curseg) <> ALN$INPAGE OR segLoadBase > 100H THEN	/* check if we should use page align */
						alignType(curseg) = ALN$PAGE;
				END;
				DO;	/* PAGE */
					alignType(curseg) = ALN$PAGE;			/* calculate new page */
					segLoadBase = ((prevLen + 0FFH) AND 0FF00H) + inSegLen;
				END;
				DO;	/* BYTE */
					IF alignType(curseg) = ALN$INPAGE THEN		/* if were in page we now have to assume page align */
						alignType(curseg) = ALN$PAGE;
					segLoadBase = prevLen + inSegLen;		/* find out load address */
				END;
			END;
			segLen(curseg) = segLoadBase;					/* update the overall seg len */
			IF (segLoadBase := segLoadBase - inSegLen) > prevLen THEN	/* backup to start of this load address */
				CALL createFragment(curseg, prevLen, segLoadBase - 1);	/* not contiguous so create fragment */
			IF segLen(curseg) < segLoadBase THEN				/* oops we went over 64k */
				CALL fatalErr(ERR221);	/* segment too large */
		END;
		IF curseg = SEG$CODE THEN		/* update the code / data base address */
			module.scode = segLoadBase;
		ELSE
			module.sdata = segLoadBase;
	END;
	ELSE
	DO;	/* SEG$STACK or SEG$MEMORY or SEG$RESERVE */
		IF alignType(curseg) = ALN$UNDEF THEN		/* set initial combine */
			alignType(curseg) = inSegCombine;
		ELSE IF alignType(curseg) <> ALN$BYTE OR inSegCombine <> ALN$BYTE THEN	/* ALN$PAGE if not both ALN$BYTE */
			alignType(curseg) = ALN$PAGE;
		segLen(curseg) = segLen(curseg) + inSegLen;	/* length is additive */
	END;
END p1StdSegments;

/*
	select requested seg, setting inSegOffset to point to base
	returns returns seg - note for common len is replaced by final linked seg
	after the comdef records have been processed
*/

selectInSeg: PROCEDURE(seg) BYTE PUBLIC;
	DECLARE seg BYTE;

	inSegOffset = 0;
	IF seg = SEG$CODE THEN
		inSegOffset = module.scode;
	ELSE IF seg = SEG$DATA THEN
		inSegOffset = module.sdata;
	ELSE IF seg >= SEG$NAMCOM AND seg <> SEG$BLANK THEN
	DO;
		IF noCommonSeen THEN	/* selecting common when none exists !! */
			CALL illegalRecord;
		IF comSegInfo(seg).combine = ALN$NONE THEN	/* named common has been seen so ok */
			RETURN comSegInfo(seg).lenOrLinkedSeg;
		IF comSegInfo(seg).combine <> ALN$UNDEF THEN
			CALL badRecordSeq;
		CALL illegalRecord;
	END;
	RETURN seg;
END selectInSeg;

pass1MODHDR: PROCEDURE PUBLIC;
	/* structure of individual segdefs in the MODHDR */
	DECLARE sdef BASED in$p STRUCTURE (segId BYTE, len ADDRESS, combine BYTE); 
	/* and the two X  fields */
	DECLARE reserved BASED in$p STRUCTURE (x1 BYTE, x2 BYTE);

	IF haveModuleHdr THEN			/* catch multiple header errors */
		CALL badRecordSeq;
	haveModuleHdr = TRUE;
	nxtSymbol$p = .module.symlist;
	IF publicsOnly THEN			/* not loading data */
		RETURN;
	in$p = in$p + inOMFName.len + 1;	/* past module name */
	IF x1x2notset THEN			/* copy x1x2 data */
	DO;
		x1x2notset = 0;
		modhdr$x1 = reserved.x1;
		modhdr$x2 = reserved.x2;
	END;
	IF reserved.x1 <> modhdr$x1 THEN	/* propgate none 0 only if same */
		modhdr$x1 = 0;
	IF reserved.x2 <> modhdr$x2 THEN
		modhdr$x2 = 0;
	in$p = in$p + 2;			/* past the x1 x2 */
	module.scode = segLen(SEG$CODE);	/* code and data offsets of this module */
	module.sdata = segLen(SEG$DATA);
	noCommonSeen = TRUE;			/* first call */
	DO seg$i = SEG$ABS TO SEG$RESERVE;
		segUsed(seg$i) = 0;
	END;
	DO WHILE in$p < .erec;		/* while more segments */
		IF (inSegCombine := sdef.combine) - 1 > 2 THEN	/* only ALN$INPAGE - ALN$BYTE valid */
			CALL illegalRecord;
		inSegLen = sdef.len;
		IF (curseg := sdef.segId) >= SEG$NAMCOM THEN
			CALL p1CommonSegments;
		ELSE
			CALL p1StdSegments;
		in$p = in$p + size(sdef);	/* advance to next def */
	END;
END pass1MODHDR;

pass1MODEND: PROCEDURE PUBLIC;
	DECLARE	inModend BASED in$p STRUCTURE (modtype BYTE, segid BYTE, offset ADDRESS);
	moreRecords = 0;
	IF publicsOnly THEN
		RETURN;
	IF inModend.modtype = MT$MAIN THEN
		IF modtype <> MT$NOTMAIN THEN	/* duplicate main modules !! */
			CALL wAEFnAndMod(.msgmore1main, LENGTH(msgmore1main));
		ELSE
		DO;
			modtype = MT$MAIN;	/* record main and save entry point */
			entrySeg = selectInSeg(inModend.segid);
			entryAddr = inSegOffset + inModend.offset;
		END;
	IF NOT noCommonSeen THEN	/* check common alignments */
		DO seg$i = 0 TO 255;
			IF comSegInfo(seg$i).combine + 1 > 1 THEN	/* only ALN$UNDEF & ALN$NONE valid */
				CALL badRecordSeq;
		END;
END pass1MODEND;

pass1CONTENT: PROCEDURE PUBLIC;	
	DECLARE	inContent BASED in$p STRUCTURE (seg BYTE, addr ADDRESS, bytes(1) BYTE);
	CALL primeRecord;
	CALL chkRead(3);	/* make sure seg and address read */
	in$p = buf$p;
	IF NOT publicsOnly THEN	/* skip if just processing publics */
	DO;
		IF (curseg := inContent.seg) = SEG$ABS THEN	/* absolute record */
			CALL createFragment(SEG$ABS, inContent.addr, inContent.addr + recLen - 5);
		ELSE						/* relocatable record */
		DO;
			IF recLen > 1025 THEN		/* only abs > 1025 */
				CALL fatalErr(ERR211);	/* record too long */
			IF curseg = SEG$STACK THEN
				CALL fatalErr(ERR238);	/* illegal stack content record */
			IF curseg < SEG$NAMCOM THEN
			DO;
				IF NOT segUsed(curseg) THEN	/* seg was not defined in modhdr */
					CALL illegalRecord;
			END;
			ELSE
			DO;
				IF curseg = 0FFH THEN	/* blank common */
				DO;
					IF NOT segUsed(0) THEN	/* set was not defined in modhdr */
						CALL illegalRecord;
				END;
				ELSE
					curseg = selectInSeg(curseg);
			END;
		END;
	END;
	CALL skipRecord;	/* don't need the data on the first pass */
END pass1CONTENT;

pass1COMDEF: PROCEDURE PUBLIC;
	DECLARE segorderlink BASED tailSegOrderLink ADDRESS;
	DECLARE	inComdef BASED in$p STRUCTURE (segId BYTE, name(1) BYTE);

	IF publicsOnly THEN	/* not needed */
		RETURN;
	IF noCommonSeen THEN	/* can't have common def if no common segments */
		CALL badRecordSeq;
	DO WHILE in$p < .erec;
		IF (curseg := inComdef.segId) < SEG$NAMCOM OR curseg = SEG$BLANK THEN	/* not a named common */
			CALL illegalRecord;
		IF comSegInfo(curseg).combine + 1 < 2 THEN	/* ALN$UNDEF and ALN$NONE invalid */
			CALL illegalRecord;
		IF find(.inComdef.name, .comdefInfo$p, F$ALNMASK) THEN	/* already exist ? */
		DO;
			/* if not both ALN$BYTE then make ALN$PAGE */
			IF comdefInfo.flags <> ALN$BYTE OR comSegInfo(curSeg).combine <> ALN$BYTE THEN
				comdefInfo.flags = ALN$PAGE;
			IF comdefInfo.len <> comSegInfo(curseg).lenOrLinkedSeg THEN	/* if not same size */
			DO;
				IF comSegInfo(curseg).lenOrLinkedSeg > comdefInfo.len THEN	/* set as max of sizes */
					comdefInfo.len = comSegInfo(curseg).lenOrLinkedSeg;
				CALL writeAndEcho(.slash2, 1);			/* warning sizes are different */
				CALL writeAndEcho(.comdefInfo.name(1), comdefInfo.name(0));
				CALL wAEFnAndMod(.msgbadcom, 27H);
			END;
		END;
		ELSE	/* new entry required */
		DO;
			comdefInfo.hashLink = allocdown(size(comdefInfo) + inComdef.name(0));
			comdefInfo$p = comdefInfo.hashLink;	/* link in and mark new end of chain */
			comdefInfo.hashLink = 0;
			comdefInfo.flags = comSegInfo(curseg).combine;	/* save the combine value */
			IF segToUse < SEG$NAMCOM THEN	/* check we haven't created too many segs in the linked file */
				CALL fatalERR(ERR236);	/* too many common segments */
			comdefInfo.linkedSeg = segToUse;	/* record the linked seg for this segment */
			segToUse = segToUse - 1;
			CALL pstrcpy(.inComdef.name, .comdefInfo.name);	/* copy the name */
			comdefInfo.len = comSegInfo(curseg).lenOrLInkedSeg;		/* and size */
			comdefInfo.segOrderLink = segOrderLink;		/* chain into seg order */
			segOrderlink = .comdefInfo.hashLink;
			tailSegOrderLink = .comdefInfo.segOrderLink;
		END; /* ELSE */
		comSegInfo(curseg).combine = ALN$NONE;		/* flag as done */
		comSegInfo(curseg).lenOrLinkedSeg = comdefInfo.linkedSeg;	/* replace len with the linkedSeg */
		in$p = in$p + 2 + inComdef.name(0);			/* next name */
	END;	/* DO WHILE */
END pass1COMDEF;

pass1PUBNAMES: PROCEDURE PUBLIC;
	DECLARE inSegId BASED in$p BYTE;
	DECLARE inPubdef BASED in$p STRUCTURE (offset ADDRESS, name(1) BYTE /*, 0 */);

	markPublic: PROCEDURE;
		DECLARE link BASED nxtSymbol$p ADDRESS;

		symbol.flags = F$PUBLIC;	/* now public */
		symbol.linkedSeg = curseg;	/* location known */
		symbol.offsetOrSym = inSegOffset + inPubdef.offset;
		segmap(curseg) = 0FFH;		/* flag as used seg */
		symbol.nxtSymbol = link;	/* add to the publics chain */
		link = .symbol.hashLink;
		nxtSymbol$p = .symbol.nxtSymbol;
	END markPublic;

	IF (curseg := inSegId) <> SEG$ABS AND publicsOnly THEN	/* publics only requires absolute targets */
		RETURN;
	curseg = selectInSeg(curseg);	/* get the linked seg */
	in$p = in$p + 1;
	DO WHILE in$p < .erec;		/* while more public definitions */
		IF find(.inPubdef.name, .symbol$p, F$SCOPEMASK) THEN	/* find extern or public */
		DO;
			IF symbol.flags = F$PUBLIC THEN			/* error if not same location */
			DO;
				IF curseg <> 0 OR symbol.linkedSeg <> curseg or symbol.offsetOrSym <> inPubdef.offset THEN
				DO;
					CALL writeAndEcho(.symbol.name(1), symbol.name(0));
					CALL wAEFnAndMod(.msgmultdef, LENGTH(msgmultdef));
				END;
			END;
			ELSE
			DO;	/* was extern but we now have an address */
				unresolved = unresolved - 1;
				CALL markPublic;
			END;
		END;
		ELSE
		DO;	/* create a new entry */
			symbol.hashLink = allocdown(size(symbol) + inPubdef.name(0));
			symbol$p = symbol.hashLink;	/* add to hash chain */
			symbol.hashLink = 0;
			CALL pstrcpy(.inPubdef.name, .symbol.name);	/* add the name */
			CALL markPublic;				/* make it a public */
		END;
		in$p = in$p + 4 + inPubdef.name(0);			/* to next pubdef */
	END;	/* do while */
END pass1PUBNAMES;

pass1EXTNAMES: PROCEDURE PUBLIC;
	IF publicsOnly THEN		/* skip if not wanted */
		RETURN;
	DO WHILE .erec > in$p;		/* while more external definitions */
		externCnt = externCnt + 1;	/* bump the number of externs */
		IF NOT find(in$p, .symbol$p, F$SCOPEMASK) THEN	/* not currently extern or public */
		DO;
			symbol.hashLink = allocdown(size(symbol) + inOMFName.len);	/* create an entry */
			symbol$p = symbol.hashLink;		/* link in */
			symbol.hashLink = 0;
			symbol.flags = F$EXTERN;		/* extern and record symcnt number */
			symbol.offsetOrSym = (symcnt := symcnt + 1);
			CALL pstrcpy(.inOMFName, .symbol.name);	/* copy name */
			unresolved = unresolved + 1;		/* one more to resolve */
			newUnresolved = newUnresolved + 1;
		END;
		in$p = in$p + 2 + inOMFName.len; /* 2 for len byte and extra 0 at end */
	END;
END pass1EXTNAMES;

/* process pass 1 records */
procPas1Recs: PROCEDURE(newModule) PUBLIC;
	DECLARE newModule BYTE;

	IF newModule THEN	/* create entry for new module */
	DO;
		hmodule.link = (curModule := allocDown(size(hmodule) + inOMFName.len));
		module.link, module.symlist = 0;
		CALL pstrcpy(.inOMFName, .module.name);
		hmodule$p = curModule;
	END;
	externCnt = 0;
	recNum = 1;
	haveModuleHdr = 0;
	moreRecords = TRUE;
	DO WHILE moreRecords;
		DO CASE SHR(inRecord.type, 1);
			CALL illegalRelo;	/* 0 */
			CALL pass1MODHDR;	/* R$MODHDR */
			CALL pass1MODEND;	/* R$MODEND */
			CALL pass1CONTENT;	/* R$CONTENT */
			;					/* R$LINENO */
			CALL illegalRelo;	/* 0A */
			CALL illegalRelo;	/* 0C */
			CALL errChkReport(ERR204, .inFileName(1), TRUE);	/* Premature R$EOF */
			;			/* R$ANCESTOR */
			;			/* R$LOCALS */
			CALL illegalRelo;	/* 14 */
			CALL pass1PUBNAMES;	/* R$PUBLICS */
			CALL pass1EXTNAMES;	/* R$EXTNAMES */
			CALL illegalRelo;	/* 1A */
			CALL illegalRelo;	/* 1C */
			CALL illegalRelo;	/* 1E */
			;			/* R$EXTREF */
			;			/* R$RELOC */
			;			/* R$INTERSEG */
			CALL badRecordSeq;	/* R$LIBLOCS */
			CALL badRecordSeq;	/* R$LIBNAMES */
			CALL badRecordSeq;	/* R$LIBDICT */
			CALL badRecordSeq;	/* R$LIBHDR */
			CALL pass1COMDEF;	/* R$COMDEF */
		END;
		CALL getRecord;
	END;
	IF externCnt > maxExternCnt THEN	/* get max of externs */
		maxExternCnt = externCnt;
	/* make sure next record is valid or EOF */
	IF inRecord.type <> R$EOF AND inRecord.type <> R$MODHDR AND inRecord.type <> R$LIBNAMES THEN
		CALL fatalErr(ERR220);	/* no EOF */
END procPas1Recs;

p1LibScan: PROCEDURE PUBLIC;
	DECLARE pad(3) BYTE;
	DECLARE (blk, byt, blk2A, byt2A, modIdx, toResolve, i, libModulesToLoad , modlocs$p) ADDRESS;
	DECLARE modlocs BASED modlocs$p (1) STRUCTURE (blk ADDRESS, byt ADDRESS);
	DECLARE inLibloc BASED in$p STRUCTURE (blk ADDRESS, byt ADDRESS);
	DECLARE inLibhdr BASED in$p STRUCTURE (cnt ADDRESS, blk ADDRESS, byt ADDRESS);

	objFile.hasModules = TRUE;
	IF unresolved > 0 THEN
	DO;
		hmodule$p = .objFile.modlist;
		blk = inLibhdr.blk;		/* library header block */
		byt = inLibhdr.byt;		/* library header byte */
		CALL iseek(blk, byt);	/* seek to library module names record */
		CALL expectType(R$LIBNAMES);	/* get rec and validate type */ 
		CALL primeRecord;			/* save pointers */
		blk = (byt + recLen + 3) / 128 + blk; /* location of the libloc record */
		byt = (byt + recLen + 3) MOD 128;
		CALL skipRecord;
		CALL expectType(R$LIBLOCS);	/* should have the locations */
		blk2A = blk + (byt + recLen + 3) / 128;	/* location of the libdic record */
		byt2A = (byt + recLen + 3) MOD 128;
		newUnresolved = unresolved;	/* first pass attempts to resolve all unresolved */
		DO WHILE newUnresolved > 0;	/* loop incase scan adds more externs that the lib can resolve */
			libModulesToLoad = 0;
			modlocs$p = allocUp(0);		/* base memory of the new module locations info */
			CALL iseek(blk2A, byt2A);	/* go to the libdic */
			CALL expectType(R$LIBDICT);
			CALL primeRecord;
			modIdx = 1;
			toResolve = newUnresolved;	/* 1st pass scans for all unresolved */
							/* later passes may finish quicker as only new unresolved */
							/* can be matched */
			newUnresolved = 0;
			/* scan the dictionary across all names or until no unresolved */
			DO WHILE readName AND toResolve > 0;
				IF inOMFName.len = 0 THEN	/* new module - 0 separates */
					modIdx = modIdx + 1;
				ELSE IF find(in$p, .symbol$p, F$EXTERN) THEN	/* matched an unresolved external */
				DO;
					i = allocUp(4);		/* adds to modlocs vector - return address is junked */
					modlocs(libModulesToLoad).blk = modIdx;	/* record the module id */
					libModulesToLoad = libModulesToLoad + 1;
					toResolve = toResolve - 1;
					DO WHILE readName AND inOMFName.len <> 0;	/* skip to next module's names */
					END;
					modIdx = modIdx + 1;
				END;
			END; /* DO WHILE */
			IF libModulesToLoad > 0 THEN	/* matched some modules */
			DO;
				CALL iseek(blk, byt);	/* get the libloc data */
				CALL expectType(R$LIBLOCS);
				CALL primeRecord;
				modIdx = 0;
				DO i = 0 TO libModulesToLoad - 1;			/* for each module */
					DO WHILE modlocs(i).blk > modIdx;	/* step its location information */
						modIdx = modIdx + 1;
						CALL readBlkByt;
					END;
					modlocs(i).blk = inLibloc.blk;	/* save the location information */
					modlocs(i).byt = inLibloc.byt;
				END;
				DO i = 0 TO libModulesToLoad - 1;			/* process each module needed */
					CALL iseek(modlocs(i).blk, modlocs(i).byt);		/* seek module location in library */
					CALL expectType(R$MODHDR);
					CALL procPas1Recs(TRUE);		/* creates a new module entry */
					module.blk = modlocs(i).blk;		/* record the module location */
					module.byt = modlocs(i).byt;		/* in the module data for phase 2 */
				END;
			END;
		END;	/* DO WHILE */
	END;
END p1LibScan;

p1LibUserModules: PROCEDURE PUBLIC;
	DECLARE (modIdx, i) ADDRESS, unmatched BYTE;
	DECLARE inLibloc BASED in$p STRUCTURE (blk ADDRESS, byt ADDRESS);
	DECLARE inLibhdr BASED in$p STRUCTURE (cnt ADDRESS, blk ADDRESS, byt ADDRESS);

	CALL iseek(inLibhdr.blk, inLibhdr.byt);	/* seek to the libnam section - libhdr is current rec */
	CALL expectType(R$LIBNAMES);
	CALL primeRecord;		/* record its a LIBNAM record and the start of the content */
	modIdx = 0;
	unmatched = TRUE;
	DO WHILE readName AND unmatched;	/* scan the library looking for specified modules */
		modIdx = modIdx + 1;	/* index for later into libloc data */
		unmatched = 0;		/* set flag for exit if module not matched */
		curModule = objFile.modlist;	/* go over the supplied list of modules */
		DO WHILE curModule > 0;		
			IF module.scode = 0 THEN	/* not matched yet */
			DO;
				IF strequ(in$p, .module.name, module.name(0) + 1) THEN
					module.scode = modIdx;	/* record matched module */
				ELSE
					unmatched = TRUE;	/* at least one module not matched */
			END;
			curModule = module.link;	/* next one */
		END;
	END;
	CALL skipRecord;		/* skip any remaining names */
	CALL expectType(R$LIBLOCS);	/* expect the libloc record */
	CALL primeRecord;			/* tag where we are */
	DO i = 1 TO modIdx;		/* for all locations */
		CALL readBlkByt;	/* get the location info */
		curModule = objFile.modlist;	/* scan the module list to see if we need this one */
		DO WHILE curModule > 0;
			IF i = module.scode THEN
			DO;
				module.blk = inLibloc.blk;	/* put in the location info */
				module.byt = inLibloc.byt;
			END;
			curModule = module.link;	/* keep going */
		END;
	END;
	hmodule$p = .objFile.modlist;		/* pointer to remove missing modules from the chain */
	curModule = objFile.modlist;
	DO WHILE curModule > 0;
		IF module.scode = 0 THEN
		DO;
			CALL wAEFnAndMod(.msgmodnotinlib, LENGTH(msgmodnotinlib));	/* Module not in library, looking for */
			hmodule.link = module.link;	/* remove this module from the list */
		END;
		ELSE
		DO;
			CALL iseek(module.blk, module.byt);	/* process the module */
			CALL expectType(R$MODHDR);
			CALL procPas1Recs(FALSE);		/* module already known so don't create entry for it */
			hmodule$p = curModule;			/* this module remains on the list */
		END;
		curModule = module.link;		/* keep going */
	END;
END p1LibUserModules;

DECLARE controls BYTE EXTERNAL;

phase1: PROCEDURE PUBLIC;
	baseHeap = .controls;			/* use memory no longer needed */
	DO seg$i = SEG$ABS TO SEG$RESERVE;
		segFrags(seg$i) = 0;
	END;
	symcnt = 0;				/* no symbols */
	tailSegOrderLink = .headSegOrderLink;	/* no common segments */
	curObjFile = objFileHead;
	DO WHILE curObjFile > 0;		/* process each item in the input list */
		CALL openObjFile;		/* open the file */
		publicsOnly = objFile.publicsOnly;
		CALL getRecord;			/* load the first record */
		IF inRecord.type = R$LIBHDR THEN	/* library? */	
		DO;
			IF objFile.hasModules THEN	/* user specified modules */
				CALL p1LibUserModules;
			ELSE
				CALL p1LibScan;		/* library scan */
		END;
		ELSE
		DO;
			IF inRecord.type = R$MODHDR THEN	/* simple object file */
			DO;
				IF objFile.hasModules THEN	/* oops user thought it was a library */
					CALL fatalErr(ERR235);	/* not a library */
				hmodule$p = .objFile.modlist;
				DO WHILE inRecord.type = R$MODHDR;	/* process each module in file */
					CALL procPas1Recs(TRUE);	/* this is a new module */
				END;
				IF inRecord.type <> R$EOF THEN
					CALL fatalErr(ERR220);	/* no EOF */
			END;
			ELSE
				CALL fatalErr(ERR239);	/* no module header record */
		END;
		CALL closeObjFile;
	END;
	CALL writeStats;
	CALL chainUnresolved;
END phase1;

END link3;
