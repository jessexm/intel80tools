link3:
DO;
$INCLUDE(LINK.EXT)
DECLARE 
	actRead ADDRESS EXTERNAL,
	inFileName(16) BYTE EXTERNAL,
	toFileName(16) BYTE EXTERNAL,
	doMap BYTE EXTERNAL,
	moduleName(32) BYTE EXTERNAL,
	isMain BYTE EXTERNAL,
	type2x1 BYTE EXTERNAL,
	type2x2 BYTE EXTERNAL,
	entrySeg BYTE EXTERNAL,
	entryAddr ADDRESS EXTERNAL,
	segSizes(6) ADDRESS EXTERNAL,
	alignType(6) BYTE EXTERNAL,
	byte$45F6(256) BYTE EXTERNAL,
	baseHeap ADDRESS EXTERNAL,
	topHeap ADDRESS EXTERNAL,
	srec$p ADDRESS EXTERNAL,
	erec$p ADDRESS EXTERNAL,
	rec$p ADDRESS EXTERNAL,
	recNum ADDRESS EXTERNAL,
	recLen ADDRESS EXTERNAL,
	npbuf ADDRESS EXTERNAL,
	sibuf$p ADDRESS EXTERNAL,
	ibuf$p ADDRESS EXTERNAL,
	eibuf$p ADDRESS EXTERNAL,
	objFileHead ADDRESS EXTERNAL,
	curObjFile ADDRESS EXTERNAL,
	curModule ADDRESS EXTERNAL,
	hashChains(128) ADDRESS EXTERNAL,
	headcitem ADDRESS EXTERNAL,
	citem$p ADDRESS EXTERNAL,
	symbol$p ADDRESS EXTERNAL,
	unresolved ADDRESS EXTERNAL,
	word$4820 ADDRESS EXTERNAL,
	headunres ADDRESS EXTERNAL;

DECLARE erec BASED erec$p BYTE;
DECLARE msgmultdef(*) BYTE INITIAL(' - MULTIPLELY DEFINED, DUPLICATE IN ');
DECLARE msgmore1main(*) BYTE INITIAL('MORE THAN 1 MAIN MODULE, CONFLICT IN ');
DECLARE msgmodnotinlib(*) BYTE INITIAL('MODULE NOT IN LIBRARY, LOOKING FOR ');
DECLARE msgbadcom(*) BYTE INITIAL('/ - UNEQUAL COMMON LENGTH, CONFLICT IN ');
DECLARE msglinkmap(*) BYTE INITIAL(0DH, 0AH, 'LINK MAP OF MODULE ');
DECLARE msgwrittento(*) BYTE INITIAL(0Dh, 0Ah, 'WRITTEN TO FILE ');
DECLARE msgismain(*) BYTE INITIAL(0Dh, 0Ah, 'MODULE IS A MAIN MODULE');
DECLARE msgnotmain(*) BYTE INITIAL(0Dh, 0Ah, 'MODULE IS NOT A MAIN MODULE');
DECLARE msgseginfo(*) BYTE INITIAL(0Dh, 0Ah, 0Ah, 'SEGMENT INFORMATION:',
			       0Dh, 0Ah, 'START   STOP LENGTH REL NAME', 0Dh, 0Ah);
DECLARE msgmodincluded(*) BYTE INITIAL(0Dh, 0Ah, 0Ah,'INPUT MODULES INCLUDED:', 0Dh, 0Ah);
DECLARE msgunresolved(*) BYTE INITIAL(0Dh, 0Ah, 'UNRESOLVED EXTERNAL NAMES:', 0Dh, 0Ah);
DECLARE spc14(*) BYTE INITIAL('              ');
DECLARE a$range(*) BYTE INITIAL ('XXXXH  XXXXH  ');
DECLARE	a$size(*) BYTE INITIAL('XXXXH  X  ');
DECLARE msgGap(*) BYTE INITIAL('  *GAP*');
DECLARE msgOverlap(*) BYTE INITIAL('  *OVERLAP*');
DECLARE aInpageSegment(*) BYTE INITIAL('  *INPAGE SEGMENT > 256 BYTES*');
DECLARE msgPublics(*) BYTE INITIAL(' (PUBLICS)');
DECLARE slash2 (2) BYTE INITIAL ('//');
DECLARE aAbsolute(*) BYTE INITIAL('ABSOLUTE', 'CODE    ', 'DATA    ', 'STACK   ', 'MEMORY  ');
DECLARE	a$types(*) BYTE INITIAL(' AIPB');


DECLARE byte$6238(6) BYTE,
	segToUse BYTE INITIAL(254),
	byte$623F BYTE INITIAL(0FFH),
	x1b2notset BYTE INITIAL(0FFH),
	segInfo$p ADDRESS INITIAL(0),
	segLists(6) ADDRESS,
	block$p ADDRESS,
	(slp, slq) ADDRESS,
	word$6255 ADDRESS,
	word$6257 ADDRESS,
	hmodule$p ADDRESS,
	byte$625B BYTE,
	byte$625C BYTE,
	type2Seen BYTE,
	byte$625E BYTE,
	curseg BYTE,
	dummyrec BYTE,
	word$6261 ADDRESS,
	word$6263 ADDRESS,
	word$6265 ADDRESS,
	word$6267 ADDRESS,
	word$6269 ADDRESS,
	word$626B ADDRESS;




/* DECLARE	pageTab1 BASED pageTab1$p (1) STRUCTURE (state BYTE, mpage BYTE);
DECLARE	pageTab2 BASED pageTab2$p (1) STRUCTURE (state BYTE, fpage BYTE);
*/
DECLARE	srec BASED srec$p STRUCTURE (type BYTE, len ADDRESS, rec(1) BYTE);
/*DECLARE	sout BASED sout$p STRUCTURE (type BYTE, len ADDRESS, rec(1) BYTE); */
DECLARE t02arec BASED rec$p STRUCTURE (name(1) BYTE);
DECLARE t02brec BASED rec$p STRUCTURE (x1 BYTE, x2 BYTE);
DECLARE t02crec BASED rec$p STRUCTURE (seg BYTE, segsize ADDRESS, align BYTE);
DECLARE	t4rec BASED rec$p STRUCTURE (subtype BYTE, segtype BYTE, addr ADDRESS);
/* DECLARE	t4out BASED out$p STRUCTURE (subtype BYTE, segtype BYTE, addr ADDRESS); */
DECLARE	t6rec BASED rec$p STRUCTURE (seg BYTE, addr ADDRESS, bytes(1) BYTE);
/* DECLARE	t6out BASED out$p STRUCTURE (seg BYTE, addr ADDRESS, bytes(1) BYTE); */
DECLARE	t8arec BASED rec$p STRUCTURE (seg BYTE);
DECLARE	t8brec BASED rec$p STRUCTURE (addr ADDRESS, line ADDRESS);
/* DECLARE	t8aout BASED out$p STRUCTURE (seg BYTE); */
/* DECLARE	t8bout BASED out$p STRUCTURE (addr ADDRESS, line ADDRESS); */
DECLARE t10rec BASED rec$p STRUCTURE (name(1) BYTE);
/* DECLARE t10out BASED out$p STRUCTURE (name(1) BYTE); */
DECLARE t12arec BASED rec$p STRUCTURE (seg BYTE);
DECLARE t12brec BASED rec$p STRUCTURE (offset ADDRESS, name(1) BYTE /*, 0 */);
/* DECLARE t12aout BASED out$p STRUCTURE (seg BYTE); */
/* DECLARE t12bout BASED out$p STRUCTURE (offset ADDRESS, name(1) BYTE); */
DECLARE t16arec LITERALLY 't12arec';
DECLARE t16brec LITERALLY 't12brec';
DECLARE t16aout LITERALLY 't12aout';
DECLARE t16bout LITERALLY 't12bout';
DECLARE t18rec BASED rec$p STRUCTURE (name(1) BYTE /*, 0 */);
/* DECLARE t18out BASED out$p STRUCTURE (name(1) BYTE); */
DECLARE	t20arec BASED rec$p STRUCTURE (fixType BYTE);
/* DECLARE	t20aout BASED out$p STRUCTURE (fixType BYTE); */
DECLARE	t20brec BASED rec$p STRUCTURE (sym ADDRESS, addr ADDRESS);
/* DECLARE	t20bout BASED out$p STRUCTURE (sym ADDRESS, addr ADDRESS); */
DECLARE	t22arec BASED rec$p STRUCTURE (fixType BYTE);
DECLARE	t22brec BASED rec$p STRUCTURE (addr ADDRESS);
DECLARE	t24arec BASED rec$p STRUCTURE (seg BYTE);
/* DECLARE	t24aout BASED out$p STRUCTURE (seg BYTE, fixType BYTE); */
/* DECLARE	t24bout BASED out$p STRUCTURE (addr ADDRESS); */
DECLARE t26rec BASED rec$p STRUCTURE (blk ADDRESS, byt ADDRESS);
DECLARE t28rec BASED rec$p STRUCTURE (modname(1) BYTE);	/* repeated */
DECLARE t2Arec BASED rec$p STRUCTURE (pubname(1) BYTE);	/* repeated 0 length end of sub list */
DECLARE t2Crec BASED rec$p STRUCTURE (unk ADDRESS, blk ADDRESS, byt ADDRESS);
DECLARE	t2Erec BASED rec$p STRUCTURE (seg BYTE, name(1) BYTE);

DECLARE segInfo BASED segInfo$p(1) STRUCTURE (flag BYTE, segsize ADDRESS);
DECLARE symbol BASED symbol$p
	STRUCTURE (link ADDRESS, flag BYTE, seg BYTE, offset ADDRESS, nxtUnres ADDRESS, name(1) BYTE);
DECLARE citem BASED citem$p
	STRUCTURE (link ADDRESS, align BYTE, seg BYTE, csize ADDRESS, link2 ADDRESS, name(8) BYTE);
DECLARE block BASED block$p STRUCTURE (link ADDRESS, bot ADDRESS, top ADDRESS);

DECLARE rbytes BASED rec$p (1) BYTE;
DECLARE rwords BASED rec$p (1) ADDRESS;
DECLARE objFile BASED curObjFile LIBRARY$T;
DECLARE module BASED curModule MODULE$T;
DECLARE hmodule BASED hmodule$p MODULE$T;


/* EXTERNALS */
chkRead: PROCEDURE(cnt) EXTERNAL;
	DECLARE cnt ADDRESS;
END chkRead;



iseek: PROCEDURE(blk, byt) EXTERNAL;
	DECLARE (blk, byt) ADDRESS;
END iseek;

illegalRecord: PROCEDURE EXTERNAL;
END illegalRecord;

illegalRelo: PROCEDURE EXTERNAL;
END illegalRelo;

badRecordSeq: PROCEDURE EXTERNAL;
END badRecordSeq;

getRecord: PROCEDURE EXTERNAL;
END getRecord;

writeCRLF: PROCEDURE EXTERNAL;
END writeCRLF;

sub$3C5B: PROCEDURE EXTERNAL;
END sub$3C5B;

binasc: PROCEDURE(num, base, padch, bufp, width) EXTERNAL;
	DECLARE num ADDRESS, (base, padch) BYTE, bufp ADDRESS, width BYTE;
END binasc;


writeBytes: PROCEDURE(buf$p, count) EXTERNAL;
	DECLARE buf$p ADDRESS;
	DECLARE count ADDRESS;
END writeBytes;


writeAndEcho: PROCEDURE(buff$p, count) EXTERNAL;
	DECLARE buff$p ADDRESS;
	DECLARE count ADDRESS;
END writeAndEcho;


allocUp: PROCEDURE(count) ADDRESS EXTERNAL;
	DECLARE count ADDRESS;
END allocUp;


allocdown: PROCEDURE(count) ADDRESS EXTERNAL;
	DECLARE count ADDRESS;
END allocdown;


fatalErr: PROCEDURE(errCode) EXTERNAL;
	DECLARE errCode BYTE;
END fatalErr;

sub$3918: PROCEDURE(buff$p, count) EXTERNAL;
	DECLARE buff$p ADDRESS;
	DECLARE count ADDRESS;
END sub$3918;

find: PROCEDURE(pstr, ppitem, arg3b) BYTE EXTERNAL;
	DECLARE (pstr, ppitem) ADDRESS, arg3b BYTE;
END find;


pstrcpy: PROCEDURE(psrc, pdst) EXTERNAL;
	DECLARE psrc ADDRESS;
	DECLARE pdst ADDRESS;
END pstrcpy;

strequ: PROCEDURE(str1p, str2p, cnt) BYTE EXTERNAL;
	DECLARE (str1p, str2p) ADDRESS;
	DECLARE cnt BYTE;
END strequ;


errChkReport: PROCEDURE(errCode, file, errExit) EXTERNAL;
	DECLARE errCode ADDRESS;
	DECLARE file ADDRESS;
	DECLARE errExit BYTE;
END errChkReport;





closeObjFile: PROCEDURE EXTERNAL;
END closeObjFile;




sub$48E1: PROCEDURE PUBLIC;

	dummyrec = srec.type;
	srec$p = .dummyrec;
	ibuf$p = rec$p;
END sub$48E1;


sub$48F5: PROCEDURE PUBLIC;
	DO WHILE eibuf$p - ibuf$p < recLen;
		recLen = recLen - (eibuf$p - ibuf$p);
		ibuf$p = eibuf$p;
		CALL chkRead(1);
	END;
	ibuf$p = ibuf$p + recLen;
END sub$48F5;

skipName: PROCEDURE BYTE PUBLIC;
	DECLARE str BASED rec$p(1) BYTE;
	CALL chkRead(1);
	rec$p = ibuf$p;
	IF recLen < 2 THEN
	DO;
		ibuf$p = ibuf$p + recLen;
		RETURN recLen := 0;
	END;

	CALL chkRead(str(0) + 1);
	rec$p = ibuf$p;
	IF recLen < str(0) + 1 THEN
		CALL illegalRecord;
	ibuf$p = ibuf$p + str(0) + 1;
	recLen = recLen - (str(0) + 1);
	RETURN 0FFH;
END skipName;

sub$49A1: PROCEDURE PUBLIC;
	IF recLen < DOUBLE(4) THEN
		CALL illegalRecord;
	CALL chkRead(4);
	ibuf$p = (rec$p := ibuf$p) + DOUBLE(4);
	recLen = recLen - DOUBLE(4);
END sub$49A1;


expectType: PROCEDURE(type) PUBLIC;
	DECLARE type BYTE;

	CALL getRecord;
	recNum = 0;
	IF type <> srec.type THEN
		CALL badRecordSeq;
END expectType;


sub$49EB: PROCEDURE(baddr, bsize, align) PUBLIC;
	DECLARE baddr ADDRESS;
	DECLARE bsize ADDRESS;
	DECLARE align BYTE;

	CALL writeCRLF;
	IF (align := align + 1) <= 1 THEN
	DO;
		CALL binasc(baddr, 16, '0', .a$range, 4);
		CALL binasc(baddr + bsize - 1, 16, '0', .a$range(7), 4);
		CALL writeBytes(.a$range, 14);
	END;
	ELSE
		CALL writeBytes(.spc14, 14);

	CALL binasc(bsize, 16, ' ', .a$size, 4);
	a$size(7) = a$types(align);
	CALL writeBytes(.a$size, 10);
END sub$49EB;


sub$4A73: PROCEDURE PUBLIC;
	DECLARE i BYTE;

	IF NOT doMap THEN
		RETURN;

	CALL writeBytes(.msglinkmap, 21);
	CALL writeBytes(.moduleName(1), moduleName(0));
	CALL writeBytes(.msgwrittento, 18);
	CALL writeBytes(.toFileName(1), toFileName(0));
	IF isMain = 0 THEN
		CALL writeBytes(.msgnotmain, 29);
	ELSE
		CALL writeBytes(.msgismain, 25);
	CALl writeBytes(.msgseginfo, 55);


	DO curseg = 1 TO 4;
		IF segSizes(curseg) > 0 THEN	/* segment has size */
		DO;
			CALL sub$49EB(0, segSizes(curseg), alignType(curseg));
			CALL writeBytes(.aAbsolute(SHL(curseg, 3)), 8);
			IF alignType(curseg) = 1 AND segSizes(curseg) > 256 THEN
				CALL writeBytes(.aInPageSegment, 30);	/* *inpage segment > 256 bytes */
			block$p = segLists(curseg);
			DO WHILE block$p > 0;
				CALL sub$49EB(block.bot, block.top - block.bot + 1, 0FFH); 
				CALL writeBytes(.aAbsolute(SHL(curseg, 3)), 8);
				CALL writeBytes(.msgGap, 7);
				block$p = block.link;
			END;
		END;
	END;

	citem$p = headcitem;
	DO WHILE citem$p > 0;
		CALL sub$49EB(0, citem.csize, citem.align);
		CALL writeBytes(.slash2, 1);
		CALL writeBytes(.citem.name(1), citem.name(0));
		CALL writeBytes(.slash2, 1);
		IF citem.align = 1 AND citem.csize > 256 THEN
			CALL writeBytes(.aInpageSegment, 30);	/* inpage segment > 256 bytes */
		citem$p = citem.link2;
	END;

	IF segSizes(0) > 0 THEN
	DO;
		CALL sub$49EB(0, segSizes(0), alignType(0));
		CALL writeBytes(.slash2, 2);
		IF alignType(0) = 1 AND segSizes(0) > 256 THEN
			CALL writeBytes(.aInpageSegment, 30);	/* inpage segment > 256 bytes */
	END;

	word$6263 = 0;
	block$p = segLists(0);
	DO WHILE block$p > 0;
		CALL sub$49EB(block.bot, block.top - block.bot + 1, 0);
		CALL writeBytes(.aAbsolute, 8);
		IF block.bot < word$6263 THEN
			CALL writeBytes(.msgOverlap, 11);
		IF block.top >= word$6263 THEN
			word$6263 = block.top + 1;
		block$p = block.link;
	END;	/* do while */

	CALL writeBytes(.msgmodincluded, 28);
	curObjFile = objFileHead;
	DO WHILE curObjFile > 0;
		curModule = objFile.modlist;
		DO WHILE curmodule > 0;
			IF NOT objFile.ispublics OR module.symlist > 0 THEN
			DO;
				CALL writeBytes(.(' '), 1);
				CALL writeBytes(.objFile.name(1), objFile.name(0));
				CALL writeBytes(.('('), 1);
				CALl writeBytes(.module.name(1), module.name(0));
				CALL writeBytes(.(')'), 1);
				IF objFile.ispublics THEN
					CALL writeBytes(.msgPublics, 10);
				CALL writeCRLF;
			END;
			curModule = module.link;
		END;
		curObjFile = objFile.link;
	END;
END sub$4A73;


sub$4DE0: PROCEDURE PUBLIC;
	DECLARE (p, q) ADDRESS;
	DECLARE symbola BASED p STRUCTURE (link ADDRESS, flag BYTE, seg BYTE, offset ADDRESS, nxtUnres ADDRESS, name(1) BYTE);
	DECLARE wrd BASED word$6257 ADDRESS;

	IF unresolved = 0 THEN
		RETURN;
	CALl writeAndEcho(.msgunresolved, 30);

	q = unresolved;
	DO word$6263 = 0 TO 127;
		symbol$p = hashChains(word$6263);
		DO WHILE symbol$p > 0;
			IF symbol.flag = 40h THEN
			DO;
				word$6257 = .headunres;
				p = headunres;
				DO WHILE p > 0;
					IF symbola.offset > symbol.offset THEN
						goto loc$4E78;
					word$6257 = .symbola.nxtUnres;
					p = symbola.nxtUnres;
				END;
			loc$4E78:
				symbol.nxtUnres = wrd;
				wrd = .symbol.link;
				IF (q := q - 1) = 0 THEN
					RETURN;
			END;
			symbol$p = symbol.link;
		END; /* DO WHILE */
	END;	/* DO .. TO */
END sub$4DE0;


sub$4EC2: PROCEDURE(seg, bot, top) PUBLIC;
	DECLARE seg BYTE;
	DECLARE (bot, top) ADDRESS;
	DECLARE pblk BASED slp STRUCTURE (link ADDRESS, bot ADDRESS, top ADDRESS);
	DECLARE wrd BASED slq ADDRESS;

	IF NOT doMAP THEN
		RETURN;

	block$p = allocUp(6);
	block.bot = bot;
	block.top = top;
	slq = .segLists(seg);
	slp = segLists(seg);
	DO WHILE slp > 0;
		IF pblk.bot > bot THEN
			goto loc$4F4A;
		slq = .pblk.link;
		slp = pblk.link;
	END;
loc$4F4A:
	block.link = wrd;
	wrd = .block.link;
END sub$4EC2;


sub$4F65: PROCEDURE PUBLIC;
	IF curseg = 0FFH THEN
	DO;
		IF byte$6238(0) THEN
			CALL illegalRecord;
		byte$6238(0) = 0FFH;
		IF word$6261 > segSizes(0) THEN
			segSizes(0) = word$6261;
		IF alignType(0) = 0 THEN
			alignType(0) = byte$625E;
		ELSE IF alignType(0) <> 3 OR byte$625E <> 3 THEN
			alignType(0) = 2;
	END;
	ELSE
	DO;
		IF byte$623F THEN
		DO;
			IF seginfo$p = 0 THEN
				segInfo$p = allocUp(300H);
			DO word$6263 = 0 TO 255;
				segInfo(word$6263).flag = 0;
			END;
			byte$623F = 0;
		END;
		IF segInfo(curseg).flag <> 0 THEN
			CALL illegalRecord;
		segInfo(curseg).flag = byte$625E;
		segInfo(curseg).segsize = word$6261;
	END;
END sub$4F65;


sub$5059: PROCEDURE PUBLIC;
	DECLARE (p, q) ADDRESS;

	IF byte$6238(curseg) THEN
		CALL illegalRecord;
	byte$6238(curseg) = 0FFH;
	IF curseg = 0 OR curseg > 4 THEN
		CALL illegalRecord;
	IF word$6261 = 0 THEN
		RETURN;
	IF curseg = 1 OR curseg = 2 THEN
	DO;
		IF alignType(curseg) = 0 THEN
		DO;
			alignType(curseg) = byte$625E;
			segSizes(curseg) = word$6261;
			q = 0;
		END;
		ELSE
		DO;
			p = segSizes(curseg);
			DO CASE byte$625E - 1;
				DO;
					IF LOW(p) + word$6261 <= 100H THEN
						q = p + word$6261;
					ELSE
						q = ((p + 0FFH) AND 0FF00H) + word$6261;

					IF alignType(curseg) <> 1 OR q > 100H THEN
						alignType(curseg) = 2;
				END;
				DO;
					alignType(curseg) = 2;
					q = ((p + 0FFH) AND 0FF00H) + word$6261;
				END;
				DO;
					IF alignType(curseg) = 1 THEN
						alignType(curseg) = 2;
					q = p + word$6261;
				END;
			END;
			segSizes(curseg) = q;
			IF (q := q - word$6261) > p THEN
				CALL sub$4EC2(curseg, p, q - 1);
			IF segSizes(curseg) < q THEN
				CALL fatalErr(ERR221);	/* segment too large */
		END;
		IF curseg = 1 THEN
			module.scode = q;
		ELSE
			module.sdata = q;

	END;
	ELSE
	DO;
		IF alignType(curseg) = 0 THEN
			alignType(curseg) = byte$625E;
		ELSE IF alignType(curseg) <> 3 OR byte$625E <> 3 THEN
			alignType(curseg) = 2;
		segSizes(curseg) = segSizes(curseg) + word$6261;
	END;
END sub$5059;


sub$52A9: PROCEDURE(arg1b) BYTE PUBLIC;
	DECLARE arg1b BYTE;

	word$626B = 0;
	IF arg1b = 1 THEN
		word$626B = module.scode;
	ELSE IF arg1b = 2 THEN
		word$626B = module.sdata;
	ELSE IF arg1b >= 6 AND arg1b <> 255 THEN
	DO;
		IF byte$623F THEN
			CALL illegalRecord;
		IF segInfo(arg1b).flag = 255 THEN
			RETURN segInfo(arg1b).segsize;
		IF segInfo(arg1b).flag <> 0 THEN
			CALL badRecordSeq;
		CALL illegalRecord;
	END;
	RETURN arg1b;
END sub$52A9;

procrec02: PROCEDURE PUBLIC;
	IF type2Seen THEN
		CALL badRecordSeq;
	type2Seen = 0FFH;
	word$6257 = .module.symlist;
	IF byte$625B THEN
		RETURN;

	rec$p = rec$p + t02arec.name(0) + 1;	/* past module name */
	IF x1b2notset THEN
	DO;
		x1b2notset = 0;
		type2x1 = t02brec.x1;
		type2x2 = t02brec.x2;
	END;
	IF t02brec.x1 <> type2x1 THEN
		type2x1 = 0;
	IF t02brec.x2 <> type2x2 THEN
		type2x2 = 0;
	rec$p = rec$p + 2;
	module.scode = segSizes(1);
	module.sdata = segSizes(2);
	byte$623F = 0FFH;
	DO word$6263 = 0 TO 5;
		byte$6238(word$6263) = 0;
	END;

	DO WHILE rec$p < .erec;
		IF (byte$625E := t02crec.align) - 1 > 2 THEN
			CALL illegalRecord;
		word$6261 = t02crec.segsize;
		IF (curseg := t02crec.seg) >= 6 THEN
			CALL sub$4F65;
		ELSE
			CALL sub$5059;
		rec$p = rec$p + 4;
	END;

END procrec02;


procrec04: PROCEDURE PUBLIC;
	byte625C = 0;
	IF byte625B THEN
		RETURN;
	IF t4rec.subtype = 1 THEN
		IF ismain <> 0 THEN
			CALL sub3918(.msgmore1main, 25H);
		ELSE
		DO;
			isMain = 1;
			entrySeg = sub52A9(t4rec.segtype);
			entryAddr = word626B + t4rec.addr;
		END;

	IF NOT byte623F THEN
		DO word6263 = 0 TO 255;
			IF seginfo(word6263).flag + 1 > 1 THEN
				CALL badRecordSeq;
		END;
END procrec04;


procrec06: PROCEDURE PUBLIC;		/* type 6 data */
	CALL sub$48E1;
	CALL chkRead(3);
	rec$p = ibuf$p;
	IF NOT byte$625B THEN
	DO;
		IF (curseg := t6rec.seg) = 0 THEN
			CALL sub$4EC2(0, t6rec.addr, t6rec.addr + recLen - 5);
		ELSE
		DO;
			IF recLen > 1025 THEN
				CALL fatalErr(ERR211);	/* record too long */
			IF curseg = 3 THEN
				CALL fatalErr(ERR238);	/* illegal stack content record */
			IF curseg < 6 THEN
			DO;
				IF NOT byte$6238(curseg) THEN
					CALL illegalRecord;

			END;
			ELSE
			DO;
				IF curseg = 0FFH THEN
				DO;
					IF NOT byte$6238(0) THEN
						CALL illegalRecord;
				END;
				ELSE
					curseg = sub$52A9(curseg);
			END;
		END;
	END;
	CALL sub$48F5;
END procrec06;


procrec2E: PROCEDURE PUBLIC;
	DECLARE wrd BASED word$6255 ADDRESS;
	IF byte$625B THEN
		RETURN;
	IF byte$623F THEN
		CALL badRecordSeq;
	DO WHILE rec$p < .erec;
		IF (curseg := t2Erec.seg) < 6 OR curseg = 255 THEN
			CALL illegalRecord;
		IF segInfo(curseg).flag + 1 < 2 THEN
			CALL illegalRecord;
		IF find(.t2Erec.name, .citem$p, 0FH) THEN
		DO;
			IF citem.align <> 3 OR segInfo(curSeg).flag <> 3 THEN
				citem.align = 2;
			IF citem.csize <> segInfo(curseg).segsize THEN
			DO;
				IF segInfo(curseg).segsize > citem.csize THEN
					citem.csize = segInfo(curseg).segsize;
				CALL writeAndEcho(.slash2, 1);
				CALL writeAndEcho(.citem.name(1), citem.name(0));
				CALL sub$3918(.msgbadcom, 27H);
			END;
		END;
		ELSE
		DO;
			citem.link = allocdown(DOUBLE(9) + t2Erec.name(0));
			citem$p = citem.link;
			citem.link = 0;
			citem.align = segInfo(curseg).flag;
			IF segToUse < 6 THEN
				CALL fatalERR(ERR236);	/* too many common segments */
			citem.seg = segToUse;
			segToUse = segToUse - 1;
			CALL pstrcpy(.t2Erec.name, .citem.name);
			citem.csize = segInfo(curseg).segsize;
			citem.link2 = wrd;
			wrd = .citem.link;
			word$6255 = .citem.link2;
		END; /* ELSE */
		segInfo(curseg).flag = 0FFH;
		segInfo(curseg).segsize = citem.seg;
		rec$p = rec$p + 2 + t2Erec.name(0);
	END;	/* DO WHILE */
END procrec2E;


procrec16: PROCEDURE PUBLIC;
	sub$58C2: PROCEDURE;
		DECLARE wrd BASED word$6257 ADDRESS;
		symbol.flag = 80H;
		symbol.seg = curseg;
		symbol.offset = word$626B + t16brec.offset;
		byte$45F6(curseg) = 0FFH;
		symbol.nxtUnres = wrd;
		wrd = .symbol.link;
		word$6257 = .symbol.nxtUnres;
	END sub$58C2;

	IF (curseg := t16arec.seg) <> 0 AND byte$625B THEN
		RETURN;
	curseg = sub$52A9(curseg);
	rec$p = rec$p + 1;
	DO WHILE rec$p < .erec;
		IF find(.t16brec.name, .symbol$p, 0F0H) THEN
		DO;
			IF symbol.flag = 80H THEN
			DO;
				IF curseg <> 0 OR symbol.seg <> curseg or symbol.offset <> t16brec.offset THEN
				DO;
					CALL writeAndEcho(.symbol.name(1), symbol.name(0));
					CALL sub$3918(.msgmultdef, 24H);
				END;
			END;
			ELSE
			DO;
				unresolved = unresolved - 1;
				CALL sub$58C2;
			END;
		END;
		ELSE
		DO;
			symbol.link = allocdown(DOUBLE(9) + t16brec.name(0));
			symbol$p = symbol.link;
			symbol.link = 0;
			CALL pstrcpy(.t16brec.name, .symbol.name);
			CALL sub$58C2;
		END;
		rec$p = rec$p + 4 + t16brec.name(0);
	END;	/* do while */
END procrec16;





procrec18: PROCEDURE PUBLIC;
	IF byte$625B THEN
		RETURN;
	DO WHILE .erec > rec$p;
		word$6269 = word$6269 + 1;
		IF NOT find(rec$p, .symbol$p, 0F0H) THEN
		DO;
			symbol.link = allocdown(DOUBLE(9) + t18rec.name(0));
			symbol$p = symbol.link;
			symbol.link = 0;
			symbol.flag = 40H;
			symbol.offset = (word$6265 := word$6265 + 1);
			CALL pstrcpy(.t18rec.name, .symbol.name);
			unresolved = unresolved + 1;
			word$6267 = word$6267 + 1;
		END;
		rec$p = rec$p + 2 + t18rec.name(0);
	END;
END procrec18;


sub$59BC: PROCEDURE(arg1b) PUBLIC;
	DECLARE arg1b BYTE;
	IF arg1b THEN
	DO;
		hmodule.link = (curModule := allocDown(DOUBLE(13) + t02arec.name(0)));
		module.link, module.symlist = 0;
		CALL pstrcpy(.t02arec.name, .module.name);
		hmodule$p = curModule;
	END;
	word$6269 = 0;
	recNum = 1;
	type2Seen = 0;
	byte$625C = 0FFH;

	DO WHILE byte$625C;
		DO CASE SHR(srec.type, 1);
			CALL illegalRelo;	/* 0 */
			CALL procrec02;		/* 2 */
			CALL procrec04;		/* 4 */
			CALL procrec06;		/* 6 */
			;			/* 8 */
			CALL illegalRelo;	/* 0A */
			CALL illegalRelo;	/* 0C */
			CALL errChkReport(ERR204, .inFileName(1), 0FFH);	/* Premature EOF */
			;			/* 10 */
			;			/* 12 */
			CALL illegalRelo;	/* 14 */
			CALL procrec16;		/* 16 */
			CALL procrec18;		/* 18 */
			CALL illegalRelo;	/* 1A */
			CALL illegalRelo;	/* 1C */
			CALL illegalRelo;	/* 1E */
			;			/* 20 */
			;			/* 22 */
			;			/* 24 */
			CALL badRecordSeq;	/* 26 */
			CALL badRecordSeq;	/* 28 */
			CALL badRecordSeq;	/* 2A */
			CALL badRecordSeq;	/* 2C */
			CALL procrec2E;		/* 2E */
		END;
		CALL getRecord;
	END;

	IF word$6269 > word$4820 THEN
		word$4820 = word$6269;
	IF srec.type <> 0EH AND srec.type <> 2 AND srec.type <> 28H THEN
		CALL fatalErr(ERR220);	/* no EOF */
END sub$59BC;


sub$5B2F: PROCEDURE PUBLIC;
	DECLARE pad(3) BYTE;
	DECLARE (blk, byt, blk2A, byt2A, modId, toResolve, i, modcnt , modlocs$p) ADDRESS;
	DECLARE modlocs BASED modlocs$p (1) STRUCTURE (blk ADDRESS, byt ADDRESS);

	objFile.hasModules = 0FFH;
	IF unresolved > 0 THEN
	DO;
		hmodule$p = .objFile.modlist;
		blk = t2Crec.blk;
		byt = t2Crec.byt;
		CALL iseek(blk, byt);
		CALL expectType(28H);
		CALL sub$48E1;
		blk = (byt + recLen + 3) / 128 + blk;
		byt = (byt + recLen + 3) MOD 128;
		CALL sub$48F5;
		CALL expectType(26H);
		blk2A = blk + (byt + recLen + 3) / 128;
		byt2A = (byt + recLen + 3) MOD 128;
		word$6267 = unresolved;
		DO WHILE word$6267 > 0;
			modcnt = 0;
			modlocs$p = allocUp(0);
			CALL iseek(blk2A, byt2A);
			CALL expectType(2AH);
			CALL sub$48E1;
			modId = 1;
			toResolve = word$6267;
			word$6267 = 0;
			DO WHILE skipName AND toResolve > 0;
				IF t2Arec.pubname(0) = 0 THEN
					modId = modId + 1;
				ELSE IF find(rec$p, .symbol$p, 40H) THEN
				DO;
					i = allocUp(4);		/* junk return address */
					modlocs(modcnt).blk = modId;
					modcnt = modcnt + 1;
					toResolve = toResolve - 1;
					DO WHILE skipName AND t2Arec.pubname(0) <> 0;
					END;
					modId = modId + 1;
				END;
			END; /* DO WHILE */
			IF modcnt > 0 THEN	/* found a module to load */
			DO;
				CALL iseek(blk, byt);
				CALL expectType(26H);
				CALL sub$48E1;
				modId = 0;
				DO i = 0 TO modcnt - 1;
					DO WHILE modlocs(i).blk > modId;
						modId = modId + 1;
						CALL sub$49A1;
					END;
					modlocs(i).blk = t26rec.blk;
					modlocs(i).byt = t26rec.byt;
				END;
				DO i = 0 TO modcnt - 1;
					CALL iseek(modlocs(i).blk, modlocs(i).byt);
					CALL expectType(2);
					CALL sub$59BC(0FFH);
					module.blk = modlocs(i).blk;
					module.byt = modlocs(i).byt;
				END;
			END;
		END;	/* DO WHILE */
	END;
END sub$5B2F;


sub$5DA8: PROCEDURE PUBLIC;
	DECLARE (p, q) ADDRESS, i BYTE;

	CALL iseek(t2Crec.blk, t2Crec.byt);
	CALL expectType(28H);
	CALL sub$48E1;
	p = 0;
	i = 0FFH;
	DO WHILE skipName AND i;
		p = p + 1;
		i = 0;
		curModule = objFile.modlist;
		DO WHILE curModule > 0;
			IF module.scode = 0 THEN
			DO;
				IF strequ(rec$p, .module.name, module.name(0) + 1) THEN
					module.scode = p;
				ELSE
					i = 0FFH;
			END;
			curModule = module.link;
		END;
	END;

	CALL sub$48F5;
	CALL expectType(26H);
	CALL sub$48E1;
	DO q = 1 TO p;	
		CALL sub$49A1;
		curModule = objFile.modlist;
		DO WHILE curModule > 0;
			IF q = module.scode THEN
			DO;
				module.blk = t26rec.blk;
				module.byt = t26rec.byt;
			END;
			curModule = module.link;
		END;
	END;
	hmodule$p = .objFile.modlist;
	curModule = objFile.modlist;
	DO WHILE curModule > 0;
		IF module.scode = 0 THEN
		DO;
			CALL sub$3918(.msgmodnotinlib, 23H);	/* Module not in library, looking for */
			hmodule.link = module.link;
		END;
		ELSE
		DO;
			CALL iseek(module.blk, module.byt);
			CALL expectType(2);
			CALL sub$59BC(0);
			hmodule$p = curModule;
		END;
		curModule = module.link;
	END;
END sub$5DA8;

DECLARE controls BYTE EXTERNAL;

sub$5F5A: PROCEDURE PUBLIC;
	baseHeap = .controls;
	DO word6263 = 0 TO 5;
		segLists(word6263) = 0;
	END;
	word6265 = 0;
	word6255 = .headcitem;
	curObjFile = objFileHead;
	DO WHILE curObjFile > 0;
		CALL sub3C5B;
		byte625B = objFile.ispublics;
		CALL getRecord;
		IF srec.type = 2CH THEN	/* library */	
		DO;
			IF objFile.hasModules THEN
				CALL sub5DA8;
			ELSE
				CALL sub5B2F;
		END;
		ELSE
		DO;
			IF srec.type = 2 THEN
			DO;
				IF objFile.hasModules THEN
					CALL fatalErr(ERR235);	/* not a library */
				hmodule$p = .objFile.modlist;
				DO WHILE srec.type = 2;
					CALL sub59BC(0FFH);
				END;
				IF srec.type <> 0EH THEN
					CALL fatalErr(ERR220);	/* no EOF */
			END;
			ELSE
				CALL fatalErr(ERR239);	/* no module header record */
		END;
		CALL closeObjFile;
	END;
	CALL sub$4A73;
	CALL sub$4DE0;
END sub$5F5A;



END;
