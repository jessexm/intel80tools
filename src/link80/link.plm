link:
DO;
$INCLUDE(LINK.EXT)
/* from ISIS.EXT */
close: procedure (conn, status$p) external;
    declare (conn, status$p) address;
end close;

write: procedure (conn, buff$p, count, status$p) external;
    declare (conn, buff$p, count, status$p) address;
end write;

exit: procedure external;
end exit;

load: procedure (path$p, load$offset, switch, entry$p, status$p) external;
    declare (path$p, load$offset, switch, entry$p, status$p) address;
end load;

DECLARE
	readfd ADDRESS PUBLIC,
	tofilefd ADDRESS PUBLIC,
	printFileNo ADDRESS PUBLIC,
	pad$4565 ADDRESS PUBLIC,
	tmpfilefd ADDRESS PUBLIC,
	statusIO ADDRESS PUBLIC,
	actRead ADDRESS PUBLIC,
	inFileName(16) BYTE PUBLIC,
	toFileName(16) BYTE PUBLIC,
	printFileName(16) BYTE PUBLIC,
	filePath(16) BYTE PUBLIC,
	linkPath(16) BYTE PUBLIC,
	doMap BYTE PUBLIC,
	moduleName(32) BYTE PUBLIC,
	isMain BYTE PUBLIC,
	type2b1 BYTE PUBLIC,
	type2b2 BYTE PUBLIC,
	entrySeg BYTE PUBLIC,
	entryAddr ADDRESS PUBLIC,
	segSizes(6) ADDRESS PUBLIC,
	alignType(6) BYTE PUBLIC,
	byte$45F6(256) BYTE PUBLIC,
	baseHeap ADDRESS PUBLIC,
	topHeap ADDRESS PUBLIC,
	srec$p ADDRESS PUBLIC,
	erec$p ADDRESS PUBLIC,
	rec$p ADDRESS PUBLIC,
	recNum ADDRESS PUBLIC,
	recLen ADDRESS PUBLIC,	
	npbuf ADDRESS PUBLIC,
	sibuf$p ADDRESS PUBLIC,
	ibuf$p ADDRESS PUBLIC,
	eibuf$p ADDRESS PUBLIC,
	sout$p ADDRESS PUBLIC,
	out$p ADDRESS PUBLIC,
	eout$p ADDRESS PUBLIC,
	objFileHead ADDRESS PUBLIC,
	curObjFile ADDRESS PUBLIC,
	curModule ADDRESS PUBLIC,
	hashChains(128) ADDRESS PUBLIC,
	headcitem ADDRESS PUBLIC,
	citem$p ADDRESS PUBLIC,
	symbol$p ADDRESS PUBLIC,
	unresolved ADDRESS PUBLIC,
	word$4820 ADDRESS PUBLIC,
	headunres ADDRESS PUBLIC,
	CRLF (2) BYTE PUBLIC INITIAL (0DH, 0AH),
	recErrMsg(*) BYTE PUBLIC INITIAL (' RECORD TYPE XXH, RECORD NUMBER *****', 0DH, 0AH),
			          /*	      13-^		 32-^		    */
	inBlk ADDRESS PUBLIC,
	inByt ADDRESS PUBLIC,
	inb$p ADDRESS PUBLIC,
	inCRC BYTE PUBLIC;



DECLARE	srec BASED srec$p STRUCTURE (type BYTE, len ADDRESS, rec(1) BYTE);
DECLARE objFile BASED curObjFile LIBRARY$T;
DECLARE module BASED curModule MODULE$T;


DECLARE COPYRIGHT(*) BYTE DATA('(C) 1976, 1977, 1979 INTEL CORP'),
	VERSION(*) BYTE PUBLIC DATA('V3.0'),
	DUMMYREC(*) BYTE PUBLIC DATA(0,0,0);


/* EXTERNALS */
DECLARE overlayVersion(4) BYTE EXTERNAL;

writeErrStr: PROCEDURE(errcode) EXTERNAL;
	DECLARE errcode ADDRESS;
END writeErrStr;

binasc: PROCEDURE(num, base, padch, bufp, width) EXTERNAL;
	DECLARE num ADDRESS, (base, padch) BYTE, bufp ADDRESS, width BYTE;
END binasc;

memmov: PROCEDURE(cnt, srcp, dstp) EXTERNAL;
	DECLARE (cnt, srcp, dstp) ADDRESS;
END memmov;

strequ: PROCEDURE(str1p, str2p, cnt) BYTE EXTERNAL;
	DECLARE (str1p, str2p) ADDRESS;
	DECLARE cnt BYTE;
END strequ;


errChkReport: PROCEDURE(errCode, file, errExit) EXTERNAL;
	DECLARE errCode ADDRESS;
	DECLARE file ADDRESS;
	DECLARE errExit BYTE;
END errChkReport;

sub6774: PROCEDURE EXTERNAL;
END sub6774;

sub5F5A: PROCEDURE EXTERNAL;
END sub5F5A;

phase2: PROCEDURE EXTERNAL;
END phase2;

conOutStr: PROCEDURE(pstr, count) PUBLIC;
	DECLARE pstr ADDRESS;
	DECLARE count ADDRESS;
	
	CALL write(0, pstr, count, .statusIO);
END conOutStr;


fatalErr: PROCEDURE(errCode) PUBLIC;
	DECLARE errCode BYTE;

	CALL conOutStr(.(' '), 1);
	CALL conOutStr(.inFileName(1), inFileName(0));
	IF curModule > 0 THEN
	DO;
		CALL conOutStr(.('('), 1);
		CALL conOutStr(.module.name(1), module.name(0));
		CALL conOutStr(.(')'), 1);
	END;
	CALL conOutStr(.(','), 1);
	CALL writeErrStr(errCode);
	CALL binasc(srec.type, 16, '0', .recErrMsg(13), 2);
	IF recNum > 0 THEN
		CALL binasc(recNum, 10, ' ', .recErrMsg(32), 5);
	CALL conOutStr(.recErrMsg, LENGTH(recErrMsg));
	CALL exit;
END fatalErr;


illegalRecord: PROCEDURE PUBLIC;
	CALL fatalErr(ERR218);	/* Illegal record format */
END illegalRecord;


illegalRelo: PROCEDURE PUBLIC;
	CALL fatalErr(ERR212);	/* Illegal relo record */
END illegalRelo;


badRecordSeq: PROCEDURE PUBLIC;
	CALL fatalErr(ERR224);	/* Bad record sequence */
END badRecordSeq;


pstrcpy: PROCEDURE(psrc, pdst) PUBLIC;
	DECLARE psrc ADDRESS;
	DECLARE pdst ADDRESS;
	DECLARE str BASED psrc(1) BYTE;

	CALL memmov(str(0) + 1, psrc, pdst);
END pstrcpy;


hash: PROCEDURE(pstr) BYTE PUBLIC;
	DECLARE pstr ADDRESS;
	DECLARE str BASED pstr (1) BYTE;
	DECLARE (i, j) BYTE;

	j = 0;
	DO i = 0 TO str(0);
		j = ROR(j, 1) XOR str(i);
	END;
	RETURN j AND 07FH;
END hash;


find: PROCEDURE(pstr, ppitem, arg3b) BYTE PUBLIC;
	DECLARE (pstr, ppitem) ADDRESS, arg3b BYTE;

	DECLARE p ADDRESS;
	DECLARE i BYTE;

	DECLARE str BASED pstr(1) BYTE;
	DECLARE pitem BASED ppitem ADDRESS;
	DECLARE item BASED p STRUCTURE (link ADDRESS, b2 BYTE, b3 BYTE, csize ADDRESS, link2 ADDRESS, name(8) BYTE);

	i = str(0) + 1;
	pitem = (p := .hashChains(hash(pstr)));
	p = item.link;

	DO WHILE p > 0;
		pitem = p;
		IF (item.b2 AND arg3b) <> 0 THEN
			IF strequ(pstr, .item.name, i) THEN
				RETURN 0FFH;
		p = item.link;
	END;
	RETURN 0;
END find;


writeBytes: PROCEDURE(buf$p, count) PUBLIC;
	DECLARE buf$p ADDRESS;
	DECLARE count ADDRESS;
	
	CALL write(printFileNo, buf$p, count, .statusIO);
	CALL errChkReport(statusIO, .printFileName(1), 0FFH);
END writeBytes;


writeCRLF: PROCEDURE PUBLIC;
	CALL writeBytes(.CRLF, 2);
END writeCRLF;


writeAndEcho: PROCEDURE(buff$p, count) PUBLIC;
	DECLARE buff$p ADDRESS;
	DECLARE count ADDRESS;
	
	CALL writeBytes(buff$p, count);
	IF printFileNo > 0 THEN
		CALL conOutStr(buff$p, count);
END writeAndEcho;

sub$3918: PROCEDURE(buff$p, count) PUBLIC;
	DECLARE buff$p ADDRESS;
	DECLARE count ADDRESS;

	CALL writeAndEcho(buff$p, count);
	CALL writeAndEcho(.inFileName(1), inFileName(0));
	CALL writeAndEcho(.('('), 1);
	CALL writeAndEcho(.module.name(1), module.name(0));
	CALL writeAndEcho(.(')',0DH, 0AH), 3);
END sub$3918;



CALL sub6774;
CALL sub5F5A;
CALL load(.filePath(1), 0, 0, .actRead, .statusIO);
CALL errChkReport(statusIO, .filePath(1), 0FFH);
IF NOT strequ(.VERSION, .overlayVersion, 4) THEN
	CALL errChkReport(ERR219, .filePath(1), 0FFH);	/* phase error */
CALL phase2;
CALL close(printFileNo, .statusIO);
CALL exit;

END link;

