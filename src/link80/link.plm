$xref
/*	Copyright (c) 2012 by Mark Ogden
	Released into the public domain for academic historic interest
	only and not for commercial gain. */
link:
DO;
$INCLUDE(LINK.EXT)
/* from ISIS.EXT */
close: procedure (conn, status$p) external;
    declare (conn, status$p) address;
end close;

write: procedure (conn, buff$p, count, status$p) external;
    declare (conn, buff$p, count, status$p) address;
end write;

exit: procedure external;
end exit;

load: procedure (path$p, load$offset, switch, entry$p, status$p) external;
    declare (path$p, load$offset, switch, entry$p, status$p) address;
end load;

DECLARE
	readfd ADDRESS PUBLIC,
	tofilefd ADDRESS PUBLIC,
	printFileNo ADDRESS PUBLIC,
	pad$4565 ADDRESS PUBLIC,
	tmpfilefd ADDRESS PUBLIC,
	statusIO ADDRESS PUBLIC,
	actRead ADDRESS PUBLIC,
	inFileName(16) BYTE PUBLIC,
	toFileName(16) BYTE PUBLIC,
	printFileName(16) BYTE PUBLIC,
	filePath(16) BYTE PUBLIC,
	linkTmpFile(16) BYTE PUBLIC,
	doMap BYTE PUBLIC,
	moduleName(32) BYTE PUBLIC,
	modtype BYTE PUBLIC,
	modhdr$x1 BYTE PUBLIC,
	modhdr$x2 BYTE PUBLIC,
	entrySeg BYTE PUBLIC,
	entryAddr ADDRESS PUBLIC,
	segLen(6) ADDRESS PUBLIC,
	alignType(6) BYTE PUBLIC,
	segmap(256) BYTE PUBLIC,
	baseHeap ADDRESS PUBLIC,
	topHeap ADDRESS PUBLIC,
	inRecord$p ADDRESS PUBLIC,
	erec$p ADDRESS PUBLIC,
	in$p ADDRESS PUBLIC,
	recNum ADDRESS PUBLIC,
	recLen ADDRESS PUBLIC,	
	npbuf ADDRESS PUBLIC,
	sbuf$p ADDRESS PUBLIC,
	buf$p ADDRESS PUBLIC,
	ebuf$p ADDRESS PUBLIC,
	sout$p ADDRESS PUBLIC,
	out$p ADDRESS PUBLIC,
	eout$p ADDRESS PUBLIC,
	objFileHead ADDRESS PUBLIC,
	curObjFile ADDRESS PUBLIC,
	curModule ADDRESS PUBLIC,
	hashChains(128) ADDRESS PUBLIC,
	headSegOrderLink ADDRESS PUBLIC,
	comdefInfo$p ADDRESS PUBLIC,
	symbol$p ADDRESS PUBLIC,
	unresolved ADDRESS PUBLIC,
	maxExternCnt ADDRESS PUBLIC,
	headUnresolved ADDRESS PUBLIC,
	CRLF (2) BYTE PUBLIC INITIAL (0DH, 0AH),
	recErrMsg(*) BYTE PUBLIC INITIAL (' RECORD TYPE XXH, RECORD NUMBER *****', 0DH, 0AH),
					/*	     13-^		32-^	    */
	inBlk ADDRESS PUBLIC,
	inByt ADDRESS PUBLIC,
	inb$p ADDRESS PUBLIC,
	inCRC BYTE PUBLIC;

DECLARE	inRecord BASED inRecord$p STRUCTURE (type BYTE, len ADDRESS, rec(1) BYTE);
DECLARE objFile BASED curObjFile LIBRARY$T;
DECLARE module BASED curModule MODULE$T;

DECLARE COPYRIGHT(*) BYTE DATA('(C) 1976, 1977, 1979 INTEL CORP'),
	VERSION(*) BYTE PUBLIC DATA('V3.0'),
	DUMMYREC(*) BYTE PUBLIC DATA(0,0,0);

/* EXTERNALS */
DECLARE overlayVersion(4) BYTE EXTERNAL;

writeErrStr: PROCEDURE(errcode) EXTERNAL;
	DECLARE errcode ADDRESS;
END writeErrStr;

binasc: PROCEDURE(num, base, padch, bufp, width) EXTERNAL;
	DECLARE num ADDRESS, (base, padch) BYTE, bufp ADDRESS, width BYTE;
END binasc;

memmov: PROCEDURE(cnt, srcp, dstp) EXTERNAL;
	DECLARE (cnt, srcp, dstp) ADDRESS;
END memmov;

strequ: PROCEDURE(str1p, str2p, cnt) BYTE EXTERNAL;
	DECLARE (str1p, str2p) ADDRESS;
	DECLARE cnt BYTE;
END strequ;

errChkReport: PROCEDURE(errCode, file, errExit) EXTERNAL;
	DECLARE errCode ADDRESS;
	DECLARE file ADDRESS;
	DECLARE errExit BYTE;
END errChkReport;

parseCmdLine: PROCEDURE EXTERNAL;
END parseCmdLine;

phase1: PROCEDURE EXTERNAL;
END phase1;

phase2: PROCEDURE EXTERNAL;
END phase2;

conOutStr: PROCEDURE(pstr, count) PUBLIC;
	DECLARE pstr ADDRESS;
	DECLARE count ADDRESS;
	
	CALL write(0, pstr, count, .statusIO);
END conOutStr;

fatalErr: PROCEDURE(errCode) PUBLIC;
	DECLARE errCode BYTE;

	CALL conOutStr(.(' '), 1);
	CALL conOutStr(.inFileName(1), inFileName(0));
	IF curModule > 0 THEN
	DO;
		CALL conOutStr(.('('), 1);
		CALL conOutStr(.module.name(1), module.name(0));
		CALL conOutStr(.(')'), 1);
	END;
	CALL conOutStr(.(','), 1);
	CALL writeErrStr(errCode);
	CALL binasc(inRecord.type, 16, '0', .recErrMsg(13), 2);
	IF recNum > 0 THEN
		CALL binasc(recNum, 10, ' ', .recErrMsg(32), 5);
	CALL conOutStr(.recErrMsg, LENGTH(recErrMsg));
	CALL exit;
END fatalErr;

illegalRecord: PROCEDURE PUBLIC;
	CALL fatalErr(ERR218);	/* Illegal record format */
END illegalRecord;

illegalRelo: PROCEDURE PUBLIC;
	CALL fatalErr(ERR212);	/* Illegal relo record */
END illegalRelo;

badRecordSeq: PROCEDURE PUBLIC;
	CALL fatalErr(ERR224);	/* Bad record sequence */
END badRecordSeq;

pstrcpy: PROCEDURE(psrc, pdst) PUBLIC;
	DECLARE psrc ADDRESS;
	DECLARE pdst ADDRESS;
	DECLARE str BASED psrc(1) BYTE;

	CALL memmov(str(0) + 1, psrc, pdst);
END pstrcpy;

hash: PROCEDURE(pstr) BYTE PUBLIC;
	DECLARE pstr ADDRESS;
	DECLARE str BASED pstr (1) BYTE;
	DECLARE (i, j) BYTE;

	j = 0;
	DO i = 0 TO str(0);
		j = ROR(j, 1) XOR str(i);
	END;
	RETURN j AND 07FH;
END hash;

find: PROCEDURE(pstr, pitem$ref, mask) BYTE PUBLIC;
	DECLARE (pstr, pitem$ref) ADDRESS, mask BYTE;
	DECLARE p ADDRESS;
	DECLARE i BYTE;
	DECLARE str BASED pstr(1) BYTE;
	DECLARE pitem BASED pitem$ref ADDRESS;	/* dereferenced out param */
	DECLARE item BASED p HASH$T;

	i = str(0) + 1;		/* size of string including length byte */
	pitem = (p := .hashChains(hash(pstr)));
	p = item.hashLink;
	DO WHILE p > 0;		/* chase down the list to look for the name */
		pitem = p;
		IF (item.flags AND mask) <> ALN$UNDEF THEN	/* ignore undef entries */
			IF strequ(pstr, .item.name, i) THEN
				RETURN TRUE;
		p = item.hashLink;	/* next */
	END;
	RETURN FALSE;
END find;

writeBytes: PROCEDURE(buf$p, count) PUBLIC;
	DECLARE buf$p ADDRESS;
	DECLARE count ADDRESS;
	
	CALL write(printFileNo, buf$p, count, .statusIO);
	CALL errChkReport(statusIO, .printFileName(1), TRUE);
END writeBytes;

writeCRLF: PROCEDURE PUBLIC;
	CALL writeBytes(.CRLF, 2);
END writeCRLF;

writeAndEcho: PROCEDURE(buff$p, count) PUBLIC;
	DECLARE buff$p ADDRESS;
	DECLARE count ADDRESS;
	
	CALL writeBytes(buff$p, count);
	IF printFileNo > 0 THEN
		CALL conOutStr(buff$p, count);
END writeAndEcho;

wAEFnAndMod: PROCEDURE(buff$p, count) PUBLIC;
	DECLARE buff$p ADDRESS;
	DECLARE count ADDRESS;

	CALL writeAndEcho(buff$p, count);
	CALL writeAndEcho(.inFileName(1), inFileName(0));
	CALL writeAndEcho(.('('), 1);
	CALL writeAndEcho(.module.name(1), module.name(0));
	CALL writeAndEcho(.(')',0DH, 0AH), 3);
END wAEFnAndMod;

main:
	CALL parseCmdLine;
	CALL phase1;
	CALL load(.filePath(1), 0, 0, .actRead, .statusIO);	/* load the overlay */
	CALL errChkReport(statusIO, .filePath(1), TRUE);
	IF NOT strequ(.VERSION, .overlayVersion, 4) THEN	/* make sure it is valid */
		CALL errChkReport(ERR219, .filePath(1), TRUE);	/* phase error */
	CALL phase2;
	CALL close(printFileNo, .statusIO);
	CALL exit;

END link;

