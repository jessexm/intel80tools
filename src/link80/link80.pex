LIT             'LITERALLY'
ERR2            '2'		/* Illegal AFTN Argument */
ERR3            '3'		/* Too many open files */
ERR4            '4'		/* Incorrectly speficied file */
ERR5            '5'		/* Unrecognised device name */
ERR9            '9'		/* Disk directory full */
ERR12           '0CH'		/* File is already open */
ERR13           '0DH'		/* No such file */
ERR14           '0EH'		/* Write protected */
ERR17           '11H'		/* Not a disk file */
ERR19           '13H'		/* Attempted seek on non-disk file */
ERR20           '14H'		/* Attemted back seek too far */
ERR21           '15H'		/* Can''t rescan */
ERR22           '16H'		/* Illegal access mode to open */
ERR23           '17H'		/* Missing filename */
ERR27           '1BH'		/* Illegal seek command */
ERR28           '1CH'		/* Missing extension */
ERR31           '1FH'		/* can''t seek on write only file */
ERR32           '20H'		/* Can''t delete open file */
ERR34           '22H'		/* Illegal load command */
ERR35           '23H'		/* Seek past EOF */
ERR203          '0CBH'		/* Invalid syntax */
ERR204          '0CCH'		/* Premature EOF */
ERR208          '0D0H'		/* Checksum error */
ERR210          '0D2H'		/* Insufficient memory */
ERR211          '0D3H'		/* Record too long */
ERR212          '0D4H'		/* Illegal relo record */
ERR213          '0D5H'		/* Fixup bounds error */
ERR218          '0DAH'		/* Illegal record format */
ERR219          '0DBH'		/* Phase error */
ERR220          '0DCH'		/* No EOF */
ERR221          '0DDH'		/* Segment too large */
ERR224          '0E0H'		/* Bad record sequence */
ERR225          '0E1H'		/* Invalid name */
ERR226          '0E2H'		/* Name too long */
ERR227          '0E3H'		/* Left parenthesis expected */
ERR228          '0E4H'		/* Right parenthesis expected */
ERR229          '0E5H'		/* Unrecognised control */
ERR233          '0E9H'		/* 'TO' expected */
ERR234          '0EAH'		/* Duplicate file name */
ERR235          '0EBH'		/* Not a library */
ERR236          '0ECH'		/* Too many common segments */
ERR238          '0EEH'		/* Illegal stack content record */
ERR239	        '0EFH'		/* No module header record */

/* relocatable record types */
R$MODHDR        '2'
R$MODEND        '4'
R$CONTENT       '6'
R$LINENO        '8'
R$EOF	        '0EH'
R$ANCESTOR      '10H'
R$LOCALS        '12H'
R$PUBLICS       '16H'
R$EXTNAMES      '18H'
R$EXTREF        '20H'
R$RELOC	        '22H'
R$INTERSEG      '24H'
R$LIBLOCS       '26H'
R$LIBNAMES      '28H'
R$LIBDICT       '2AH'
R$LIBHDR        '2CH'
R$COMDEF        '2EH'

/* segment types */
SEG$ABS         '0'
SEG$CODE        '1'
SEG$DATA        '2'
SEG$STACK       '3'
SEG$MEMORY      '4'
SEG$RESERVE     '5'		/* reserved for future Intel use */
SEG$NAMCOM      '6'
SEG$BLANK       '255'

/* fixup types */
FIX$UNDEF       '0'
FIX$LOW	        '1'
FIX$HI	        '2'
FIX$BOTH        '3'

/* alignment types */
ALN$UNDEF       '0'
ALN$INPAGE      '1'
ALN$PAGE        '2'
ALN$BYTE        '3'
ALN$NONE        '255'		/* special value used to indicate named common procssed or gap */

/* module type */
MT$NOTMAIN      '0'
MT$MAIN         '1'

/* flags */
F$ALNMASK       '0FH'
F$SCOPEMASK     '0F0H'
F$EXTERN        '40H'
F$PUBLIC        '80H'

/* misc */
TRUE            '0FFH'
FALSE           '0'
CR              '0DH'

/* user types */
COMINFO$T       'STRUCTURE (COMINFO$T1,COMINFO$T2)'
COMINFO$T1      'hashLink ADDRESS, flags BYTE, linkedSeg BYTE'
COMINFO$T2      'len ADDRESS, segOrderLink ADDRESS, name(1) BYTE'
HASH$T          'STRUCTURE (hashLink ADDRESS, flags BYTE, linkedSeg BYTE, val ADDRESS, link ADDRESS, name(1) BYTE)'
LIBRARY$T       'STRUCTURE (link ADDRESS, modlist ADDRESS, publicsOnly BYTE, hasModules BYTE, name(1) BYTE)'
MODULE$T        'STRUCTURE (MODULE$T1,MODULE$T2)'
MODULE$T1       'link ADDRESS, blk ADDRESS, byt ADDRESS, symlist ADDRESS'
MODULE$T2       'scode ADDRESS, sdata ADDRESS, name(1) BYTE'
SPATH$T         'STRUCTURE (deviceId BYTE, name(6) BYTE, ext(3) BYTE, deviceType BYTE, driveType BYTE)'
SYMBOL$T        'STRUCTURE (SYMBOL$T1,SYMBOL$T2)'
SYMBOL$T1       'hashLink ADDRESS, flags BYTE, linkedSeg BYTE, offsetOrSym ADDRESS'
SYMBOL$T2       'nxtSymbol ADDRESS, name(1) BYTE'
RECORD$ST	'STRUCTURE (type BYTE, len ADDRESS, rec(1) BYTE)'	/* start of a record */
COMSEGINFO$T    'STRUCTURE (combine BYTE, lenOrLinkedSeg ADDRESS)'
OMFNAME$T	'STRUCTURE (len BYTE, name(1) BYTE)'			/* structure of an OMF name */
SEGFRAG$T       'STRUCTURE (link ADDRESS, bot ADDRESS, top ADDRESS)'

/* common based vars */
cmdbuf          BS..cmd$p
cmdch           B..cmd$p
comdefInfo      "COMINFO$T"..comdefInfo$p
comSegInfo	"COMSEGINFO$T"S..comSegInfo$p
erec            B..erec$p
hmodule         "MODULE$T"..hmodule$p
inOMFName       "OMFNAME$T"..in$p
inRecord        "RECORD$ST"..inRecord$p
module          "MODULE$T"..curModule
objFile         "LIBRARY$T"..curObjFile
outOMFName      "OMFNAME$T"..out$p
outRecord       "RECORD$ST"..outRecord$p
rbytes          BS..in$p
rwords          AS..in$p
segFrag         "SEGFRAG$T"..segFrag$p
symbol          "SYMBOL$T"..symbol$p

$file(system.lib)
IOPEN           '0'
ICLOSE          '1'
IDELETE         '2'
IREAD           '3'
IWRITE          '4'
ISEEK           '5'
ILOAD           '6'
IRENAME         '7'
ICONSOL         '8'
IEXIT           '9'
IATTRIB         '10'
IRESCAN         '11'
IERROR          '12'
IWHOCON         '13'
ISPATH          '14'
delete          P(A path$p,A status$p)
rescan          P(A conn,A status$p)
spath           P(A path$p,A info$p,A status$p)
memck           PA


$file(binasc.plm)
binasc          P(A num,B base,B padch,A bufp,B width)

$file(errrpt.plm)
errChkReport    P(A errCode,A file,B errExit)

$file(isis.plm)
close           P(A conn,A status$p)
error           P(A error$num)
exit            P
load            P(A path$p,A load$offset,A switch,A entry$p,A status$p)
open            P(A conn$p,A path$p,A access,A echo,A status$p)
read            P(A conn,A buff$p,A count,A actual$p,A status$p)
seek            P(A conn,A mode,A block$p,A byte$p,A status$p)
write           P(A conn,A buff$p,A count,A status$p)

$file(isisen.asm)
isis            P(B type,A parameter$ptr)

$file(lineuc.plm)
crStrUpper      P(A PCH)

$file(link.plm)
actRead         A
alignType       BS
baseHeap        A
buf$p           A
comdefInfo$p    A
CRLF            BS
curModule       A
curObjFile      A
doMap           B
DUMMYREC        BS
ebuf$p          A
entryAddr       A
entrySeg        B
eout$p          A
erec$p          A
filePath        BS
hashChains      AS
headSegOrderLink A
headUnresolved  A
inBlk           A
inb$p           A
inByt           A
inCRC           B
inFileName      BS
in$p            A
inRecord$p      A
linkTmpFile     BS
maxExternCnt    A
modhdr$x1       B
modhdr$x2       B
modtype         B
moduleName      BS
npbuf           A
objFileHead     A
out$p           A
pad$4565        A
printFileName   BS
printFileNo     A
readfd          A
recErrMsg       BS
recLen          A
recNum          A
sbuf$p          A
segLen          AS
segmap          BS
sout$p          A
statusIO        A
symbol$p        A
tmpfilefd       A
tofilefd        A
toFileName      BS
topHeap         A
unresolved      A
VERSION         BS
badRecordSeq    P
conOutStr       P(A pstr,A count)
fatalErr        P(B errCode)
find            P(A pstr,A pitem$ref,B mask)B
hash            P(A pstr)B
illegalRecord   P
illegalRelo     P
pstrcpy         P(A psrc,A pdst)
wAEFnAndMod     P(A buff$p,A count)
writeAndEcho    P(A buff$p,A count)
writeBytes      P(A buf$p,A count)
writeCRLF       P

$file(link1a.plm)
allocdown       P(A count)A
allocUp         P(A count)A
chkRead         P(A cnt)
closeObjFile    P
getRecord       P
objSeek          P(A blk,A byt)
openObjFile     P

$file(link3.plm)
chainUnresolved P
createFragment  P(B seg,A bot,A top)
expectType      P(B type)
p1CommonSegments P
p1LibScan       P
p1LibUserModules P
p1StdSegments   P
pass1COMDEF     P
pass1CONTENT    P
pass1EXTNAMES   P
pass1MODEND     P
pass1MODHDR     P
pass1PUBNAMES   P
phase1          P
primeRecord     P
procPas1Recs    P(B newModule)
readBlkByt      P
readName        PB
selectInSeg     P(B seg)B
skipRecord      P
writeBaseSizeAlign P(A baddr,A bsize,B align)
writeStats      P

$file(link3a.plm)
controls        BS
addFileToInputList P
checkFile       P
chkLP           P
chkRP           P
errNotDiscFile  P
expectChar      P(B ch,B errCode)
expectComma     P
fatalCmdLineErr P(A errCode)
getInputListItem P
getModuleName   P(A pstr)
parseCmdLine    P
parseControl    P
readCmdLine     P
skipNonArgChars P(A arg1w)

$file(linkov.plm)
modName         BS
msgrefin        BS
outRecord$p     A
OVERLAYVERSION  BS
addExtMap       P(A sym$p)
emit$ANCESTOR   P
emitCOMDEF      P
emitEnding      P
emitEXTNAMES    P
emitMODHDR      P
emitPUBLICS     P
endRecord       P
extendRec       P(A cnt)B
flushTo         P
getSymbol$p     P(A symId)A
initExternsMap  P
initRecord      P(B type)
pageInExtMap    P
pageOutExtMap   P
pass2ANCESTOR   P
pass2COMDEF     P
pass2CONTENT    P
pass2EXTNAMES   P
pass2LINENO     P
pass2LOCALS     P
pass2MODHDR     P
phase2          P
seekExtMap      P
selectOutSeg    P(B seg)B

$file(merge.pl)

$file(mkfnam.plm)
makeFullName    P(A pinfo,A pstr)

$file(memmov.asm)
memmov          P(A cnt,A srcp,A dstp)

$file(pstafn.plm)
pastAFN         P(A pch)A

$file(pstfn.plm)
pastFileName    P(A pch)A

$file(skpspc.plm)
skipSpc         P(A pch)A

$file(strequ.plm)
strequ          P(A str1p,A str2p,B cnt)B

$file(wrerr.plm)
writeErrStr     P(A errCode)
