absio.plm
Absio: do;
$include(absio.ipx)
Absio: procedure(cmd, disk, block, buffer) public;
	declare (cmd, disk) byte, (block, buffer) address;
	declare dcb DCB$T;

	dcb.iocw = 80H;
	dcb.ioins = cmd;
	dcb.nsec = 1;
	dcb.tadr = high(block);
	dcb.sadr = low(block);
	dcb.buf = buffer;
	call Diskio(disk, .dcb);
end;
end;
alloc.plm
alloc: do;
declare maskArray(8) byte public data(80h, 40h, 20h, 10h, 8, 4, 2, 1);
declare mapBase address public;
end;
clbuf.plm
ClearBuffer: do;
ClearBuffer: procedure(buf$ptr) public;
	declare buf$ptr address, i byte;
	declare buf based buf$ptr (1) byte;


	do i = 0 to 127;
		buf(i) = 0;
	end;
end;
end;

dblank.plm
deblank: do;

Deblank: procedure(ptr) address public;
	declare ptr address;
	declare c based ptr byte;

	do while (c = ' ');
		ptr = ptr + 1;
	end;
	return ptr;
end;
end;
direct.plm
direct: do;
$include(direct.ipx)
declare direct DIRECT$T public;
declare directINO address public;
end;
diskio.plm
Diskio: do;
$include(diskio.ipx)
Diskio: procedure(disk, dcb$p) public;
	declare disk address, dcb$p address;
	declare (param1, param2) address;

	param1 = disk;
	param2 = dcb$p;
	call ISIS('D', .param1);
end;
end;
dlimit.plm
delimit: do;

Delimit: procedure(ptr) address public;
	declare ptr address;
	declare c based ptr byte;

	do while (c = ':' or c = '.' or ('0' <= c and c <= '9') or ('A' <= c and c <= 'Z'));
		ptr = ptr + 1;
	end;
	return ptr;
end;
end;
ferror.plm
fileerror: do;
$include(ferror.ipx)

FileError: procedure(status, ptr, callExit) public;
	declare (status, ptr) address, callExit byte;
	declare actual address;

	if status <> 0 then
	do;
		ptr = deblank(ptr);
		call write(0, .(' '), 1, .actual);
		call write(0, ptr, wdelimit(ptr) - ptr, .actual);
		call write(0, .(','), 1, .actual);
		call reporterror(status);
		if callExit then
			call exit;
	end;
end;
end;
filerr.plm
FILEERROR: DO;
$include(filerr.ipx)

FileError: procedure(status, ptr, callExit) public;
    declare (status, ptr) address, callExit byte;
    declare actual address;

    if status <> 0 then
    do;
        ptr = Deblank(ptr);
        call Write(0, .(' '), 1, .actual);
        call Write(0, ptr, WDelimit(ptr) - ptr, .actual);
        call Write(0, .(','), 1, .actual);
        call ReportError(status);
        if callExit then
            call exit;
    end;
end;
end;
fixmap.plm
fixmap: do;
Seek: procedure(conn, mode, block$p, byte$p, status$p) external; /* force load */
	declare (conn, mode, block$p, byte$p, status$p) address;
end;
$include(fixmap.ipx)

declare copyright(*) byte data('(C) 1975,1976,1977,1978,1979,1980,1981,1982 INTEL CORP'),
	version(*) byte data(4, 0, 'program_version_number=', 1, 'V4.3', 0);

declare	actual address;
declare aTrkSec(*) byte initial(' ('),
	aTrack(*) byte initial('***,'),
	aSector(*) byte initial('***) ');
declare	aftn address;
declare badFile(*) byte initial(':F*:ISIS.BAD ');
declare b4E51 byte;
declare badFileBuffer(3712) byte, mapFileBuffer(3712) byte;
declare w6B52 address;
declare logicalTrackSector address, (logicalSector, logicalTrack) byte at(.logicalTrackSector);
declare aBadSector(*) byte initial(' ***** BAD SECTORS', CR, LF);
declare buffer(128) byte;
declare	bufferPtr address, char based bufferPtr byte;
declare padding address;
declare changed bool initial(FALSE);
declare w6BEF address;
declare driveNumber byte;
declare diskType byte public initial(4);
declare b6BF3 byte, w6BF4 address, b6BF6 byte;
declare a6BF7(1) byte initial(' '),
	a6BF8(*) byte initial('***, '),
	a6BFD(*) byte initial('***', CR, LF);
declare b6C02 byte;
declare mapFile(*) byte initial(':F*:ISIS.MAP ');
declare (w6C10, w6C12, status) address;
declare (b6C16, b6C17) byte;

declare	pn(12) byte at(.MEMORY);

	WriteChanges: procedure;
		if not changed then
			call Write(0, .(' NO CHANGES',CR,LF), 13, .status);
		else
		do;
			call Attrib(.badFile, 3, 0, .status);
			call Attrib(.badFile, 2, 0, .status);
			call Open(.aftn, .badFile, WRITE$MODE, 0, .status);
			call Write(aftn, .badFileBuffer, 3712, .status);
			call FileError(status, .badFile, TRUE);
			call Close(aftn, .status);
			w6B52 = w6BEF + 29;
			call Attrib(.badFile, 3, 1, .status);
			call Attrib(.mapFile, 3, 0, .status);
			call Attrib(.mapFile, 2, 0, .status);
			call Open(.aftn, .mapFile, UPDATE$MODE, 0, .status);
			call Write(aftn, .mapFileBuffer, 3712, .status);
			call FileError(status, .mapFile, TRUE);
			call Close(aftn, .status);
			call Attrib(.mapFile, 3, 1, .status);
			changed = FALSE;
			call Write(0, .(' CHANGES RECORDED', CR, LF), 19, .status);
		end;
	end;



	sub3D6C: procedure;
		bufferPtr = .badFileBuffer;
		do logicalTrack = 0 to 199;
			logicalSector = 1;
			do b6C02 = 1 to 18;
				if (b6C16 := char) = 0 then
					logicalSector = logicalSector + 8;
				else
					do b4E51 =  1 to 8;
						if (b6C16 := rol(b6C16, 1)) then
						do;
							call NumOut(logicalTrack, 10, ' ', .a6BF8, 3);
							call NumOut(logicalSector, 10, ' ', .a6BFD, 3);
							call Write(aftn, .a6BF7, 11, .status);
						end;
						logicalSector = logicalSector + 1;
					end;
				bufferPtr = bufferPtr + 1;
			end;

		end;
		if aftn <> 0 then
			call Write(0, .(' LIST WRITTEN', CR, LF), 15, .status);
	end;


	ErrInvalidSyntax: procedure;
		call FileError(INVALID$SYNTAX, bufferPtr, FALSE);
	end;

	sub3E49: procedure bool;
		if char - '0' > 9 then
		do;
			call ErrInvalidSyntax;
			return 0;
		end;
		w6C12 = bufferPtr;
		if (logicalTrack := ScanInteger(.w6C12)) > 0C7h then
		do;
			call Write(0, .(' TRACK OUT OF RANGE',CR, LF), 21, .status);
			return FALSE;
		end;
		bufferPtr = Deblank(w6C12);
		if char - '0' > 9 then
		do;
			call ErrInvalidSyntax;
			return FALSE;
		end;

		if (logicalSector := ScanInteger(.w6C12)) -1 > 8Fh then
		do;
			call Write(0, .(' SECTOR OUT OF RANGE',CR,LF), 22, .status);
			return FALSE;
		end;

		bufferPtr = Deblank(w6C12);
		if char = CR then
		do;
			b6C17 = 0;
			return TRUE;
		end;
		else if char <> 'T' then
		do;
			call ErrInvalidSyntax;
			return FALSE;
		end;

		bufferPtr = Deblank(bufferPtr + 1);
		if char <> CR then
		do;
			call ErrInvalidSyntax;
			return FALSE;
		end;
		b6C17 = TRUE;
		return TRUE;
	end;




	writeTrackSector: procedure;
		call NumOut(logicalTrack, 10, 0, .aTrack, 3);
		call NumOut(logicalSector, 10, 0, .aSector, 3);
		call Write(0, .aTrkSec, 11, .status);
	end;


	GetBitStatus: procedure(bufferPtr) byte;
		declare bufferPtr address, buffer based bufferPtr (1) byte;

		return rol(buffer(18 * logicalTrack + shr(logicalSector - 1, 3)), logicalSector mod 8);
	end;


	MarkSector: procedure;
		if (logicalTrack = 0 and (logicalSector <= 1Bh or logicalSector >= 73h))
		    or (logicalTrack = 1 and (3Fh >= logicalSector or (logicalSector >= 49h and 87h >= logicalSector)))
		    or (logicalTrack = 2 and 1eh >= logicalSector) then
		do;
			call writeTrackSector;
			call Write(0, .('REQUIRED BY ISIS-II',CR,LF), 21, .status);
			return;
		end;
		if GetBitStatus(.mapFileBuffer) then
		do;
			call writeTrackSector;
			if GetBitStatus(.badFileBuffer) then
				call Write(0, .('ALREADY MARKED',CR,LF), 16, .status);
			else
				call Write(0, .('IN USE',CR,LF), 8, .status);
			return;
		end;

		mapBase = .mapFileBuffer;
		call SetBlock(logicalTrackSector);
		if not GetBitStatus(.badFileBuffer) then
		do;
			mapBase = .badFileBuffer;
			call SetBlock(logicalTrackSector);
			w6BEF = w6BEF + 1;
		end;

		changed = TRUE;
		if not b6C17 then
			call Write(0, .(' SECTOR MARKED',CR,LF), 16, .status);
	end;


	MarkTrack: procedure;
		b6BF3 = logicalSector  - ((logicalSector - 1) mod 36);
		b6BF6 =  b6BF3 + 35;
		do logicalSector = b6BF3 to b6BF6;
			call MarkSector;
		end;
		call Write(0, .(' TRACK PROCESSED',CR,LF), 18, .status);
	end;


	UnmarkSector: procedure;
		if not GetBitStatus(.badFileBuffer) then
		do;
			call WriteTrackSector;
			if GetBitStatus(.mapFileBuffer) then
				call Write(0, .('NOT A BAD SECTOR', CR, LF), 18, .status);
			else
				call Write(0, .('ALREADY FREE',CR,LF), 14, .status);
		end;
		else
		do;

		w6BF4 = 18 * logicalTrack + shr(logicalSector - 1, 3);
		b4E51 = logicalSector mod 8;
		mapFileBuffer(w6BF4) = ror(rol(mapFileBuffer(w6BF4), b4E51) and 0FEh, b4E51);	/* clear bit */
		badFileBuffer(w6BF4) = ror(rol(badFileBuffer(w6BF4), b4E51) and 0FEh, b4E51);
		w6BEF = w6BEF - 1;
		changed = TRUE;
		if not b6C17 then
			call Write(0, .(' SECTOR FREED',CR,LF), 15, .status);
		end;
	end;


	UnmarkTrack: procedure;
		b6BF3 =	 logicalSector - ((logicalSector - 1) mod 36);
		b6BF6 = b6BF3 + 35;
		do logicalSector = b6BF3 to b6BF6;
			call UnmarkSector;
		end;
		call Write(0, .(' TRACK PROCESSED', CR, LF), 18, .status);
	end;



	sub41D7: procedure(str, len) byte;
		declare str address, len byte;
		declare strCh based str byte;

		do while char = strCh and len <> 0;
			bufferPtr = bufferPtr + 1;
			str = str + 1;
			len = len - 1;
		end;

		if 'A' <= char and char <= 'Z' or bufferPtr = w6c10 then
		do;
			bufferPtr = w6C10;
			return 0;
		end;
		else
		do;
			bufferPtr = Deblank(bufferPtr);
			return TRUE;
		end;
	end;

entry:
	call Write(0, .('ISIS-II MAP FIXER V1.0', CR, LF), 24, .status);
	call SPath(.('A '), .pn, .status);
	if pn(11) <> 4 then
	do;
		call Write(0, .(' USE ON HARD DISK SYSTEM ONLY', CR, LF), 31, .status);
		call Exit;
	end;

	call Read(1, .buffer, 128, .actual, .status);
	buffer(actual) = CR;
	call ForceUpper(.buffer);
	bufferPtr = Deblank(.buffer);
	driveNumber = char - '0';
	if driveNumber > 9 then
		call FileError(INVALID$SYNTAX, bufferPtr, TRUE);
	else if driveNumber > 3 then
	do;
		call Write(0, .(' DRIVE NUMBER OUT OF RANGE', CR, LF), 28, .status);
		call Exit;
	end;
	mapFile(2), badFile(2) = char;
	bufferPtr = Deblank(bufferPtr + 1);
	if char <> CR then
		call FileError(INVALID$SYNTAX, bufferPtr, TRUE);

	call Open(.aftn, .mapFile, READ$MODE, 0, .status);
	call FileError(status, .mapFile, TRUE);
	call Read(aftn, .mapFileBuffer, 3712, .actual, .status);
	call Close(aftn, .status);

	call Open(.aftn, .badFile, READ$MODE, 0, .status);
	call FileError(status, .badFile, TRUE);
	call Read(aftn, .badFileBuffer, 3712, .actual, .status);
	call Close(aftn, .status);

	do while TRUE;
		call Write(0, .('*'), 1, .status);
		call Read(1, .buffer, 128, .actual, .status);
		buffer(actual) = CR;
		call ForceUpper(.buffer);
		bufferPtr, w6C10 = Deblank(.buffer);
		if sub41D7(.('MARK'), 4) then
		do;
			if sub3E49 then
				if b6C17 then
					call MarkTrack;
				else
					call MarkSector;
		end;
		else if sub41D7(.('FREE'), 4) then
		do;
			if sub3E49 then
				if b6C17 then
					call UnmarkTrack;
				else
					call UnmarkSector;
		end;
		else if sub41D7(.('EXIT'), 4) then
		do;
			if char <> CR then
				call ErrInvalidSyntax;
			else
			do;
				call WriteChanges;
				call Exit;
			end;
		end;
		else if sub41D7(.('QUIT'), 4) then
		do;
			if char <> CR then
				call ErrInvalidSyntax;
			else
				call Exit;
		end;
		else if sub41D7(.('RECORD'), 6) then
		do;
			if char <> CR then
				call ErrInvalidSyntax;
			else
				call WriteChanges;
		end;
		else if sub41D7(.('COUNT'), 5) then
		do;
			if char <> CR then
				call ErrInvalidSyntax;
			else if w6BEF = 0 then
				call Write(0, .(' NO BAD SECTORS',CR,LF), 17, .status);
			else
			do;
				call NumOut(w6BEF, 10, 0, .aBadSector + 1, 5);
				if w6BEF = 1 then
					aBadSector(17) = 0;
				else
					aBadSector(17) = 'S';
				call Write(0, .aBadSector, 20, .status);
			end;
		end;
		else if sub41D7(.('LIST'), 4) then
		do;
			if char = CR then
				bufferPtr = .(':CO: ',CR);
			call Spath(bufferPtr, .pn, .status);
			if status <> 0 then
				call FileError(status, bufferPtr, FALSE);
			else if pn(0) = driveNumber then
				call Write(0, .(' CANNOT LIST TO TARGET DRIVE',CR,LF), 30, .status);
			else if pn(10) = 0 then
				call FileError(16h, bufferPtr, FALSE);
			else
			do;
				bufferPtr = Deblank(Delimit(w6C10 := bufferPtr));
				if char <> CR then
					call ErrInvalidSyntax;
				else if w6BEF = 0 then
					call Write(0, .(' NO BAD SECTORS',CR,LF), 17, .status);
				else
				do;
					call Open(.aftn, w6C10, WRITE$MODE, 0, .status);
					if status <> 0 then
						call FileError(status, w6C10, FALSE);
					else
						call sub3D6C;
					call Close(aftn, .status);
				end;
			end;
		end;
		else if char <> CR then
			call ErrInvalidSyntax;
	end;
end;	/* end of entry */

fmttrk.plm
formatTrack: do;
$include(fmttrk.ipx)

FormatTrack: procedure(disk,sTrack,eTrack,interleave) public;
	declare (disk,interleave) byte, (sTrack, eTrack) address;
	declare curTrack address, (sectors, vTracks) byte;
	declare (i,j,interTrackSkew) byte, trackBuf(104) byte,
	dcb DCB$T;

	if diskType = 4 then	/* HD */
	do;
		sectors = 36;
		interTrackSkew = 17;
	end;
	else if diskType = 1 then	/* DD */
	do;
		sectors = 52;
		interTrackSkew = 7;
	end;
	else
	do;
		sectors = 26;
		interTrackSkew = 4;
	end;

	dcb.iocw = 0c0h;
	vTracks = sectors * 2 - 1;
	do i = 1 to vTracks by 2;
		trackBuf(i) = 0c7h;
	end;

	j = 0;

	if diskType = 4 then
	do;
		sTrack = sTrack * 4;
		eTrack = eTrack * 4 + 3;
	end;

	do curTrack = sTrack to eTrack;
		dcb.ioins = 2;
		do i = 0 to vTracks by 2;
			trackBuf(i) = 0;
		end;
		do i = 1 to sectors;
			j = (j + interleave) mod sectors;
			do while trackBuf(j * 2) <> 0;
				j = (j + 1) mod sectors;
			end;
			trackBuf(j + j) = i;
		end;
		if diskType <> 4 then
			dcb.tadr = curTrack;
		else
		do;
			dcb.tadr = curTrack / 4;
			dcb.sadr = (curTrack mod 4) * 36 + 1;
		end;
		dcb.buf = .trackBuf;
		call Diskio(disk, .dcb);
		j = j + interTrackSkew;
	end;
end;
end;
format.plm
format: do;
Seek: procedure(conn, mode, block$p, byte$p, status$p) external; /* force load */
	declare (conn, mode, block$p, byte$p, status$p) address;
end;

$include(format.ipx)
declare copyright(*) byte data('(C) 1975,1976,1977,1978,1979,1980,1981,1982 INTEL CORP'),
	version(*) byte data(4, 0, 'program_version_number=', 1, 'V4.3', 0);
/*
	the code block below is loaded into isis.t0 on non system disks to print a message
	the corresponding asm code is

		ASEG
		org 3000h

		in	79h
		in	7Bh
	L3004:	in	0FFh
		ani	2
		jnz	L3004
		lxi	h, Msg
		mvi	b, 32
	L3010:	mov	c, m
		call	0F809h	; CO
		inx	h
		dcr	b
		jnz	L3010
		rst	0
	Msg:	db	0Dh, 0Ah
		db	'NON-SYSTEM DISK, TRY ANOTHER'
		db	0Dh, 0Ah
		end
*/
declare codeBlock(*) byte data(0DBh, 79h, 0DBh, 7Bh, 0DBh, 0FFh, 0E6h, 2,
			       0C2h, 4, 30h, 21h, 1Ah, 30h, 6, 20h, 4Eh,
			       0CDh, 9, 0F8h, 23h, 5, 0C2h, 10h, 30h, 0C7h,
			       CR, LF, 'NON-SYSTEM DISK, TRY ANOTHER', CR, LF);

declare buffer(256) byte;
declare	memSize address;
declare	actual address;
declare	pn(12) byte;
declare	buffer$ptr address, char based buffer$ptr byte;
declare	(i, j, k) address;	/* k no longer used !! */
declare	(system, copyAll, copy) bool;
declare	(targetDisk, srcDisk) byte;
declare unused address;
declare	(aftIn, aftOut, dirAft) address;
declare	status address;
declare	attributeList(*) byte data(1, 2, 4);	/* no longer used */
declare crlf(2) byte data(CR, LF);
declare	inputString(16) byte,	/* no longer used */
	outputString(16) byte;	/* no longer used */

declare	t0File(*) byte initial(':FX:ISIS.T0 '),
	cliFile(*) byte initial(':FX:ISIS.CLI '),
	binFile(*) byte initial(':FX:ISIS.BIN '),
	ov0File(*) byte initial(':FX:ISIS.OV0 '),
	mapFile(*) byte initial(':FX:ISIS.MAP '),
	labFile(*) byte initial(':FX:ISIS.LAB '),
	dirFile(*) byte initial(':FX:ISIS.DIR '),
	badFile(*) byte initial(':FX:ISIS.BAD '),
	t0File2(*) byte initial(':FX:ISIS.T0 '),
	labFile2(*) byte initial(':FX:ISIS.LAB '),
	dirFile2(*) byte initial(':FX:ISIS.DIR ');

declare	diskType byte public;

declare	fmtTable(5) structure(t0Interleave byte, t1Interleave byte, interleave  byte,
		   	      tracks address, labBlkSize address)
		initial(0,  0, 0,   0,    0,	/* controller not present */
			1,  4, 5,  76,  80h,	/* 2 board DD */
			1, 12, 6,  76,  80h,	/* 2 board SD */
			1, 12, 6,  76,  80h,	/* integrated SD */
			7, 16, 9, 199, 0FBh	/* 2 board HD */
		);



declare labBlk structure(name(9) byte,
			 version(2) byte,
			 leftOver(38) byte,
			 crlf(2) byte,
		         fmtTable(200) byte) at (.buffer);

start:
	call Read(1, .buffer, 256, .actual, .status);
	buffer(actual) = CR;
	call forceUpper(.buffer);
	bufferPtr = Deblank(.buffer);
	call Spath(bufferPtr, .pn, .status);
	if pn(11) = 5 or 6 then
		status = 0ECh;
	if pn(11) = 8 then
		status = 3Dh;

	call FileError(status, bufferPtr, TRUE);
	targetDisk = TestRange(pn(0), bufferPtr);
	diskType = pn(11);
	t0File(2), cliFile(2), binFile(2), ov0File(2),
	mapFile(2), labFile(2), dirFile(2), badFile(2) = targetDisk + '0';
	srcDisk = 0;
	system = 0;
	copyAll = 0;

	bufferPtr = Deblank(Delimit(bufferPtr));

	do while char <> CR;
		if char = 'S' then
			system = TRUE;
		else if char = 'A' then
			copyAll = TRUE;
		else if Seq(bufferPtr, .('FROM '), 5) then
		do;
			bufferPtr = Deblank(bufferPtr + 5);
			srcDisk = char - '0';
			if srcDisk > F9DEV then
				call FileError(UNRECOG$SWITCH, bufferPtr, TRUE);
		end;
		else if char <> '$' then
			call FileError(UNRECOG$SWITCH, bufferPtr, TRUE);
		bufferPtr = Deblank(bufferPtr + 1);
	end;

	if srcDisk = targetDisk then
	do;
		call ReportError(0EAh);
		call Exit;
	end;
	else
		labFile2(2), dirFile2(2), t0File2(2) = srcDisk + '0';

	if targetDisk = 0 and diskType = 4 and not system and not copyAll then
	do;
		call Write(0, .('NON-SYSTEM HARD DISK DRIVE 0 NOT ALLOWED', CR, LF), 42, .status);
		call Exit;
	end;

	call Open(.aftIn, .labFile2, READ$MODE, 0, .status);
	call FileError(status, .labFile2, TRUE);
	call Read(aftIn, .buffer, 251, .actual, .status);
	call FileError(status, .labFile2, TRUE);
	call Close(aftIn, .status);
	call FileError(status, .labFile2, TRUE);

	labBlk.fmtTable(0) = fmtTable(diskType).t0Interleave + '0';
	labBlk.fmtTable(1) = fmtTable(diskType).t1Interleave + '0';
	do i = 2 to fmtTable(diskType).tracks;
		labBlk.fmtTable(i) = fmtTable(diskType).interleave + '0';
	end;

	call FormatTrack(targetDisk, 0, 0, labBlk.fmtTable(0) - '0');
	call FormatTrack(targetDisk, 1, 1, labBlk.fmtTable(1) - '0');
	call FormatTrack(targetDisk, 2, fmtTable(diskType).tracks, labBlk.fmtTable(2) - '0');

	mapBase = .MEMORY;
	unused = SetupMap(targetDisk) + 29;
	call WriteDirectory(targetDisk);
	call Open(.aftOut, .labFile, UPDATE$MODE, 0, .status);
	call FileError(status, .labFile, TRUE);
	call moveAscii(.labBlk, .pn(1), 9);

	call Write(aftOut, .buffer, fmtTable(diskType).labBlkSize, .status);
	call Close(aftout, .status);
	call FileError(status, .labFile, TRUE);

	if system or copyAll then
	do;
		if copyAll then
			call Write(0, .('COPYING ALL FILES', CR, LF), 19, .status);
		else
			call Write(0, .('COPYING SYSTEM FILES', CR, LF), 22, .status);

		memSize = (Memck - .Memory) and 0ff80h;
		call Open(.dirAFT, .dirFile2, READ$MODE, 0, .status);
		call FileError(status, .dirFile2, TRUE);
		direct.empty = 0;
		do while direct.empty <> 7fh;
			call Read(dirAft, .direct, size(direct), .actual, .status);
			call FileError(status, .dirFile2, TRUE);
			if actual < size(direct) then
				direct.empty = 7fh;
			else if not direct.empty then
			do;
				if (direct.attrib and 80h) <> 0 then
				do;
					copy = 0;
					if Seq(.direct.file, .('ISIS',0,0,'BIN'), 9) or
					   Seq(.direct.file, .('ISIS',0,0,'CLI'), 9) or
					   Seq(.direct.file, .('ISIS',0,0,'T0'), 8) or
					   Seq(.direct.file, .('ISIS',0,0,'OV0'), 9) then
						copy = TRUE;
				end;
				else
					copy = (direct.attrib and 2) <> 0 or copyAll;

				if copy then
				do;
					direct.empty = srcDisk;
					call Ypath(.direct, .inputString);
					direct.empty = targetDisk;
					call Ypath(.direct, .outputString);
					call Open(.aftOut, .outputString, UPDATE$MODE, 0, .status);
					call FileError(status, .outputString, TRUE);
					call Open(.aftIn, .inputString, READ$MODE, 0, .status);
					call FileError(status, .inputString, TRUE);
					actual = memSize;
					do while actual = memSize;
						call Read(aftIn, .MEMORY, memSize, .actual, .status);
						call FileError(status, .inputString, TRUE);
						call Write(aftOut, .MEMORY, actual, .status);
					end;

					call Close(aftOut, .status);
					call FileError(status, .outputString, TRUE);
					call Close(aftIn, .status);
					call FileError(status, .inputString, TRUE);
					do i = 0 to 2;
						if (attributeList(i) and direct.attrib) <> 0 then
						do;
							call Attrib(.outputString, i, TRUE, .status);
							call FileError(status, .outputString, TRUE);
						end;
					end;
					/* find end of file name skipping :Fx: */
					k = Delimit(.inputString + 4) - .inputString - 4;
					call Write(0, .inputString + 4, k, .status);
					call Write(0, .crlf, 2, .status);
				end;
			end;
		end;
		call Close(dirAft, .status);
	end;
	else
	do;
		call Open(.aftOut, .t0File, UPDATE$MODE, 0, .status);
		call Write(aftOut, .codeBlock, 58, .status);
		call Close(aftOut, .status);
		call Delete(.binFile, .status);
		call Write(0, .('NON-SYSTEM DISK', CR, LF), 17, .status);
	end;

	call Attrib(.dirFile, 3, 0ffh, .status);
	call Attrib(.t0File, 3, 0ffh, .status);
	call Attrib(.labFile, 3, 0ffh, .status);
	call Attrib(.mapFile, 3, 0ffh, .status);
	if diskType = 4 then
		call Attrib(.badFile, 3, 0ffh, .status);

	if system or copyAll then
	do;
		call Attrib(.binFile, 3, 0ffh, .status);
		call Attrib(.cliFile, 3, 0ffh, .status);
		call Attrib(.ov0File, 3, 0ffh, .status);
	end;
	call Exit;
end;

forupp.plm
FORCEUPPER: DO;
$include(forupp.ipx)

ForceUpper: procedure(bufferPtr) public;
    declare bufferPtr address, ch based bufferPtr byte;

    do while ch <> CR;
        ch = uppercase(ch);
        bufferPtr = bufferPtr + 1;
    end;
end;
end;
fupper.plm
ForceUpper: do;
$include(fupper.ipx)

ForceUpper: procedure(bufferPtr) public;
	declare bufferPtr address, ch based bufferPtr byte;

	do while ch <> CR;
		ch = Uppercase(ch);
		bufferPtr = bufferPtr + 1;
	end;
end;
end;
getdsk.plm
GetDisk: do;
$include(getdsk.ipx)

declare source(3) structure(name(6) byte) data('SYSTEM', 'SOURCE', 'OUTPUT');

GetDisk: procedure(n) public;
	declare n byte;
	declare buf(128) byte, status address, junk address, actual address;

	call Write(0, .('LOAD '), 5, .status);
	call Write(0, .source(n), 6, .status);
	call Write(0, .(' DISK, THEN TYPE (CR)'), 21, .status);
	call Read(1, .buf, 128, .actual, .status);
end;
end;
hexobj.plm
hexobj: DO;
$include(hexobj.ipx)
declare VERSION$LEVEL literally '4',
        EDIT$LEVEL literally '0';

declare copyRight(*) byte data(
    '(C) 1975,1976,1977,1978,1979,1980,1981,1982 INTEL CORP');
declare version(*) byte data(VERSION$LEVEL, EDIT$LEVEL);
declare programVersion(*) byte data('program_version_number=', 1, 'V4.3', 0);

declare buffer$size word;
declare iBuf(3328) byte;
declare iPtr word;
declare buffer(128) byte;
declare buffer$ptr pointer, char based buffer$ptr byte;
declare (output$ptr, input$ptr) pointer;
declare actual word;
declare status word;
declare (start, endFile) bool;
declare (aft$out, aft$in) word;
declare start$value word;
declare record$ptr word;
declare memory$ptr pointer, mem based memory$ptr byte;
/*                                 */
/*  content record definition      */
/*                                 */
declare content structure(
                type   byte,
                length word,
                seg$id byte,
                addr   word,
                dat    byte
                ) at (.MEMORY);
declare record$address word;
declare rlen byte;
declare type byte;
declare i byte;
declare checksum byte;
/*                                  */
/*  module header record definition */
/*                                  */
declare modhdr structure(
                type(1)  byte,
                length   word,
                name$len byte,
                name(31) byte,
                trn$id   byte,
                trn$vn   byte,
                chksum   byte);
/*                                 */
/*  module end record definition   */
/*                                 */
declare modend structure(
                rec$type byte,
                length   word,
                type     byte,
                seg$id   byte,
                offset   word,
                chksum   byte);

/*                                 */
/*  module end of file record      */
/*  definition                     */
/*                                 */
declare modeof structure(
                type    byte,
                length  word,
                chksum  byte);
/*                                 */

declare temp$ptr pointer;
declare modloc structure(
                rectype  byte,
                length   word,
                segid    byte,
                offset   word,
                namelen  byte,
                name(35) byte);
declare temp(17) byte;

OutRecord: procedure(ptr);
    declare ptr pointer, char based ptr(1) byte;
    declare p1 apointer, addr based p1 word;
    declare (i, status) word;
    declare checksum byte;

    p1 = ptr + 1;
    checksum = 0;
    do i = 0 to addr + 1;
        checksum = checksum + char(i);
    end;
    char(addr + 2) = 0 - checksum;
    call Write(aft$out, ptr, addr + 3, .status);
    call FileError(status, output$ptr, TRUE);
end OutRecord;

Gnc: procedure byte;

    if iPtr = length(iBuf) then
    do;
        call Read(aft$in, .iBuf, length(iBuf), .actual, .status);
        call FileError(status, input$ptr, TRUE);
        if actual = 0 then
        do;
            call FileError(EARLY$EOF, input$ptr, TRUE);
            call Exit;
        end;
        iPtr = 0;
    end;
    iPtr = iPtr + 1;
    return iBuf(iPtr - 1) and 7fh;
end Gnc;

Hex: procedure byte;
    declare char byte;

    if (char := Gnc) >= '0' and char <= '9' then return char - '0';
    if char >= 'A' and char <= 'F' then return char - 37h;
    return 0ffh;
end Hex;

Bytes: procedure byte;
    declare char byte;

    char = shl(Hex, 4) + Hex;
    checksum = checksum + char;
    return char;
end Bytes;

/* *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
   *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*

      BEGINNING OF MAIN PROGRAM.

   *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
   *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-* */

                /* Initialize module header record area */
start, endfile = 0;
modhdr.type(0) = MODHDR$TYPE;
do i = 1 to size(modhdr) - 1;
    modhdr.type(i) = 0;
end;
/*                                 */
input$ptr = .(':CI: ');
call Read(1, .buffer, length(buffer), .actual, .status);
call FileError(status, input$ptr, TRUE);
buffer(actual) = CR;
call ForceUpper(.buffer);
input$ptr,buffer$ptr  = Deblank(.buffer);
call Open(.aft$in, input$ptr, READ$MODE, 0, .status);
call FileError(status, input$ptr, TRUE);
buffer$ptr = Deblank(Delimit(buffer$ptr));
if Seq(.('TO '), buffer$ptr, 3) then
do;
    output$ptr,buffer$ptr = Deblank(buffer$ptr + 2);
    buffer$ptr = Deblank(Delimit(buffer$ptr));
end;
else
do;
    call FileError(INVALID$SYNTAX, output$ptr, TRUE);
end;
do while char <> CR;
    if char = '$' then
        buffer$ptr = Deblank(buffer$ptr + 1);
    if Seq(buffer$ptr, .('START'), 5) then
    do;
        start = TRUE;
        buffer$ptr = Deblank(buffer$ptr + 5);
        if char <> '(' then
        do;
            call FileError(INVALID$SYNTAX, buffer$ptr, TRUE);
        end;
        buffer$ptr = buffer$ptr + 1;
        start$value = ScanInteger(.buffer$ptr);    
        buffer$ptr = Deblank(buffer$ptr);
        if char <> ')' then
        do;
            call FileError(INVALID$SYNTAX, buffer$ptr, TRUE);
        end;
        buffer$ptr = Deblank(buffer$ptr + 1);
    end;                /* end of search loop */
    else
    do;                 /* unrecognized option */
        call FileError(UNRECOG$SWITCH, buffer$ptr, TRUE);
    end;
end;            /* end of command line search */
/*                                 */
/*                                 */
call Open(.aft$out, output$ptr, WRITE$MODE, 0, .status);
call FileError(status, output$ptr, TRUE);
status = Path(input$ptr, .modhdr.name$len);
modhdr.name$len = 6;
do while modhdr.name(modhdr.name$len - 1) = 0;
    modhdr.name$len = modhdr.name$len - 1;
end;
modhdr.length = modhdr.name$len + 4;
modhdr.type(modhdr.name$len + 4) = 0; /* TRN ID */
modhdr.type(modhdr.name$len + 5) = 0; /* TRN VN */
       
/*
  Output module header record
*/

call OutRecord(.modhdr);
/*                                       */
/* Assemble and output content record(s) */
/*                                       */
buffer$size = Memck - .MEMORY - 64;
content.type = CONTENT$TYPE;
content.length = 0;
content.seg$id = ABS$SEG;
content.addr = 0;
memory$ptr = .MEMORY + 6;
record$ptr = 0;
iPtr = length(iBuf);
rlen = 1;
do while rlen <> 0;
    do while (char := Gnc) <> ':';
        if char >= '0' and char <= '9' then
        do;
            do while Gnc <> ' ';
                ;
            end;
            do while (char := Gnc) = ' ';
                ;
            end;
            modloc.name(0) = char;
            i = 1;
            do while (modloc.name(i) := Gnc) <> ' ';
                i = i + 1;
            end;
            modloc.name(i) = 0;
            modloc.namelen = i;
            modloc.length = i + 6;
            do while (char := Gnc) < '0' or char > '9';
                ;
            end;
            do i = 0 to 9;
                temp(i) = ' ';
            end;
            i = 1;
            temp(0) = char;
            do while (char := Gnc) <> ' ' and char <> '$' and char <> CR;
                temp(i) = char;
                i = i + 1;
            end;
            temp$ptr = .temp;   /* this is ludicrious, but needed do to ScanInteger */
            modloc.offset = ScanInteger(.temp$ptr);
            modloc.segId = 0;
            modloc.recType = 12h;
            call OutRecord(.modloc);
        end;
    end;
    checksum = 0;
    rlen = Bytes;
    if rlen <> 0 then
    do;
        record$address = Bytes * 256 + Bytes;
        if record$ptr <> record$address or
          content.length > buffer$size then
        do;
            if content.length <> 0 then
            do;
                content.length = content.length + 4;
                call OutRecord(.MEMORY);
            end;
            content.length = 0;
            record$ptr = record$address;
            memory$ptr = .MEMORY + 6;
            content.addr = record$address;
        end;
        type = Bytes;
        do i = 1 to rlen;
            mem = Bytes;
            memory$ptr = memory$ptr + 1;
            record$ptr = record$ptr + 1;
            content.length = content.length + 1;
        end;
        type = Bytes;   /* compute checksum */
        if checksum <> 0 then
        do;
            call FileError(CHECKSUM$ERROR, input$ptr, TRUE);
            call Exit;
        end;
    end; 
    else
    do;
        if content.length <> 0 then
        do;
            content.length = content.length + 4;
            call OutRecord(.MEMORY);
        end;

        /*
            Initialize, assemble and
            output module end record
        */

        modend.rec$type = MODEND$TYPE;
        modend.length = 5;
        modend.type = 1;
        modend.seg$id = 0;
        modend.offset = Bytes * 256 + Bytes;
        if start then
            modend.offset = start$value;    /* start address was specified */
        call OutRecord(.modend);
    /*                                  */
    /*    Initialize, assemble and      */
    /*    output the                    */
    /*    module end of file record     */
    /*                                  */
        modeof.type = EOF$TYPE;
        modeof.length = 1;
        call OutRecord(.modeof);
    end;
end; 

call Close(aft$in, .status);
call FileError(status, input$ptr, TRUE);
call Close(aft$out, .status);
call FileError(status, output$ptr, TRUE);
call Exit;
end hexobj;
EOF
idisk.plm
idisk: do;
$include(idisk.ipx)
declare copyright(*) byte data('(C) 1975,1976,1977,1978,1979,1980,1981,1982 INTEL CORP'),
	version(*) byte data(4, 0, 'program_version_number=', 1, 'V4.3', 0);
/*
	the code block below is loaded into isis.t0 on non system disks to print a message
	the corresponding asm code is

		ASEG
		org 3000h

		in	79h
		in	7Bh
	L3004:	in	0FFh
		ani	2
		jnz	L3004
		lxi	h, Msg
		mvi	b, 32
	L3010:	mov	c, m
		call	0F809h	; CO
		inx	h
		dcr	b
		jnz	L3010
		rst	0
	Msg:	db	0Dh, 0Ah
		db	'NON-SYSTEM DISK, TRY ANOTHER'
		db	0Dh, 0Ah
		end
*/
declare codeBlock(*) byte data(0DBh, 79h, 0DBh, 7Bh, 0DBh, 0FFh, 0E6h, 2,
			       0C2h, 4, 30h, 21h, 1Ah, 30h, 6, 20h, 4Eh,
			       0CDh, 9, 0F8h, 23h, 5, 0C2h, 10h, 30h, 0C7h,
			       CR, LF, 'NON-SYSTEM DISK, TRY ANOTHER', CR, LF);

declare	memSize address;
declare	actual address;
declare	pn(12) byte;
declare	buffer$ptr address, char based buffer$ptr byte;
declare	(i, j, k) address;	/* j, k no longer used !! */
declare	(fileNumber, hadPrint) byte;
declare	next address;
declare	w550F address;
declare	(system, first, copy) bool;
declare	(aftIn, aftOut, dirAft) address;
declare	status address;
declare	attributeList(*) byte data(1, 2, 4);	/* no longer used */
declare	tracks byte;
declare	(srcDisk, targetDisk) byte;
declare	unused address;
declare	diskType byte public;
declare	fmtTable(5) structure(t0Interleave byte, t1Interleave byte, interleave  byte,
		   	      tracks address, bitmapSize address, labBlkSize address)
		initial(0,  0, 0,   0,     0,    0,	/* controller not present */
			1,  4, 5,  76,  200h,  80h,	/* 2 board DD */
			1, 12, 6,  76,  100h,  80h,	/* 2 board SD */
			1, 12, 6,  76,  100h,  80h,	/* integrated SD */
			7, 16, 9, 199, 11DAh, 0FBh	/* 2 board HD */
		);
declare	inputString(16) byte,	/* no longer used */
	outputString(16) byte;	/* no longer used */

declare file(8) structure(name(13) byte)
	initial(':FX:ISIS.BIN ',
		':FX:ISIS.T0  ',
		':FX:ISIS.CLI ',
		':FX:ISIS.OV0 ',
		':FX:ISIS.MAP ',
		':FX:ISIS.DIR ',
		':FX:ISIS.LAB ',
		':FX:ISIS.BAD ');
declare buffer(256) byte;

declare labBlk structure(name(9) byte,
			 version(2) byte,
			 leftOver(38) byte,
			 crlf(2) byte,
		         fmtTable(200) byte) at (.buffer);
declare singleDrive bool public;
declare info based next structure(length address, offset address, begin address);


Initialize: procedure;
	call FormatTrack(targetDisk, 0, 0, labBlk.fmtTable(0) - '0');
	call FormatTrack(targetDisk, 1, 1, labBlk.fmtTable(1) - '0');
	call FormatTrack(targetDisk, 2, tracks, labBlk.fmtTable(2) - '0');
	mapBase = .MEMORY;
	unused = SetupMap(targetDisk) + 29;
	call WriteDirectory(targetDisk);
	file(6).name(2) = targetDisk + '0';
	call Open(.aftOut, .file(6), UPDATE$MODE, 0, .status);
	call SFileError(status, .file(6));
	call MoveAscii(.labBlk, .pn + 1, 9);
	call Write(aftOut, .labBlk, fmtTable(diskType).labBlkSize, .status);
	call SFileError(status, .file(6));
	call Close(aftOut, .status);
	call SFileError(status, .file(6));
end;


entry:
	call Read(1, .buffer, 256, .actual, .status);
	buffer(actual) = CR;
	call ForceUpper(.buffer);
	bufferPtr = Deblank(.buffer);
	call Spath(bufferPtr, .pn, .status);
	if (diskType := pn(11)) = 5 or 6 then	/* 6 is pointless as it does not impact test */
		status = 0ECh;
	if pn(11) = 8 then
		status = 3Dh;
	call FileError(status, bufferPtr, TRUE);
	targetDisk = TestRange(pn(0), bufferPtr);
	srcDisk = 0;
	system = 0;
	singleDrive = 0;
	bufferPtr = Deblank(Delimit(bufferPtr));

	do while char <> CR;
		if char = 'P' then
			singleDrive = TRUE;
		else if char = 'S' then
			system = TRUE;
		else if Seq(bufferPtr, .('FROM '), 5) then
		do;
			bufferPtr = Deblank(bufferPtr + 5);
			if (srcDisk := char - '0') > 9 then
				call FileError(UNRECOG$SWITCH, bufferptr, TRUE);

		end;
		else if char <> '$' then
			call FileError(UNRECOG$SWITCH, bufferPtr, TRUE);
		bufferPtr = Deblank(bufferPtr + 1);
	end;
	if srcDisk = targetDisk then
		singleDrive = TRUE;
	if targetDIsk = 0 and diskType = 4 and not system then
	do;
		call Write(0, .('NON-SYSTEM HARD DISK DRIVE 0 NOT ALLOWED', CR, LF), 2Ah, .status);
		call Exit;
	end;
	file(6).name(2) = srcDisk + '0';
	call Open(.aftIn, .file(6), 1, 0, .status);
	call FileError(status, .file(6), TRUE);
	call Read(aftIn, .buffer, 251, .actual, .status);
	call FileError(status, .file(6), TRUE);
	call Close(aftIn, .status);
	call FileError(status, .file(6), TRUE);
	tracks = fmtTable(diskType).tracks;
	labBlk.fmtTable(0) = fmtTable(diskType).t0Interleave + '0';
	labBlk.fmtTable(1) = fmtTable(diskType).t1Interleave + '0';
	do i = 2 to tracks;
		labBlk.fmtTable(i) = fmtTable(diskType).interleave + '0';
	end;

	if system then
	do;
		call Write(0, .('SYSTEM DISK', CR, LF), 13, .status);
		first = TRUE;
		next = fmtTable(diskType).bitmapSize + .MEMORY;
		memSize = Memck - next;
		fileNumber = 0;
		hadPrint = 0;
		info.offset, i = 0;
		do while fileNumber < 4;
			memSize = memSize - 8;
			file(fileNumber).name(2) = srcDisk + '0';
			call Open(.aftIn, .file(fileNumber), READ$MODE, 0, .status);
			call SFileError(status, .file(fileNumber));
			call Seek(aftIn, SEEK$ABS, .i, .info.offset, .status);
			call SFileError(status, .file(fileNumber));
			call Read(aftIn, .info.begin, memSize, .actual, .status);
			call SFileError(status, .file(fileNumber));
			call Close(aftIn, .status);
			call SFileError(status, .file(fileNumber));
			info.length = actual;
			next = .info.begin + actual;
			if fileNumber = 3 or (memSize := memSize - actual) < 8 then
			do;
				if singleDrive then
					call GetDisk(2);

				if first then
				do;
					call Initialize;
					next = .MEMORY + fmtTable(diskType).bitmapSize;
					first = FALSE;
				end;
				else
					next = .MEMORY;

				do while hadPrint <= fileNumber;
					file(hadPrint).name(2) = targetDisk + '0';
					call Open(.aftOut, .file(hadPrint), UPDATE$MODE, 0, .status);
					call SFileError(status, .file(hadPrint));
					call Seek(aftOut, SEEK$ABS, .i, .info.offset, .status);
					call SFileError(status, .file(hadPrint));
					call Write(aftOut, .info.begin, info.length, .status);
					call SFileError(status, .file(hadPrint));
					call Close(aftOut, .status);
					call SFileError(status, .file(hadPrint));
					if hadPrint < fileNumber then
						next = .info.begin + info.length;
					hadPrint = hadPrint + 1;
				end;
				w550F = info.offset + info.length;
				next = .MEMORY;
				if memSize = 0 then
				do;
					hadPrint = fileNumber;
					fileNumber = fileNumber - 1;
					info.offset = w550F;
				end;
				else
					info.offset = 0;

				memSize = Memck - next;
				if fileNumber + 1 < 4 and singleDrive then
					call GetDisk(0);
			end;
			else
				info.offset = 0;
			fileNumber = fileNumber + 1;
		end;
	end;
	else
	do;
		call Write(0, .('NON-SYSTEM DISK', CR, LF), 17, .status);
		if singleDrive then
			call GetDisk(2);
		call Initialize;
		file(0).name(2) = targetDisk + '0';
		file(1).name(2) = targetDisk + '0';
		call Open(.aftOut, .file(1), UPDATE$MODE, 0, .status);
		call SFileError(status, .file(1));
		call Write(aftOut, .codeBlock, 3Ah, .status);	/* code to write non system disk */
		call SFileError(status, .file(1));
		call close(aftOut, .status);
		call SFileError(status, .file(1));
		call Delete(.file(0), .status);
	end;
	do i = 0 to 7;
		file(i).name(2) = targetDisk + '0';
		call Attrib(.file(i), 3, TRUE, .status);
	end;

	call Attrib(.file(2), 0, TRUE, .status);
	call Attrib(.file(2), 1, TRUE, .status);
	call Attrib(.file(3), 0, TRUE, .status);
	call Attrib(.file(3), 1, TRUE, .status);
	if singleDrive then
		call GetDisk(0);
	call Exit;
end;
mvasci.plm
MOVEASCII: DO;
MoveAscii: procedure(dst, src, cnt) public;
    declare (dst, src) address, cnt byte, i byte;
    declare dch based dst (1) byte, sch based src (1) byte;

    do i = 0 to cnt - 1;
        dch(i) = sch(i);
    end;
end;
end;
numout.plm
numout: do;
declare digits(*) byte data('0123456789ABCDEF');

NumOut: procedure(value, base, lc, bufAdr, width) public;
	declare (value, bufAdr) address, (base, lc, width) byte;
	declare i byte;
	declare buf based bufAdr (1) byte;

	do i = 1 to width;
		buf(width - i) = digits(value mod base);
		value = value / base;
	end;

	i = 0;
	do while buf(i) = '0' and i < width - 1;
		buf(i) = lc;
		i = i + 1;
	end;
end;
end;
objhex.plm
OBJHEX:
DO;
$include(objhex.ipx)
DECLARE copyRight(*) byte data(
	'(C) 1975,1976,1977,1978,1979,1980,1981,1982 INTEL CORP');
DECLARE programVersion(*) byte data(4, 0, 'program_version_number=', 1, 'V4.3', 0);

DECLARE BUFFER$COUNT WORD;
DECLARE SEG$ID BYTE;
DECLARE RECLEN WORD;
DECLARE TYPE BYTE;
DECLARE CHECKSUM BYTE;
DECLARE (I,J) WORD;
DECLARE HEXLEN WORD;
DECLARE ADDR WORD;
DECLARE TEMP BYTE;
DECLARE BUFFER$SIZE WORD;
DECLARE IPTR WORD;
DECLARE BUFFER(128) BYTE;
DECLARE BUFFER$PTR POINTER, CHAR BASED BUFFER$PTR BYTE;
DECLARE (OUTPUT$PTR,INPUT$PTR) POINTER;
DECLARE ACTUAL WORD;
DECLARE STATUS WORD;
DECLARE (AFT$OUT,AFT$IN) WORD;
/*
   HEXADECIMAL CONTENT RECORD.
*/
DECLARE HEXRECORD STRUCTURE(
                     HEADER BYTE,
                     LENGTH WORD,
                     ADDR(2) WORD,
                     TYPE WORD,
                     DAT(16) WORD,
                     CHKSUM WORD,
                     TRAILER(2) BYTE);
/*
   HEXADECIMAL END RECORD.
*/
DECLARE ENDRECORD STRUCTURE(
                   HEADER BYTE,
                   LENGTH WORD,
                   ADDR(2) WORD,
                   TYPE WORD,
                   CHKSUM WORD,
                   TRAILER(2) BYTE);

GET$BYTE:
  PROCEDURE BYTE;
     IF BUFFER$COUNT = 0 THEN
     DO;
      CALL READ(AFT$IN,.MEMORY,BUFFER$SIZE,.BUFFER$COUNT,.STATUS);
      CALL FILE$ERROR(STATUS,INPUT$PTR,TRUE);
      IF BUFFER$COUNT = 0 THEN
      DO;
         CALL FILE$ERROR(EARLY$EOF,INPUT$PTR,TRUE);
         CALL EXIT;
      END;
      IPTR = 0;
     END;
     BUFFER$COUNT = BUFFER$COUNT - 1;
     IPTR = IPTR + 1;
     RETURN MEMORY(IPTR-1);
  END GET$BYTE;

GET$ADDRESS:
  PROCEDURE ADDRESS;
     RETURN GET$BYTE + GET$BYTE*256;
  END GET$ADDRESS;

/* *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
   *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*

      BEGINNING OF MAIN PROGRAM.

   *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
   *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-* */

/*
  INITIALIZE RECORD STRUCTURES.
*/
HEXRECORD.HEADER = ':';
HEXRECORD.TYPE = '00';
ENDRECORD.HEADER = ':';
ENDRECORD.TRAILER(0) = CR;
ENDRECORD.TRAILER(1) = LF;
/*
  READ AND PROCESS COMMAND TAIL.
*/
INPUT$PTR = .(':CI: ');
CALL READ(1, .BUFFER,LENGTH(BUFFER),.ACTUAL, .STATUS);
CALL FILE$ERROR(STATUS, INPUT$PTR, TRUE);
BUFFER(ACTUAL) = CR;
CALL FORCE$UPPER(.BUFFER);
INPUT$PTR,BUFFER$PTR = DEBLANK(.BUFFER);
CALL OPEN(.AFT$IN, INPUT$PTR,READ$MODE,0,.STATUS);
CALL FILE$ERROR(STATUS,INPUT$PTR,TRUE);
BUFFER$PTR = DEBLANK(DELIMIT(BUFFER$PTR));
IF SEQ( .('TO '),BUFFER$PTR,3) THEN
DO;
   OUTPUT$PTR,BUFFER$PTR = DEBLANK(BUFFER$PTR+2);
   BUFFER$PTR = DEBLANK(DELIMIT(BUFFER$PTR));
END;
ELSE
DO;
   CALL FILE$ERROR(INVALID$SYNTAX,OUTPUT$PTR,TRUE);
END;
IF CHAR <> CR THEN CALL FILE$ERROR(INVALID$SYNTAX,BUFFER$PTR,TRUE);
CALL OPEN(.AFT$OUT,OUTPUT$PTR,WRITE$MODE,0,.STATUS);
CALL FILE$ERROR(STATUS,OUTPUT$PTR,TRUE);
/*
   COMPUTE SIZE OF WORKSPACE.
*/
BUFFER$SIZE = MEMCK - .MEMORY;
BUFFER$COUNT = 0;
/*
   READ OBJECT RECORDS, WRITE HEXADECIBAL RECORDS.
*/
DO FOREVER;
   TYPE = GET$BYTE;
   IF TYPE >= RELOC$TYPE THEN
     CALL FILE$ERROR(BAD$REC$TYP,INPUT$PTR,TRUE);
   IF TYPE = MODEND$TYPE THEN
   DO;
     RECLEN = GET$ADDRESS;
     TEMP = GET$BYTE;
     TEMP = GET$BYTE;
     ADDR = GET$ADDRESS;
     CHECKSUM = LOW(ADDR) + HIGH(ADDR) + 1;
     CALL NUMOUT(0,16,'0',.ENDRECORD.LENGTH,2);
     CALL NUMOUT(ADDR,16,'0',.ENDRECORD.ADDR,4);
     CALL NUMOUT(1,16,'0',.ENDRECORD.TYPE,2);
     CALL NUMOUT(-CHECKSUM,16,'0',.ENDRECORD.CHKSUM,2);
     CALL WRITE(AFT$OUT,.ENDRECORD,SIZE(ENDRECORD),.STATUS);
     CALL CLOSE(AFT$IN,.STATUS);
     CALL CLOSE(AFT$OUT,.STATUS);
     CALL EXIT;
   END;
   IF TYPE <> CONTENT$TYPE THEN
   DO;
     RECLEN = GET$ADDRESS;
     DO I = 1 TO RECLEN;
       TEMP = GET$BYTE;
     END;
   END;
   ELSE
   DO;
     RECLEN = GET$ADDRESS;
     SEG$ID = GET$BYTE;
     ADDR = GET$ADDRESS;
     RECLEN = RECLEN - 4;
     DO WHILE RECLEN <> 0;
       HEXLEN = RECLEN;
       IF HEXLEN > LENGTH(HEXRECORD.DAT) THEN
         HEXLEN = LENGTH(HEXRECORD.DAT);
       RECLEN = RECLEN - HEXLEN;
       DO I = 0 TO LENGTH(HEXRECORD.DAT)+1;
         HEXRECORD.DAT(I) = 0A0DH;
       END;
       CHECKSUM = HEXLEN + LOW(ADDR) + HIGH(ADDR);
       CALL NUMOUT(HEXLEN,16,'0',.HEXRECORD.LENGTH,2);
       CALL NUMOUT(ADDR,16,'0',.HEXRECORD.ADDR,4);
       DO J = 0 TO HEXLEN - 1;
         ADDR = ADDR + 1;
         TEMP = GET$BYTE;
         CHECKSUM = CHECKSUM + TEMP;
         CALL NUMOUT(TEMP,16,'0',.HEXRECORD.DAT(J),2);
       END;
       CALL NUMOUT(-CHECKSUM,16,'0',.HEXRECORD.DAT(HEXLEN),2);
       CALL WRITE(AFT$OUT,.HEXRECORD,HEXLEN+HEXLEN+13, .STATUS);
     END;
     TEMP = GET$BYTE;
   END;
END;
END OBJHEX;
EOF
path.plm
PATH: DO;
$include(path.ipx)

Path: procedure(filename, pn) byte public;
	declare (filename, pn) address;
	declare info(12) byte, status byte;

	call Spath(filename, .info, .status);	/* bug? status only a byte */
	call MoveAscii(pn, .info, 10);
	return status;
end;
end;
popul.plm
population: do;

declare bitCnt(*) byte initial(
	0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
	4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8);

Population: procedure(bufferLoc, length) address;
	declare (bufferLoc, length, total) address,
	(i, t, l) byte;
	declare buffer based bufferLoc (1) byte;

	total = 0;
	do while length > 31;
		t = 0;
		do i = 0 to 30;
			t = t + bitCnt(buffer(i));
		end;
		total = total + t;
		bufferLoc = bufferLoc + 31;
		length = length - 31;
	end;
	l = length - 1;
	t = 0;
	do i = 0 to l;
		t = t + bitCnt(buffer(i));
	end;
	return total + t;
end;
end;
reperr.plm
REPORTERROR: DO;
$include(reperr.ipx)

declare msg(*) byte DATA(0, 0,
    2, 'ILLEGAL AFTN ARGUMENT', 0,
    4, 'INCORRECTLY SPECIFIED FILE', 0,
    5, 'UNRECOGNIZED DEVICE NAME', 0,
    6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
    8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
    9, 'DISK DIRECTORY FULL', 0,
    0AH, 'NOT ON SAME DISK', 0,
    0BH, 'FILE ALREADY EXISTS', 0,
    0CH, 'FILE IS ALREADY OPEN', 0,
    0DH, 'NO SUCH FILE', 0,
    0EH, 'WRITE PROTECTED', 0,
    11H, 'NOT A DISK FILE', 0,
    12H, 'ILLEGAL ISIS COMMAND', 0,
    13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
    14H, 'ATTEMPTED BACK SEEK TOO FAR', 0,
    15H, 'CAN''T RESCAN', 0,
    16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
    17H, 'MISSING FILENAME', 0,
    19H, 'ILLEGAL ECHO FILE', 0,
    1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
    1BH, 'ILLEGAL SEEK COMMAND', 0,
    1CH, 'MISSING EXTENSION', 0,
    1FH, 'CAN''T SEEK ON WRITE ONLY FILE', 0,
    20H, 'CAN''T DELETE OPEN FILE', 0,
    23H, 'SEEK PAST EOF', 0,
    0C9H, 'UNRECOGNIZED SWITCH', 0,
    0CAH, 'UNRECOGNIZED DELIMITER', 0,
    0CBH, 'INVALID SYNTAX', 0,
    0CCH, 'PREMATURE EOF', 0,
    0CEH, 'ILLEGAL DISKETTE LABEL', 0,
    0D0H, 'CHECKSUM ERROR', 0,
    0D1H, 'RELO FILE SEQUENCE ERROR', 0,
    0D2H, 'INSUFFICIENT MEMORY', 0,
    0D3H, 'RECORD TOO LONG', 0,
    0D4H, 'ILLEGAL RELO RECORD', 0,
    0D5H, 'FIXUP BOUNDS ERROR', 0,
    0D6H, 'ILLEGAL SUBMIT PARAMETER', 0,
    0D7H, 'ARGUMENT TOO LONG', 0,
    0D8H, 'TOO MANY PARAMETERS', 0,
    0D9H, 'OBJECT RECORD TOO SHORT', 0,
    0DAH, 'ILLEGAL RECORD FORMAT', 0,
    0DBH, 'PHASE ERROR', 0,
    0EAh, 'CANNOT FORMAT FROM TARGET DRIVE', 0,
    0EBh, 'NON-DISK DEVICE', 0,
    3DH, 'UNASSIGNED DEVICE', 0,
    0ECH, 'ILLEGAL FORMAT ON REMOTE DEVICE', 0
    );


ReportError: procedure(errNum) public;
    declare errNum address;
    declare numberBuffer(3) byte, i address, status address;
    
    if errNum <> 0 then
    do;
        i = 0;
        do while i < size(msg);
            if errNum = msg(i) and msg(i + 1) <> 0 then
            do;
                i = i + 1;
                call write(0, .(' '), 1, .status);
                do while msg(i) <> 0;
                    call Write(0, .msg(i), 1, .status);
                    i = i + 1;
                end;
                call Write(0, .(0dh, 0ah), 2, .status);
                return;
            end;
            else
            do;
                do while msg(i) <> 0;
                    i = i + 1;
                end;
                i = i + 1;
            end;
        end;
        call error(errNum);
    end;
end;
end;
rpterr.plm
ReportError: do;
$include(rpterr.ipx)
declare msg(*) byte DATA(0, 0,
	2, 'ILLEGAL AFTN ARGUMENT', 0,
	4, 'INCORRECTLY SPECIFIED FILE', 0,
	5, 'UNRECOGNIZED DEVICE NAME', 0,
	6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
	8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
	9, 'DISK DIRECTORY FULL', 0,
	0AH, 'NOT ON SAME DISK', 0,
	0BH, 'FILE ALREADY EXISTS', 0,
	0CH, 'FILE IS ALREADY OPEN', 0,
	0DH, 'NO SUCH FILE', 0,
	0EH, 'WRITE PROTECTED', 0,
	11H, 'NOT A DISK FILE', 0,
	12H, 'ILLEGAL ISIS COMMAND', 0,
	13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
	14H, 'ATTEMPTED BACK SEEK TOO FAR', 0,
	15H, 'CAN', 27H, 'T RESCAN', 0,
	16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
	17H, 'MISSING FILENAME', 0,
	19H, 'ILLEGAL ECHO FILE', 0,
	1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
	1BH, 'ILLEGAL SEEK COMMAND', 0,
	1CH, 'MISSING EXTENSION', 0,
	1FH, 'CAN', 27H, 'T SEEK ON WRITE ONLY FILE', 0,
	20H, 'CAN', 27H, 'T DELETE OPEN FILE', 0,
	23H, 'SEEK PAST EOF', 0,
	0C9H, 'UNRECOGNIZED SWITCH', 0,
	0CAH, 'UNRECOGNIZED DELIMITER', 0,
	0CBH, 'INVALID SYNTAX', 0,
	0CCH, 'PREMATURE EOF', 0,
	0CEH, 'ILLEGAL DISKETTE LABEL', 0,
	0D0H, 'CHECKSUM ERROR', 0,
	0D1H, 'RELO FILE SEQUENCE ERROR', 0,
	0D2H, 'INSUFFICIENT MEMORY', 0,
	0D3H, 'RECORD TOO LONG', 0,
	0D4H, 'ILLEGAL RELO RECORD', 0,
	0D5H, 'FIXUP BOUNDS ERROR', 0,
	0D6H, 'ILLEGAL SUBMIT PARAMETER', 0,
	0D7H, 'ARGUMENT TOO LONG', 0,
	0D8H, 'TOO MANY PARAMETERS', 0,
	0D9H, 'OBJECT RECORD TOO SHORT', 0,
	0DAH, 'ILLEGAL RECORD FORMAT', 0,
	0DBH, 'PHASE ERROR', 0,
	0EAH, 'CANNOT FORMAT FROM TARGET DRIVE', 0,
	0EBH, 'NON-DISK DEVICE', 0,
	3DH, 'UNASSIGNED DEVICE', 0,
	0ECH, 'ILLEGAL FORMAT ON REMOTE DEVICE', 0
	);

ReportError: procedure(errNum) public;
	declare errNum address;
	declare numberBuffer(3) byte, i address, status address;


	if errNum <> 0 then
	do;
		i = 0;
		do while i < size(msg);
			if errNum = msg(i) and msg(i + 1) <> 0 then
			do;
				i = i + 1;
				call write(0, .(' '), 1, .status);
				do while msg(i) <> 0;
					call write(0, .msg(i), 1, .status);
					i = i + 1;
				end;
				call write(0, .(0dh, 0ah), 2, .status);
				return;
			end;
			else
			do;
				do while msg(i) <> 0;
					i = i + 1;
				end;
				i = i + 1;
			end;
		end;
	call error(errNum);
	end;
end;
end;
scanin.plm
ScanInteger: do;

declare digits(*) byte data('0123456789ABCDEF');

ScanInteger: procedure(ptrPtr) address public;
	declare ptrPtr address;
	declare ptr based ptrPtr address;
	declare (scanPtr, updatePtr, stopPtr) address;
	declare (i, radix, increment) byte;
	declare (nVal, oVal) address;
	declare c based scanPtr byte;

	scanPtr = ptr;
	do while c = ' ';
		scanPtr = scanPtr + 1;
	end;
	ptr = scanPtr;
	do while '0' <= c and c <= '9' or 'A' <= c and c <= 'F';
		scanPtr = scanPtr + 1;
	end;

	stopPtr = scanPtr;
	updatePtr = scanPtr + 1;
	if c = 'H' then
		radix = 16;
	else if c = 'O' or c = 'Q' then
		radix = 8;
	else
	do;
		updatePtr = scanPtr;
		stopPtr, scanPtr = scanPtr - 1;
		if c = 'B' then
			radix = 2;
		else
		do;
			radix = 10;
			if c <> 'D' then	/* include last increment */
				stopPtr = stopPtr + 1;
		end;
	end;
	scanPtr = ptr;
	nVal, oVal = 0;
	do while scanPtr < stopPtr;
		do i = 0 to 15;
			if c = digits(i) then
				increment = i;
		end;
		if increment >= radix then
			return 0;
		nVal = oVal * radix + increment;
		if nVal < oVal then
			return 0;
		oVal = nVal;
		scanPtr = scanPtr + 1;
	end;
	ptr = updatePtr;
	return nVal;
end;
end;
seq.plm
Seq: do;
$include(seq.ipx)

Seq: procedure(s1, s2, len) bool public;
	declare (s1,s2) address, len byte;
	declare chrs1 based s1(1) byte;
	declare chrs2 based s2(1) byte;
	declare i byte;
	len = len - 1;
	do i = 0 to len;
		if chrs1(i) <> chrs2(i) then
			return FALSE;
	end;
	return TRUE;
end;
end;

serror.plm
SFileError: do;
$include(serror.ipx)

declare singleDrive bool external;
SFileError: procedure(status, name$p) public;
	declare (status, name$p) address;
	declare lStatus address;

	if status <> 0 then
	do;
		if singleDrive then
			call GetDisk(0);
		name$p = Deblank(name$p);
		call Write(0, .(' '), 1, .lStatus);
		call Write(0, name$p, WDelimit(name$p) - name$p, .lStatus);
		call Write(0, .(','), 1, .lStatus);
		call ReportError(status);
		call Exit;
	end;
end;
end;
setblk.plm
SetBlock: do;
$include(setblk.ipx)
declare mapBase address external;
SetBlock: procedure(adr) public;
	declare adr address;
	declare (bit, byt) address, spt byte;
	declare bitmap based mapBase (1) byte;

	if diskType = 4 then
		spt = 90h;
	else if diskType = 1 then
		spt = 34h;
	else
		spt = 1ah;

	bit = high(adr) * spt + low(adr) - 1;
	byt = shr(bit, 3);
	bitmap(byt) = bitmap(byt) or maskArray(low(bit) and 7);
end;
end;
setmap.plm
SetupMap: do;
declare CR literally '0dh';
declare LF literally '0ah';

Write: procedure(conn, buff$p, count, status$p) external;
         declare conn address, buff$p address, count address, status$p address; end;

Exit: procedure external; end;

Absio: procedure(cmd, disk, block, buffer) external;
         declare cmd byte, disk byte, block address, buffer address; end;

numout: procedure(val, base, lc, bufAdr, width) external;
          declare val address, base byte, lc byte, bufAdr address, width byte; end;

SetBlock: procedure(adr) external; declare adr address; end;

declare mapBase address external;
declare maskArray(1) byte external;
declare diskType byte external;

declare fatalMsg(*) byte initial(' FATAL',
/* 6 */		               ' BAD SPOT AT LOGICAL ADDRESS ( ',
/* 37 */		       '***, ',
/* 42 */		       '*** ), STATUS = ',
/* 58 */		       '****', CR, LF);

declare trap0B structure(jmp byte, target address) at (0bh),
	trap0E address at (0eh);

declare trap0BCodeLocation address data(.SetupMap + 0DCh);
declare bitmap based mapBase (1) byte;

SetupMap: procedure(disk) address public;
	declare disk byte;
	declare logicalTrackSector address,
		(logicalSector, logicalTrack) byte at (.logicalTrackSector),
		(readBuf, savedSP) address,
		savedTrap0B structure(jmp byte, target address),
		(badSectorCount, headFixItemPtr, nextFixItemPtr, fixItemPtr) address,
		j byte, (i, bitmapLast, status) address;
	declare fixItem based fixItemPtr structure(sector byte, driveErr address, next address);

	ChkFixedSectors: procedure;
		if (logicalTrack = 0 and (logicalSector < 1Ch or logicalSector = 58h or logicalSector > 72h))
		  or (logicalTrack = 1 and (logicalSector < 40h or (48h < logicalSector and logicalSector < 88h)))
		  or (logicalTrack = 2 and logicalSector < 20h) then
		do;
			call NumOut(logicalTrack, 10, 0, .fatalMsg(37), 3);
			call NumOut(logicalSector, 10, 0, .fatalMsg(42), 3);
			call NumOut(trap0E, 16, 0, .fatalMsg(58), 4);
			call Write(0, .fatalMsg, 64, .status);
			call Exit;
		end;
	end;


	AddBadSector: procedure;
		declare (p, q) address;
		call ChkFixedSectors;
		call SetBlock(logicalTrackSector);
		fixItemPtr, p = headFixItemPtr;
		fixItemPtr = fixItem.next;

		/* look for insert point p->sector <  logicalsector and logicalsector <= *fixItemPtr */
		do while fixItem.sector < logicalSector;
			p = fixItemPtr;
			fixItemPtr = fixItem.next;
		end;
		if fixItem.sector = logicalSector then	/* already in list */
			return;

		q = fixItemPtr;				/* insert into list and set values */
		fixItemPtr = p;
		fixItem.next = nextFixItemPtr;
		fixItemPtr = nextFixItemPtr;
		fixItem.sector = logicalSector;
		fixItem.driveErr = trap0E;
		fixItem.next = q;
		nextFixItemPtr = nextFixItemPtr + size(fixItem);	/* set up next item */
	end;


	if diskType = 4 then	/* HD */
		bitmapLast = 3711;
	else if diskType = 1 then	/* DD */
		bitmapLast = 511;
	else
		bitmapLast = 255;	/* SD */

	do i = 0 to bitmapLast;
		bitmap(i) = 0;
	end;

	if diskType <> 4 then
		return 0;
	badSectorCount = 0;
	headFixItemPtr = (readBuf := mapBase + 3712) + 128;
	savedSP = STACKPTR;
	savedTrap0B.jmp = trap0B.jmp;
	trap0B.jmp = 0c3h;
	savedTrap0B.target = trap0B.target;
	trap0B.target = trap0BCodeLocation;
	logicalTrack = 0;

nextTrack:
	fixItemPtr = headFixItemPtr;
	fixItem.next = fixItemPtr + size(fixItem);
	fixItemPtr = headFixItemPtr + size(fixItem);
	fixItem.sector = 145;	/* max sector + 1 */
	nextFixItemPtr = fixItemPtr + size(fixItem);
	logicalSector = 1;

nextSector:
	call Absio(4, disk, logicalTrackSector, readBuf);
	goto skipTrap;

newTrap0B:
	STACKPTR = savedSP;
	trap0B.jmp = savedTrap0B.jmp;
	trap0B.target = savedTrap0B.target;
	if trap0E <> 1 and trap0E <> 10 then
		call AddBadSector;
	else
	do;
		/* mark all of the track under this head as bad. Note 4 heads per logical  track */
		logicalSector = (logicalSector - 1) - ((logicalSector - 1) mod 36);	/* first sector for head */
		do j = 1 to 36;
			logicalSector = logicalSector + 1;
			call AddBadSector;
		end;
	end;

	trap0B.jmp = 0c3h;
	trap0B.target = trap0BCodeLocation;

skipTrap:
	if (logicalSector := logicalSector + 1) < 145 then
		goto nextSector;

	fixItemPtr = headFixItemPtr;
	fixItemPtr = fixItem.next;

	do while fixItem.sector < 145;
		call NumOut(logicalTrack, 10, 0, .fatalMsg(37), 3);
		call NumOut(fixItem.sector, 10, 0, .fatalMsg(42), 3);
		call NumOut(fixItem.driveErr, 16, 0, .fatalMsg(58), 4);
		call Write(0, .fatalMsg(6), 58, .status);
		if logicalTrack > 1 then
			badSectorCount = badSectorCount + 1;
		fixItemPtr = fixItem.next;
	end;
	if (logicalTrack := logicalTrack + 1) < 200 then
		goto nextTrack;

	trap0B.jmp = savedTrap0B.jmp;
	trap0B.target = savedTrap0B.target;
	return badSectorCount;
end;
end;
submit.plm
SUBMIT:
DO;
$include(submit.ipx)
DECLARE copyRight(*) byte data(
    '(C) 1975,1976,1977,1978,1979,1980,1981,1982 INTEL CORP');
DECLARE programVersion(*) byte data(4, 0, 'program_version_number=', 1, 'V4.3', 0);

/*
    THIS VERSION OF SUBMIT HAS BEEN MODIFIED TO WORK ON DOUBLE DENSITY.
    IT RECOGNIZES DISK DRIVES 4 AND 5.
*/

/*

 THIS CUSP HAY BE CALLED BY EITHER OF 2 COMMAND STRINGS:

1.   -SUBMIT RESTORE <MACRO-FILENAME> (<PATHNAHE>,<BLOCKNO>,<BYTENO>)

       WHEN INVOKED IN THIS FASHION, SUBMIT WILL REPLACE THE
     CURRENT CONSOLE INPUT DEVICE (:CI:) BY THE FILE SPECIFIED
     BY <PATHNAME>; THEN THE FILE CALLED :FX:<MACRO-FILENAME>.CF
     IS DELETED.

       FURTHERMORE, IF <PATHNAME> SPECIFIES A DISK FILE, THEN
     A SEEK IS PERFORMED ON IT, AFTER IT BECOMES THE NEW :CI:
     FILE, USING THE <BLOCKNO> AHD <BYTENO> PARAMETERS, WHICH
     ARE ASSUMED TO BE INTEGERS.

2.    -SUBMIT <MACRO-FILENAME>(<ARG0>,<ARG1>,...,<ARG9>)

        WHEN INVOKED IN THIS FASHION, SUBMIT WILL CREATE A FILE
      :FX:<MACRO-FILENAME>.CF BY SUBSTITUTING THE ACTUAL
      PARAMETERS (<ARGS>'S) GIVEN FOR THE FORMAL PARAMATERS IN THE
      FILE SPECIFIED BY <MACRO-FILENAME>. (THE K'TH FORMAL PARAMATER
      IS %K, K A DIGIT.) THE CURRENT CONSOLE INPUT DEVICE IS THEN
      TEMPORARILY REDEFINED AS :FX:<MACRO-FILENAME>.CF; WHEN END OF
      FILE ON :FX:<MACRO-FILENAME>.CF IS REACHED, IT IS DELETED,
      AND :CI: IS RESUMED AS BEFORE. (NOTE THAT SUBMITS CAN BE NESTED).
*/

/*
  STRUCTURE TO STORE ACTUAL PARAMETERS AND CORRESPONDING LENGTHS.
*/

declare params(10) structure(
    dat(31) byte,
    length byte);

declare buffer(1024) byte;
declare buffer$ptr pointer;
declare buffer$count word;
declare char based buffer$ptr byte;
declare auxptr pointer;
declare pn(10) byte;
declare i word;
declare l byte;
declare (restore,scanning,debug,param$scan) bool;
declare (csd,cs,status,actual) word, (blockNo,byteNo) address;
declare (csdName,csName,nickName,ci) (15) byte;

/* *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-* 
   *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*

    Beginning of main program

   *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
   *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-* */

    /*
      Initialize parameter arrays.
    */
    do i=0 to size(params);
        params(0).dat(i) = 0;
    end;
    call Rescan(1, .status);
    call Read(1, .buffer, length(buffer), .actual, .status);
    buffer(actual) = CR;
    buffer$ptr = .buffer; /* force$upper that stops at params */
    do while char <> CR and char <> '(';
        char = UpperCase(char);
        buffer$ptr = buffer$ptr + 1;
    end;
    buffer$ptr = Deblank(.buffer);
    /*
      save name submit was invoked by.
    */
    debug = FALSE;
    if Seq(buffer$ptr, .('DEBUG '), 6) then
    do;
        debug = TRUE;
        buffer$ptr = Deblank(buffer$ptr + 5);
    end;
    status = Path(buffer$ptr, .pn);
    call Unpath(.pn, .nickName);
    buffer$ptr = Deblank(Delimit(buffer$ptr));
    /*
      Test for restore command.
    */
    restore = FALSE;
    if Seq(buffer$ptr, .('RESTORE '), 8) then
    do;
        restore = TRUE;
        buffer$ptr = Deblank(buffer$ptr + 8);
    end;
    /*
      Parse filenames.
    */
    call FileError(Path(buffer$ptr,.pn), buffer$ptr, TRUE);
    if pn(7) = 0 then
    do;
        pn(7) = 'C';
        pn(8) = 'S';
        pn(9) = 'D';
    end;
    call  Unpath(.pn, .csdName);
    pn(7) = 'C';
    pn(8) = 'S';
    pn(9) = 0;
    call  Unpath(.pn, .csName);
    buffer$ptr = Deblank(Delimit(buffer$ptr));
    /*
      Process actual paramaters.
    */
    i = 0;  /* parameter count */
    if char = '(' then
    do;
        buffer$ptr = buffer$ptr + 1;
        scanning = TRUE;
        do while scanning;
            auxptr, buffer$ptr = Deblank(buffer$ptr);
            if i = length(params) then
                call FileError(TOO$MANY$PARAMS, auxptr, TRUE);
            l = 0;  /* parameter length counter */
            if char = '''' then
            do;
                param$scan = TRUE;
                buffer$ptr = buffer$ptr + 1;
                do while param$scan;
                    if l = length(params.dat) then
                        call FileError(ARG$TOO$LONG, auxptr, TRUE);
                    params(i).dat(l) = char;
                    if char = '''' then
                    do;
                        param$scan = FALSE;
                        buffer$ptr = buffer$ptr + 1;
                        if char = '''' then
                        do;
                            param$scan = true;
                            buffer$ptr = buffer$ptr + 1;
                        end;
                    end;
                    else buffer$ptr = buffer$ptr + 1;
                    l = l + 1;
                end;
                l = l - 1;
            end;
            else
            do;
                param$scan = TRUE;
                do while param$scan;
                    if l = length(params.dat) then
                        call FileError(ARG$TOO$LONG, auxptr, TRUE);
                    if char > ' ' and char <= 'z'
                    and char <> ','
                    and char <> ')' then
                    do;
                        params(i).dat(l) = char;
                        buffer$ptr = buffer$ptr + 1;
                        l = l + 1;
                    end;
                    else param$scan = FALSE;
                end;
            end;
            buffer$ptr = Deblank(buffer$ptr);
            if char = ',' then
            do;
                buffer$ptr = buffer$ptr + 1;
            end;
            else
            if char = ')' then
            do;
                scanning = FALSE;
                buffer$ptr = Deblank(buffer$ptr + 1);
            end;
            else call FIleError(INVALID$SYNTAX, auxptr, TRUE);
            params(i).length = l;
            i = i + 1;
        end;
    end;
    if char <> CR  then call FileError(INVALID$SYNTAX, buffer$ptr, TRUE);
    if restore then
    do;
        /*
            change console to previous file
        */
        call Consol(.params(0).dat, .(':CO: '), .status);
        status = Path(.params(0).dat, .pn);
        if TestRange(pn(0), 1) <= 9 then   /* disk file */
        do;
            blockNo = .params(1).dat;
            blockNo = ScanInteger(.blockNo);
            byteNo = .params(2).dat;
            byteNo = ScanInteger(.byteNo);
            call Seek(1, SEEK$ABS, .blockNo, .byteNo, .status);
        end;
        /*
            delete file which just was the console
        */
        call Delete(.csName, .status);
        call FileError(status, .csName, TRUE);
    end;
    else
    do;
        /*
            write <MACRO-FILENAME>.CS.
        */
        GetInput: procedure byte;
            declare temp byte;

            if buffer$count = 0 then
            do;
                buffer$ptr = .buffer;
                call Read(csd, .buffer, length(buffer), .buffer$count, .status);
            end;
            if buffer$count = 0 then return 0;
            temp = char;
            buffer$ptr = buffer$ptr + 1;
            buffer$count = buffer$count - 1;
            return temp;
        end GetInput;

        call Open(.csd, .csdName, READ$MODE, 0, .status);
        call FileError(status, .csdName, TRUE);
        call Open(.cs, .csName, WRITE$MODE, 0, .status);
        call FileError(status, .csName, TRUE);
        buffer$count = 0;
        do while (l:=GetInput) <> 0;
            if l = CONTROL$P then
            do;
                l = GetInput;
                call Write(cs, .l, 1, .status);
            end;
            else
            if l <> '%' then call Write(cs, .l, 1, .status);
            else
            do;
                l = GetInput - '0';
                if l > last(params) then
                    call FileError(BAD$PARAM, buffer$ptr - 1, TRUE);
                call Write(cs, .params(l).dat, params(l).length, .status);
            end;
        end;
        /*
            add command to restore prior console
        */
        call Close(csd, .status);
        if debug then
        do;
            call Write(cs, .('DEBUG '), 6, .status);
        end;
        call Write(cs, .nickName, Delimit(.nickName) - .nickName + 1, .status);
        call Write(cs, .('RESTORE '), 8, .status);
        call Write(cs, .csName, Delimit(.csName) - .csName, .status);
        call Write(cs, .('('), 1, .status);
        /*
            ci := current console input device
        */
        call Whocon(1, .ci);
        call Write(cs, .ci, Delimit(.ci) - .ci, .status);
        status = Path(.ci, .pn);
        if TestRange(pn(0), 1) <= 9 then  /* disk file */
        do;
            PrintBlockOrByte: procedure(x);
                declare x word, ptr pointer;
                declare buf(6) byte;

                buf(5) = ' ';
                call Write(cs, .(','), 1, .status);
                call NumOut(x, 10, ' ', .buf, 5);
                ptr = Deblank(.buf);
                call Write(cs, ptr, Delimit(ptr) - ptr, .status);
            end PrintBlockOrByte;

            call Seek(1, SEEK$RETURN, .blockNo, .byteNo, .status);
            call PrintBlockOrByte(blockNo);
            call PrintBlockOrByte(byteNo);
        end;
        call Write(cs, .(')', CR, LF), 3, .status);
        call Close(cs, .status);
        call Consol(.csname, .(':CO: '), .status);
    end;
    call Exit;
end;
eof;
 
trange.plm
TestRange: do;
$include(trange.ipx)
TestRange: procedure(device, buffer$p) byte public;
	declare device byte, buffer$p address;

	if device >= 25 then	/* diskdrive 6-9 */
		device = device - 19;	/* bring disks together */
	else if device > 5 then		/* shift others above disks */
		device = device + 4;

	if device <=  9 or buffer$p = 1 then
		return device;
	if buffer$p <> 0 then
		call FileError(0EBh, buffer$p, TRUE);
	else
	do;
		call ReportError(0EBh);
		call exit;
	end;
end;
end;

ucase.plm
UpperCase: do;
UpperCase: procedure(char) byte public;
	declare char byte;
	if char < 'a' then
		return char;
	if char > 'z' then
		return char;
	return char and 0dfh;
end;
end;
unpath.plm
UNPATH: DO;

declare devTab(*) byte data('F0F1F2F3F4F5TITO',
			     'VIVOI1O1TRHRR1R2',
			     'TPHPP1P2LPL1BBCICO',
			     'F6F7F8F9');

Unpath:	procedure(int, ext) public;
	declare (int, ext) address;
	declare i byte;
	declare intName based int (1) byte;
	declare extName based ext (1) byte;

	extName(0) = ':';
	extName(1) = devTab(intName(0) + intName(0));
	extName(2) = devTab(intName(0) + intName(0) + 1);
	extName(3) = ':';	
	ext = ext + 4;
	do i = 0 to 5;
		if (extName(0) := intName(i + 1)) <> 0 then
			ext = ext + 1; 
	end;
	if intName(7) <> 0 then
	do;
		extName(0) = '.';
		ext = ext + 1;
	end;
	do i = 0 to 2;
		if (extName(0) := intName(i + 7)) <> 0 then
			ext = ext + 1; 

	end;
	extName(0) = ' ';
end;
end;
upcase.plm
UPPERCASE: DO;
UpperCase: procedure(char) byte public;
    declare char byte;
    if char < 'a' then
        return char;
    if char > 'z' then
        return char;
    return char and 0dfh;
end;
end;
isisUtil_4.3.pex
# common literals
TRUE            '0FFh'
FALSE           '0'
CR              '0Dh'
LF      '0Ah'
BELL            '7'
TAB             '9'
CONTROL$P	'10h'
FOREVER     'WHILE TRUE'


# my user types
pointer     'address'
bool        'byte'
apointer    'address'
word        'address'

# typedefs
DCB$T	'STRUCTURE (iocw BYTE, ioins BYTE, nsec BYTE, tadr BYTE, sadr BYTE, buf ADDRESS)'
DIRECT$T 'structure(empty byte, file(9) byte, attrib byte, eof$count byte, blk address, hdrBlk address)'


# standard ISIS system calls
Attrib		P("pointer" path$p,"word" attrib,"word" on$off,"apointer" status$p)
Close           P("word" conn,"apointer" status$p)
Co          P(B char)
Consol		P(A ci$p,A co$p,A status$p)
Delete          P(A path$p,A status$p)
Error       P("word" errnum)
Exit        P
Isis            P(B type,A parameter$ptr)
Memck           P"pointer"
Open            P("apointer" conn$p,"pointer" path$p,"word" access,"word" echo,"apointer" status$p)
Read            P("word" conn,"pointer" buff$p,"word" count,"apointer" actual$p,"apointer" status$p)
Rename          P(A old$p,A new$p,A status$p)
Rescan		P(A conn,A status$p)
Seek            P(A conn,A mode,A block$p,A byte$p,A status$p)
Spath       P("pointer" path$p,"pointer" info$p,"apointer" status$p)    
whocon		P(A conn,A buff$p)
Write           P(A conn,A buff$p,A count,A status$p)


F9DEV		'9'

# error codes
OK	'0'
NO$FREE$BUFFER	'1'
BAD$AFT$NO	'2'
AFT$FULL	'3'
BAD$PATH	'4'
BAD$DEVICE	'5'
CANT$WRITE	'6'
DISK$FULL	'7'
CANT$READ	'8'
DIRECTORY$FULL	'9'
DIFFERENT$DISK	'10'
MULTIDEFINED	'11'
ALREADY$OPEN	'12'
NO$SUCH$FILE	'13'
WRITE$PROTECT	'14'
ISIS$OVERWRITE	'15'
BAD$LOAD$FORMAT	'16'
NON$DISK$FILE	'17'
BAD$COMMAND	'18'
NON$DISK$SEEK	'19'
LONG$BACK$SEEK	'20'
CANT$RESCAN	'21'
ILLEGAL$ACCESS	'22'
NULL$FILENAME	'23'
DISK$IO$ERROR	'24'
BAD$ECHO	'25'
BAD$ATTRIB	'26'
BAD$SEEK$ARG	'27'
NULL$EXTENSION	'28'
CONSOLE$EOF	'29'
DRIVE$NOT$READY	'30'
SEEK$ON$WRITE	'31'
CANT$DELETE	'32'
ILLEGAL$PARAM	'33'
BAD$RETSW	'34'
SEEK$PAST$EOF	'35'
UNRECOG$SWITCH	'201'
UNRECOG$DELIM	'202'
INVALID$SYNTAX	'203'
EARLY$EOF	'204'
BAD$LABEL	'206'
NO$END$STAT	'207'
CHECKSUM$ERROR	'208'
RELO$SEQ$ERR	'209'
INSUFF$MEMORY	'210'
REC$TOO$LONG	'211'
BAD$REC$TYP	'212'
FIXUP$BOUNDS	'213'
BAD$PARAM	'214'
ARG$TOO$LONG	'215'
TOO$MANY$PARAMS	'216'
REC$TOO$SHORT	'217'
ILL$REC$FMT	'218'
PHASE$ERROR	'219'
NO$EOF		'220'
SEG$OVERFLOW	'221'
UNRECOG$REC	'222'
FIXUP$ERROR	'223'
ILL$REC$SEQ	'224'
BAD$MOD$NAME	'225'
LONG$MOD$NAME	'226'
NO$L$PAREN	'227'
NO$R$PAREN	'228'
UNRECOG$CONTROL	'229'
DUP$SYMBOL	'230'
FILE$EXISTS	'231'
UNRECOG$COM	'232'
NO$TO		'233'
DUP$FILE$NAME	'234'
NOT$LIB$FILE	'235'
TOO$MANY$CMNS	'236'
MISSING$COMMON	'237'
STACK$CONTENT	'238'
NO$MODHDR	'239'
OUT$OF$RANGE	'240'
INV$OBJ$FILE	'241'

# supported record types
RELOC$TYPE  '22h'
MODHDR$TYPE '2'
MODEND$TYPE '4'
CONTENT$TYPE    '6'
EOF$TYPE    '0eh'

ABS$SEG     '0'

# aftn for console devices
CONSOLE$OUTPUT  '0'
CONSOLE$INPUT   '1'

# open modes
READ$MODE	'1'
WRITE$MODE	'2'
UPDATE$MODE	'3'
OPEN$FOR$READ   '1'
OPEN$FOR$WRITE  '2'
NO$LINE$EDIT    '0'

# seek modes
SEEK$RETURN	'0'
SEEK$ABS	'2'

# public variables
direct		"DIRECT$T"
directINO	A
diskType        B
mapBase         A
maskArray       BS
singleDrive	B


# public procedures
Absio           P(B cmd,B disk,A block,A buffer)
ClearBuffer     P(A buf$ptr)
Deblank     P("pointer" ptr)"pointer"
Delimit     P("pointer" ptr)"pointer"
Diskio          P(A disk,A dcb$p)
FileError   P("word" status,"pointer" ptr,"bool" fatal)
FlushBlock      P(A adr)
ForceUpper  P("pointer" ptr)
FormatTrack     P(B disk,A sTrack,A eTrack,B interleave)
GetDisk         P(B n)
MoveAscii   P("pointer" dst,"pointer" src,B cnt)
NumOut      P("word" val,B base,B lc,"pointer" buf,B width)
Path        P("pointer" filename,"pointer" pn)B
ReportError P("word" errNum)
ScanInteger P("pointer" buf$p)"word"
Seq     P("pointer" str1,"pointer" str2,B cnt)"bool"
SetBlock        P(A adr)
SetupMap   P(B disk)A
SFileError      P(A status,A name$p)
TestRange       P(B device,A buffer$p)B
unpath		P(A int, A ext)
UpperCase       P(B char)B
WDelimit    P("pointer" ptr)"pointer"
WriteDirectory  P(B disk)
Ypath		P(A int,A ext)

vers.plm
vers: do;
$include(vers.ipx)

declare copyright(*) byte data  ('(C)1981,1982 INTEL CORP');
declare SENTINEL$0 literally '0',
        SENTINEL$1 literally '1',
        SENTINEL$2 literally '2';
declare READ$BUFFER$LENGTH literally '2048';

declare program$version$number$string(*) byte data
    ('PROGRAM VERSION NUMBER=', SENTINEL$1, 'V4.3 ', SENTINEL$0, 'VERS X002', SENTINEL$2);

declare string$to$search(*) byte  initial('program_version_number=');
declare alt$string$to$search(*) byte initial('PROGRAM VERSION NUMBER=');
declare found$msg(*) byte initial('    program version number is ');
declare not$found$msg (*) byte initial('    file does not contain a program version number', CR,LF);

declare file$name(15) byte initial (':F0:           ');
declare buffer(READ$BUFFER$LENGTH) byte;
declare actual address;
declare aft$in address;
declare buffer$index address;
declare buffer$ptr pointer;
declare (len, len1) word;
declare status word;
declare version$msg$length address;
declare end$of$file bool;
declare sentinel byte;
declare i byte;
declare program$msg$printed bool;
declare string$index byte;
declare successful$find bool;
declare no$ver$found bool initial(TRUE);
declare end$ptr address;


SkipBlanksNTabs: procedure(char$ptr) pointer;
    declare char$ptr pointer, char based char$ptr byte;

    do while char = ' ' or char = TAB;
        char$ptr = char$ptr + 1;
    end;
    return char$ptr;
end;

CheckStatus: procedure(isis$status);
    declare isis$status word;

    if isis$status <> 0 then
    do;
        call Error(isis$status);
        call Exit;
    end;
end;

StopEveryThing: procedure(msg$ptr);
    declare msg$ptr pointer, msg based msg$ptr (256) byte;
    declare msg$length word;

    msg$length = 0;

    do while msg(msg$length) <> 0 and msg$length < 255;
        msg$length = msg$length + 1;
    end;

    call Write(CONSOLE$OUTPUT, msg$ptr, msg$length, .status);
    call CheckStatus(status);
    call Co(BELL);
    call Exit;
end;

Capitalize: procedure(ptr, len);
    declare ptr pointer, char based ptr byte;
    declare len byte;
    declare i byte;

    do i = 1 to len;
        if char >= 'a' and char <= 'z' then
            char = char - 20h;
        ptr = ptr + 1;
    end;
end;

AsciiDigit: procedure(char) bool;
    declare char byte;

    if char >= '0' and char <= '9' then
        return TRUE;
    else
        return FALSE;
end;

FileNameLength: procedure(ptr) byte;
    declare ptr pointer, char based ptr byte;
    declare tmp$ptr address;

    tmp$ptr = ptr;
    do while   (char >= 'A' and char <= 'Z')
            or (AsciiDigit(char))
            or char = '.'
            or char = ':';
        ptr =  ptr + 1;
    end;
    tmp$ptr = ptr - tmp$ptr;
    if tmp$ptr > 14 then
    do;
        call Error(4);  /* illegal filename specification */
        call Exit;
    end;
    return tmp$ptr;
end;

StringFound: procedure(buffer$ptr, len0) bool;
    declare buffer$ptr pointer;
    declare len0 word;
    declare buffer$char based buffer$ptr (256) byte;

    buffer$index = 0;
    do while buffer$index < len0 and string$index < len1;
        if   buffer$char(buffer$index) = string$to$search(string$index)
          or buffer$char(buffer$index) = alt$string$to$search(string$index) then
            string$index = string$index + 1;
        else
        if string$index > 0 then
        do;
            buffer$index = buffer$index - 1;
            string$index = 0;
        end;
        buffer$index = buffer$index + 1;
    end;

    if string$index >= len1 then
        return TRUE;
    else
        return FALSE;
end;

CheckVersionNumber: procedure(char$ptr);
    declare char$ptr pointer, char based char$ptr byte;
    declare (version$type$v, version$type$x) byte;

    version$type$v, version$type$x = FALSE;
    if char = 'V'  then
        version$type$v = TRUE;
    else
    if char = 'X'  then
        version$type$x = TRUE;

    if version$type$v  or  version$type$x  then
    do;
        version$msg$length = 4;
        program$msg$printed = true;
        char$ptr = char$ptr + 1;
        if AsciiDigit(char)  then
        do;
            char$ptr = char$ptr + 1;
            if (char = '.'  and  version$type$v)  or
                (AsciiDigit(char)  and  version$type$x)  then
            do;
                char$ptr = char$ptr + 1;
                if  AsciiDigit(char)  then
                    return;
            end;
        end;
    end;

    if char = SENTINEL$1 then     /* look for  1...0  combination  */
    do;
        char$ptr = char$ptr + 1;  /* advance beyond the sentinel  */
        buffer$ptr = buffer$ptr + 1;  /* don't print the sentinel  */
        program$msg$printed = false;
        version$msg$length = 0;
        do while char <> sentinel;  /*  determine the message length  */
            version$msg$length = version$msg$length + 1;
            if (char$ptr := char$ptr + 1) > end$ptr then
            do;
                call Write(CONSOLE$OUTPUT, buffer$ptr, version$msg$length, .status);
                call CheckStatus(status);
                call Read(aft$in, .buffer, READ$BUFFER$LENGTH, .actual, .status);
                call CheckStatus(status);
                buffer$ptr, char$ptr = .buffer;
                version$msg$length = 0;
            end;
        end;
        return;
    end;

    successful$find = false;
    string$index = 0;
end;

PrintResult: procedure;
    if program$msg$printed then
    do;
        call Write(CONSOLE$OUTPUT, .found$msg, length(found$msg), .status);
        call CheckStatus(status);
    end;
    call Write(console$output, buffer$ptr, version$msg$length, .status);
    call CheckStatus(status);
    call Write(console$output, .(CR, LF), 2, .status);
    call CheckStatus(status);
    string$index = 0;
end;

ParseCommandTail:  procedure;
    declare command$tail(140) byte;
    declare char$ptr pointer,
    char based char$ptr byte;

    call read(CONSOLE$INPUT, .command$tail, length(command$tail), .actual, .status);
    call CheckStatus(status);

    command$tail(actual - 1) = CR;
    call Capitalize(.command$tail, actual);
    char$ptr = SkipBlanksNTabs(.command$tail);

    len = FileNameLength(char$ptr);
    if char = ':'  then
    do i = 0  to  len;
      file$name(i) = char;
      char$ptr = char$ptr + 1;
    end;
    else
    do i = 4  to  len + 4;
      file$name(i) = char;
      char$ptr = char$ptr + 1;
    end;

    char$ptr = SkipBlanksNTabs(char$ptr);
    if char = 'X'  then
    do;
        char$ptr = char$ptr + 1;
        sentinel = 2;
    end;
    else
        sentinel = 0;
    char$ptr = SkipBlanksNTabs(char$ptr);
    if char <> CR then
        call stop$everything(.('Syntax is "VERS  <file name>" ',CR, LF, 0));
end;

SearchForString:  procedure;

    call open(.aft$in, .file$name, READ$MODE, NO$LINE$EDIT, .status);
    call CheckStatus(status);

    len1 = length(string$to$search);
    successful$find, end$of$file = FALSE;
    string$index = 0;
    end$ptr = .actual;

    do while not end$of$file;
        call Read(aft$in, .buffer, read$buffer$length, .actual, .status);
        call CheckStatus(status);
        if actual < READ$BUFFER$LENGTH  then
          end$of$file = TRUE;

        buffer$ptr = .buffer;

        do while buffer$ptr < .buffer(actual);
          successful$find = StringFound(buffer$ptr, .buffer(actual) - buffer$ptr);
          buffer$ptr = buffer$ptr + buffer$index;
          if successful$find  then
            do;
              call CheckVersionNumber(buffer$ptr);
              if successful$find  then
              do;
                call PrintResult;
                end$of$file = true;
                no$ver$found = FALSE;
              end;
            end;
        end;
    end;
end SearchForString;
 
main:
    call ParseCommandTail;
    call SearchForString;
    if no$ver$found then
      call Write(CONSOLE$OUTPUT, .not$found$msg, length(not$found$msg), .status);
    call CheckStatus(status);
    call Close(aft$in, .status);
    call CheckStatus(status);
    call Exit;
end;
eof; 
wd.plm
WriteDirectory: do;
$include(wd.ipx)
declare mapBase address external;
declare bitmap based mapBase (1) byte;

declare file(6) structure(name(9) byte) data('ISIS',0,0,'DIR',
					     'ISIS',0,0,'MAP',
					     'ISIS',0,0,'T0',0,
					     'ISIS',0,0,'BIN',
					     'ISIS',0,0,'LAB',
					     'ISIS',0,0,'BAD');

WriteDirectory: procedure(disk) public;
	declare	disk byte, binIdx byte, i byte, jj address, dirBuf(64) address,
		direct(8) structure(empty byte, file(9) byte, attrib byte,
				    eof$count byte, blk address, hdrBlk address) at(.dirBuf),
		countBitMapSectors byte, binHdrBlk address, countDirSectors byte;

	SetLinks: procedure(start, count, firstBlock);
		declare (start, count, firstBlock, ii) address;

		do ii = 0 to count - 1;
			dirBuf(start + ii) = firstBlock + ii;
			call setBlock(firstBlock + ii);
		end;
	end;

	FlushBlock: procedure(adr);
		declare adr address;

		call Absio(6, disk, adr, .dirBuf);
		call SetBlock(adr);
		call ClearBuffer(.dirBuf);
	end;

	countDirSectors =  25;
	if diskType = 1 then
	do;
		countBitMapSectors = 4;
		binHdrBlk = 206h;
	end;
	else if diskType = 4 then
	do;
		countBitMapSectors = 29;
		binHdrBlk = 21fh;
		countDirSectors = 62;
	end;
	else
	do;
		countBitMapSectors = 2;
		binHdrBlk = 204h;
	end;

	jj = .bitmap - 128;
	if diskType = 4 then
		do i = 0 to countBitMapSectors - 1;
			call Absio(6, disk, i + 74h, (jj := jj + 128));
		end;
	/* set linkage for isis.t0 */
	call ClearBuffer(.dirBuf);
	call SetLinks(2, 23, 1);
	call FlushBlock(18h);		
	/* set linkage for isis.lab */
	if diskType = 4 then		/* hard disk */
	do;
		dirBuf(1) = 58h;	/* next linkage is sector 58h */
		call SetLinks(2, 3Eh, 1Ah);	/* first part of isis.lab */ 
	end;
	else if diskType = 1 then
	do;
		call SetLinks(2, 27, 1Ah);	/* allocate 53 blocks in 2 groups */
		call SetLinks(1Dh, 26, 11Bh);
	end;
	else
		call SetLinks(2, 1, 1Ah);	/* allocate 1 block */

	call FlushBlock(19h);		/* write label linkage */
	if diskType = 4 then
	do;
		dirBuf(0) = 19h;	/* link to previous */
		call SetLinks(2, 26, 59h);
		call SetLinks(1ch, 9, 140h);
		call SetLinks(25h, 9, 188h);
		call FlushBlock(58h);	/* write label linkage */
	end;
	/* set linkage for isis.bad for hd only */
	if diskType = 4 then
	do;
		call SetLinks(2, countBitMapSectors, 74h);
		call FlushBlock(73h);
	end;

	/* set linkage for isis.dir */
	call SetLinks(2, countDirSectors, 102h);
	if diskType = 4 then
		dirBuf(1) = 149h;	/* link to next */
	call FlushBlock(101h);
	if diskType = 4 then
	do;
		dirBuf(0) = 101h;	/* link to previous */
		call SetLinks(2, countDirSectors, 14Ah);
		call FlushBlock(149h);
	end;

	/* set linkage for isis.map */
	call SetLinks(2, countBitMapSectors, 202h);
	call FlushBlock(201h);
	call FlushBlock(binHdrBlk);

	/* isis.dir */
	call MoveAscii(.direct(0).file, .file(0), 9);
	if diskType = 4 then
		direct(0).blk = 124;	/* larger size */
	else
		direct(0).blk = 25;

	direct(0).hdrBlk = 101h;	/* linkage at t1 s1 */
	direct(0).attrib = 1;
	direct(0).eof$count = 128;

	/* isis.map */
	call MoveAscii(.direct(1).file, .file(1), 9);
	direct(1).blk = countBitMapSectors;
	direct(1).hdrBlk = 201h;	/* linkage at t2 s1 */
	direct(1).attrib = 1;
	direct(1).eof$count = 128;

	/* isis.t0 */
	call MoveAscii(.direct(2).file, .file(2), 9);
	direct(2).blk = 17h;
	direct(2).hdrBlk = 18h;		/* linkage at t0 s24 */
	direct(2).attrib = 1;
	direct(2).eof$count = 128;

	/* isis.lab */
	call MoveAscii(.direct(3).file, .file(4), 9);
	if diskType = 1 then
		direct(3).blk = 35h;
	else if diskType = 4 then
		direct(3).blk = 6Ah;
	else
		direct(3).blk = 1;
	direct(3).hdrBlk = 19h;		/* linkage at t0 s25 */
	direct(3).attrib = 1;
	direct(3).eof$count = 128;

	/* isis.bad */
	if diskType = 4 then
	do;
		call MoveAscii(.direct(4).file, .file(5), 9);
		direct(4).blk = countBitMapSectors;
		direct(4).hdrBlk = 73h;
		direct(4).attrib = 1;
		direct(4).eof$count = 128;
		binIdx = 5;
	end;
	else
		binIdx = 4;

	/* isis.bin */
	call MoveAscii(.direct(binIdx).file, .file(3), 9);
	direct(binIdx).hdrBlk = binHdrBlk;
	direct(binIdx).attrib = 3;
	direct(binIdx).eof$count = 128;

	/* flag as no further entries */
	do i = binIdx + 1 to 7;
		direct(i).empty = 7fh;
	end;

	call FlushBlock(102h);
	do i = 0 to 7;
		direct(i).empty = 7fh;
	end;

	do i = 1 to countDirSectors - 1;
		call Absio(6, disk, 102h + i, .dirBuf);
	end;

	if diskType = 4 then
		do i = 0 to countDirSectors - 1;
			call Absio(6, disk, 14Ah + i, .dirBuf);
		end;

	jj = .bitmap - 128;
	do i = 0 to countBitMapSectors - 1;
		call Absio(6, disk, 202h + i, (jj := jj + 128));
	end;
end;
end;

wdelim.plm
WDelimit: do;
WDelimit: procedure(ptr) address public;
	declare ptr address;
	declare ch based ptr byte;

	do while (ch = ':' or ch = '.' or ch = '*' or ch = '?' or
		  ('0' <= ch and ch <= '9') or ('A' <= ch and ch <= 'Z'));
		ptr = ptr + 1;
	end;
	return ptr;
end;
end;
wdlmt.plm
WDELIMIT: DO;
/* b1=01, b2=31, CODE(63H) byte, DATA(2H) byte, STACK(4H) byte, MEMORY(0H) byte,*/
WDelimit: procedure(ptr) address public;
    declare ptr address;
    declare ch based ptr byte;

    do while (ch = ':' or ch = '.' or ch = '*' or ch = '?' or
          ('0' <= ch and ch <= '9') or ('A' <= ch and ch <= 'Z'));
        ptr = ptr + 1;
    end;
    return ptr;
end;
end;
ypath.plm
ypath: do;
declare devTab(*) byte data('F0F1F2F3F4F5TITOVIVOI1O1TRHRR1R2TPHPP1P2LPL1BBCICOF6F7F8F9');


Ypath: procedure(int, ext) public;
	declare (int, ext) address;
	declare i byte;
	declare intName based int (1) byte,
		extName based ext (1) byte;

	extName(0) = ':';
	i = intName(0);
	/* map internal device to formal device index */
	if i > 9 then
		i = i - 4;
	else if i > 5 then
		i = i + 19;

	extName(1) = devTab(i + i);
	extName(2) = devTab(i + i + 1);
	extName(3) = ':';
	ext = ext + 4;

	do i = 0 to 5;
		if (extName(0) := intName(i + 1)) <> 0 then
			ext = ext + 1;
	end;
	if intName(7) <> 0 then
	do;
		extName(0) = '.';
		ext = ext + 1;
	end;
	do i = 0 to 2;
		if (extName(0) := intName(i + 7)) <> 0 then
			ext = ext + 1;
	end;
	extName(0) = ' ';
end;
end;
