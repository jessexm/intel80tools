disk.pex
CR	'0dh'
LF	'0ah'
TRUE	'0ffh'
FALSE	'0'
boolean	'byte'
DCB$T	'STRUCTURE (iocw BYTE, ioins BYTE, nsec BYTE, tadr BYTE, sadr BYTE, buf ADDRESS)'
DIRECT$T 'structure(empty byte, file(9) byte, attrib byte, eof$count byte, blk address, hdrBlk address)'

Attrib		P(A path$p,A attrib,A on$off,A status$p)
Close           P(A conn,A status$p)
Delete          P(A path$p,A status$p)
Error           P(A error$num)
Exit            P
Isis            P(B type,A parameter$ptr)
Memck           PA
Open            P(A conn$p,A path$p,A access,A echo,A status$p)
Read            P(A conn,A buff$p,A count,A actual$p,A status$p)
Rename          P(A old$p,A new$p,A status$p)
Seek            P(A conn,A mode,A block$p,A byte$p,A status$p)
Spath		P(A path$p,A info$p,A status$p)
Write           P(A conn,A buff$p,A count,A status$p)



$file(absio.plm)
Absio           P(B cmd,B disk,A block,A buffer)

$file(alloc.plm)
maskArray       BS

$file(setmap.plm)
SetupMap   P(B disk)A

$file(clbuf.plm)
ClearBuffer     P(A buf$ptr)

$file(dblank.plm)
deblank         P(A ptr)A

$file(direct.plm)
direct		"DIRECT$T"
directINO	A

$file(diskio.plm)
Diskio          P(A disk,A dcb$p)

$file(dlimit.plm)
Delimit         P(A ptr)A

$file(ferror.plm)
FileError       P(A status,A ptr,B callExit)

$file(fmttrk.plm)
FormatTrack     P(B disk,A sTrack,A eTrack,B interleave)

$file(fupper.plm)
ForceUpper      P(A bufferPtr)

$file(fshblk.plm)
FlushBlock      P(A adr)

$file(getdsk.plm)
GetDisk         P(B n)

$file(chkdev.plm)
TestRange       P(B device,A buffer$p)B

$file(idisk.plm,format.plm)
mapBase         A
diskType        B

$file(idisk.plm)
singleDrive	B

$file(mascii.plm)
MoveAscii       P(A dst,A src,B cnt)

$file(numout.plm)
numout          P(A val,B base,B lc,A bufAdr,B width)

$file(rpterr.plm)
ReportError     P(A errNum)

$file(scanin.plm)
ScanInteger	P(A ptrPtr)A

$file(seq.plm)
Seq             P(A str1,A str2,B cnt)"boolean"

$file(setblk.plm)
SetBlock        P(A adr)

$file(serror.plm)
SFileError      P(A status,A name$p)

$file(ypath.plm)
Ypath		P(A int,A ext)

$file(ucase.plm)
UpperCase       P(B char)B

$file(wdelim.plm)
WDelimit        P(A ptr)A

$file(wd.plm)
WriteDirectory  P(B disk)

idisk.plm
idisk: do;
$include(idisk.ipx)
declare copyright(*) byte data('(C) 1975,1976,1977,1978,1979,1980,1981,1982 INTEL CORP'),
	version(*) byte data(4, 0, 'program_version_number=', 1, 'V4.3', 0);
/*
	the code block below is loaded into isis.t0 on non system disks to print a message
	the corresponding asm code is

		ASEG
		org 3000h

		in	79h
		in	7Bh
	L3004:	in	0FFh
		ani	2
		jnz	L3004
		lxi	h, Msg
		mvi	b, 32
	L3010:	mov	c, m
		call	0F809h	; CO
		inx	h
		dcr	b
		jnz	L3010
		rst	0
	Msg:	db	0Dh, 0Ah
		db	'NON-SYSTEM DISK, TRY ANOTHER'
		db	0Dh, 0Ah
		end
*/
declare codeBlock(*) byte data(0DBh, 79h, 0DBh, 7Bh, 0DBh, 0FFh, 0E6h, 2,
			       0C2h, 4, 30h, 21h, 1Ah, 30h, 6, 20h, 4Eh,
			       0CDh, 9, 0F8h, 23h, 5, 0C2h, 10h, 30h, 0C7h,
			       CR, LF, 'NON-SYSTEM DISK, TRY ANOTHER', CR, LF);

declare	memSize address;
declare	actual address;
declare	pn(12) byte;
declare	buffer$ptr address, char based buffer$ptr byte;
declare	(i, j, k) address;	/* j, k no longer used !! */
declare	(fileNumber, hadPrint) byte;
declare	next address;
declare	w550F address;
declare	(system, first, copy) boolean;
declare	(aftIn, aftOut, dirAft) address;
declare	status address;
declare	attributeList(*) byte data(1, 2, 4);	/* no longer used */
declare	tracks byte;
declare	(srcDisk, targetDisk) byte;
declare	unused address;
declare	diskType byte public;
declare	fmtTable(5) structure(t0Interleave byte, t1Interleave byte, interleave  byte,
		   	      tracks address, bitmapSize address, labBlkSize address)
		initial(0,  0, 0,   0,     0,    0,	/* controller not present */
			1,  4, 5,  76,  200h,  80h,	/* 2 board DD */
			1, 12, 6,  76,  100h,  80h,	/* 2 board SD */
			1, 12, 6,  76,  100h,  80h,	/* integrated SD */
			7, 16, 9, 199, 11DAh, 0FBh	/* 2 board HD */
		);
declare	inputString(16) byte,	/* no longer used */
	outputString(16) byte;	/* no longer used */

declare file(8) structure(name(13) byte)
	initial(':FX:ISIS.BIN ',
		':FX:ISIS.T0  ',
		':FX:ISIS.CLI ',
		':FX:ISIS.OV0 ',
		':FX:ISIS.MAP ',
		':FX:ISIS.DIR ',
		':FX:ISIS.LAB ',
		':FX:ISIS.BAD ');
declare buffer(256) byte;

declare labBlk structure(name(9) byte,
			 version(2) byte,
			 leftOver(38) byte,
			 crlf(2) byte,
		         fmtTable(200) byte) at (.buffer);
declare singleDrive boolean public;
declare info based next structure(length address, offset address, begin address);


Initialize: procedure;
	call FormatTrack(targetDisk, 0, 0, labBlk.fmtTable(0) - '0');
	call FormatTrack(targetDisk, 1, 1, labBlk.fmtTable(1) - '0');
	call FormatTrack(targetDisk, 2, tracks, labBlk.fmtTable(2) - '0');
	mapBase = .MEMORY;
	unused = SetupMap(targetDisk) + 29;
	call WriteDirectory(targetDisk);
	file(6).name(2) = targetDisk + '0';
	call Open(.aftOut, .file(6), 3, 0, .status);
	call SFileError(status, .file(6));
	call MoveAscii(.labBlk, .pn + 1, 9);
	call Write(aftOut, .labBlk, fmtTable(diskType).labBlkSize, .status);
	call SFileError(status, .file(6));
	call Close(aftOut, .status);
	call SFileError(status, .file(6));
end;


entry:
	call Read(1, .buffer, 256, .actual, .status);
	buffer(actual) = CR;
	call ForceUpper(.buffer);
	bufferPtr = Deblank(.buffer);
	call Spath(bufferPtr, .pn, .status);
	if (diskType := pn(11)) = 5 or 6 then	/* 6 is pointless as it does not impact test */
		status = 0ECh;
	if pn(11) = 8 then
		status = 3Dh;
	call FileError(status, bufferPtr, TRUE);
	targetDisk = TestRange(pn(0), bufferPtr);
	srcDisk = 0;
	system = 0;
	singleDrive = 0;
	bufferPtr = Deblank(Delimit(bufferPtr));

	do while char <> CR;
		if char = 'P' then
			singleDrive = TRUE;
		else if char = 'S' then
			system = TRUE;
		else if Seq(bufferPtr, .('FROM '), 5) then
		do;
			bufferPtr = Deblank(bufferPtr + 5);
			if (srcDisk := char - '0') > 9 then
				call FileError(0C9h, bufferptr, TRUE);

		end;
		else if char <> '$' then
			call FileError(0C9h, bufferPtr, TRUE);
		bufferPtr = Deblank(bufferPtr + 1);
	end;
	if srcDisk = targetDisk then
		singleDrive = TRUE;
	if targetDIsk = 0 and diskType = 4 and not system then
	do;
		call Write(0, .('NON-SYSTEM HARD DISK DRIVE 0 NOT ALLOWED', CR, LF), 2Ah, .status);
		call Exit;
	end;
	file(6).name(2) = srcDisk + '0';
	call Open(.aftIn, .file(6), 1, 0, .status);
	call FileError(status, .file(6), TRUE);
	call Read(aftIn, .buffer, 251, .actual, .status);
	call FileError(status, .file(6), TRUE);
	call Close(aftIn, .status);
	call FileError(status, .file(6), TRUE);
	tracks = fmtTable(diskType).tracks;
	labBlk.fmtTable(0) = fmtTable(diskType).t0Interleave + '0';
	labBlk.fmtTable(1) = fmtTable(diskType).t1Interleave + '0';
	do i = 2 to tracks;
		labBlk.fmtTable(i) = fmtTable(diskType).interleave + '0';
	end;

	if system then
	do;
		call Write(0, .('SYSTEM DISK', CR, LF), 13, .status);
		first = TRUE;
		next = fmtTable(diskType).bitmapSize + .MEMORY;
		memSize = Memck - next;
		fileNumber = 0;
		hadPrint = 0;
		info.offset, i = 0;
		do while fileNumber < 4;
			memSize = memSize - 8;
			file(fileNumber).name(2) = srcDisk + '0';
			call Open(.aftIn, .file(fileNumber), 1, 0, .status);
			call SFileError(status, .file(fileNumber));
			call Seek(aftIn, 2, .i, .info.offset, .status);
			call SFileError(status, .file(fileNumber));
			call Read(aftIn, .info.begin, memSize, .actual, .status);
			call SFileError(status, .file(fileNumber));
			call Close(aftIn, .status);
			call SFileError(status, .file(fileNumber));
			info.length = actual;
			next = .info.begin + actual;
			if fileNumber = 3 or (memSize := memSize - actual) < 8 then
			do;
				if singleDrive then
					call GetDisk(2);

				if first then
				do;
					call Initialize;
					next = .MEMORY + fmtTable(diskType).bitmapSize;
					first = FALSE;
				end;
				else
					next = .MEMORY;

				do while hadPrint <= fileNumber;
					file(hadPrint).name(2) = targetDisk + '0';
					call Open(.aftOut, .file(hadPrint), 3, 0, .status);
					call SFileError(status, .file(hadPrint));
					call Seek(aftOut, 2, .i, .info.offset, .status);
					call SFileError(status, .file(hadPrint));
					call Write(aftOut, .info.begin, info.length, .status);
					call SFileError(status, .file(hadPrint));
					call Close(aftOut, .status);
					call SFileError(status, .file(hadPrint));
					if hadPrint < fileNumber then
						next = .info.begin + info.length;
					hadPrint = hadPrint + 1;
				end;
				w550F = info.offset + info.length;
				next = .MEMORY;
				if memSize = 0 then
				do;
					hadPrint = fileNumber;
					fileNumber = fileNumber - 1;
					info.offset = w550F;
				end;
				else
					info.offset = 0;

				memSize = Memck - next;
				if fileNumber + 1 < 4 and singleDrive then
					call GetDisk(0);
			end;
			else
				info.offset = 0;
			fileNumber = fileNumber + 1;
		end;
	end;
	else
	do;
		call Write(0, .('NON-SYSTEM DISK', CR, LF), 17, .status);
		if singleDrive then
			call GetDisk(2);
		call Initialize;
		file(0).name(2) = targetDisk + '0';
		file(1).name(2) = targetDisk + '0';
		call Open(.aftOut, .file(1), 3, 0, .status);
		call SFileError(status, .file(1));
		call Write(aftOut, .codeBlock, 3Ah, .status);	/* code to write non system disk */
		call SFileError(status, .file(1));
		call close(aftOut, .status);
		call SFileError(status, .file(1));
		call Delete(.file(0), .status);
	end;
	do i = 0 to 7;
		file(i).name(2) = targetDisk + '0';
		call Attrib(.file(i), 3, TRUE, .status);
	end;

	call Attrib(.file(2), 0, TRUE, .status);
	call Attrib(.file(2), 1, TRUE, .status);
	call Attrib(.file(3), 0, TRUE, .status);
	call Attrib(.file(3), 1, TRUE, .status);
	if singleDrive then
		call GetDisk(0);
	call Exit;
end;
format.plm
format: do;
Seek: procedure(conn, mode, block$p, byte$p, status$p) external; /* force load */
	declare (conn, mode, block$p, byte$p, status$p) address;
end;

$include(format.ipx)
declare copyright(*) byte data('(C) 1975,1976,1977,1978,1979,1980,1981,1982 INTEL CORP'),
	version(*) byte data(4, 0, 'program_version_number=', 1, 'V4.3', 0);
/*
	the code block below is loaded into isis.t0 on non system disks to print a message
	the corresponding asm code is

		ASEG
		org 3000h

		in	79h
		in	7Bh
	L3004:	in	0FFh
		ani	2
		jnz	L3004
		lxi	h, Msg
		mvi	b, 32
	L3010:	mov	c, m
		call	0F809h	; CO
		inx	h
		dcr	b
		jnz	L3010
		rst	0
	Msg:	db	0Dh, 0Ah
		db	'NON-SYSTEM DISK, TRY ANOTHER'
		db	0Dh, 0Ah
		end
*/
declare codeBlock(*) byte data(0DBh, 79h, 0DBh, 7Bh, 0DBh, 0FFh, 0E6h, 2,
			       0C2h, 4, 30h, 21h, 1Ah, 30h, 6, 20h, 4Eh,
			       0CDh, 9, 0F8h, 23h, 5, 0C2h, 10h, 30h, 0C7h,
			       CR, LF, 'NON-SYSTEM DISK, TRY ANOTHER', CR, LF);

declare buffer(256) byte;
declare	memSize address;
declare	actual address;
declare	pn(12) byte;
declare	buffer$ptr address, char based buffer$ptr byte;
declare	(i, j, k) address;	/* k no longer used !! */
declare	(system, copyAll, copy) boolean;
declare	(targetDisk, srcDisk) byte;
declare unused address;
declare	(aftIn, aftOut, dirAft) address;
declare	status address;
declare	attributeList(*) byte data(1, 2, 4);	/* no longer used */
declare crlf(2) byte data(CR, LF);
declare	inputString(16) byte,	/* no longer used */
	outputString(16) byte;	/* no longer used */

declare	t0File(*) byte initial(':FX:ISIS.T0 '),
	cliFile(*) byte initial(':FX:ISIS.CLI '),
	binFile(*) byte initial(':FX:ISIS.BIN '),
	ov0File(*) byte initial(':FX:ISIS.OV0 '),
	mapFile(*) byte initial(':FX:ISIS.MAP '),
	labFile(*) byte initial(':FX:ISIS.LAB '),
	dirFile(*) byte initial(':FX:ISIS.DIR '),
	badFile(*) byte initial(':FX:ISIS.BAD '),
	t0File2(*) byte initial(':FX:ISIS.T0 '),
	labFile2(*) byte initial(':FX:ISIS.LAB '),
	dirFile2(*) byte initial(':FX:ISIS.DIR ');

declare	diskType byte public;

declare	fmtTable(5) structure(t0Interleave byte, t1Interleave byte, interleave  byte,
		   	      tracks address, labBlkSize address)
		initial(0,  0, 0,   0,    0,	/* controller not present */
			1,  4, 5,  76,  80h,	/* 2 board DD */
			1, 12, 6,  76,  80h,	/* 2 board SD */
			1, 12, 6,  76,  80h,	/* integrated SD */
			7, 16, 9, 199, 0FBh	/* 2 board HD */
		);



declare labBlk structure(name(9) byte,
			 version(2) byte,
			 leftOver(38) byte,
			 crlf(2) byte,
		         fmtTable(200) byte) at (.buffer);

start:
	call Read(1, .buffer, 256, .actual, .status);
	buffer(actual) = CR;
	call forceUpper(.buffer);
	bufferPtr = Deblank(.buffer);
	call Spath(bufferPtr, .pn, .status);
	if pn(11) = 5 or 6 then
		status = 0ECh;
	if pn(11) = 8 then
		status = 3Dh;

	call FileError(status, bufferPtr, TRUE);
	targetDisk = TestRange(pn(0), bufferPtr);
	diskType = pn(11);
	t0File(2), cliFile(2), binFile(2), ov0File(2),
	mapFile(2), labFile(2), dirFile(2), badFile(2) = targetDisk + '0';
	srcDisk = 0;
	system = 0;
	copyAll = 0;

	bufferPtr = Deblank(Delimit(bufferPtr));

	do while char <> CR;
		if char = 'S' then
			system = TRUE;
		else if char = 'A' then
			copyAll = TRUE;
		else if Seq(bufferPtr, .('FROM '), 5) then
		do;
			bufferPtr = Deblank(bufferPtr + 5);
			srcDisk = char - '0';
			if srcDisk > 9 then
				call FileError(0c9h, bufferPtr, TRUE);
		end;
		else if char <> '$' then
			call FileError(0c9h, bufferPtr, TRUE);
		bufferPtr = Deblank(bufferPtr + 1);
	end;

	if srcDisk = targetDisk then
	do;
		call ReportError(0EAh);
		call Exit;
	end;
	else
		labFile2(2), dirFile2(2), t0File2(2) = srcDisk + '0';

	if targetDisk = 0 and diskType = 4 and not system and not copyAll then
	do;
		call Write(0, .('NON-SYSTEM HARD DISK DRIVE 0 NOT ALLOWED', CR, LF), 42, .status);
		call Exit;
	end;

	call Open(.aftIn, .labFile2, 1, 0, .status);
	call FileError(status, .labFile2, TRUE);
	call Read(aftIn, .buffer, 251, .actual, .status);
	call FileError(status, .labFile2, TRUE);
	call Close(aftIn, .status);
	call FileError(status, .labFile2, TRUE);

	labBlk.fmtTable(0) = fmtTable(diskType).t0Interleave + '0';
	labBlk.fmtTable(1) = fmtTable(diskType).t1Interleave + '0';
	do i = 2 to fmtTable(diskType).tracks;
		labBlk.fmtTable(i) = fmtTable(diskType).interleave + '0';
	end;

	call FormatTrack(targetDisk, 0, 0, labBlk.fmtTable(0) - '0');
	call FormatTrack(targetDisk, 1, 1, labBlk.fmtTable(1) - '0');
	call FormatTrack(targetDisk, 2, fmtTable(diskType).tracks, labBlk.fmtTable(2) - '0');

	mapBase = .MEMORY;
	unused = SetupMap(targetDisk) + 29;
	call WriteDirectory(targetDisk);
	call Open(.aftOut, .labFile, 3, 0, .status);
	call FileError(status, .labFile, TRUE);
	call moveAscii(.labBlk, .pn(1), 9);

	call Write(aftOut, .buffer, fmtTable(diskType).labBlkSize, .status);
	call Close(aftout, .status);
	call FileError(status, .labFile, TRUE);

	if system or copyAll then
	do;
		if copyAll then
			call Write(0, .('COPYING ALL FILES', CR, LF), 19, .status);
		else
			call Write(0, .('COPYING SYSTEM FILES', CR, LF), 22, .status);

		memSize = (Memck - .Memory) and 0ff80h;
		call Open(.dirAFT, .dirFile2, 1, 0, .status);
		call FileError(status, .dirFile2, TRUE);
		direct.empty = 0;
		do while direct.empty <> 7fh;
			call Read(dirAft, .direct, size(direct), .actual, .status);
			call FileError(status, .dirFile2, TRUE);
			if actual < size(direct) then
				direct.empty = 7fh;
			else if not direct.empty then
			do;
				if (direct.attrib and 80h) <> 0 then
				do;
					copy = 0;
					if Seq(.direct.file, .('ISIS',0,0,'BIN'), 9) or
					   Seq(.direct.file, .('ISIS',0,0,'CLI'), 9) or
					   Seq(.direct.file, .('ISIS',0,0,'T0'), 8) or
					   Seq(.direct.file, .('ISIS',0,0,'OV0'), 9) then
						copy = TRUE;
				end;
				else
					copy = (direct.attrib and 2) <> 0 or copyAll;

				if copy then
				do;
					direct.empty = srcDisk;
					call Ypath(.direct, .inputString);
					direct.empty = targetDisk;
					call Ypath(.direct, .outputString);
					call Open(.aftOut, .outputString, 3, 0, .status);
					call FileError(status, .outputString, TRUE);
					call Open(.aftIn, .inputString, 1, 0, .status);
					call FileError(status, .inputString, TRUE);
					actual = memSize;
					do while actual = memSize;
						call Read(aftIn, .MEMORY, memSize, .actual, .status);
						call FileError(status, .inputString, TRUE);
						call Write(aftOut, .MEMORY, actual, .status);
					end;

					call Close(aftOut, .status);
					call FileError(status, .outputString, TRUE);
					call Close(aftIn, .status);
					call FileError(status, .inputString, TRUE);
					do i = 0 to 2;
						if (attributeList(i) and direct.attrib) <> 0 then
						do;
							call Attrib(.outputString, i, TRUE, .status);
							call FileError(status, .outputString, TRUE);
						end;
					end;
					/* find end of file name skipping :Fx: */
					k = Delimit(.inputString + 4) - .inputString - 4;
					call Write(0, .inputString + 4, k, .status);
					call Write(0, .crlf, 2, .status);
				end;
			end;
		end;
		call Close(dirAft, .status);
	end;
	else
	do;
		call Open(.aftOut, .t0File, 3, 0, .status);
		call Write(aftOut, .codeBlock, 58, .status);
		call Close(aftOut, .status);
		call Delete(.binFile, .status);
		call Write(0, .('NON-SYSTEM DISK', CR, LF), 17, .status);
	end;

	call Attrib(.dirFile, 3, 0ffh, .status);
	call Attrib(.t0File, 3, 0ffh, .status);
	call Attrib(.labFile, 3, 0ffh, .status);
	call Attrib(.mapFile, 3, 0ffh, .status);
	if diskType = 4 then
		call Attrib(.badFile, 3, 0ffh, .status);

	if system or copyAll then
	do;
		call Attrib(.binFile, 3, 0ffh, .status);
		call Attrib(.cliFile, 3, 0ffh, .status);
		call Attrib(.ov0File, 3, 0ffh, .status);
	end;
	call Exit;
end;

fixmap.plm
fixmap: do;
Seek: procedure(conn, mode, block$p, byte$p, status$p) external; /* force load */
	declare (conn, mode, block$p, byte$p, status$p) address;
end;
$include(fixmap.ipx)

declare copyright(*) byte data('(C) 1975,1976,1977,1978,1979,1980,1981,1982 INTEL CORP'),
	version(*) byte data(4, 0, 'program_version_number=', 1, 'V4.3', 0);

declare	actual address;
declare aTrkSec(*) byte initial(' ('),
	aTrack(*) byte initial('***,'),
	aSector(*) byte initial('***) ');
declare	aftn address;
declare badFile(*) byte initial(':F*:ISIS.BAD ');
declare b4E51 byte;
declare badFileBuffer(3712) byte, mapFileBuffer(3712) byte;
declare w6B52 address;
declare logicalTrackSector address, (logicalSector, logicalTrack) byte at(.logicalTrackSector);
declare aBadSector(*) byte initial(' ***** BAD SECTORS', CR, LF);
declare buffer(128) byte;
declare	bufferPtr address, char based bufferPtr byte;
declare padding address;
declare changed boolean initial(FALSE);
declare w6BEF address;
declare driveNumber byte;
declare diskType byte public initial(4);
declare b6BF3 byte, w6BF4 address, b6BF6 byte;
declare a6BF7(1) byte initial(' '),
	a6BF8(*) byte initial('***, '),
	a6BFD(*) byte initial('***', CR, LF);
declare b6C02 byte;
declare mapFile(*) byte initial(':F*:ISIS.MAP ');
declare (w6C10, w6C12, status) address;
declare (b6C16, b6C17) byte;

declare	pn(12) byte at(.MEMORY);

	WriteChanges: procedure;
		if not changed then
			call Write(0, .(' NO CHANGES',CR,LF), 13, .status);
		else
		do;
			call Attrib(.badFile, 3, 0, .status);
			call Attrib(.badFile, 2, 0, .status);
			call Open(.aftn, .badFile, 2, 0, .status);
			call Write(aftn, .badFileBuffer, 3712, .status);
			call FileError(status, .badFile, TRUE);
			call Close(aftn, .status);
			w6B52 = w6BEF + 29;
			call Attrib(.badFile, 3, 1, .status);
			call Attrib(.mapFile, 3, 0, .status);
			call Attrib(.mapFile, 2, 0, .status);
			call Open(.aftn, .mapFile, 3, 0, .status);
			call Write(aftn, .mapFileBuffer, 3712, .status);
			call FileError(status, .mapFile, TRUE);
			call Close(aftn, .status);
			call Attrib(.mapFile, 3, 1, .status);
			changed = FALSE;
			call Write(0, .(' CHANGES RECORDED', CR, LF), 19, .status);
		end;
	end;



	sub3D6C: procedure;
		bufferPtr = .badFileBuffer;
		do logicalTrack = 0 to 199;
			logicalSector = 1;
			do b6C02 = 1 to 18;
				if (b6C16 := char) = 0 then
					logicalSector = logicalSector + 8;
				else
					do b4E51 =  1 to 8;
						if (b6C16 := rol(b6C16, 1)) then
						do;
							call NumOut(logicalTrack, 10, ' ', .a6BF8, 3);
							call NumOut(logicalSector, 10, ' ', .a6BFD, 3);
							call Write(aftn, .a6BF7, 11, .status);
						end;
						logicalSector = logicalSector + 1;
					end;
				bufferPtr = bufferPtr + 1;
			end;

		end;
		if aftn <> 0 then
			call Write(0, .(' LIST WRITTEN', CR, LF), 15, .status);
	end;


	invalidSyntax: procedure;
		call FileError(0CBh, bufferPtr, FALSE);
	end;

	sub3E49: procedure boolean;
		if char - '0' > 9 then
		do;
			call InvalidSyntax;
			return 0;
		end;
		w6C12 = bufferPtr;
		if (logicalTrack := ScanInteger(.w6C12)) > 0C7h then
		do;
			call Write(0, .(' TRACK OUT OF RANGE',CR, LF), 21, .status);
			return FALSE;
		end;
		bufferPtr = Deblank(w6C12);
		if char - '0' > 9 then
		do;
			call InvalidSyntax;
			return FALSE;
		end;

		if (logicalSector := ScanInteger(.w6C12)) -1 > 8Fh then
		do;
			call Write(0, .(' SECTOR OUT OF RANGE',CR,LF), 22, .status);
			return FALSE;
		end;

		bufferPtr = Deblank(w6C12);
		if char = CR then
		do;
			b6C17 = 0;
			return TRUE;
		end;
		else if char <> 'T' then
		do;
			call InvalidSyntax;
			return FALSE;
		end;

		bufferPtr = Deblank(bufferPtr + 1);
		if char <> CR then
		do;
			call InvalidSyntax;
			return FALSE;
		end;
		b6C17 = TRUE;
		return TRUE;
	end;




	writeTrackSector: procedure;
		call NumOut(logicalTrack, 10, 0, .aTrack, 3);
		call NumOut(logicalSector, 10, 0, .aSector, 3);
		call Write(0, .aTrkSec, 11, .status);
	end;


	GetBitStatus: procedure(bufferPtr) byte;
		declare bufferPtr address, buffer based bufferPtr (1) byte;

		return rol(buffer(18 * logicalTrack + shr(logicalSector - 1, 3)), logicalSector mod 8);
	end;


	MarkSector: procedure;
		if (logicalTrack = 0 and (logicalSector <= 1Bh or logicalSector >= 73h))
		    or (logicalTrack = 1 and (3Fh >= logicalSector or (logicalSector >= 49h and 87h >= logicalSector)))
		    or (logicalTrack = 2 and 1eh >= logicalSector) then
		do;
			call writeTrackSector;
			call Write(0, .('REQUIRED BY ISIS-II',CR,LF), 21, .status);
			return;
		end;
		if GetBitStatus(.mapFileBuffer) then
		do;
			call writeTrackSector;
			if GetBitStatus(.badFileBuffer) then
				call Write(0, .('ALREADY MARKED',CR,LF), 16, .status);
			else
				call Write(0, .('IN USE',CR,LF), 8, .status);
			return;
		end;

		mapBase = .mapFileBuffer;
		call SetBlock(logicalTrackSector);
		if not GetBitStatus(.badFileBuffer) then
		do;
			mapBase = .badFileBuffer;
			call SetBlock(logicalTrackSector);
			w6BEF = w6BEF + 1;
		end;

		changed = TRUE;
		if not b6C17 then
			call Write(0, .(' SECTOR MARKED',CR,LF), 16, .status);
	end;


	MarkTrack: procedure;
		b6BF3 = logicalSector  - ((logicalSector - 1) mod 36);
		b6BF6 =  b6BF3 + 35;
		do logicalSector = b6BF3 to b6BF6;
			call MarkSector;
		end;
		call Write(0, .(' TRACK PROCESSED',CR,LF), 18, .status);
	end;


	UnmarkSector: procedure;
		if not GetBitStatus(.badFileBuffer) then
		do;
			call WriteTrackSector;
			if GetBitStatus(.mapFileBuffer) then
				call Write(0, .('NOT A BAD SECTOR', CR, LF), 18, .status);
			else
				call Write(0, .('ALREADY FREE',CR,LF), 14, .status);
		end;
		else
		do;

		w6BF4 = 18 * logicalTrack + shr(logicalSector - 1, 3);
		b4E51 = logicalSector mod 8;
		mapFileBuffer(w6BF4) = ror(rol(mapFileBuffer(w6BF4), b4E51) and 0FEh, b4E51);	/* clear bit */
		badFileBuffer(w6BF4) = ror(rol(badFileBuffer(w6BF4), b4E51) and 0FEh, b4E51);
		w6BEF = w6BEF - 1;
		changed = TRUE;
		if not b6C17 then
			call Write(0, .(' SECTOR FREED',CR,LF), 15, .status);
		end;
	end;


	UnmarkTrack: procedure;
		b6BF3 =	 logicalSector - ((logicalSector - 1) mod 36);
		b6BF6 = b6BF3 + 35;
		do logicalSector = b6BF3 to b6BF6;
			call UnmarkSector;
		end;
		call Write(0, .(' TRACK PROCESSED', CR, LF), 18, .status);
	end;



	sub41D7: procedure(str, len) byte;
		declare str address, len byte;
		declare strCh based str byte;

		do while char = strCh and len <> 0;
			bufferPtr = bufferPtr + 1;
			str = str + 1;
			len = len - 1;
		end;

		if 'A' <= char and char <= 'Z' or bufferPtr = w6c10 then
		do;
			bufferPtr = w6C10;
			return 0;
		end;
		else
		do;
			bufferPtr = Deblank(bufferPtr);
			return TRUE;
		end;
	end;

entry:
	call Write(0, .('ISIS-II MAP FIXER V1.0', CR, LF), 24, .status);
	call SPath(.('A '), .pn, .status);
	if pn(11) <> 4 then
	do;
		call Write(0, .(' USE ON HARD DISK SYSTEM ONLY', CR, LF), 31, .status);
		call Exit;
	end;

	call Read(1, .buffer, 128, .actual, .status);
	buffer(actual) = CR;
	call ForceUpper(.buffer);
	bufferPtr = Deblank(.buffer);
	driveNumber = char - '0';
	if driveNumber > 9 then
		call FileError(0CBh, bufferPtr, TRUE);
	else if driveNumber > 3 then
	do;
		call Write(0, .(' DRIVE NUMBER OUT OF RANGE', CR, LF), 28, .status);
		call Exit;
	end;
	mapFile(2), badFile(2) = char;
	bufferPtr = Deblank(bufferPtr + 1);
	if char <> CR then
		call FileError(0CBh, bufferPtr, TRUE);

	call Open(.aftn, .mapFile, 1, 0, .status);
	call FileError(status, .mapFile, TRUE);
	call Read(aftn, .mapFileBuffer, 3712, .actual, .status);
	call Close(aftn, .status);

	call Open(.aftn, .badFile, 1, 0, .status);
	call FileError(status, .badFile, TRUE);
	call Read(aftn, .badFileBuffer, 3712, .actual, .status);
	call Close(aftn, .status);

	do while TRUE;
		call Write(0, .('*'), 1, .status);
		call Read(1, .buffer, 128, .actual, .status);
		buffer(actual) = CR;
		call ForceUpper(.buffer);
		bufferPtr, w6C10 = Deblank(.buffer);
		if sub41D7(.('MARK'), 4) then
		do;
			if sub3E49 then
				if b6C17 then
					call MarkTrack;
				else
					call MarkSector;
		end;
		else if sub41D7(.('FREE'), 4) then
		do;
			if sub3E49 then
				if b6C17 then
					call UnmarkTrack;
				else
					call UnmarkSector;
		end;
		else if sub41D7(.('EXIT'), 4) then
		do;
			if char <> CR then
				call InvalidSyntax;
			else
			do;
				call WriteChanges;
				call Exit;
			end;
		end;
		else if sub41D7(.('QUIT'), 4) then
		do;
			if char <> CR then
				call InvalidSyntax;
			else
				call Exit;
		end;
		else if sub41D7(.('RECORD'), 6) then
		do;
			if char <> CR then
				call InvalidSyntax;
			else
				call WriteChanges;
		end;
		else if sub41D7(.('COUNT'), 5) then
		do;
			if char <> CR then
				call InvalidSyntax;
			else if w6BEF = 0 then
				call Write(0, .(' NO BAD SECTORS',CR,LF), 17, .status);
			else
			do;
				call NumOut(w6BEF, 10, 0, .aBadSector + 1, 5);
				if w6BEF = 1 then
					aBadSector(17) = 0;
				else
					aBadSector(17) = 'S';
				call Write(0, .aBadSector, 20, .status);
			end;
		end;
		else if sub41D7(.('LIST'), 4) then
		do;
			if char = CR then
				bufferPtr = .(':CO: ',CR);
			call Spath(bufferPtr, .pn, .status);
			if status <> 0 then
				call FileError(status, bufferPtr, FALSE);
			else if pn(0) = driveNumber then
				call Write(0, .(' CANNOT LIST TO TARGET DRIVE',CR,LF), 30, .status);
			else if pn(10) = 0 then
				call FileError(16h, bufferPtr, FALSE);
			else
			do;
				bufferPtr = Deblank(Delimit(w6C10 := bufferPtr));
				if char <> CR then
					call InvalidSyntax;
				else if w6BEF = 0 then
					call Write(0, .(' NO BAD SECTORS',CR,LF), 17, .status);
				else
				do;
					call Open(.aftn, w6C10, 2, 0, .status);
					if status <> 0 then
						call FileError(status, w6C10, FALSE);
					else
						call sub3D6C;
					call Close(aftn, .status);
				end;
			end;
		end;
		else if char <> CR then
			call InvalidSyntax;
	end;
end;	/* end of entry */

alloc.plm
alloc: do;
declare maskArray(8) byte public data(80h, 40h, 20h, 10h, 8, 4, 2, 1);
declare mapBase address public;
end;
direct.plm
direct: do;
$include(direct.ipx)
declare direct DIRECT$T public;
declare directINO address public;
end;
dblank.plm
deblank: do;

Deblank: procedure(ptr) address public;
	declare ptr address;
	declare c based ptr byte;

	do while (c = ' ');
		ptr = ptr + 1;
	end;
	return ptr;
end;
end;
dlimit.plm
delimit: do;

Delimit: procedure(ptr) address public;
	declare ptr address;
	declare c based ptr byte;

	do while (c = ':' or c = '.' or ('0' <= c and c <= '9') or ('A' <= c and c <= 'Z'));
		ptr = ptr + 1;
	end;
	return ptr;
end;
end;
ferror.plm
fileerror: do;
$include(ferror.ipx)

FileError: procedure(status, ptr, callExit) public;
	declare (status, ptr) address, callExit byte;
	declare actual address;

	if status <> 0 then
	do;
		ptr = deblank(ptr);
		call write(0, .(' '), 1, .actual);
		call write(0, ptr, wdelimit(ptr) - ptr, .actual);
		call write(0, .(','), 1, .actual);
		call reporterror(status);
		if callExit then
			call exit;
	end;
end;
end;
fmttrk.plm
formatTrack: do;
$include(fmttrk.ipx)

FormatTrack: procedure(disk,sTrack,eTrack,interleave) public;
	declare (disk,interleave) byte, (sTrack, eTrack) address;
	declare curTrack address, (sectors, vTracks) byte;
	declare (i,j,interTrackSkew) byte, trackBuf(104) byte,
	dcb DCB$T;

	if diskType = 4 then	/* HD */
	do;
		sectors = 36;
		interTrackSkew = 17;
	end;
	else if diskType = 1 then	/* DD */
	do;
		sectors = 52;
		interTrackSkew = 7;
	end;
	else
	do;
		sectors = 26;
		interTrackSkew = 4;
	end;

	dcb.iocw = 0c0h;
	vTracks = sectors * 2 - 1;
	do i = 1 to vTracks by 2;
		trackBuf(i) = 0c7h;
	end;

	j = 0;

	if diskType = 4 then
	do;
		sTrack = sTrack * 4;
		eTrack = eTrack * 4 + 3;
	end;

	do curTrack = sTrack to eTrack;
		dcb.ioins = 2;
		do i = 0 to vTracks by 2;
			trackBuf(i) = 0;
		end;
		do i = 1 to sectors;
			j = (j + interleave) mod sectors;
			do while trackBuf(j * 2) <> 0;
				j = (j + 1) mod sectors;
			end;
			trackBuf(j + j) = i;
		end;
		if diskType <> 4 then
			dcb.tadr = curTrack;
		else
		do;
			dcb.tadr = curTrack / 4;
			dcb.sadr = (curTrack mod 4) * 36 + 1;
		end;
		dcb.buf = .trackBuf;
		call Diskio(disk, .dcb);
		j = j + interTrackSkew;
	end;
end;
end;
fupper.plm
ForceUpper: do;
$include(fupper.ipx)

ForceUpper: procedure(bufferPtr) public;
	declare bufferPtr address, ch based bufferPtr byte;

	do while ch <> CR;
		ch = Uppercase(ch);
		bufferPtr = bufferPtr + 1;
	end;
end;
end;
getdsk.plm
GetDisk: do;
$include(getdsk.ipx)

declare source(3) structure(name(6) byte) data('SYSTEM', 'SOURCE', 'OUTPUT');

GetDisk: procedure(n) public;
	declare n byte;
	declare buf(128) byte, status address, junk address, actual address;

	call Write(0, .('LOAD '), 5, .status);
	call Write(0, .source(n), 6, .status);
	call Write(0, .(' DISK, THEN TYPE (CR)'), 21, .status);
	call Read(1, .buf, 128, .actual, .status);
end;
end;
mascii.plm
MoveAscii: do;

MoveAscii: procedure(dst, src, cnt) public;
	declare (dst, src) address, cnt byte, i byte;
	declare dch based dst (1) byte, sch based src (1) byte;

	do i = 0 to cnt - 1;
		dch(i) = sch(i);
	end;
end;
end;
serror.plm
SFileError: do;
$include(serror.ipx)

declare singleDrive boolean external;
SFileError: procedure(status, name$p) public;
	declare (status, name$p) address;
	declare lStatus address;

	if status <> 0 then
	do;
		if singleDrive then
			call GetDisk(0);
		name$p = Deblank(name$p);
		call Write(0, .(' '), 1, .lStatus);
		call Write(0, name$p, WDelimit(name$p) - name$p, .lStatus);
		call Write(0, .(','), 1, .lStatus);
		call ReportError(status);
		call Exit;
	end;
end;
end;
seq.plm
Seq: do;
$include(seq.ipx)

Seq: procedure(s1, s2, len) boolean public;
	declare (s1,s2) address, len byte;
	declare chrs1 based s1(1) byte;
	declare chrs2 based s2(1) byte;
	declare i byte;
	len = len - 1;
	do i = 0 to len;
		if chrs1(i) <> chrs2(i) then
			return FALSE;
	end;
	return TRUE;
end;
end;

setmap.plm
SetupMap: do;
$include(setmap.ipx)

declare aFatal(*) byte initial(' FATAL'),
	aBad(*) byte initial(' BAD SPOT AT LOGICAL ADDRESS ( '),
	aTrack(*) byte initial('***, '),
	aSector(*) byte initial('*** ), STATUS = '),
	aStatus(*) byte initial('****', CR, LF);

declare trap0B structure(jmp byte, target address) at (0bh),
	trap0E address at (0eh);

declare trap0BCodeLocation address data(.SetupMap + 0DCh);
declare mapBase address external;
declare bitmap based mapBase (1) byte;

SetupMap: procedure(disk) address public;
	declare disk byte;
	declare logicalTrackSector address,
		(logicalSector, logicalTrack) byte at (.logicalTrackSector),
		(w5851, savedSP) address,
		savedTrap0B structure(jmp byte, target address),
		(w5858, w585A, w585C, w585E) address,
		b5860 byte, (w5861, w5863, status) address;
	declare struct based w585E structure(b0 byte, w1 address, w3 address);

	ChkFixedSectors: procedure;
		if (logicalTrack = 0 and (logicalSector < 1Ch or logicalSector = 58h or logicalSector > 72h))
		  or (logicalTrack = 1 and (logicalSector < 40h or (48h < logicalSector and logicalSector < 88h)))
		  or (logicalTrack = 2 and logicalSector < 20h) then
		do;
			call NumOut(logicalTrack, 10, 0, .aTrack, 3);
			call NumOut(logicalSector, 10, 0, .aSector, 3);
			call NumOut(trap0E, 16, 0, .aStatus, 4);
			call Write(0, .aFatal, 64, .status);
			call Exit;
		end;
	end;


	AddBadSector: procedure;
		declare (w5867, w5869) address;
		call ChkFixedSectors;
		call SetBlock(logicalTrackSector);
		w585E, w5867 = w585A;
		w585E = struct.w3;

		do while struct.b0 < logicalSector;
			w5867 = w585E;
			w585E = struct.w3;
		end;
		if struct.b0 = logicalSector then
			return;

		w5869 = w585E;
		w585E = w5867;
		struct.w3 = w585C;
		w585E = w585C;
		struct.b0 = logicalSector;
		struct.w1 = trap0E;
		struct.w3 = w5869;
		w585C = w585C + 5;
	end;


	if diskType = 4 then
		w5863 = 0E7FH;
	else if diskType = 1 then
		w5863 = 1ffh;
	else
		w5863 = 0ffh;

	do w5861 = 0 to w5863;
		bitmap(w5861) = 0;
	end;

	if diskType <> 4 then
		return 0;
	w5858 = 0;
	w585A = (w5851 := mapBase + 0E80h) + 128;
	savedSP = STACKPTR;
	savedTrap0B.jmp = trap0B.jmp;
	trap0B.jmp = 0c3h;
	savedTrap0B.target = trap0B.target;
	trap0B.target = trap0BCodeLocation;
	logicalTrack = 0;

L43F1:
	w585E = w585A;
	struct.w3 = w585E + size(struct);
	w585E = w585A + size(struct);
	struct.b0 = 91h;
	w585C = w585E + size(struct);
	logicalSector = 1;

L441C:
	call Absio(4, disk, logicalTrackSector, w5851);
	goto L44A8;

newTrap0B:
	STACKPTR = savedSP;
	trap0B.jmp = savedTrap0B.jmp;
	trap0B.target = savedTrap0B.target;
	if trap0E <> 1 and trap0E <> 10 then
		call AddBadSector;
	else
	do;
		logicalSector = (logicalSector - 1) - ((logicalSector - 1) mod 36);
		do b5860 = 1 to 36;
			logicalSector = logicalSector + 1;
			call AddBadSector;
		end;
	end;

	trap0B.jmp = 0c3h;
	trap0B.target = trap0BCodeLocation;

L44A8:
	if (logicalSector := logicalSector + 1) < 91h then
		goto L441C;

	w585E = w585A;
	w585E = struct.w3;

	do while struct.b0 < 91h;
		call NumOut(logicalTrack, 10, 0, .aTrack, 3);
		call NumOut(struct.b0, 10, 0, .aSector, 3);
		call NumOut(struct.w1, 16, 0, .aStatus, 4);
		call Write(0, .aBad, 58, .status);
		if logicalTrack > 1 then
			w5858 = w5858 + 1;
		w585E = struct.w3;
	end;
	if (logicalTrack := logicalTrack + 1) < 0c8h then
		goto L43F1;

	trap0B.jmp = savedTrap0B.jmp;
	trap0B.target = savedTrap0B.target;
	return w5858;
end;
end;

trange.plm
TestRange: do;
$include(trange.ipx)
TestRange: procedure(device, buffer$p) byte public;
	declare device byte, buffer$p address;

	if device >= 25 then	/* diskdrive 6-9 */
		device = device - 19;	/* bring disks together */
	else if device > 5 then		/* shift others above disks */
		device = device + 4;

	if device <=  9 or buffer$p = 1 then
		return device;
	if buffer$p <> 0 then
		call FileError(0EBh, buffer$p, TRUE);
	else
	do;
		call ReportError(0EBh);
		call exit;
	end;
end;
end;

wd.plm
WriteDirectory: do;
$include(wd.ipx)
declare mapBase address external;
declare bitmap based mapBase (1) byte;

declare file(6) structure(name(9) byte) data('ISIS',0,0,'DIR',
					     'ISIS',0,0,'MAP',
					     'ISIS',0,0,'T0',0,
					     'ISIS',0,0,'BIN',
					     'ISIS',0,0,'LAB',
					     'ISIS',0,0,'BAD');

WriteDirectory: procedure(disk) public;
	declare	disk byte, binIdx byte, i byte, jj address, dirBuf(64) address,
		direct(8) structure(empty byte, file(9) byte, attrib byte,
				    eof$count byte, blk address, hdrBlk address) at(.dirBuf),
		countBitMapSectors byte, binHdrBlk address, countDirSectors byte;

	SetLinks: procedure(start, count, firstBlock);
		declare (start, count, firstBlock, ii) address;

		do ii = 0 to count - 1;
			dirBuf(start + ii) = firstBlock + ii;
			call setBlock(firstBlock + ii);
		end;
	end;

	FlushBlock: procedure(adr);
		declare adr address;

		call Absio(6, disk, adr, .dirBuf);
		call SetBlock(adr);
		call ClearBuffer(.dirBuf);
	end;

	countDirSectors =  25;
	if diskType = 1 then
	do;
		countBitMapSectors = 4;
		binHdrBlk = 206h;
	end;
	else if diskType = 4 then
	do;
		countBitMapSectors = 29;
		binHdrBlk = 21fh;
		countDirSectors = 62;
	end;
	else
	do;
		countBitMapSectors = 2;
		binHdrBlk = 204h;
	end;

	jj = .bitmap - 128;
	if diskType = 4 then
		do i = 0 to countBitMapSectors - 1;
			call Absio(6, disk, i + 74h, (jj := jj + 128));
		end;
	/* set linkage for isis.t0 */
	call ClearBuffer(.dirBuf);
	call SetLinks(2, 23, 1);
	call FlushBlock(18h);		
	/* set linkage for isis.lab */
	if diskType = 4 then		/* hard disk */
	do;
		dirBuf(1) = 58h;	/* next linkage is sector 58h */
		call SetLinks(2, 3Eh, 1Ah);	/* first part of isis.lab */ 
	end;
	else if diskType = 1 then
	do;
		call SetLinks(2, 27, 1Ah);	/* allocate 53 blocks in 2 groups */
		call SetLinks(1Dh, 26, 11Bh);
	end;
	else
		call SetLinks(2, 1, 1Ah);	/* allocate 1 block */

	call FlushBlock(19h);		/* write label linkage */
	if diskType = 4 then
	do;
		dirBuf(0) = 19h;	/* link to previous */
		call SetLinks(2, 26, 59h);
		call SetLinks(1ch, 9, 140h);
		call SetLinks(25h, 9, 188h);
		call FlushBlock(58h);	/* write label linkage */
	end;
	/* set linkage for isis.bad for hd only */
	if diskType = 4 then
	do;
		call SetLinks(2, countBitMapSectors, 74h);
		call FlushBlock(73h);
	end;

	/* set linkage for isis.dir */
	call SetLinks(2, countDirSectors, 102h);
	if diskType = 4 then
		dirBuf(1) = 149h;	/* link to next */
	call FlushBlock(101h);
	if diskType = 4 then
	do;
		dirBuf(0) = 101h;	/* link to previous */
		call SetLinks(2, countDirSectors, 14Ah);
		call FlushBlock(149h);
	end;

	/* set linkage for isis.map */
	call SetLinks(2, countBitMapSectors, 202h);
	call FlushBlock(201h);
	call FlushBlock(binHdrBlk);

	/* isis.dir */
	call MoveAscii(.direct(0).file, .file(0), 9);
	if diskType = 4 then
		direct(0).blk = 124;	/* larger size */
	else
		direct(0).blk = 25;

	direct(0).hdrBlk = 101h;	/* linkage at t1 s1 */
	direct(0).attrib = 1;
	direct(0).eof$count = 128;

	/* isis.map */
	call MoveAscii(.direct(1).file, .file(1), 9);
	direct(1).blk = countBitMapSectors;
	direct(1).hdrBlk = 201h;	/* linkage at t2 s1 */
	direct(1).attrib = 1;
	direct(1).eof$count = 128;

	/* isis.t0 */
	call MoveAscii(.direct(2).file, .file(2), 9);
	direct(2).blk = 17h;
	direct(2).hdrBlk = 18h;		/* linkage at t0 s24 */
	direct(2).attrib = 1;
	direct(2).eof$count = 128;

	/* isis.lab */
	call MoveAscii(.direct(3).file, .file(4), 9);
	if diskType = 1 then
		direct(3).blk = 35h;
	else if diskType = 4 then
		direct(3).blk = 6Ah;
	else
		direct(3).blk = 1;
	direct(3).hdrBlk = 19h;		/* linkage at t0 s25 */
	direct(3).attrib = 1;
	direct(3).eof$count = 128;

	/* isis.bad */
	if diskType = 4 then
	do;
		call MoveAscii(.direct(4).file, .file(5), 9);
		direct(4).blk = countBitMapSectors;
		direct(4).hdrBlk = 73h;
		direct(4).attrib = 1;
		direct(4).eof$count = 128;
		binIdx = 5;
	end;
	else
		binIdx = 4;

	/* isis.bin */
	call MoveAscii(.direct(binIdx).file, .file(3), 9);
	direct(binIdx).hdrBlk = binHdrBlk;
	direct(binIdx).attrib = 3;
	direct(binIdx).eof$count = 128;

	/* flag as no further entries */
	do i = binIdx + 1 to 7;
		direct(i).empty = 7fh;
	end;

	call FlushBlock(102h);
	do i = 0 to 7;
		direct(i).empty = 7fh;
	end;

	do i = 1 to countDirSectors - 1;
		call Absio(6, disk, 102h + i, .dirBuf);
	end;

	if diskType = 4 then
		do i = 0 to countDirSectors - 1;
			call Absio(6, disk, 14Ah + i, .dirBuf);
		end;

	jj = .bitmap - 128;
	do i = 0 to countBitMapSectors - 1;
		call Absio(6, disk, 202h + i, (jj := jj + 128));
	end;
end;
end;

ypath.plm
ypath: do;
declare devTab(*) byte data('F0F1F2F3F4F5TITOVIVOI1O1TRHRR1R2TPHPP1P2LPL1BBCICOF6F7F8F9');


Ypath: procedure(int, ext) public;
	declare (int, ext) address;
	declare i byte;
	declare intName based int (1) byte,
		extName based ext (1) byte;

	extName(0) = ':';
	i = intName(0);
	/* map internal device to formal device index */
	if i > 9 then
		i = i - 4;
	else if i > 5 then
		i = i + 19;

	extName(1) = devTab(i + i);
	extName(2) = devTab(i + i + 1);
	extName(3) = ':';
	ext = ext + 4;

	do i = 0 to 5;
		if (extName(0) := intName(i + 1)) <> 0 then
			ext = ext + 1;
	end;
	if intName(7) <> 0 then
	do;
		extName(0) = '.';
		ext = ext + 1;
	end;
	do i = 0 to 2;
		if (extName(0) := intName(i + 7)) <> 0 then
			ext = ext + 1;
	end;
	extName(0) = ' ';
end;
end;
absio.plm
Absio: do;
$include(absio.ipx)
Absio: procedure(cmd, disk, block, buffer) public;
	declare (cmd, disk) byte, (block, buffer) address;
	declare dcb DCB$T;

	dcb.iocw = 80H;
	dcb.ioins = cmd;
	dcb.nsec = 1;
	dcb.tadr = high(block);
	dcb.sadr = low(block);
	dcb.buf = buffer;
	call Diskio(disk, .dcb);
end;
end;
clbuf.plm
ClearBuffer: do;
ClearBuffer: procedure(buf$ptr) public;
	declare buf$ptr address, i byte;
	declare buf based buf$ptr (1) byte;


	do i = 0 to 127;
		buf(i) = 0;
	end;
end;
end;

diskio.plm
Diskio: do;
$include(diskio.ipx)
Diskio: procedure(disk, dcb$p) public;
	declare disk address, dcb$p address;
	declare (param1, param2) address;

	param1 = disk;
	param2 = dcb$p;
	call ISIS('D', .param1);
end;
end;
numout.plm
numout: do;
declare digits(*) byte data('0123456789ABCDEF');

NumOut: procedure(value, base, lc, bufAdr, width) public;
	declare (value, bufAdr) address, (base, lc, width) byte;
	declare i byte;
	declare buf based bufAdr (1) byte;

	do i = 1 to width;
		buf(width - i) = digits(value mod base);
		value = value / base;
	end;

	i = 0;
	do while buf(i) = '0' and i < width - 1;
		buf(i) = lc;
		i = i + 1;
	end;
end;
end;
popul.plm
population: do;

declare bitCnt(*) byte initial(
	0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
	4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8);

Population: procedure(bufferLoc, length) address;
	declare (bufferLoc, length, total) address,
	(i, t, l) byte;
	declare buffer based bufferLoc (1) byte;

	total = 0;
	do while length > 31;
		t = 0;
		do i = 0 to 30;
			t = t + bitCnt(buffer(i));
		end;
		total = total + t;
		bufferLoc = bufferLoc + 31;
		length = length - 31;
	end;
	l = length - 1;
	t = 0;
	do i = 0 to l;
		t = t + bitCnt(buffer(i));
	end;
	return total + t;
end;
end;
rpterr.plm
ReportError: do;
$include(rpterr.ipx)
declare msg(*) byte DATA(0, 0,
	2, 'ILLEGAL AFTN ARGUMENT', 0,
	4, 'INCORRECTLY SPECIFIED FILE', 0,
	5, 'UNRECOGNIZED DEVICE NAME', 0,
	6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
	8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
	9, 'DISK DIRECTORY FULL', 0,
	0AH, 'NOT ON SAME DISK', 0,
	0BH, 'FILE ALREADY EXISTS', 0,
	0CH, 'FILE IS ALREADY OPEN', 0,
	0DH, 'NO SUCH FILE', 0,
	0EH, 'WRITE PROTECTED', 0,
	11H, 'NOT A DISK FILE', 0,
	12H, 'ILLEGAL ISIS COMMAND', 0,
	13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
	14H, 'ATTEMPTED BACK SEEK TOO FAR', 0,
	15H, 'CAN', 27H, 'T RESCAN', 0,
	16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
	17H, 'MISSING FILENAME', 0,
	19H, 'ILLEGAL ECHO FILE', 0,
	1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
	1BH, 'ILLEGAL SEEK COMMAND', 0,
	1CH, 'MISSING EXTENSION', 0,
	1FH, 'CAN', 27H, 'T SEEK ON WRITE ONLY FILE', 0,
	20H, 'CAN', 27H, 'T DELETE OPEN FILE', 0,
	23H, 'SEEK PAST EOF', 0,
	0C9H, 'UNRECOGNIZED SWITCH', 0,
	0CAH, 'UNRECOGNIZED DELIMITER', 0,
	0CBH, 'INVALID SYNTAX', 0,
	0CCH, 'PREMATURE EOF', 0,
	0CEH, 'ILLEGAL DISKETTE LABEL', 0,
	0D0H, 'CHECKSUM ERROR', 0,
	0D1H, 'RELO FILE SEQUENCE ERROR', 0,
	0D2H, 'INSUFFICIENT MEMORY', 0,
	0D3H, 'RECORD TOO LONG', 0,
	0D4H, 'ILLEGAL RELO RECORD', 0,
	0D5H, 'FIXUP BOUNDS ERROR', 0,
	0D6H, 'ILLEGAL SUBMIT PARAMETER', 0,
	0D7H, 'ARGUMENT TOO LONG', 0,
	0D8H, 'TOO MANY PARAMETERS', 0,
	0D9H, 'OBJECT RECORD TOO SHORT', 0,
	0DAH, 'ILLEGAL RECORD FORMAT', 0,
	0DBH, 'PHASE ERROR', 0,
	0EAH, 'CANNOT FORMAT FROM TARGET DRIVE', 0,
	0EBH, 'NON-DISK DEVICE', 0,
	3DH, 'UNASSIGNED DEVICE', 0,
	0ECH, 'ILLEGAL FORMAT ON REMOTE DEVICE', 0
	);

ReportError: procedure(errNum) public;
	declare errNum address;
	declare numberBuffer(3) byte, i address, status address;


	if errNum <> 0 then
	do;
		i = 0;
		do while i < size(msg);
			if errNum = msg(i) and msg(i + 1) <> 0 then
			do;
				i = i + 1;
				call write(0, .(' '), 1, .status);
				do while msg(i) <> 0;
					call write(0, .msg(i), 1, .status);
					i = i + 1;
				end;
				call write(0, .(0dh, 0ah), 2, .status);
				return;
			end;
			else
			do;
				do while msg(i) <> 0;
					i = i + 1;
				end;
				i = i + 1;
			end;
		end;
	call error(errNum);
	end;
end;
end;
setblk.plm
SetBlock: do;
$include(setblk.ipx)
declare mapBase address external;
SetBlock: procedure(adr) public;
	declare adr address;
	declare (bit, byt) address, spt byte;
	declare bitmap based mapBase (1) byte;

	if diskType = 4 then
		spt = 90h;
	else if diskType = 1 then
		spt = 34h;
	else
		spt = 1ah;

	bit = high(adr) * spt + low(adr) - 1;
	byt = shr(bit, 3);
	bitmap(byt) = bitmap(byt) or maskArray(low(bit) and 7);
end;
end;
scanin.plm
ScanInteger: do;

declare digits(*) byte data('0123456789ABCDEF');

ScanInteger: procedure(ptrPtr) address public;
	declare ptrPtr address;
	declare ptr based ptrPtr address;
	declare (scanPtr, updatePtr, stopPtr) address;
	declare (i, radix, increment) byte;
	declare (nVal, oVal) address;
	declare c based scanPtr byte;

	scanPtr = ptr;
	do while c = ' ';
		scanPtr = scanPtr + 1;
	end;
	ptr = scanPtr;
	do while '0' <= c and c <= '9' or 'A' <= c and c <= 'F';
		scanPtr = scanPtr + 1;
	end;

	stopPtr = scanPtr;
	updatePtr = scanPtr + 1;
	if c = 'H' then
		radix = 16;
	else if c = 'O' or c = 'Q' then
		radix = 8;
	else
	do;
		updatePtr = scanPtr;
		stopPtr, scanPtr = scanPtr - 1;
		if c = 'B' then
			radix = 2;
		else
		do;
			radix = 10;
			if c <> 'D' then	/* include last increment */
				stopPtr = stopPtr + 1;
		end;
	end;
	scanPtr = ptr;
	nVal, oVal = 0;
	do while scanPtr < stopPtr;
		do i = 0 to 15;
			if c = digits(i) then
				increment = i;
		end;
		if increment >= radix then
			return 0;
		nVal = oVal * radix + increment;
		if nVal < oVal then
			return 0;
		oVal = nVal;
		scanPtr = scanPtr + 1;
	end;
	ptr = updatePtr;
	return nVal;
end;
end;
ucase.plm
UpperCase: do;
UpperCase: procedure(char) byte public;
	declare char byte;
	if char < 'a' then
		return char;
	if char > 'z' then
		return char;
	return char and 0dfh;
end;
end;
wdelim.plm
WDelimit: do;
WDelimit: procedure(ptr) address public;
	declare ptr address;
	declare ch based ptr byte;

	do while (ch = ':' or ch = '.' or ch = '*' or ch = '?' or
		  ('0' <= ch and ch <= '9') or ('A' <= ch and ch <= 'Z'));
		ptr = ptr + 1;
	end;
	return ptr;
end;
end;
