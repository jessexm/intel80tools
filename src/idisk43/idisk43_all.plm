idisk.pex
CR	'0dh'
LF	'0ah'
TRUE	'0ffh'
FALSE	'0'
boolean	'byte'
DCB$T	'STRUCTURE (iocw BYTE, ioins BYTE, nsec BYTE, tadr BYTE, sadr BYTE, buf ADDRESS)'

Attrib		P(A path$p,A attrib,A on$off,A status$p)
Close           P(A conn,A status$p)
Delete          P(A path$p,A status$p)
Error           P(A error$num)
Exit            P
Isis            P(B type,A parameter$ptr)
Memck           PA
Open            P(A conn$p,A path$p,A access,A echo,A status$p)
Read            P(A conn,A buff$p,A count,A actual$p,A status$p)
Rename          P(A old$p,A new$p,A status$p)
Seek            P(A conn,A mode,A block$p,A byte$p,A status$p)
Spath		P(A path$p,A info$p,A status$p)
Write           P(A conn,A buff$p,A count,A status$p)



$file(absio.plm)
Absio           P(B cmd,B disk,A block,A buffer)

$file(alloc.plm)
maskArray       BS

$file(chkbad.plm)
ChkBadSectors   P(B disk)A

$file(clrbuf.plm)
ClearBuffer     P(A buf$ptr)

$file(dblank.plm)
deblank         P(A ptr)A

$file(diskio.plm)
Diskio          P(A disk,A dcb$p)

$file(dlimit.plm)
Delimit         P(A ptr)A

$file(filerr.plm)
FileError       P(A status,A ptr,B callExit)

$file(fmttrk.plm)
FormatTrack     P(B disk,A sTrack,A eTrack,B interleave)

$file(forupp.plm)
ForceUpper      P(A bufferPtr)

$file(fshblk.plm)
FlushBlock      P(A adr)

$file(getdsk.plm)
GetDisk         P(B n)

$file(gettar.plm)
GetTarget       P(B device,A buffer$p)B

$file(idisk.plm)
mapBase         A
diskType        B
singleDrive	B

$file(mvasci.plm)
MoveAscii       P(A dst,A src,B cnt)

$file(numout.plm)
numout          P(A val,B base,B lc,A bufAdr,B width)

$file(rpterr.plm)
ReportError     P(A errNum)

$file(seq.plm)
Seq             P(A str1,A str2,B cnt)"boolean"

$file(setblk.plm)
SetBlock        P(A adr)

$file(sfierr.plm)
SFileError      P(A status,A name$p)

$file(upcase.plm)
UpperCase       P(B char)B

$file(wdlimt.plm)
WDelimit        P(A ptr)A

$file(wrdir.plm)
WriteDirectory  P(B disk)

idisk.plm
idisk: do;
$include(idisk.ipx)
declare copyright(*) byte data('(C) 1975,1976,1977,1978,1979,1980,1981,1982 INTEL CORP'),
	version(*) byte data(4, 0, 'program_version_number=', 1, 'V4.3', 0);
/*
	the code block below is loaded into isis.t0 on non system disks to print a message
	the corresponding asm code is

		ASEG
		org 3000h

		in	79h
		in	7Bh
	L3004:	in	0FFh
		ani	2
		jnz	L3004
		lxi	h, Msg
		mvi	b, 32
	L3010:	mov	c, m
		call	0F809h	; CO
		inx	h
		dcr	b
		jnz	L3010
		rst	0
	Msg:	db	0Dh, 0Ah
		db	'NON-SYSTEM DISK, TRY ANOTHER'
		db	0Dh, 0Ah
		end
*/
declare codeBlock(*) byte data(0DBh, 79h, 0DBh, 7Bh, 0DBh, 0FFh, 0E6h, 2,
			       0C2h, 4, 30h, 21h, 1Ah, 30h, 6, 20h, 4Eh,
			       0CDh, 9, 0F8h, 23h, 5, 0C2h, 10h, 30h, 0C7h,
			       CR, LF, 'NON-SYSTEM DISK, TRY ANOTHER', CR, LF);

declare	memSize address;
declare	actual address;
declare	pn(12) byte;
declare	buffer$ptr address, char based buffer$ptr byte;
declare	(i, j, k) address;	/* j, k no longer used !! */
declare	(fileNumber, hadPrint) byte;
declare	next address;
declare	w550F address;
declare	(system, first, copy) boolean;
declare	(aftIn, aftOut, dirAft) address;
declare	status address;
declare	attributeList(*) byte data(1, 2, 4);	/* no longer used */
declare	tracks byte;
declare	(srcDisk, targetDisk) byte;
declare	w551F address;
declare	diskType byte public;
declare	fmtTable(5) structure(t0Interleave byte, t1Interleave byte, interleave  byte,
		   	      tracks address, bitmapSize address, labBlkSize address)
		initial(0,  0, 0,   0,     0,    0,
			1,  4, 5,  76,  200h,  80h,
			1, 12, 6,  76,  100h,  80h,
			1, 12, 6,  76,  100h,  80h,
			7, 16, 9, 199, 11DAh, 0FBh
		);
declare	inputString(16) byte,	/* no longer used */
	outputString(16) byte;	/* no longer used */

declare file(8) structure(name(13) byte)
	initial(':FX:ISIS.BIN ',
		':FX:ISIS.T0  ',
		':FX:ISIS.CLI ',
		':FX:ISIS.OV0 ',
		':FX:ISIS.MAP ',
		':FX:ISIS.DIR ',
		':FX:ISIS.LAB ',
		':FX:ISIS.BAD ');
declare buffer(256) byte;

declare labBlk structure(name(9) byte,
			 version(2) byte,
			 leftOver(38) byte,
			 crlf(2) byte,
		         fmtTable(200) byte) at (.buffer);
declare singleDrive boolean public;
declare info based next structure(length address, offset address, begin address);
declare mapBase address public;
declare padding(18) byte;


Initialize: procedure;
	call FormatTrack(targetDisk, 0, 0, labBlk.fmtTable(0) - '0');
	call FormatTrack(targetDisk, 1, 1, labBlk.fmtTable(1) - '0');
	call FormatTrack(targetDisk, 2, tracks, labBlk.fmtTable(2) - '0');
	mapBase = .MEMORY;
	w551F = ChkBadSectors(targetDisk) + 29;	
	call WriteDirectory(targetDisk);
	file(6).name(2) = targetDisk + '0';
	call Open(.aftOut, .file(6), 3, 0, .status);
	call SFileError(status, .file(6));
	call MoveAscii(.labBlk, .pn + 1, 9);
	call Write(aftOut, .labBlk, fmtTable(diskType).labBlkSize, .status);
	call SFileError(status, .file(6));
	call Close(aftOut, .status);
	call SFileError(status, .file(6));
end;


entry:
	call Read(1, .buffer, 256, .actual, .status);
	buffer(actual) = CR;
	call ForceUpper(.buffer);
	bufferPtr = Deblank(.buffer);
	call Spath(bufferPtr, .pn, .status);
	if (diskType := pn(11)) = 5 or 6 then	/* 6 is pointless as it does not impact test */
		status = 0ECh;
	if pn(11) = 8 then
		status = 3Dh;
	call FileError(status, bufferPtr, TRUE);
	targetDisk = GetTarget(pn(0), bufferPtr);
	srcDisk = 0;
	system = 0;
	singleDrive = 0;
	bufferPtr = Deblank(Delimit(bufferPtr));

	do while char <> CR;
		if char = 'P' then
			singleDrive = TRUE;
		else if char = 'S' then
			system = TRUE;
		else if Seq(bufferPtr, .('FROM '), 5) then
		do;
			bufferPtr = Deblank(bufferPtr + 5);
			if (srcDisk := char - '0') > 9 then
				call FileError(0C9h, bufferptr, TRUE);
		
		end;	
		else if char <> '$' then
			call FileError(0C9h, bufferPtr, TRUE);
		bufferPtr = Deblank(bufferPtr + 1);
	end;
	if srcDisk = targetDisk then
		singleDrive = TRUE;
	if targetDIsk = 0 and diskType = 4 and not system then
	do;
		call Write(0, .('NON-SYSTEM HARD DISK DRIVE 0 NOT ALLOWED', CR, LF), 2Ah, .status);
		call Exit;
	end;
	file(6).name(2) = srcDisk + '0';
	call Open(.aftIn, .file(6), 1, 0, .status);
	call FileError(status, .file(6), TRUE);
	call Read(aftIn, .buffer, 251, .actual, .status);
	call FileError(status, .file(6), TRUE);
	call Close(aftIn, .status);
	call FileError(status, .file(6), TRUE);
	tracks = fmtTable(diskType).tracks;
	labBlk.fmtTable(0) = fmtTable(diskType).t0Interleave + '0';
	labBlk.fmtTable(1) = fmtTable(diskType).t1Interleave + '0';
	do i = 2 to tracks;
		labBlk.fmtTable(i) = fmtTable(diskType).interleave + '0';
	end;

	if system then
	do;
		call Write(0, .('SYSTEM DISK', CR, LF), 13, .status);
		first = TRUE;
		next = fmtTable(diskType).bitmapSize + .MEMORY;	
		memSize = Memck - next;
		fileNumber = 0;
		hadPrint = 0;
		info.offset, i = 0;
		do while fileNumber < 4;
			memSize = memSize - 8;
			file(fileNumber).name(2) = srcDisk + '0';
			call Open(.aftIn, .file(fileNumber), 1, 0, .status);
			call SFileError(status, .file(fileNumber));
			call Seek(aftIn, 2, .i, .info.offset, .status);
			call SFileError(status, .file(fileNumber));
			call Read(aftIn, .info.begin, memSize, .actual, .status);
			call SFileError(status, .file(fileNumber));
			call Close(aftIn, .status);
			call SFileError(status, .file(fileNumber));
			info.length = actual;
			next = .info.begin + actual;
			if fileNumber = 3 or (memSize := memSize - actual) < 8 then
			do;
				if singleDrive then
					call GetDisk(2);
				
				if first then
				do;
					call Initialize;
					next = .MEMORY + fmtTable(diskType).bitmapSize;
					first = FALSE;
				end;
				else
					next = .MEMORY;

				do while hadPrint <= fileNumber;
					file(hadPrint).name(2) = targetDisk + '0';
					call Open(.aftOut, .file(hadPrint), 3, 0, .status);
					call SFileError(status, .file(hadPrint));
					call Seek(aftOut, 2, .i, .info.offset, .status);
					call SFileError(status, .file(hadPrint));
					call Write(aftOut, .info.begin, info.length, .status);
					call SFileError(status, .file(hadPrint));
					call Close(aftOut, .status);
					call SFileError(status, .file(hadPrint));
					if hadPrint < fileNumber then
						next = .info.begin + info.length;
					hadPrint = hadPrint + 1;
				end;
				w550F = info.offset + info.length;
				next = .MEMORY;
				if memSize = 0 then
				do;
					hadPrint = fileNumber;
					fileNumber = fileNumber - 1;
					info.offset = w550F;
				end;
				else
					info.offset = 0;

				memSize = Memck - next;
				if fileNumber + 1 < 4 and singleDrive then
					call GetDisk(0);
			end;
			else
				info.offset = 0;
			fileNumber = fileNumber + 1;
		end;
	end;
	else
	do;
		call Write(0, .('NON-SYSTEM DISK', CR, LF), 17, .status);
		if singleDrive then
			call GetDisk(2);
		call Initialize;
		file(0).name(2) = targetDisk + '0';
		file(1).name(2) = targetDisk + '0';
		call Open(.aftOut, .file(1), 3, 0, .status);
		call SFileError(status, .file(1));
		call Write(aftOut, .codeBlock, 3Ah, .status);	/* code to write non system disk */
		call SFileError(status, .file(1));
		call close(aftOut, .status);
		call SFileError(status, .file(1));
		call Delete(.file(0), .status);
	end;
	do i = 0 to 7;
		file(i).name(2) = targetDisk + '0';
		call Attrib(.file(i), 3, TRUE, .status);
	end;

	call Attrib(.file(2), 0, TRUE, .status);
	call Attrib(.file(2), 1, TRUE, .status);
	call Attrib(.file(3), 0, TRUE, .status);
	call Attrib(.file(3), 1, TRUE, .status);
	if singleDrive then
		call GetDisk(0);
	call Exit;
end;

alloc.plm
alloc: do;
declare maskArray(8) byte public data(80h, 40h, 20h, 10h, 8, 4, 2, 1);
end;
dblank.plm
deblank: do;

deblank: procedure(ptr) address public;
	declare ptr address;
	declare c based ptr byte;

	do while (c = ' ');
		ptr = ptr + 1;
	end;
	return ptr;
end;
end;
dlimit.plm
delimit: do;

Delimit: procedure(ptr) address public;
	declare ptr address;
	declare c based ptr byte;

	do while (c = ':' or c = '.' or ('0' <= c and c <= '9') or ('A' <= c and c <= 'Z'));
		ptr = ptr + 1;
	end;
	return ptr;
end;
end;
filerr.plm
fileerror: do;
$include(filerr.ipx)

FileError: procedure(status, ptr, callExit) public;
	declare (status, ptr) address, callExit byte;
	declare lStatus address;

	if status <> 0 then
	do;
		ptr = deblank(ptr);
		call write(0, .(' '), 1, .lStatus);
		call write(0, ptr, wdelimit(ptr) - ptr, .lStatus);
		call write(0, .(','), 1, .lStatus);
		call reporterror(status);
		if callExit then
			call exit;
	end;
end;
end;
fmttrk.plm
formatTrack: do;
$include(fmttrk.ipx)

FormatTrack: procedure(disk,sTrack,eTrack,interleave) public;
	declare (disk,interleave) byte, (sTrack, eTrack) address;
	declare curTrack address, (sectors, vTracks) byte;
	declare (i,j,interTrackSkew) byte, trackBuf(104) byte,
	dcb DCB$T;

	if diskType = 4 then
	do;
		sectors = 36;
		interTrackSkew = 17;
	end;
	else if diskType = 1 then
	do;
		sectors = 52;
		interTrackSkew = 7;
	end;
	else
	do;
		sectors = 26;
		interTrackSkew = 4;
	end;
	
	dcb.iocw = 0c0h;
	vTracks = sectors * 2 - 1;
	do i = 1 to vTracks by 2;
		trackBuf(i) = 0c7h;
	end;

	j = 0;
	
	if diskType = 4 then
	do;
		sTrack = sTrack * 4;
		eTrack = eTrack * 4 + 3;
	end;

	do curTrack = sTrack to eTrack;
		dcb.ioins = 2;
		do i = 0 to vTracks by 2;
			trackBuf(i) = 0;
		end;
		do i = 1 to sectors;
			j = (j + interleave) mod sectors;
			do while trackBuf(j * 2) <> 0;
				j = (j + 1) mod sectors;
			end;
			trackBuf(j + j) = i;
		end;
		if diskType <> 4 then
			dcb.tadr = curTrack;
		else
		do;
			dcb.tadr = curTrack / 4;
			dcb.sadr = (curTrack mod 4) * 36 + 1;
		end;	
		dcb.buf = .trackBuf;
		call Diskio(disk, .dcb);
		j = j + interTrackSkew;
	end;
end;
end;
forupp.plm
ForceUpper: do;
$include(forupp.ipx)

ForceUpper: procedure(bufferPtr) public;
	declare bufferPtr address, ch based bufferPtr byte;

	do while ch <> CR;
		ch = Uppercase(ch);
		bufferPtr = bufferPtr + 1;
	end;
end;
end;
getdsk.plm
GetDisk: do;
$include(getdsk.ipx)

declare source(3) structure(name(6) byte) data('SYSTEM', 'SOURCE', 'OUTPUT');

GetDisk: procedure(n) public;
	declare n byte;
	declare buf(128) byte, status address, junk address, actual address;

	call Write(0, .('LOAD '), 5, .status);
	call Write(0, .source(n), 6, .status);
	call Write(0, .(' DISK, THEN TYPE (CR)'), 21, .status);
	call Read(1, .buf, 128, .actual, .status);
end;
end;
mvasci.plm
MoveAscii: do;

MoveAscii: procedure(dst, src, cnt) public;
	declare (dst, src) address, cnt byte, i byte;
	declare dch based dst (1) byte, sch based src (1) byte;

	do i = 0 to cnt - 1;
		dch(i) = sch(i);
	end;
end;
end;
sfierr.plm
SFileError: do;
$include(sfierr.ipx)

declare singleDrive boolean external;
SFileError: procedure(status, name$p) public;
	declare (status, name$p) address;
	declare lStatus address;

	if status <> 0 then
	do;
		if singleDrive then
			call GetDisk(0);
		name$p = Deblank(name$p);
		call Write(0, .(' '), 1, .lStatus);
		call Write(0, name$p, WDelimit(name$p) - name$p, .lStatus);
		call Write(0, .(','), 1, .lStatus);
		call ReportError(status);
		call Exit;
	end;
end;
end;
seq.plm
Seq: do;
$include(seq.ipx)

Seq: procedure(str1, str2, cnt) boolean public;
	declare (str1,str2) address, cnt byte;
	declare chrs1 based str1(1) byte;
	declare chrs2 based str2(1) byte;
	declare i byte;
	cnt = cnt - 1;
	do i = 0 to cnt;
		if chrs1(i) <> chrs2(i) then
			return FALSE;
	end;
	return TRUE;
end;
end;

chkbad.plm
ChkBadSectors: do;
$include(chkbad.ipx)

declare aFatal(*) byte initial(' FATAL'),
	aBad(*) byte initial(' BAD SPOT AT LOGICAL ADDRESS ( '),
	aTrack(*) byte initial('***, '),
	aSector(*) byte initial('*** ), STATUS = '),
	aStatus(*) byte initial('****', CR, LF);

declare trap0B structure(jmp byte, target address) at (0bh),
	trap0E address at (0eh);

declare addrNewTrap0B literally '4432h';	/* address of newTrap0B below */
declare vec4354 address data(addrNewTrap0B);
declare mapBase address external;
declare bitmap based mapBase (1) byte;

ChkBadSectors: procedure(disk) address public;
	declare disk byte;
	declare logicalTrackSector address, 
		(logicalSector, logicalTrack) byte at (.logicalTrackSector),
		(w5851, savedSP) address,
		savedTrap0B structure(jmp byte, target address),
		(w5858, w585A, w585C, w585E) address,
		b5860 byte, (w5861, w5863, status) address;
	declare struct based w585E structure(b0 byte, w1 address, w3 address);	

	sub4561: procedure;
		if (logicalTrack = 0 and (logicalSector < 1Ch or logicalSector = 58h or logicalSector > 72h))
		  or (logicalTrack = 1 and (logicalSector < 40h or (48h < logicalSector and logicalSector < 88h)))
		  or (logicalTrack = 2 and logicalSector < 20h) then
		do;
			call NumOut(logicalTrack, 10, 0, .aTrack, 3);
			call NumOut(logicalSector, 10, 0, .aSector, 3);
			call NumOut(trap0E, 16, 0, .aStatus, 4);
			call Write(0, .aFatal, 64, .status);
			call Exit;
		end;
	end;


	sub4615: procedure;
		declare (w5867, w5869) address;
		call sub4561;
		call SetBlock(logicalTrackSector);
		w585E, w5867 = w585A;
		w585E = struct.w3;

		do while struct.b0 < logicalSector;
			w5867 = w585E;
			w585E = struct.w3;
		end;
		if struct.b0 = logicalSector then
			return;

		w5869 = w585E;
		w585E = w5867;
		struct.w3 = w585C;
		w585E = w585C;
		struct.b0 = logicalSector;
		struct.w1 = trap0E;
		struct.w3 = w5869;
		w585C = w585C + 5;
	end;


	if diskType = 4 then
		w5863 = 0E7FH;
	else if diskType = 1 then
		w5863 = 1ffh;
	else
		w5863 = 0ffh;

	do w5861 = 0 to w5863;
		bitmap(w5861) = 0;
	end;

	if diskType <> 4 then
		return 0;
	w5858 = 0;
	w585A = (w5851 := mapBase + 0E80h) + 128;
	savedSP = STACKPTR;
	savedTrap0B.jmp = trap0B.jmp;
	trap0B.jmp = 0c3h;
	savedTrap0B.target = trap0B.target;
	trap0B.target = vec4354;
	logicalTrack = 0;

L43F1:
	w585E = w585A;
	struct.w3 = w585E + size(struct);
	w585E = w585A + size(struct);
	struct.b0 = 91h;
	w585C = w585E + size(struct);
	logicalSector = 1;

L441C:
	call Absio(4, disk, logicalTrackSector, w5851); 
	goto L44A8;

newTrap0B:
	STACKPTR = savedSP;
	trap0B.jmp = savedTrap0B.jmp;
	trap0B.target = savedTrap0B.target;
	if trap0E <> 1 and trap0E <> 10 then
		call sub4615;
	else
	do;
		logicalSector = (logicalSector - 1) - ((logicalSector - 1) mod 36);
		do b5860 = 1 to 36;
			logicalSector = logicalSector + 1;
			call sub4615;
		end;
	end;

	trap0B.jmp = 0c3h;
	trap0B.target = vec4354;

L44A8:
	if (logicalSector := logicalSector + 1) < 91h then
		goto L441C;

	w585E = w585A;
	w585E = struct.w3;

	do while struct.b0 < 91h;
		call NumOut(logicalTrack, 10, 0, .aTrack, 3);
		call NumOut(struct.b0, 10, 0, .aSector, 3);
		call NumOut(struct.w1, 16, 0, .aStatus, 4);
		call Write(0, .aBad, 58, .status);
		if logicalTrack > 1 then
			w5858 = w5858 + 1;
		w585E = struct.w3;
	end;
	if (logicalTrack := logicalTrack + 1) < 0c8h then
		goto L43F1;

	trap0B.jmp = savedTrap0B.jmp;
	trap0B.target = savedTrap0B.target;
	return w5858;
end;
end;

gettar.plm
GetTarget: do;
$include(gettar.ipx)
GetTarget: procedure(device, buffer$p) byte public;
	declare device byte, buffer$p address;

	if device >= 25 then	/* diskdrive 6-9 */
		device = device - 19;	/* bring disks together */
	else if device > 5 then		/* shift others above disks */
		device = device + 4;

	if device <=  9 or buffer$p = 1 then
		return device;
	if buffer$p <> 0 then
		call FileError(0EBh, buffer$p, TRUE);
	else
	do;
		call ReportError(0EBh);
		call exit;
	end;
end;
end;

wrdir.plm
WriteDirectory: do;
$include(wrdir.ipx)
declare mapBase address external;
declare bitmap based mapBase (1) byte;

declare file(6) structure(name(9) byte) data('ISIS',0,0,'DIR',
					     'ISIS',0,0,'MAP',
					     'ISIS',0,0,'T0',0,
					     'ISIS',0,0,'BIN',
					     'ISIS',0,0,'LAB',
					     'ISIS',0,0,'BAD');

WriteDirectory: procedure(disk) public;
	declare	disk byte, binIdx byte, i byte, jj address, dirBuf(64) address,
		direct(8) structure(empty byte, file(9) byte, attrib byte,
				    eof$count byte, blk address, hdrBlk address) at(.dirBuf),
		b58F3 byte, w58F4 address, b58F6 byte;

	sub4B4E: procedure(arg1w, arg2w, arg3w);
		declare (arg1w, arg2w, arg3w, ii) address;

		do ii = 0 to arg2w - 1;
			dirBuf(arg1w + ii) = arg3w + ii;
			call setBlock(arg3w + ii);
		end;
	end;

	FlushBlock: procedure(adr);
		declare adr address;

		call Absio(6, disk, adr, .dirBuf);
		call SetBlock(adr);
		call ClearBuffer(.dirBuf);
	end;

	b58F6 =  25;
	if diskType = 1 then
	do;
		b58F3 = 4;
		w58F4 = 206h;
	end;
	else if diskType = 4 then
	do;
		b58F3 = 29;
		w58F4 = 21fh;
		b58F6 = 62;
	end;
	else
	do;
		b58F3 = 2;
		w58F4 = 204h;
	end;

	jj = .bitmap - 128;
	if diskType = 4 then
		do i = 0 to b58F3 - 1;
			call Absio(6, disk, i + 74h, (jj := jj + 128));
		end;
	call ClearBuffer(.dirBuf);
	call sub4B4E(2, 17h, 1);
	call FlushBlock(18h);
	if diskType = 4 then
	do;
		dirBuf(1) = 58h;
		call sub4B4E(2, 3Eh, 1Ah);
	end;
	else if diskType = 1 then
	do;
		call sub4B4E(2, 1Bh, 1Ah);
		call sub4B4E(1Dh, 1Ah, 11Bh);
	end;
	else
		call sub4B4E(2, 1, 1Ah);

	call FlushBlock(19h);
	if diskType = 4 then
	do;
		dirBuf(0) = 19h;	
		call sub4B4E(2, 1Ah, 59h);
		call sub4B4E(1ch, 9, 140h);
		call sub4B4E(25h, 9, 188h);
		call FlushBlock(58h);
	end;
	if diskType = 4 then
	do;
		call sub4B4E(2, b58F3, 74h);
		call FlushBlock(73h);
	end;
	call sub4B4E(2, b58F6, 102h);
	if diskType = 4 then
		dirBuf(1) = 149h;
	call FlushBlock(101h);
	if diskType = 4 then
	do;
		dirBuf(0) = 101h;
		call sub4B4E(2, b58F6, 14Ah);
		call FlushBlock(149h);
	end;

	call sub4B4E(2, b58F3, 202h);
	call FlushBlock(201h);
	call FlushBlock(w58F4);
	call MoveAscii(.direct(0).file, .file(0), 9);
	if diskType = 4 then
		direct(0).blk = 7Ch;
	else
		direct(0).blk = 19h;

	direct(0).hdrBlk = 101h;
	direct(0).attrib = 1;
	direct(0).eof$count = 128;
	
	call MoveAscii(.direct(1).file, .file(1), 9);
	direct(1).blk = b58F3;
	direct(1).hdrBlk = 201h;
	direct(1).attrib = 1;
	direct(1).eof$count = 128;

	call MoveAscii(.direct(2).file, .file(2), 9);
	direct(2).blk = 17h;
	direct(2).hdrBlk = 18h;
	direct(2).attrib = 1;
	direct(2).eof$count = 128;

	call MoveAscii(.direct(3).file, .file(4), 9);
	if diskType = 1 then
		direct(3).blk = 35h;
	else if diskType = 4 then
		direct(3).blk = 6Ah;
	else
		direct(3).blk = 1;
	direct(3).hdrBlk = 19h;
	direct(3).attrib = 1;
	direct(3).eof$count = 128;

	if diskType = 4 then
	do;
		call MoveAscii(.direct(4).file, .file(5), 9);
		direct(4).blk = b58F3;
		direct(4).hdrBlk = 73h;
		direct(4).attrib = 1;
		direct(4).eof$count = 128;
		binIdx = 5;
	end;
	else
		binIdx = 4;

	call MoveAscii(.direct(binIdx).file, .file(3), 9);
	direct(binIdx).hdrBlk = w58F4;
	direct(binIdx).attrib = 3;
	direct(binIdx).eof$count = 128;

	do i = binIdx + 1 to 7;
		direct(i).empty = 7fh;
	end;	

	call FlushBlock(102h);
	do i = 0 to 7;
		direct(i).empty = 7fh;
	end;

	do i = 1 to b58F6 - 1;
		call Absio(6, disk, 102h + i, .dirBuf);
	end;

	if diskType = 4 then
		do i = 0 to b58F6 - 1;
			call Absio(6, disk, 14Ah + i, .dirBuf);
		end;

	jj = .bitmap - 128;
	do i = 0 to b58F3 - 1;
		call Absio(6, disk, 202h + i, (jj := jj + 128)); 
	end;
end;
end;


fshblk.plm
FlushBlock: do;
$include(fshblk.ipx)

end;
absio.plm
Absio: do;
$include(absio.ipx)
Absio: procedure(cmd, disk, block, buffer) public;
	declare (cmd, disk) byte, (block, buffer) address;
	declare dcb DCB$T;

	dcb.iocw = 80H;
	dcb.ioins = cmd;
	dcb.nsec = 1;
	dcb.tadr = high(block);
	dcb.sadr = low(block);
	dcb.buf = buffer;
	call Diskio(disk, .dcb);
end;
end;
clrbuf.plm
ClearBuffer: do;
ClearBuffer: procedure(buf$ptr) public;
	declare buf$ptr address, i byte;
	declare buf based buf$ptr (1) byte;


	do i = 0 to 127;
		buf(i) = 0;
	end;
end;		
end;

diskio.plm
Diskio: do;
$include(diskio.ipx)
Diskio: procedure(disk, dcb$p) public;
	declare disk address, dcb$p address;
	declare (param1, param2) address;

	param1 = disk;
	param2 = dcb$p;
	call ISIS('D', .param1);
end;
end;
numout.plm
numout: do;
declare digits(*) byte data('0123456789ABCDEF');

numout: procedure(val, base, lc, bufAdr, width) public;
	declare (val, bufAdr) address, (base, lc, width) byte; 
	declare i byte;
	declare buf based bufAdr (1) byte;

	do i = 1 to width;
		buf(width - i) = digits(val mod base);
		val = val / base;	
	end;

	i = 0;
	do while buf(i) = '0' and i < width - 1;
		buf(i) = lc;
		i = i + 1;
	end;
end;
end;
rpterr.plm
ReportError: do;
$include(rpterr.ipx)
declare msg(*) byte DATA(0, 0,
	2, 'ILLEGAL AFTN ARGUMENT', 0,
	4, 'INCORRECTLY SPECIFIED FILE', 0,
	5, 'UNRECOGNIZED DEVICE NAME', 0,
	6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
	8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
	9, 'DISK DIRECTORY FULL', 0,
	0AH, 'NOT ON SAME DISK', 0,
	0BH, 'FILE ALREADY EXISTS', 0,
	0CH, 'FILE IS ALREADY OPEN', 0,
	0DH, 'NO SUCH FILE', 0,
	0EH, 'WRITE PROTECTED', 0,
	11H, 'NOT A DISK FILE', 0,
	12H, 'ILLEGAL ISIS COMMAND', 0,
	13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
	14H, 'ATTEMPTED BACK SEEK TOO FAR', 0,
	15H, 'CAN', 27H, 'T RESCAN', 0,
	16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
	17H, 'MISSING FILENAME', 0,
	19H, 'ILLEGAL ECHO FILE', 0,
	1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
	1BH, 'ILLEGAL SEEK COMMAND', 0,
	1CH, 'MISSING EXTENSION', 0,
	1FH, 'CAN', 27H, 'T SEEK ON WRITE ONLY FILE', 0,
	20H, 'CAN', 27H, 'T DELETE OPEN FILE', 0,
	23H, 'SEEK PAST EOF', 0,
	0C9H, 'UNRECOGNIZED SWITCH', 0,
	0CAH, 'UNRECOGNIZED DELIMITER', 0,
	0CBH, 'INVALID SYNTAX', 0,
	0CCH, 'PREMATURE EOF', 0,
	0CEH, 'ILLEGAL DISKETTE LABEL', 0,
	0D0H, 'CHECKSUM ERROR', 0,
	0D1H, 'RELO FILE SEQUENCE ERROR', 0,
	0D2H, 'INSUFFICIENT MEMORY', 0,
	0D3H, 'RECORD TOO LONG', 0,
	0D4H, 'ILLEGAL RELO RECORD', 0,
	0D5H, 'FIXUP BOUNDS ERROR', 0,
	0D6H, 'ILLEGAL SUBMIT PARAMETER', 0,
	0D7H, 'ARGUMENT TOO LONG', 0,
	0D8H, 'TOO MANY PARAMETERS', 0,
	0D9H, 'OBJECT RECORD TOO SHORT', 0,
	0DAH, 'ILLEGAL RECORD FORMAT', 0,
	0DBH, 'PHASE ERROR', 0,
	0EAH, 'CANNOT FORMAT FROM TARGET DRIVE', 0,
	0EBH, 'NON-DISK DEVICE', 0,
	3DH, 'UNASSIGNED DEVICE', 0,
	0ECH, 'ILLEGAL FORMAT ON REMOTE DEVICE', 0
	);

ReportError: procedure(errNum) public;
	declare errNum address;
	declare numberBuffer(3) byte, i address, status address;
 

	if errNum <> 0 then
	do;
		i = 0;
		do while i < size(msg);
			if errNum = msg(i) and msg(i + 1) <> 0 then
			do;
				i = i + 1;
				call write(0, .(' '), 1, .status);
				do while msg(i) <> 0;
					call write(0, .msg(i), 1, .status);
					i = i + 1;
				end;
				call write(0, .(0dh, 0ah), 2, .status);
				return;
			end;
			else
			do;
				do while msg(i) <> 0;
					i = i + 1;
				end;
				i = i + 1;
			end;
		end;
	call error(errNum);
	end;
end;
end;
setblk.plm
SetBlock: do;
$include(setblk.ipx)
declare mapBase address external;
SetBlock: procedure(adr) public;
	declare adr address;
	declare (bit, byt) address, spt byte;
	declare bitmap based mapBase (1) byte;

	if diskType = 4 then
		spt = 90h;
	else if diskType = 1 then
		spt = 34h;
	else
		spt = 1ah;

	bit = high(adr) * spt + low(adr) - 1;
	byt = shr(bit, 3);
	bitmap(byt) = bitmap(byt) or maskArray(low(bit) and 7);
end;
end;

upcase.plm
UpperCase: do;
UpperCase: procedure(char) byte public;
	declare char byte;
	if char < 'a' then
		return char;
	if char > 'z' then
		return char;
	return char and 0dfh;
end;
end;
wdlimt.plm
WDelimit: do;
WDelimit: procedure(ptr) address public;
	declare ptr address;
	declare ch based ptr byte;

	do while (ch = ':' or ch = '.' or ch = '*' or ch = '?' or
		  ('0' <= ch and ch <= '9') or ('A' <= ch and ch <= 'Z'));
		ptr = ptr + 1;
	end;
	return ptr;
end;
end;
