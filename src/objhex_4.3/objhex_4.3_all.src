objhex.pex
# common literals
TRUE            '0FFh'
FALSE           '0'
CR              '0Dh'
LF		'0Ah'
FOREVER		'WHILE TRUE'

# my user types
pointer		'address'
bool		'byte'
apointer	'address'
word		'address'

# supported record types
RELOC$TYPE	'22h'
MODEND$TYPE	'4'
CONTENT$TYPE	'6'

# error codes
INVALID$SYNTAX	'203'
EARLY$EOF	'204'
BAD$REC$TYP	'212'

# external procedures
Deblank		P("pointer" ptr)"pointer"
Delimit		P("pointer" ptr)"pointer"
MoveAscii	P("pointer" dst,"pointer" src,B cnt)
FileError	P("word" status,"pointer" ptr,"bool" fatal)
ForceUpper	P("pointer" ptr)
NumOut		P("word" val,B base,B lc,"pointer" buf,B width)
Path		P("pointer" filename,"pointer" pn)B
Seq		P("pointer" str1,"pointer" str2,B cnt)"bool"
ReportError	P("word" errNum)
UpperCase	P(B char)B
WDelimit	P("pointer" ptr)"pointer"

Close           P("word" conn,"apointer" status$p)
Error		P("word" errnum)
Exit		P
Memck           P"apointer"
Open            P("apointer" conn$p,"pointer" path$p,"word" access,"word" echo,"apointer" status$p)
Read            P("word" conn,"pointer" buff$p,"word" count,"apointer" actual$p,"apointer" status$p)
Spath		P("pointer" path$p,"pointer" info$p,"apointer" status$p)	
Write           P("word" conn,"pointer" buff$p,"word" count,"apointer" status$p)

# file access modes
READ$MODE	'1'
WRITE$MODE	'2'

objhex.plm
OBJHEX:
DO;
$include(objhex.ipx)
DECLARE copyRight(*) byte data(
	'(C) 1975,1976,1977,1978,1979,1980,1981,1982 INTEL CORP');
DECLARE programVersion(*) byte data(4, 0, 'program_version_number=', 1, 'V4.3', 0);

DECLARE BUFFER$COUNT WORD;
DECLARE SEG$ID BYTE;
DECLARE RECLEN WORD;
DECLARE TYPE BYTE;
DECLARE CHECKSUM BYTE;
DECLARE (I,J) WORD;
DECLARE HEXLEN WORD;
DECLARE ADDR WORD;
DECLARE TEMP BYTE;
DECLARE BUFFER$SIZE WORD;
DECLARE IPTR WORD;
DECLARE BUFFER(128) BYTE;
DECLARE BUFFER$PTR POINTER, CHAR BASED BUFFER$PTR BYTE;
DECLARE (OUTPUT$PTR,INPUT$PTR) POINTER;
DECLARE ACTUAL WORD;
DECLARE STATUS WORD;
DECLARE (AFT$OUT,AFT$IN) WORD;
/*
   HEXADECIMAL CONTENT RECORD.
*/
DECLARE HEXRECORD STRUCTURE(
                     HEADER BYTE,
                     LENGTH WORD,
                     ADDR(2) WORD,
                     TYPE WORD,
                     DAT(16) WORD,
                     CHKSUM WORD,
                     TRAILER(2) BYTE);
/*
   HEXADECIMAL END RECORD.
*/
DECLARE ENDRECORD STRUCTURE(
                   HEADER BYTE,
                   LENGTH WORD,
                   ADDR(2) WORD,
                   TYPE WORD,
                   CHKSUM WORD,
                   TRAILER(2) BYTE);

GET$BYTE:
  PROCEDURE BYTE;
     IF BUFFER$COUNT = 0 THEN
     DO;
      CALL READ(AFT$IN,.MEMORY,BUFFER$SIZE,.BUFFER$COUNT,.STATUS);
      CALL FILE$ERROR(STATUS,INPUT$PTR,TRUE);
      IF BUFFER$COUNT = 0 THEN
      DO;
         CALL FILE$ERROR(EARLY$EOF,INPUT$PTR,TRUE);
         CALL EXIT;
      END;
      IPTR = 0;
     END;
     BUFFER$COUNT = BUFFER$COUNT - 1;
     IPTR = IPTR + 1;
     RETURN MEMORY(IPTR-1);
  END GET$BYTE;

GET$ADDRESS:
  PROCEDURE ADDRESS;
     RETURN GET$BYTE + GET$BYTE*256;
  END GET$ADDRESS;

/* *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
   *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*

      BEGINNING OF MAIN PROGRAM.

   *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
   *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-* */

/*
  INITIALIZE RECORD STRUCTURES.
*/
HEXRECORD.HEADER = ':';
HEXRECORD.TYPE = '00';
ENDRECORD.HEADER = ':';
ENDRECORD.TRAILER(0) = CR;
ENDRECORD.TRAILER(1) = LF;
/*
  READ AND PROCESS COMMAND TAIL.
*/
INPUT$PTR = .(':CI: ');
CALL READ(1, .BUFFER,LENGTH(BUFFER),.ACTUAL, .STATUS);
CALL FILE$ERROR(STATUS, INPUT$PTR, TRUE);
BUFFER(ACTUAL) = CR;
CALL FORCE$UPPER(.BUFFER);
INPUT$PTR,BUFFER$PTR = DEBLANK(.BUFFER);
CALL OPEN(.AFT$IN, INPUT$PTR,READ$MODE,0,.STATUS);
CALL FILE$ERROR(STATUS,INPUT$PTR,TRUE);
BUFFER$PTR = DEBLANK(DELIMIT(BUFFER$PTR));
IF SEQ( .('TO '),BUFFER$PTR,3) THEN
DO;
   OUTPUT$PTR,BUFFER$PTR = DEBLANK(BUFFER$PTR+2);
   BUFFER$PTR = DEBLANK(DELIMIT(BUFFER$PTR));
END;
ELSE
DO;
   CALL FILE$ERROR(INVALID$SYNTAX,OUTPUT$PTR,TRUE);
END;
IF CHAR <> CR THEN CALL FILE$ERROR(INVALID$SYNTAX,BUFFER$PTR,TRUE);
CALL OPEN(.AFT$OUT,OUTPUT$PTR,WRITE$MODE,0,.STATUS);
CALL FILE$ERROR(STATUS,OUTPUT$PTR,TRUE);
/*
   COMPUTE SIZE OF WORKSPACE.
*/
BUFFER$SIZE = MEMCK - .MEMORY;
BUFFER$COUNT = 0;
/*
   READ OBJECT RECORDS, WRITE HEXADECIBAL RECORDS.
*/
DO FOREVER;
   TYPE = GET$BYTE;
   IF TYPE >= RELOC$TYPE THEN
     CALL FILE$ERROR(BAD$REC$TYP,INPUT$PTR,TRUE);
   IF TYPE = MODEND$TYPE THEN
   DO;
     RECLEN = GET$ADDRESS;
     TEMP = GET$BYTE;
     TEMP = GET$BYTE;
     ADDR = GET$ADDRESS;
     CHECKSUM = LOW(ADDR) + HIGH(ADDR) + 1;
     CALL NUMOUT(0,16,'0',.ENDRECORD.LENGTH,2);
     CALL NUMOUT(ADDR,16,'0',.ENDRECORD.ADDR,4);
     CALL NUMOUT(1,16,'0',.ENDRECORD.TYPE,2);
     CALL NUMOUT(-CHECKSUM,16,'0',.ENDRECORD.CHKSUM,2);
     CALL WRITE(AFT$OUT,.ENDRECORD,SIZE(ENDRECORD),.STATUS);
     CALL CLOSE(AFT$IN,.STATUS);
     CALL CLOSE(AFT$OUT,.STATUS);
     CALL EXIT;
   END;
   IF TYPE <> CONTENT$TYPE THEN
   DO;
     RECLEN = GET$ADDRESS;
     DO I = 1 TO RECLEN;
       TEMP = GET$BYTE;
     END;
   END;
   ELSE
   DO;
     RECLEN = GET$ADDRESS;
     SEG$ID = GET$BYTE;
     ADDR = GET$ADDRESS;
     RECLEN = RECLEN - 4;
     DO WHILE RECLEN <> 0;
       HEXLEN = RECLEN;
       IF HEXLEN > LENGTH(HEXRECORD.DAT) THEN
         HEXLEN = LENGTH(HEXRECORD.DAT);
       RECLEN = RECLEN - HEXLEN;
       DO I = 0 TO LENGTH(HEXRECORD.DAT)+1;
         HEXRECORD.DAT(I) = 0A0DH;
       END;
       CHECKSUM = HEXLEN + LOW(ADDR) + HIGH(ADDR);
       CALL NUMOUT(HEXLEN,16,'0',.HEXRECORD.LENGTH,2);
       CALL NUMOUT(ADDR,16,'0',.HEXRECORD.ADDR,4);
       DO J = 0 TO HEXLEN - 1;
         ADDR = ADDR + 1;
         TEMP = GET$BYTE;
         CHECKSUM = CHECKSUM + TEMP;
         CALL NUMOUT(TEMP,16,'0',.HEXRECORD.DAT(J),2);
       END;
       CALL NUMOUT(-CHECKSUM,16,'0',.HEXRECORD.DAT(HEXLEN),2);
       CALL WRITE(AFT$OUT,.HEXRECORD,HEXLEN+HEXLEN+13, .STATUS);
     END;
     TEMP = GET$BYTE;
   END;
END;
END OBJHEX;
EOF
dblank.plm
DEBLANK: DO;
Deblank: procedure(str) address public;
	declare str address;
	declare c based str byte;

	do while (c = ' ');
		str = str + 1;
	end;
	return str;
end;

end;
dlimit.plm
DELIMIT: DO;
Delimit: procedure(ptr) address public;
	declare ptr address, ch based ptr byte;

	do while ch = ':' or ch = '.' or
		 ('0' <= ch and ch <= '9') or
		 ('A' <= ch and ch <= 'Z');
		ptr = ptr + 1;
	end;
	return ptr;
end;
end;
filerr.plm
FILEERROR: DO;
$include(filerr.ipx)

FileError: procedure(status, ptr, callExit) public;
	declare (status, ptr) address, callExit byte;
	declare actual address;

	if status <> 0 then
	do;
		ptr = Deblank(ptr);
		call Write(0, .(' '), 1, .actual);
		call Write(0, ptr, WDelimit(ptr) - ptr, .actual);
		call Write(0, .(','), 1, .actual);
		call ReportError(status);
		if callExit then
			call exit;
	end;
end;
end;
forupp.plm
FORCEUPPER: DO;
$include(forupp.ipx)

ForceUpper: procedure(bufferPtr) public;
	declare bufferPtr address, ch based bufferPtr byte;

	do while ch <> CR;
		ch = uppercase(ch);
		bufferPtr = bufferPtr + 1;
	end;
end;
end;
numout.plm
NUMOUT: DO;

declare digits(*) byte data('0123456789ABCDEF');

NumOut: procedure(val, base, lc, bufAdr, width) public;
	declare (val, bufAdr) address, (base, lc, width) byte; 
	declare i byte;
	declare buf based bufAdr (1) byte;

	do i = 1 to width;
		buf(width - i) = digits(val mod base);
		val = val / base;	
	end;

	i = 0;
	do while buf(i) = '0' and i < width - 1;
		buf(i) = lc;
		i = i + 1;
	end;
end;
end;
path.plm
PATH: DO;
$include(path.ipx)

Path: procedure(filename, pn) byte public;
	declare (filename, pn) address;
	declare info(12) byte;
	declare status byte;	/* ? bug should be word */

	call Spath(filename, .info, .status);
	call MoveAscii(pn, .info, size(info) - 2);
	return status;
end;
end;
seq.plm
SEQ: DO;
Seq: procedure(s1, s2, cnt) byte public;
	declare (s1,s2) address, cnt byte;
	declare s1a based s1(1) byte;
	declare s2a based s2(1) byte;
	declare i byte;
	cnt = cnt - 1;
	do i = 0 to cnt;
		if s1a(i) <> s2a(i) then
			return 0;
	end;
	return 0ffh;
end;
end;
mvasci.plm
MOVEASCII: DO;
MoveAscii: procedure(dst, src, cnt) public;
	declare (dst, src) address, cnt byte, i byte;
	declare dch based dst (1) byte, sch based src (1) byte;

	do i = 0 to cnt - 1;
		dch(i) = sch(i);
	end;
end;
end;
reperr.plm
REPORTERROR: DO;
$include(reperr.ipx)

declare msg(*) byte DATA(0, 0,
	2, 'ILLEGAL AFTN ARGUMENT', 0,
	4, 'INCORRECTLY SPECIFIED FILE', 0,
	5, 'UNRECOGNIZED DEVICE NAME', 0,
	6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
	8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
	9, 'DISK DIRECTORY FULL', 0,
	0AH, 'NOT ON SAME DISK', 0,
	0BH, 'FILE ALREADY EXISTS', 0,
	0CH, 'FILE IS ALREADY OPEN', 0,
	0DH, 'NO SUCH FILE', 0,
	0EH, 'WRITE PROTECTED', 0,
	11H, 'NOT A DISK FILE', 0,
	12H, 'ILLEGAL ISIS COMMAND', 0,
	13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
	14H, 'ATTEMPTED BACK SEEK TOO FAR', 0,
	15H, 'CAN''T RESCAN', 0,
	16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
	17H, 'MISSING FILENAME', 0,
	19H, 'ILLEGAL ECHO FILE', 0,
	1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
	1BH, 'ILLEGAL SEEK COMMAND', 0,
	1CH, 'MISSING EXTENSION', 0,
	1FH, 'CAN''T SEEK ON WRITE ONLY FILE', 0,
	20H, 'CAN''T DELETE OPEN FILE', 0,
	23H, 'SEEK PAST EOF', 0,
	0C9H, 'UNRECOGNIZED SWITCH', 0,
	0CAH, 'UNRECOGNIZED DELIMITER', 0,
	0CBH, 'INVALID SYNTAX', 0,
	0CCH, 'PREMATURE EOF', 0,
	0CEH, 'ILLEGAL DISKETTE LABEL', 0,
	0D0H, 'CHECKSUM ERROR', 0,
	0D1H, 'RELO FILE SEQUENCE ERROR', 0,
	0D2H, 'INSUFFICIENT MEMORY', 0,
	0D3H, 'RECORD TOO LONG', 0,
	0D4H, 'ILLEGAL RELO RECORD', 0,
	0D5H, 'FIXUP BOUNDS ERROR', 0,
	0D6H, 'ILLEGAL SUBMIT PARAMETER', 0,
	0D7H, 'ARGUMENT TOO LONG', 0,
	0D8H, 'TOO MANY PARAMETERS', 0,
	0D9H, 'OBJECT RECORD TOO SHORT', 0,
	0DAH, 'ILLEGAL RECORD FORMAT', 0,
	0DBH, 'PHASE ERROR', 0,
	0EAh, 'CANNOT FORMAT FROM TARGET DRIVE', 0,
	0EBh, 'NON-DISK DEVICE', 0,
	3DH, 'UNASSIGNED DEVICE', 0,
	0ECH, 'ILLEGAL FORMAT ON REMOTE DEVICE', 0
	);


ReportError: procedure(errNum) public;
	declare errNum address;
	declare numberBuffer(3) byte, i address, status address;
	
	if errNum <> 0 then
	do;
		i = 0;
		do while i < size(msg);
			if errNum = msg(i) and msg(i + 1) <> 0 then
			do;
				i = i + 1;
				call write(0, .(' '), 1, .status);
				do while msg(i) <> 0;
					call Write(0, .msg(i), 1, .status);
					i = i + 1;
				end;
				call Write(0, .(0dh, 0ah), 2, .status);
				return;
			end;
			else
			do;
				do while msg(i) <> 0;
					i = i + 1;
				end;
				i = i + 1;
			end;
		end;
		call error(errNum);
	end;
end;
end;
upcase.plm
UPPERCASE: DO;
UpperCase: procedure(char) byte public;
	declare char byte;
	if char < 'a' then
		return char;
	if char > 'z' then
		return char;
	return char and 0dfh;
end;
end;
wdlmt.plm
WDELIMIT: DO;
/* b1=01, b2=31, CODE(63H) byte, DATA(2H) byte, STACK(4H) byte, MEMORY(0H) byte,*/
WDelimit: procedure(ptr) address public;
	declare ptr address;
	declare ch based ptr byte;

	do while (ch = ':' or ch = '.' or ch = '*' or ch = '?' or
		  ('0' <= ch and ch <= '9') or ('A' <= ch and ch <= 'Z'));
		ptr = ptr + 1;
	end;
	return ptr;
end;
end;
