absio.plm
Absio: do;
$include(absio.ipx)
Absio: procedure(cmd, disk, block, buffer) public;
	declare (cmd, disk) byte, (block, buffer) address;
	declare dcb DCB$T;

	dcb.iocw = 80H;
	dcb.ioins = cmd;
	dcb.nsec = 1;
	dcb.tadr = high(block);
	dcb.sadr = low(block);
	dcb.buf = buffer;
	call Diskio(disk, .dcb);
end;
end;
alloc.plm
alloc: do;
declare maskArray(8) byte public data(80h, 40h, 20h, 10h, 8, 4, 2, 1);
declare mapBase address public;
end;
clbuf.plm
ClearBuffer: do;
ClearBuffer: procedure(buf$ptr) public;
	declare buf$ptr address, i byte;
	declare buf based buf$ptr (1) byte;


	do i = 0 to 127;
		buf(i) = 0;
	end;
end;
end;

dblank.plm
deblank: do;

Deblank: procedure(ptr) address public;
	declare ptr address;
	declare c based ptr byte;

	do while (c = ' ');
		ptr = ptr + 1;
	end;
	return ptr;
end;
end;
direct.plm
direct: do;
$include(direct.ipx)
declare direct DIRECT$T public;
declare directINO address public;
end;
diskio.plm
Diskio: do;
$include(diskio.ipx)
Diskio: procedure(disk, dcb$p) public;
	declare disk address, dcb$p address;
	declare (param1, param2) address;

	param1 = disk;
	param2 = dcb$p;
	call ISIS('D', .param1);
end;

WDiskio: procedure(wiopb$p, status$p) public;
    declare wiopb$p pointer, status$p wpointer;
    declare status based status$p word;
 
    call StrtWD(wiopb$p);
    status = StatWD;
end;
end;
dlimit.plm
delimit: do;

Delimit: procedure(ptr) address public;
	declare ptr address;
	declare c based ptr byte;

	do while (c = ':' or c = '.' or ('0' <= c and c <= '9') or ('A' <= c and c <= 'Z'));
		ptr = ptr + 1;
	end;
	return ptr;
end;
end;
ferror.plm
fileerror: do;
$include(ferror.ipx)

FileError: procedure(status, ptr, callExit) public;
	declare (status, ptr) address, callExit byte;
	declare actual address;

	if status <> 0 then
	do;
		ptr = deblank(ptr);
		call write(0, .(' '), 1, .actual);
		call write(0, ptr, wdelimit(ptr) - ptr, .actual);
		call write(0, .(','), 1, .actual);
		call reporterror(status);
		if callExit then
			call exit;
	end;
end;
end;
fmttrk.plm
formatTrack: do;
$include(fmttrk.ipx)

declare INFOSIG literally '0ABCDH'; 

declare fmtErrMsg(*) byte initial('FORMAT ERROR: **', CR, LF),
        status word,
        wiopb WDCB$T initial(0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0);
declare badTrkSig address initial(INFOSIG),
        badTrkCnt address initial(0),
        badTrkInfo(255) structure(cyl address, head byte, unk byte);
declare altTrkSig address initial(INFOSIG),
        altTrkCnt address initial(0),
        altTrkInfo(255) structure(cyl address, head byte, unk byte);

LoadBadTrackInfo: procedure;
    declare i word;

    do i = 0 to 3;
        wiopb.function = WINREAD;
        wiopb.cyl = 523;    /* location of bad track list */
        wiopb.head = 4;
        wiopb.sector = i * 16;  /* try all 4 copies */
        wiopb.buffer(0) = .badTrkSig;
        wiopb.count(0) = 1024;
        call WDiskio(.wiopb, .status);
        if status = 0 then
            goto gotBadInfo;
    end;
    goto badinfo;

gotBadInfo:
    do i = 0 to 3;
        wiopb.function = WINREAD;
        wiopb.cyl = 522;     /* location of alt track list */
        wiopb.head = 4;
        wiopb.sector = i * 16;  /* try all 4 copies */
        wiopb.buffer(0) = .altTrkSig;
        wiopb.count(0) = 1024;
        call WDiskio(.wiopb, .status);
        if status = 0 then
            goto gotAltInfo;
    end;
    goto badinfo;

    gotAltInfo:
    if badTrkSig = INFOSIG and altTrkSig = INFOSIG then
        return;

    badInfo:
    call Write(CONSOLE$OUTPUT,
               .(' CANNOT READ DEFECTIVE TRACK INFORMATION', CR, LF),
               42, .status);
    call Exit;
end;

FormatTrack: procedure(disk,sTrack,eTrack,interleave) public;
	declare (disk,interleave) byte, (sTrack, eTrack) address;
    declare (wCyl, wHead) address;
	declare curTrack address, (sectors, vTracks) address;
	declare (i,j,interTrackSkew) address,
            wDisk address, trackBuf(104) byte, dcb DCB$T;

	if diskType = 9 then	/* Winchester */
	do;
        call LoadBadTrackInfo;
        sTrack = 3 * sTrack;
        eTrack = 3 * eTrack + 2;
        do curTrack = sTrack to eTrack;
            trackBuf(0) = 0;        /* format data track */
            trackBuf(1) = 0c7h;
            trackBuf(2) = 0c7h;
            trackBuf(3) = 0c7h;
            trackBuf(4) = 0c7h;
            trackBuf(5) = interleave;
            wDisk = disk;
            wDisk = disk * 128;
            wCyl = curTrack / 5 + wDisk;
            wHead = curTrack mod 5;
            if badTrkCnt <> 0 then
                do i = 0 to badTrkCnt - 1;
                    /* see if current track is on bad list */
                    if badTrkInfo(i).cyl = wCyl and
                       badTrkInfo(i).head = wHead then
                    do;
                        trackBuf(0) = 40h;  /* format assigned alternate track */
                        wiopb.function = WINFORMAT;
                        wiopb.buffer(0) = .trackBuf;
                        wiopb.cyl = altTrkInfo(i).cyl;
                        wiopb.head = altTrkInfo(i).head;
                        call WDiskio(.wiopb, .status);
                        if status <> 0 then
                            goto fmtErr;
                        trackBuf(0) = 80h;  /* format defective track */
                        trackBuf(1) = low(altTrkInfo(i).cyl);
                        trackBuf(2) = high(altTrkInfo(i).cyl);
                        trackBuf(3) = altTrkInfo(i).head;
                        trackBuf(4) = 0;    /* no user pattern */
                        goto break;
                    end;
                end;
        break:
            wiopb.function = WINFORMAT;
            wiopb.buffer(0) = .trackBuf;
            wiopb.cyl = wCyl;
            wiopb.head = wHead;
            call WDiskio(.wiopb, .status);
            if status <> 0 then
                goto fmtErr;
        end;
        return;
	end;

    if diskType = 1 then	/* DD */ 
    do;
        sectors = 52;
        interTrackSkew = 7;
    end;
    else
    do;
        sectors = 26;
        interTrackSkew = 4;
    end;

    dcb.iocw = 0c0h;
    vTracks = sectors * 2 - 1;
    do i = 1 to vTracks by 2;
        trackBuf(i) = 0c7h;
    end;

    j = 0;

    do curTrack = sTrack to eTrack;
        dcb.ioins = 2;
        do i = 0 to vTracks by 2;
            trackBuf(i) = 0;
        end;
        do i = 1 to sectors;
            j = (j + interleave) mod sectors;
            do while trackBuf(j * 2) <> 0;
                j = (j + 1) mod sectors;
            end;
            trackBuf(j + j) = i;
        end;
    
        dcb.tadr = curTrack;
        dcb.buf = .trackBuf;
        call Diskio(disk, .dcb);
        j = j + interTrackSkew;
    end;
    return;

fmtErr:
    call NumOut(status, 16, '0', .fmtErrMsg + 14, 2);
    call Write(0, .fmtErrMsg, 18, .status);
    call Exit;
end;

end;
forupp.plm
FORCEUPPER: DO;
$include(forupp.ipx)

ForceUpper: procedure(bufferPtr) public;
    declare bufferPtr address, ch based bufferPtr byte;

    do while ch <> CR;
        ch = uppercase(ch);
        bufferPtr = bufferPtr + 1;
    end;
end;
end;
getdsk.plm
GetDisk: do;
$include(getdsk.ipx)

declare source(3) structure(name(6) byte) data('SYSTEM', 'SOURCE', 'OUTPUT');

GetDisk: procedure(n) public;
	declare n byte;
	declare buf(128) byte, status address, junk address, actual address;

	call Write(0, .('LOAD '), 5, .status);
	call Write(0, .source(n), 6, .status);
	call Write(0, .(' DISK, THEN TYPE (CR)'), 21, .status);
	call Read(1, .buf, 128, .actual, .status);
end;
end;
idisk.plm
idisk: do;
$include(idisk.ipx)
declare copyright(*) byte data('(C) 1976,1977,1978,1979,1980,1981,1982 INTEL CORP'),
    version(*) byte data(4, 0, 'program_version_number=', 1, 'V4.3W', 0);
/*
    the code block below is loaded into isis.t0 on non system disks to print a message
    the corresponding asm code is

        ASEG
        org 3000h

        in  79h
        in  7Bh
    L3004:  in  0FFh
        ani 2
        jnz L3004
        lxi h, Msg
        mvi b, 32
    L3010:  mov c, m
        call    0F809h  ; CO
        inx h
        dcr b
        jnz L3010
        rst 0
    Msg:    db  0Dh, 0Ah
        db  'NON-SYSTEM DISK, TRY ANOTHER'
        db  0Dh, 0Ah
        end
*/
declare codeBlock(*) byte data(0DBh, 79h, 0DBh, 7Bh, 0DBh, 0FFh, 0E6h, 2,
                   0C2h, 4, 30h, 21h, 1Ah, 30h, 6, 20h, 4Eh,
                   0CDh, 9, 0F8h, 23h, 5, 0C2h, 10h, 30h, 0C7h,
                   CR, LF, 'NON-SYSTEM DISK, TRY ANOTHER', CR, LF);

declare memSize address;
declare actual address;
declare pn(12) byte;
declare buffer$ptr address, char based buffer$ptr byte;
declare (i, j, k) address; /* j, k no longer used !! */
declare (fileNumber, hadPrint) byte;
declare next address;
declare w5933 address;
declare (system, first, copy) bool;
declare (aftIn, aftOut, dirAft) address;
declare status address;
declare attributeList(*) byte data(1, 2, 4);    /* no longer used */
declare tracks byte;
declare (srcDisk, targetDisk) byte;
declare unused address;
declare diskType byte public;
declare fmtTable(10) structure(t0Interleave byte, t1Interleave byte, interleave  byte,
                  tracks address, bitmapSize address, labBlkSize address)
        initial(0,  0, 0,   0,     0,    0, /* controller not present */
                1,  4, 5,  76,  200h,  80h, /* 2 board DD */
                1, 12, 6,  76,  100h,  80h, /* 2 board SD */
                1, 12, 6,  76,  100h,  80h, /* integrated SD */
                7, 16, 9, 199,  4570,  251, /* 2 board HD */
                0,  0, 0,   0,     0,    0, /* controller not present */
                0,  0, 0,   0,     0,    0, /* controller not present */
                1,  1, 1, 131,   512,  128, /* type 7? */
                0,  0, 0,   0,     0,    0, /* controller not present */
                1, 50,25, 212,  6490,  263  /* winchester */
        );
declare padding(32) byte;

declare confirmMsg(*) byte initial(
        'FORMATTING WILL DESTROY ALL FILES AND DATA ON DEVICE :F*:', CR, LF,
        ' DO YOU WANT TO CONTINUE? ');
declare file(8) structure(name(13) byte)
    initial(':FX:ISIS.BIN ',
        ':FX:ISIS.T0  ',
        ':FX:ISIS.CLI ',
        ':FX:ISIS.OV0 ',
        ':FX:ISIS.MAP ',
        ':FX:ISIS.DIR ',
        ':FX:ISIS.LAB ',
        ':FX:ISIS.BAD ');
declare buffer(384) byte;

declare labBlk structure(name(9) byte,
             version(2) byte,
             leftOver(38) byte,
             crlf(2) byte,
                 fmtTable(1) byte) at (.buffer);
declare singleDrive bool public;
declare info based next structure(length address, offset address, begin address);


Initialize: procedure;
    if diskType = 9 then    /* winchester is quiet and takes a long time */
        call Write(CONSOLE$OUTPUT, .(' FORMATTING ...', CR, LF), 17, .status);
    call FormatTrack(targetDisk, 0, 0, labBlk.fmtTable(0) - '0');
    call FormatTrack(targetDisk, 1, 1, labBlk.fmtTable(1) - '0');
    call FormatTrack(targetDisk, 2, tracks, labBlk.fmtTable(2) - '0');
    mapBase = .MEMORY;
    unused = SetupMap(targetDisk) + 44;
    call WriteDirectory(targetDisk);
    file(6).name(2) = targetDisk + '0';
    call Open(.aftOut, .file(6), UPDATE$MODE, 0, .status);
    call SFileError(status, .file(6));
    call MoveAscii(.labBlk, .pn + 1, 9);
    call Write(aftOut, .labBlk, fmtTable(diskType).labBlkSize, .status);
    call SFileError(status, .file(6));
    call Close(aftOut, .status);
    call SFileError(status, .file(6));
end;


entry:
    call Read(CONSOLE$INPUT, .buffer, size(buffer), .actual, .status);
    buffer(actual) = CR;
    call ForceUpper(.buffer);
    bufferPtr = Deblank(.buffer);
    call Spath(bufferPtr, .pn, .status);
    if (diskType := pn(11)) = 5 or 6 then   /* 6 is pointless as it does not impact test */
        status = 0ECh;
    if pn(11) = 8 then
        status = 3Dh;
    call FileError(status, bufferPtr, TRUE);
    targetDisk = TestRange(pn(0), bufferPtr);
    srcDisk = 0;
    system = 0;
    singleDrive = 0;
    bufferPtr = Deblank(Delimit(bufferPtr));

    do while char <> CR;
        if char = 'P' then
            singleDrive = TRUE;
        else if char = 'S' then
            system = TRUE;
        else if Seq(bufferPtr, .('FROM '), 5) then
        do;
            bufferPtr = Deblank(bufferPtr + 5);
            if (srcDisk := char - '0') > 9 then
                call FileError(UNRECOG$SWITCH, bufferptr, TRUE);

        end;
        else if char <> '$' then
            call FileError(UNRECOG$SWITCH, bufferPtr, TRUE);
        bufferPtr = Deblank(bufferPtr + 1);
    end;
    if srcDisk = targetDisk then
        singleDrive = TRUE;
    if targetDIsk = 0 and diskType = 9 and not system then
    do;
        call Write(0, .('NON-SYSTEM WINCHESTER DRIVE 0 NOT ALLOWED', CR, LF), 2Bh, .status);
        call Exit;
    end;
    if diskType = 9 then
    do;
        call NumOut(targetDisk, 10, 0, .confirmMsg + 55, 1);
        call Write(CONSOLE$OUTPUT, .confirmMsg, 85, .status);
        call Read(CONSOLE$INPUT, .buffer, size(buffer), .actual, .status);
        buffer(actual) = CR;
        call ForceUpper(.buffer);
        if buffer(0) <> 'Y' then
            call Exit;
    end;
    file(6).name(2) = srcDisk + '0';
    call Open(.aftIn, .file(6), 1, 0, .status);
    call FileError(status, .file(6), TRUE);
    call Read(aftIn, .buffer, 263, .actual, .status);
    call FileError(status, .file(6), TRUE);
    call Close(aftIn, .status);
    call FileError(status, .file(6), TRUE);
    tracks = fmtTable(diskType).tracks;
    labBlk.fmtTable(0) = fmtTable(diskType).t0Interleave + '0';
    labBlk.fmtTable(1) = fmtTable(diskType).t1Interleave + '0';
    do i = 2 to tracks;
        labBlk.fmtTable(i) = fmtTable(diskType).interleave + '0';
    end;

    if system then
    do;
        call Write(0, .('SYSTEM DISK', CR, LF), 13, .status);
        first = TRUE;
        next = fmtTable(diskType).bitmapSize + .MEMORY;
        memSize = Memck - next;
        fileNumber = 0;
        hadPrint = 0;
        info.offset, i = 0;
        do while fileNumber < 4;
            memSize = memSize - 8;
            file(fileNumber).name(2) = srcDisk + '0';
            call Open(.aftIn, .file(fileNumber), READ$MODE, 0, .status);
            call SFileError(status, .file(fileNumber));
            call Seek(aftIn, SEEK$ABS, .i, .info.offset, .status);
            call SFileError(status, .file(fileNumber));
            call Read(aftIn, .info.begin, memSize, .actual, .status);
            call SFileError(status, .file(fileNumber));
            call Close(aftIn, .status);
            call SFileError(status, .file(fileNumber));
            info.length = actual;
            next = .info.begin + actual;
            if fileNumber = 3 or (memSize := memSize - actual) < 8 then
            do;
                if singleDrive then
                    call GetDisk(2);

                if first then
                do;
                    call Initialize;
                    next = .MEMORY + fmtTable(diskType).bitmapSize;
                    first = FALSE;
                end;
                else
                    next = .MEMORY;

                do while hadPrint <= fileNumber;
                    file(hadPrint).name(2) = targetDisk + '0';
                    call Open(.aftOut, .file(hadPrint), UPDATE$MODE, 0, .status);
                    call SFileError(status, .file(hadPrint));
                    call Seek(aftOut, SEEK$ABS, .i, .info.offset, .status);
                    call SFileError(status, .file(hadPrint));
                    call Write(aftOut, .info.begin, info.length, .status);
                    call SFileError(status, .file(hadPrint));
                    call Close(aftOut, .status);
                    call SFileError(status, .file(hadPrint));
                    if hadPrint < fileNumber then
                        next = .info.begin + info.length;
                    hadPrint = hadPrint + 1;
                end;
                w5933 = info.offset + info.length;
                next = .MEMORY;
                if memSize = 0 then
                do;
                    hadPrint = fileNumber;
                    fileNumber = fileNumber - 1;
                    info.offset = w5933;
                end;
                else
                    info.offset = 0;

                memSize = Memck - next;
                if fileNumber + 1 < 4 and singleDrive then
                    call GetDisk(0);
            end;
            else
                info.offset = 0;
            fileNumber = fileNumber + 1;
        end;
    end;
    else
    do;
        call Write(0, .('NON-SYSTEM DISK', CR, LF), 17, .status);
        if singleDrive then
            call GetDisk(2);
        call Initialize;
        file(0).name(2) = targetDisk + '0';
        file(1).name(2) = targetDisk + '0';
        call Open(.aftOut, .file(1), UPDATE$MODE, 0, .status);
        call SFileError(status, .file(1));
        call Write(aftOut, .codeBlock, 3Ah, .status);   /* code to write non system disk */
        call SFileError(status, .file(1));
        call close(aftOut, .status);
        call SFileError(status, .file(1));
        call Delete(.file(0), .status);
    end;
    do i = 0 to 7;
        file(i).name(2) = targetDisk + '0';
        call Attrib(.file(i), 3, TRUE, .status);
    end;

    call Attrib(.file(2), 0, TRUE, .status);
    call Attrib(.file(2), 1, TRUE, .status);
    call Attrib(.file(3), 0, TRUE, .status);
    call Attrib(.file(3), 1, TRUE, .status);
    if singleDrive then
        call GetDisk(0);
    call Exit;
end;
isisutil_4.3w.pex
# common literals
TRUE            '0FFh'
FALSE           '0'
CR              '0Dh'
LF      '0Ah'
BELL            '7'
TAB             '9'
CONTROL$P	'10h'
FOREVER     'WHILE TRUE'


# my user types
pointer     'address'
bool        'byte'
wpointer    'address'
word        'address'

# typedefs
DCB$T	'STRUCTURE (iocw BYTE, ioins BYTE, nsec BYTE, tadr BYTE, sadr BYTE, buf ADDRESS)'
DIRECT$T 'structure(empty byte, file(9) byte, attrib byte, eof$count byte, blk address, hdrBlk address)'
CONFIG$T1   'slot byte, endslot byte, ctlId byte, dtype byte'
CONFIG$T2   'trk byte, sec byte, unitmap(4) byte, rdymsk(4) byte'
CONFIG$T 'STRUCTURE(CONFIG$T1,CONFIG$T2)'
WSTATUS$T 'structure(status(3) byte, cyl word, head byte, sector byte, aCyl word, ahead byte, aSec byte, retries byte)'
WWAKE$T 'structure(wake byte, reserved byte, ccb(2) address)'
WCCB$T 'structure(ccw1 byte, busy1 byte, cib(2) address, res word, ccw2 byte, busy2 byte, cp(2) address, cptr word)'
WCONTROL$T 'structure(res1 byte, opStatus byte, cmdSem byte, stSem byte, csa(2) address, iopb(2) address, res2(2) word)'
WDCB$T1 'reserved(2) word, actual(2) word, device word, unit byte, function byte, modifier word'
WDCB$T2 'cyl word, head byte, sector byte, buffer(2) address, count(2) word, gaptr(2) address'
WDCB$T 'STRUCTURE(WDCB$T1, WDCB$T2)';

# standard ISIS system calls
Attrib		P("pointer" path$p,"word" attrib,"word" on$off,"wpointer" status$p)
Close           P("word" conn,"wpointer" status$p)
Co          P(B char)
Consol		P(A ci$p,A co$p,A status$p)
Delete          P(A path$p,A status$p)
Error       P("word" errnum)
Exit        P
Isis            P(B type,A parameter$ptr)
Memck           P"pointer"
Open            P("wpointer" conn$p,"pointer" path$p,"word" access,"word" echo,"wpointer" status$p)
Read            P("word" conn,"pointer" buff$p,"word" count,"wpointer" actual$p,"wpointer" status$p)
Rename          P(A old$p,A new$p,A status$p)
Rescan		P(A conn,A status$p)
Seek            P(A conn,A mode,A block$p,A byte$p,A status$p)
Spath       P("pointer" path$p,"pointer" info$p,"wpointer" status$p)    
whocon		P(A conn,A buff$p)
Write           P(A conn,A buff$p,A count,A status$p)


F9DEV		'9'

# error codes
OK	'0'
NO$FREE$BUFFER	'1'
BAD$AFT$NO	'2'
AFT$FULL	'3'
BAD$PATH	'4'
BAD$DEVICE	'5'
CANT$WRITE	'6'
DISK$FULL	'7'
CANT$READ	'8'
DIRECTORY$FULL	'9'
DIFFERENT$DISK	'10'
MULTIDEFINED	'11'
ALREADY$OPEN	'12'
NO$SUCH$FILE	'13'
WRITE$PROTECT	'14'
ISIS$OVERWRITE	'15'
BAD$LOAD$FORMAT	'16'
NON$DISK$FILE	'17'
BAD$COMMAND	'18'
NON$DISK$SEEK	'19'
LONG$BACK$SEEK	'20'
CANT$RESCAN	'21'
ILLEGAL$ACCESS	'22'
NULL$FILENAME	'23'
DISK$IO$ERROR	'24'
BAD$ECHO	'25'
BAD$ATTRIB	'26'
BAD$SEEK$ARG	'27'
NULL$EXTENSION	'28'
CONSOLE$EOF	'29'
DRIVE$NOT$READY	'30'
SEEK$ON$WRITE	'31'
CANT$DELETE	'32'
ILLEGAL$PARAM	'33'
BAD$RETSW	'34'
SEEK$PAST$EOF	'35'
UNRECOG$SWITCH	'201'
UNRECOG$DELIM	'202'
INVALID$SYNTAX	'203'
EARLY$EOF	'204'
BAD$LABEL	'206'
NO$END$STAT	'207'
CHECKSUM$ERROR	'208'
RELO$SEQ$ERR	'209'
INSUFF$MEMORY	'210'
REC$TOO$LONG	'211'
BAD$REC$TYP	'212'
FIXUP$BOUNDS	'213'
BAD$PARAM	'214'
ARG$TOO$LONG	'215'
TOO$MANY$PARAMS	'216'
REC$TOO$SHORT	'217'
ILL$REC$FMT	'218'
PHASE$ERROR	'219'
NO$EOF		'220'
SEG$OVERFLOW	'221'
UNRECOG$REC	'222'
FIXUP$ERROR	'223'
ILL$REC$SEQ	'224'
BAD$MOD$NAME	'225'
LONG$MOD$NAME	'226'
NO$L$PAREN	'227'
NO$R$PAREN	'228'
UNRECOG$CONTROL	'229'
DUP$SYMBOL	'230'
FILE$EXISTS	'231'
UNRECOG$COM	'232'
NO$TO		'233'
DUP$FILE$NAME	'234'
NOT$LIB$FILE	'235'
TOO$MANY$CMNS	'236'
MISSING$COMMON	'237'
STACK$CONTENT	'238'
NO$MODHDR	'239'
OUT$OF$RANGE	'240'
INV$OBJ$FILE	'241'

# supported record types
RELOC$TYPE  '22h'
MODHDR$TYPE '2'
MODEND$TYPE '4'
CONTENT$TYPE    '6'
EOF$TYPE    '0eh'

ABS$SEG     '0'

# aftn for console devices
CONSOLE$OUTPUT  '0'
CONSOLE$INPUT   '1'

# open modes
READ$MODE	'1'
WRITE$MODE	'2'
UPDATE$MODE	'3'
OPEN$FOR$READ   '1'
OPEN$FOR$WRITE  '2'
NO$LINE$EDIT    '0'

# seek modes
SEEK$RETURN	'0'
SEEK$ABS	'2'

# public variables
direct		"DIRECT$T"
directINO	A
diskType        B
mapBase         A
maskArray       BS
singleDrive	B

# winchester modes
WININIT     '0'
WINSTATUS   '1'
WINFORMAT   '2'
WINREADID   '3'
WINREAD     '4'
WINREADBUF  '5'
WINWRITE    '6'
WINWRITEBUF '7'
WINSEEK     '8'
WINDIAG     '15'

# public procedures
Absio           P(B cmd,B disk,A block,A buffer)
ClearBuffer     P(A buf$ptr)
Deblank     P("pointer" ptr)"pointer"
Delimit     P("pointer" ptr)"pointer"
Diskio          P(A disk,A dcb$p)
FileError   P("word" status,"pointer" ptr,"bool" fatal)
FlushBlock      P(A adr)
ForceUpper  P("pointer" ptr)
FormatTrack     P(B disk,A sTrack,A eTrack,B interleave)
GetDisk         P(B n)
MoveAscii   P("pointer" dst,"pointer" src,B cnt)
NumOut      P("word" val,B base,B lc,"pointer" buf,B width)
Path        P("pointer" filename,"pointer" pn)B
ReportError P("word" errNum)
ScanInteger P("pointer" buf$p)"word"
Seq     P("pointer" str1,"pointer" str2,B cnt)"bool"
SetBlock        P(A adr)
SetupMap   P(B disk)A
SFileError      P(A status,A name$p)
StrtWD      P("pointer" wiopb$p)
StatWD      PB
TestRange       P(B device,A buffer$p)B
unpath		P(A int, A ext)
UpperCase       P(B char)B
WDelimit    P("pointer" ptr)"pointer"
WDiskIo          P(A wiopb$p, "wpointer" status$p)
WriteDirectory  P(B disk)
Ypath		P(A int,A ext)

mvasci.plm
MOVEASCII: DO;
MoveAscii: procedure(dst, src, cnt) public;
    declare (dst, src) address, cnt byte, i byte;
    declare dch based dst (1) byte, sch based src (1) byte;

    do i = 0 to cnt - 1;
        dch(i) = sch(i);
    end;
end;
end;
numout.plm
numout: do;
declare digits(*) byte data('0123456789ABCDEF');

NumOut: procedure(value, base, lc, bufAdr, width) public;
	declare (value, bufAdr) address, (base, lc, width) byte;
	declare i byte;
	declare buf based bufAdr (1) byte;

	do i = 1 to width;
		buf(width - i) = digits(value mod base);
		value = value / base;
	end;

	i = 0;
	do while buf(i) = '0' and i < width - 1;
		buf(i) = lc;
		i = i + 1;
	end;
end;
end;
rpterr.plm
ReportError: do;
$include(rpterr.ipx)
declare msg(*) byte DATA(0, 0,
	2, 'ILLEGAL AFTN ARGUMENT', 0,
	4, 'INCORRECTLY SPECIFIED FILE', 0,
	5, 'UNRECOGNIZED DEVICE NAME', 0,
	6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
	8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
	9, 'DISK DIRECTORY FULL', 0,
	0AH, 'NOT ON SAME DISK', 0,
	0BH, 'FILE ALREADY EXISTS', 0,
	0CH, 'FILE IS ALREADY OPEN', 0,
	0DH, 'NO SUCH FILE', 0,
	0EH, 'WRITE PROTECTED', 0,
	11H, 'NOT A DISK FILE', 0,
	12H, 'ILLEGAL ISIS COMMAND', 0,
	13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
	14H, 'ATTEMPTED BACK SEEK TOO FAR', 0,
	15H, 'CAN', 27H, 'T RESCAN', 0,
	16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
	17H, 'MISSING FILENAME', 0,
	19H, 'ILLEGAL ECHO FILE', 0,
	1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
	1BH, 'ILLEGAL SEEK COMMAND', 0,
	1CH, 'MISSING EXTENSION', 0,
	1FH, 'CAN', 27H, 'T SEEK ON WRITE ONLY FILE', 0,
	20H, 'CAN', 27H, 'T DELETE OPEN FILE', 0,
	23H, 'SEEK PAST EOF', 0,
	0C9H, 'UNRECOGNIZED SWITCH', 0,
	0CAH, 'UNRECOGNIZED DELIMITER', 0,
	0CBH, 'INVALID SYNTAX', 0,
	0CCH, 'PREMATURE EOF', 0,
	0CEH, 'ILLEGAL DISKETTE LABEL', 0,
	0D0H, 'CHECKSUM ERROR', 0,
	0D1H, 'RELO FILE SEQUENCE ERROR', 0,
	0D2H, 'INSUFFICIENT MEMORY', 0,
	0D3H, 'RECORD TOO LONG', 0,
	0D4H, 'ILLEGAL RELO RECORD', 0,
	0D5H, 'FIXUP BOUNDS ERROR', 0,
	0D6H, 'ILLEGAL SUBMIT PARAMETER', 0,
	0D7H, 'ARGUMENT TOO LONG', 0,
	0D8H, 'TOO MANY PARAMETERS', 0,
	0D9H, 'OBJECT RECORD TOO SHORT', 0,
	0DAH, 'ILLEGAL RECORD FORMAT', 0,
	0DBH, 'PHASE ERROR', 0,
	0EAH, 'CANNOT FORMAT FROM TARGET DRIVE', 0,
	0EBH, 'NON-DISK DEVICE', 0,
	3DH, 'UNASSIGNED DEVICE', 0,
	0ECH, 'ILLEGAL FORMAT ON REMOTE DEVICE', 0
	);

ReportError: procedure(errNum) public;
	declare errNum address;
	declare numberBuffer(3) byte, i address, status address;


	if errNum <> 0 then
	do;
		i = 0;
		do while i < size(msg);
			if errNum = msg(i) and msg(i + 1) <> 0 then
			do;
				i = i + 1;
				call write(0, .(' '), 1, .status);
				do while msg(i) <> 0;
					call write(0, .msg(i), 1, .status);
					i = i + 1;
				end;
				call write(0, .(CR, LF), 2, .status);
				return;
			end;
			else
			do;
				do while msg(i) <> 0;
					i = i + 1;
				end;
				i = i + 1;
			end;
		end;
	call error(errNum);
	end;
end;
end;
seq.plm
Seq: do;
$include(seq.ipx)

Seq: procedure(s1, s2, len) bool public;
	declare (s1,s2) address, len byte;
	declare chrs1 based s1(1) byte;
	declare chrs2 based s2(1) byte;
	declare i byte;
	len = len - 1;
	do i = 0 to len;
		if chrs1(i) <> chrs2(i) then
			return FALSE;
	end;
	return TRUE;
end;
end;

serror.plm
SFileError: do;
$include(serror.ipx)

declare singleDrive bool external;
SFileError: procedure(status, name$p) public;
	declare (status, name$p) address;
	declare lStatus address;

	if status <> 0 then
	do;
		if singleDrive then
			call GetDisk(0);
		name$p = Deblank(name$p);
		call Write(0, .(' '), 1, .lStatus);
		call Write(0, name$p, WDelimit(name$p) - name$p, .lStatus);
		call Write(0, .(','), 1, .lStatus);
		call ReportError(status);
		call Exit;
	end;
end;
end;
setblk.plm
SetBlock: do;
$include(setblk.ipx)
declare mapBase address external;
SetBlock: procedure(adr) public;
	declare adr address;
	declare (bit, byt) address, spt byte;
	declare bitmap based mapBase (1) byte;

	if diskType = 9 then
		spt = 210;
	else if diskType = 1 then
		spt = 52;
	else
		spt = 26;

	byt = shr(bit := double(high(adr)) * spt + low(adr) - 1, 3);
	bitmap(byt) = bitmap(byt) or maskArray(low(bit) and 7);
end;
end;
setmap.plm
SetupMap: do;
$include(setmap.ipx)

declare fatalMsg(*) byte initial(' FATAL',
/* 6 */		               ' BAD SPOT AT LOGICAL ADDRESS ( ',
/* 37 */		       '***, ',
/* 42 */		       '*** ), STATUS = ',
/* 58 */		       '****', CR, LF);

declare trap0B structure(jmp byte, target address) at (0bh),
	trap0E address at (0eh);

declare bitmap based mapBase (1) byte;

SetupMap: procedure(disk) address public;
	declare disk byte;
	declare logicalTrackSector address,
		(logicalSector, logicalTrack) byte at (.logicalTrackSector),
		(readBuf, savedSP) address,
		savedTrap0B structure(jmp byte, target address),
		(badSectorCount, headFixItemPtr, nextFixItemPtr, fixItemPtr) address,
		j byte, (i, bitmapLast, status) address;
	declare fixItem based fixItemPtr structure(sector byte, driveErr address, next address);

    declare trap0BCodeLocation address data(.newTrap0B);    /* used for error intercept handler */

	ChkFixedSectors: procedure;
		if (logicalTrack = 0 and (logicalSector < 1Ch or logicalSector = 58h
                                  or logicalSector = 97h or logicalSector > 0A5h))
		  or (logicalTrack = 1 and (logicalSector < 40h or (48h < logicalSector and logicalSector < 88h)
                                    or logicalSector = 0AFh))
		  or (logicalTrack = 2 and logicalSector < 2Eh) then
		do;
			call NumOut(logicalTrack, 10, 0, .fatalMsg(37), 3);
			call NumOut(logicalSector, 10, 0, .fatalMsg(42), 3);
			call NumOut(trap0E, 16, 0, .fatalMsg(58), 4);
			call Write(0, .fatalMsg, 64, .status);
			call Exit;
		end;
	end;


	AddBadSector: procedure;
		declare (p, q) address;
		call ChkFixedSectors;
		call SetBlock(logicalTrackSector);
		fixItemPtr, p = headFixItemPtr;
		fixItemPtr = fixItem.next;

		/* look for insert point p->sector <  logicalsector and logicalsector <= *fixItemPtr */
		do while fixItem.sector < logicalSector;
			p = fixItemPtr;
			fixItemPtr = fixItem.next;
		end;
		if fixItem.sector = logicalSector then	/* already in list */
			return;

		q = fixItemPtr;				/* insert into list and set values */
		fixItemPtr = p;
		fixItem.next = nextFixItemPtr;
		fixItemPtr = nextFixItemPtr;
		fixItem.sector = logicalSector;
		fixItem.driveErr = trap0E;
		fixItem.next = q;
		nextFixItemPtr = nextFixItemPtr + size(fixItem);	/* set up next item */
	end;


	if diskType = 9 then	/* WD */
		bitmapLast = 15FFh;
	else if diskType = 1 then	/* DD */
		bitmapLast = 1FFh;
	else
		bitmapLast = 0FFh;	/* SD */

	do i = 0 to bitmapLast;
		bitmap(i) = 0;
	end;

	if diskType <> 9 then
		return 0;
    call Write(CONSOLE$OUTPUT, .(' CHECK READ ... ', CR, LF), 18, .status);
    
	badSectorCount = 0;
	headFixItemPtr = (readBuf := mapBase + 1600h) + 128;
	savedSP = STACKPTR;
	savedTrap0B.jmp = trap0B.jmp;
	trap0B.jmp = 0c3h;
	savedTrap0B.target = trap0B.target;
	trap0B.target = trap0BCodeLocation;
	logicalTrack = 0;

nextTrack:
	fixItemPtr = headFixItemPtr;
	fixItem.next = fixItemPtr + size(fixItem);
	fixItemPtr = headFixItemPtr + size(fixItem);
	fixItem.sector = 211;	/* max sector + 1 */
	nextFixItemPtr = fixItemPtr + size(fixItem);
	logicalSector = 1;

nextSector:
	call Absio(4, disk, logicalTrackSector, readBuf);
	goto skipTrap;

newTrap0B:
	STACKPTR = savedSP;
	trap0B.jmp = savedTrap0B.jmp;
	trap0B.target = savedTrap0B.target;
	if (trap0E and 40h)  <> 40h and (trap0E and 1Fh) <> 9 and (trap0E and 1Fh) <> 1 then
		call AddBadSector;
	else
	do;
		/* mark all of the track under this head as bad */
		logicalSector = (logicalSector - 1) - ((logicalSector - 1) mod 70);	/* first sector for head */
		do j = 1 to 70;
			logicalSector = logicalSector + 1;
			call AddBadSector;
		end;
	end;

	trap0B.jmp = 0c3h;
	trap0B.target = trap0BCodeLocation;

skipTrap:
	if (logicalSector := logicalSector + 1) < 211 then
		goto nextSector;

	fixItemPtr = headFixItemPtr;
	fixItemPtr = fixItem.next;

	do while fixItem.sector < 211;
		call NumOut(logicalTrack, 10, 0, .fatalMsg(37), 3);
		call NumOut(fixItem.sector, 10, 0, .fatalMsg(42), 3);
		call NumOut(fixItem.driveErr, 16, 0, .fatalMsg(58), 4);
		call Write(0, .fatalMsg(6), 58, .status);
		if logicalTrack > 1 then
			badSectorCount = badSectorCount + 1;
		fixItemPtr = fixItem.next;
	end;
	if (logicalTrack := logicalTrack + 1) < 212 then
		goto nextTrack;

	trap0B.jmp = savedTrap0B.jmp;
	trap0B.target = savedTrap0B.target;
	return badSectorCount;
end;
end;
trange.plm
TestRange: do;
$include(trange.ipx)
TestRange: procedure(device, buffer$p) byte public;
	declare device byte, buffer$p address;

	if device >= 25 then	/* diskdrive 6-9 */
		device = device - 19;	/* bring disks together */
	else if device > 5 then		/* shift others above disks */
		device = device + 4;

	if device <=  9 or buffer$p = 1 then
		return device;
	if buffer$p <> 0 then
		call FileError(0EBh, buffer$p, TRUE);
	else
	do;
		call ReportError(0EBh);
		call exit;
	end;
end;
end;
ucase.plm
UpperCase: do;
UpperCase: procedure(char) byte public;
	declare char byte;
	if char < 'a' then
		return char;
	if char > 'z' then
		return char;
	return char and 0dfh;
end;
end;
wd.plm
WriteDirectory: do;
$include(wd.ipx)
declare mapBase address external;
declare bitmap based mapBase (1) byte;

declare file(6) structure(name(9) byte) data('ISIS',0,0,'DIR',
					     'ISIS',0,0,'MAP',
					     'ISIS',0,0,'T0',0,
					     'ISIS',0,0,'BIN',
					     'ISIS',0,0,'LAB',
					     'ISIS',0,0,'BAD');

WriteDirectory: procedure(disk) public;
	declare	disk byte, binIdx byte, i byte, jj address, dirBuf(64) address,
		direct(8) structure(empty byte, file(9) byte, attrib byte,
				    eof$count byte, blk address, hdrBlk address) at(.dirBuf),
		countBitMapSectors byte, binHdrBlk address, countDirSectors byte;

	SetLinks: procedure(start, count, firstBlock);
		declare (start, count, firstBlock, ii) address;

		do ii = 0 to count - 1;
			dirBuf(start + ii) = firstBlock + ii;
			call setBlock(firstBlock + ii);
		end;
	end;

	FlushBlock: procedure(adr);
		declare adr address;

		call Absio(6, disk, adr, .dirBuf);
		call SetBlock(adr);
		call ClearBuffer(.dirBuf);
	end;

	countDirSectors =  25;
	if diskType = 1 then
	do;
		countBitMapSectors = 4;
		binHdrBlk = 206h;
	end;
	else if diskType = 9 then
	do;
		countBitMapSectors = 44;
		binHdrBlk = 22Eh;
		countDirSectors = 62;
	end;
	else
	do;
		countBitMapSectors = 2;
		binHdrBlk = 204h;
	end;

	jj = .bitmap - 128;
	if diskType = 9 then
		do i = 0 to countBitMapSectors - 1;
			call Absio(6, disk, i + 0A7h, (jj := jj + 128));
		end;
	/* set linkage for isis.t0 */
	call ClearBuffer(.dirBuf);
	call SetLinks(2, 23, 1);
	call FlushBlock(18h);		
	/* set linkage for isis.lab */
	if diskType = 9 then		/* hard disk */
	do;
		dirBuf(1) = 58h;	/* next linkage is sector 58h */
		call SetLinks(2, 3Eh, 1Ah);	/* first part of isis.lab */ 
	end;
	else if diskType = 1 then
	do;
		call SetLinks(2, 27, 1Ah);	/* allocate 53 blocks in 2 groups */
		call SetLinks(1Dh, 26, 11Bh);
	end;
	else
		call SetLinks(2, 1, 1Ah);	/* allocate 1 block */

	call FlushBlock(19h);		/* write label linkage */
	if diskType = 9 then
	do;
		dirBuf(0) = 19h;	/* link to previous */
        dirBuf(1) = 97h;    /* link to next */
		call SetLinks(2, 3Eh, 59h);
		call FlushBlock(58h);	/* write label linkage */
		dirBuf(0) = 58h;	/* link to previous */
        dirBuf(1) = 1AFh;   /* link to next */
		call SetLinks(2, 0Eh, 98h);
		call SetLinks(10h, 9, 140h);
		call SetLinks(19h, 27h, 188h);
		call FlushBlock(97h);	/* write label linkage */
        dirBuf(0) = 97h;
		call SetLinks(2, 23h, 1B0h);
		call FlushBlock(1AFh);	/* write label linkage */
	end;
	/* set linkage for isis.bad for hd only */
	if diskType = 9 then
	do;
		call SetLinks(2, countBitMapSectors, 0A7h);
		call FlushBlock(0A6h);
	end;

	/* set linkage for isis.dir */
	call SetLinks(2, countDirSectors, 102h);
	if diskType = 9 then
		dirBuf(1) = 149h;	/* link to next */
	call FlushBlock(101h);
	if diskType = 9 then
	do;
		dirBuf(0) = 101h;	/* link to previous */
		call SetLinks(2, countDirSectors, 14Ah);
		call FlushBlock(149h);
	end;

	/* set linkage for isis.map */
	call SetLinks(2, countBitMapSectors, 202h);
	call FlushBlock(201h);
	call FlushBlock(binHdrBlk);

	/* isis.dir */
	call MoveAscii(.direct(0).file, .file(0), 9);
	if diskType = 9 then
		direct(0).blk = 124;	/* larger size */
	else
		direct(0).blk = 25;

	direct(0).hdrBlk = 101h;	/* linkage at t1 s1 */
	direct(0).attrib = 1;
	direct(0).eof$count = 128;

	/* isis.map */
	call MoveAscii(.direct(1).file, .file(1), 9);
	direct(1).blk = countBitMapSectors;
	direct(1).hdrBlk = 201h;	/* linkage at t2 s1 */
	direct(1).attrib = 1;
	direct(1).eof$count = 128;

	/* isis.t0 */
	call MoveAscii(.direct(2).file, .file(2), 9);
	direct(2).blk = 17h;
	direct(2).hdrBlk = 18h;		/* linkage at t0 s24 */
	direct(2).attrib = 1;
	direct(2).eof$count = 128;

	/* isis.lab */
	call MoveAscii(.direct(3).file, .file(4), 9);
	if diskType = 1 then
		direct(3).blk = 35h;
	else if diskType = 9 then
        direct(3).blk = 0DDh;
    else
		direct(3).blk = 1;
	direct(3).hdrBlk = 19h;		/* linkage at t0 s25 */
	direct(3).attrib = 1;
	direct(3).eof$count = 128;

	/* isis.bad */
	if diskType = 9 then
	do;
		call MoveAscii(.direct(4).file, .file(5), 9);
		direct(4).blk = countBitMapSectors;
		direct(4).hdrBlk = 0A6h;
		direct(4).attrib = 1;
		direct(4).eof$count = 128;
		binIdx = 5;
	end;
	else
		binIdx = 4;

	/* isis.bin */
	call MoveAscii(.direct(binIdx).file, .file(3), 9);
	direct(binIdx).hdrBlk = binHdrBlk;
	direct(binIdx).attrib = 3;
	direct(binIdx).eof$count = 128;

	/* flag as no further entries */
	do i = binIdx + 1 to 7;
		direct(i).empty = 7fh;
	end;

	call FlushBlock(102h);
	do i = 0 to 7;
		direct(i).empty = 7fh;
	end;

	do i = 1 to countDirSectors - 1;
		call Absio(6, disk, 102h + i, .dirBuf);
	end;

	if diskType = 9 then
		do i = 0 to countDirSectors - 1;
			call Absio(6, disk, 14Ah + i, .dirBuf);
		end;

	jj = .bitmap - 128;
	do i = 0 to countBitMapSectors - 1;
		call Absio(6, disk, 202h + i, (jj := jj + 128));
	end;
end;
end;

wdelim.plm
WDelimit: do;
WDelimit: procedure(ptr) address public;
	declare ptr address;
	declare ch based ptr byte;

	do while (ch = ':' or ch = '.' or ch = '*' or ch = '?' or
		  ('0' <= ch and ch <= '9') or ('A' <= ch and ch <= 'Z'));
		ptr = ptr + 1;
	end;
	return ptr;
end;
end;
wdisk.asm
    name    wdisk
    aseg
; declare the winchester interface structure locations
    org 44h
wiSBuf: ds  12
wiWake: ds  6 
wiCcb:  ds  16
wiCtlb: ds  16
wiIopb: ds  30

    cseg

dkstat:
    lda wiCtlb+3        ; read the status semaphore
    ana a
    jz  dk1
    mvi a,4             ; flag as complete
dk1:
    ori 1
    ret

    public  StatWD
StatWD:
    lda wiCtlb+1        ; op status
    ani 40h
    rz
    lxi     h,wiSbuf    ; read in the status buffer
    shld    wiIopb+18   ; buffer (low address)
    mvi     a,1         ; transfer status
    sta     wiIopb+11    ; function
    lxi     b,wiIopb
    call    StrtWD
    lda     wiSbuf+2    ; read status byte 2
    ani     38h         ; drive fault, id field ecc error, data field ecc error
    rlc                 ; * 4
    rlc
    mov     b,a
    lhld    wiSbuf      ; status bytes 0 & 1
    mov     a,l         ; status byte 0
    ani     0f8h
    mov     l,a
    lda     wiSbuf+2    ; status byte 2
    ani     0c0h        ; merge top 2 bits as low 2 bits of status byte 0
    rlc
    rlc
    ora     l
    mov     l,a
; at this point
; hl has from high to low bit
; write protect, unit not ready, invalid address, sector not found,
; invalid  function, no index, diagnostic fault, illegal sector size
; end of medium, illegal format type, seek in progress, isbc rom error
; isbc ram error, 0, seek error, cylinder address miscompare
; and b has from high to low bit
; drive fault, id field ecc error, data field ecc error

    mvi     c,10h
stat1:
    mvi     a,80h       ; find first set bit
    ana     h
    jnz     stat2
    dad     h
    dcr     c
    jnz     stat1
stat2:
    mov     a,c
    ora     b
    ret


    public StrtWD
StrtWD:
    mov     a,c
    sta     wiCtlb+8        ; save iopb
    mov     a,b
    sta     wiCtlb+9
    xra     a
    sta     wiCtlb+3        ; reset the status sepahore
    mvi     a,1             ; wake up the controller
    out     5

strt1:
    call    dkstat          ; wait till done
    ani     4
    jz      strt1
    ret

    end
    
