absio.plm
Absio: do;
$include(absio.ipx)
Absio: procedure(cmd, disk, block, buffer) public;
    declare (cmd, disk) byte, (block, buffer) address;
    declare dcb DCB$T;

    dcb.iocw = 80H;
    dcb.ioins = cmd;
    dcb.nsec = 1;
    dcb.tadr = high(block);
    dcb.sadr = low(block);
    dcb.buf = buffer;
    call Diskio(disk, .dcb);
end;
end;
alloc.plm
alloc: do;
declare maskArray(8) byte public data(80h, 40h, 20h, 10h, 8, 4, 2, 1);
declare mapBase address public;
end;
clbuf.plm
ClearBuffer: do;
ClearBuffer: procedure(buf$ptr) public;
    declare buf$ptr address, i byte;
    declare buf based buf$ptr (1) byte;


    do i = 0 to 127;
        buf(i) = 0;
    end;
end;
end;
altmap.plm
altmap: do;
$include(altmap.ipx)

declare copyRight(*) byte data('(C) 1975,1976,1977,1978,1979,1980,1981 INTEL CORP');
declare version(*) byte data(4, 0, 'program_version_number=', 1, 'V4.2W', 0);

/* disk dimensioning info */
declare maxCyl word data(522);
declare maxUsrCyl word data(511);
declare minAltCyl word data(512);
declare CYL$BAD literally '523',    /* bad track info cylinder */
        CYL$ALT literally '522',    /* alt track info cylinder */
        CYL$DIAG literally '524',   /* diagnostic cylinder */
        INFOSIG literally '0ABCDh';

/*
    messages collected here to allow size(msg) to be used
    could have been put in line but would require manual size calculation
*/

declare help1(*) byte data(CR, LF,
                ' IF THE BAD/ALTERNATE TRACK MAPS FOR THIS DISK HAVE NEVER BEEN INITIALIZED:', CR, LF);
declare help11(*) byte data('  1. USE THE MARK COMMAND TO DEFINE THE BAD TRACKS.', CR, LF);
declare help12(*) byte data('  2. USE THE AUTO COMMAND TO DEFINE THE ALTERNATE TRACKS.', CR, LF);
declare help13(*) byte data('  3. USE THE INIT COMMAND TO INITIALIZE THE BAD/ALTERNATE MAP AREAS ON', CR, LF);
declare help13a(*) byte data('     THE DISK.', CR, LF);
declare help14(*) byte data('  4. USE THE WRITE COMMAND TO WRITE THE BAD/ALTERNATE MAPS ON THE DISK', CR, LF);
declare help15(*) byte data('  5. USE THE EXIT COMMAND TO RETURN TO ISIS.', CR, LF, CR, LF);
declare help2(*) byte data(' IF THE BAD/ALTERNATE TRACK MAPS FOR THIS DISK HAVE ALREADY BEEN INITIALIZED:', CR, LF);
declare help21(*) byte data('  1. USE THE READ COMMAND TO READ THE BAD AND ALTERNATE TRACKS.', CR, LF);
declare help22(*) byte data('  2. USE THE MARK/FREE COMMANDS TO CHANGE THE MAPS.', CR, LF);
declare help23(*) byte data('  3. USE THE WRITE COMMAND TO REWRITE THE BAD/ALTERNATE MAPS ON THE DISK', CR, LF);
declare help24(*) byte data('  4. USE THE EXIT COMMAND TO RETURN TO ISIS.', CR, LF, CR, LF);
declare help3(*) byte data(' VALID COMMANDS: AUTO, COUNT, EXIT, FREE, INIT, LIST, MARK, QUIT, READ, WRITE',
                           CR, LF, CR, LF);
declare aCannotReadBad(*) byte data(' CANNOT READ DEFECTIVE TRACK MAP', CR, LF);
declare altMapMismatch(*) byte data(' ALTERNATE TRACK MAP DOES NOT MATCH DEFECTIVE TRACK MAP', CR, LF);
declare aCannotReadAlt(*) byte data(' CANNOT READ ALTERNATE TRACK MAP', CR, LF);
declare confirmWriteBad(*) byte data('THIS COMMAND CHANGES THE DEFECTIVE TRACK MAP', CR, LF,
                                     ' DO YOU WANT TO CONTINUE (Y/N)? ');
declare badMapWritten(*) byte data(' DEFECTIVE TRACK MAP CHANGES RECORDED', CR, LF);
declare partialAltMap(*) byte data(' ALTERNATE TRACKS NOT COMPLETELY SPECIFIED', CR, LF);
declare confirmWriteAlt(*) byte data('THIS COMMAND CHANGES THE ALTERNATE TRACK MAP', CR, LF,
                                       ' DO YOU WANT TO CONTINUE (Y/N)? ');
declare altMapWritten(*) byte data(' ALTERNATE TRACK MAP CHANGES RECORDED', CR, LF);
declare altMapTooBig(*) byte data(' ALTERNATE TRACKS EXCEEDED', CR, LF);
declare aListWritten(*) byte data(' LIST WRITTEN', CR, LF);
declare badDefCyl(*) byte data(' DEFECTIVE CYLINDER OUT OF RANGE', CR, LF);
declare badDefHead(*) byte data(' DEFECTIVE HEAD OUT OF RANGE', CR, LF);
declare badAltCyl(*) byte data(' ALTERNATE CYLINDER OUT OF RANGE', CR, LF);
declare badAltHead(*) byte data(' ALTERNATE HEAD OUT OF RANGE', CR, LF);
declare badAlternate(*) byte data(' DEFECTIVE ALTERNATE TRACKS MUST BE MAPPED TO "0 0"', CR, LF);
declare altProcessed(*) byte data(' ALTERNATE PROCESSED', CR, LF);
declare altAlreadyMarked(*) byte data(' TRACK ALREADY MARKED', CR, LF);
declare altInUse(*) byte data(' ALTERNATE TRACK IN USE', CR, LF);
declare altTrackBad(*) byte data(' ALTERNATE TRACK IS DEFECTIVE', CR, LF);
declare badTrackAlreadyAlt(*) byte data(' DEFECTIVE TRACK IN USE AS ALTERNATE', CR, LF);
declare aTrackProcessed(*) byte data(' TRACK PROCESSED', CR, LF);
declare noDefects(*) byte data(' NO DEFECTIVE TRACKS', CR, LF);
declare aTrackProcessed1(*) byte data(' TRACK PROCESSED', CR, LF);
declare aTrackFree(*) byte data(' TRACK ALREADY FREE', CR, LF);
declare signon(*) byte data('ISIS-II WINCHESTER DEFECTIVE TRACK MAPPER V1.2', CR, LF, CR, LF);
declare aA(*) byte data('A ');
declare winOnly(*) byte data(' USE ON WINCHESTER DISK SYSTEM ONLY', CR, LF);
declare checkingWin(*) byte data('CHECKING WINCHESTER CONTROLLER AND DRIVE...', CR, LF);
declare notResponding(*) byte data(' WINCHESTER CONTROLLER IS NOT RESPONDING.', CR, LF);
declare checkInserted(*) byte data('   CHECK TO BE SURE CONTROLLER IS INSERTED PROPERLY.', CR, LF);
declare failedRom(*) byte data(' WINCHESTER CONTROLLER FAILED ROM SELF-TEST DIAGNOSTIC.', CR, LF,
                                       '   REPLACE CONTROLLER.', CR, LF);
declare noDiagnostic(*) byte data(' CANNOT ACCESS WINCHESTER DISK FOR DIAGNOSTIC TEST.', CR, LF,
                                     '   CHECK WINCHESTER CABLES AND BE SURE WINCHESTER IS SPINNING.', CR, LF,
                                     '   IF THE WINCHESTER IS CONNECTED CORRECTLY AND THE DRIVE HAS NEVER ', CR, LF,
                                     '   BEEN FORMATTED, THE DIAGNOSTIC TRACK MAY NOT BE FORMATTED CORRECTLY.',
                                     CR, LF, CR, LF,
                                     '   DO YOU WANT TO FORMAT THE DIAGNOSTIC TRACK (Y/N)? ');
declare badController(*) byte data(' WINCHESTER CONTROLLER IS NOT COMMUNICATING CORRECTLY.', CR, LF,
                                       '   REPLACE CONTROLLER.', CR, LF);

declare aPrompt(*) byte data('*');
declare aHelp(*) byte data('HELP');
declare aMark(*) byte data('MARK');
declare aFree(*) byte data('FREE');
declare aExit(*) byte data('EXIT');
declare aQuit(*) byte data('QUIT');
declare notWritten(*) byte data('THE CURRENT BAD/ALTERNATE TRACK MAPS HAVE NOT BEEN WRITTEN ON DISK', CR, LF);
declare useWrite(*) byte data('  TO WRITE THE CHANGES ON DISK, YOU MUST USE THE WRITE COMMAND.', CR, LF, CR, LF);
declare exitNoWrite(*) byte data('DO YOU WANT TO EXIT WITHOUT WRITING THE MAPS ON DISK? ');
declare aInit(*) byte data('INIT');
declare confirmInit(*) byte data('INIT WILL REFORMAT THE MAP AREA ON THE DISK.', CR, LF,
                                     ' DO YOU WANT TO CONTINUE (Y/N)? ');
declare aRead(*) byte data('READ');
declare aWrite(*) byte data('WRITE');
declare aAuto(*) byte data('AUTO');
declare aCount(*) byte data('COUNT');
declare noDefects1(*) byte data(' NO DEFECTIVE TRACKS', CR, LF);
declare aList(*) byte data('LIST');
declare aCo(*) byte data(':CO: ', CR);
declare cannotList(*) byte data(' CANNOT LIST TO TARGET DRIVE', CR, LF);
declare emptyList(*) byte data(' NO DEFECTIVE TRACKS IN MEMORY BUFFER.', CR, LF,
                           ' TO LIST DEFECTIVE TRACKS RECORDED ON DISK, USE THE READ COMMAND BEFORE LIST.', CR, LF);
declare listOfDefects(*) byte data('LIST OF DEFECTIVE TRACKS IN MEMORY BUFFER.', CR, LF,
                           ' TO LIST DEFECTIVE TRACKS RECORDED ON DISK, USE THE READ COMMAND BEFORE LIST.', CR, LF);

/* local variables and modifiable messages */
                                /* modifier set to 1 all others cleared */
declare wiCcb WCCB$T at (56h);
declare wiopb WDCB$T initial(0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0);
declare actual word;
declare pad1(*) byte initial(' (***,**) ');
declare aftOut word;
declare altCyl word;
declare altHead byte;
declare pad2 word;
declare defectiveTracks(*) byte initial(' ***** DEFECTIVE TRACKS', CR, LF);
declare cmdBuf(128) byte;
declare cmdPtr pointer, cmdCh based cmdPtr byte;
declare queryBuf(128) byte;
declare dirty bool initial(FALSE);
declare pattern(128) byte;  /* used for diagnostics */
declare badCyl word;
declare badHead byte;
declare b64DB byte;     /* BUG this is never initialised */
declare diskType byte public initial(9);
declare diagTrackError(*) byte initial(' CANNOT FORMAT DIAGNOSTIC TRACK, DISK ERROR: **', CR, LF);
declare mapTrackError(*) byte initial(' CANNOT INITIALIZE MAP, DISK ERROR: **', CR, LF);
declare i byte;
declare mapping(*) byte initial(' ***,**:***,**', CR, LF);
declare subCmd byte;
declare (tokStart, scanPtr) pointer;
declare status word;
declare (badTrackInfo, altTrackInfo) (256) structure(cyl word, head byte, res byte);
declare (badTrackSig, badTrackCount) word at(.badTrackInfo) initial(0, 0);
declare (altTrackSig, altTrackCount) word at(.altTrackInfo) initial(0, 0);
declare fmtBuf(6) byte initial(0, 0c7h, 0c7h, 0c7h, 0c7h, 1);
declare pn(12) byte at(.MEMORY);


    Help: procedure;
        /* this and similar messages could have been written inline
           this way however allows the use of size(msg)
        */
        call Write(CONSOLE$OUTPUT, .help1, size(help1), .status);
        call Write(CONSOLE$OUTPUT, .help11, size(help11), .status);
        call Write(CONSOLE$OUTPUT, .help12, size(help12), .status);
        call Write(CONSOLE$OUTPUT, .help13, size(help13), .status);
        call Write(CONSOLE$OUTPUT, .help13a, size(help13a), .status);
        call Write(CONSOLE$OUTPUT, .help14, size(help14), .status);
        call Write(CONSOLE$OUTPUT, .help15, size(help15), .status);
        call Write(CONSOLE$OUTPUT, .help2, size(help2), .status);
        call Write(CONSOLE$OUTPUT, .help21, size(help21), .status);
        call Write(CONSOLE$OUTPUT, .help22, size(help22), .status);
        call Write(CONSOLE$OUTPUT, .help23, size(help23), .status);
        call Write(CONSOLE$OUTPUT, .help24, size(help24), .status);
        call Write(CONSOLE$OUTPUT, .help3, size(help3), .status);
    end;

    InitAltTrackMap: procedure;
        declare i word;

        altTrackSig = INFOSIG;
        altTrackCount = badTrackCount;
        do i = 0 to 254;
            altTrackInfo(i + 1).cyl = 0;
            altTrackInfo(i + 1).head = 0;
            altTrackInfo(i + 1).res = 0;
        end;
        if badTrackCount <> 0 then
            do i = 0 to badTrackCount - 1;
                altTrackInfo(i + 1).cyl = 0FFFFh;
                altTrackInfo(i + 1).head = 0FFh;
            end;
    end;

    InitBadTrackMap: procedure;
        declare i word;

        badTrackSig = INFOSIG;
        do i = (badTrackCount := 0) to 254;
            badTrackInfo(i + 1).cyl = 0;
            badTrackInfo(i + 1).head = 0;
            badTrackInfo(i + 1).res = 0;
        end;
        call InitAltTrackMap;
    end;

    ReadDefectiveTrackMap: procedure;
        declare i word;

        do i = 0 to 3;
            wiopb.function = WINREAD;
            wiopb.cyl = 523;        /* location of bad track info */
            wiopb.head = 4;
            wiopb.sector = i * 16;
            wiopb.buffer(0) = .badTrackInfo;
            wiopb.count(0) = size(badTrackInfo);
            call WDiskio(.wiopb, .status);
            if status = 0 then
                goto read;
        end;
        goto error;

    read:
        if badTrackSig = INFOSIG then
        do;
            call InitAltTrackMap;
            dirty = FALSE;
            return;
        end;

    error:
        call Write(CONSOLE$OUTPUT, .aCannotReadBad, size(aCannotReadBad), .status);
        call InitBadTrackMap;
    end;

    ReadAlternateTrackMap: procedure;
        declare i word, pad(3) byte;

        do i = 0 to 3;
            wiopb.function = WINREAD;
            wiopb.cyl = 522;        /* location of alt track info */
            wiopb.head = 4;
            wiopb.sector = i * 16;
            wiopb.buffer(0) = .altTrackInfo;
            wiopb.count(0) = size(altTrackInfo);
            call WDiskio(.wiopb, .status);
            if status = 0 then
                goto read;
        end;
        goto error;

    read:
        if altTrackSig = INFOSIG then
        do;
            if altTrackCount <> badTrackCount then
            do;
                call Write(CONSOLE$OUTPUT, .altMapMismatch, size(altMapMismatch), .status);
                if badTrackCount > altTrackCount then
                    do i = altTrackCount to badTrackCount - 1;
                        altTrackInfo(i + 1).cyl = 0FFFFh;
                        altTrackInfo(i + 1).head = 0FFh;
                    end;
                altTrackCount = badTrackCount;
            end;
            return;
        end;

    error:
        call Write(CONSOLE$OUTPUT, .aCannotReadAlt, size(aCannotReadAlt), .status);
        call InitAltTrackMap;
    end;

    FormatBadTrackMap: procedure bool;
        wiopb.function = WINFORMAT;
        wiopb.cyl = CYL$BAD;        /* track where bad track info is kept */
        wiopb.head = 4;
        wiopb.buffer(0) = .fmtBuf;
        call WDiskio(.wiopb, .status);
        if status = 0 then
            return TRUE;
       
        call NumOut(status, 16, '0', .mapTrackError + 36, 2); 
        call Write(CONSOLE$OUTPUT, .mapTrackError, size(mapTrackError), .status); 
        return FALSE;
    end;

    FormatAltTrackMap: procedure bool;
        wiopb.function = WINFORMAT;
        wiopb.cyl = CYL$ALT;        /* track where alt track info is kept */
        wiopb.head = 4;
        wiopb.buffer(0) = .fmtBuf;
        call WDiskio(.wiopb, .status);
        if status = 0 then
            return TRUE;
                                      /* bug should be + 36 */
        call NumOut(status, 16, '0', .mapTrackError + 37, 2); 
        call Write(CONSOLE$OUTPUT, .mapTrackError, size(mapTrackError), .status); 
        return FALSE;
    end;

    FormatDiagnosticTrack: procedure bool;
        wiopb.function = WINFORMAT;
        wiopb.cyl = CYL$DIAG;    /* diagnostic track */
        wiopb.head = 0;
        wiopb.buffer(0) = .fmtBuf;
        call WDiskio(.wiopb, .status);
        if status = 0 then
            return TRUE;

        call NumOut(status, 16, '0', .diagTrackError + 45, 2); 
        call Write(CONSOLE$OUTPUT, .diagTrackError, size(diagTrackError), .status); 
        return FALSE;
    end;

    WriteBadTrackMap: procedure;
        declare i byte;

        call Write(CONSOLE$OUTPUT, .confirmWriteBad, size(confirmWriteBad), .status);
        call Read(CONSOLE$INPUT, .queryBuf, 128, .actual, .status);
        queryBuf(actual) = CR;
        call ForceUpper(.queryBuf);
        if queryBuf(0) <> 'Y' then
            return;

        do i = 0 to 3;
            wiopb.function = WINWRITE;
            wiopb.cyl = CYL$BAD;
            wiopb.head = 4;
            wiopb.sector = i * 16;
            wiopb.buffer(0) = .badTrackInfo;
            wiopb.count(0) = size(badTrackInfo);
            call WDiskio(.wiopb, .status);
        end;

        dirty = FALSE;
        call Write(CONSOLE$OUTPUT, .badMapWritten, size(badMapWritten), .status);
    end;

    WriteAltTrackMap: procedure;
        declare i word;

        if badTrackCount <> 0 then
            do i = 0 to badTrackCount - 1;
                if altTrackInfo(i + 1).cyl = 0FFFFh and altTrackInfo(i + 1).head = 0FFh then
                do;
                    call Write(CONSOLE$OUTPUT, .partialAltMap, size(partialAltMap), .status);
                    return;
                end;
            end;

        call Write(CONSOLE$OUTPUT, .confirmWriteAlt, size(confirmWriteAlt), .status);
        call Read(CONSOLE$INPUT, .queryBuf, 128, .actual, .status);
        queryBuf(actual) = CR;
        call ForceUpper(.queryBuf);
        if queryBuf(0) <> 'Y' then
            return;

        do i = 0 to 3;
            wiopb.function = WINWRITE;
            wiopb.cyl = CYL$ALT;
            wiopb.head = 4;
            wiopb.sector = i * 16;
            wiopb.buffer(0) = .altTrackInfo;
            wiopb.count(0) = size(altTrackInfo);
            call WDiskio(.wiopb, .status);
        end;

        dirty = FALSE;
        call Write(CONSOLE$OUTPUT, .altMapWritten, size(altMapWritten), .status);
    end;


    Auto: procedure;
        declare (i, j) word;

        if badTrackCount = 0 then
            return;

        altCyl = 511;
        altHead = 4;
        do i = 0 to badTrackCount - 1;
            if badTrackInfo(i + 1).cyl > maxUsrCyl then
            do;
                altTrackInfo(i + 1).cyl = 0;
                altTrackInfo(i + 1).head = 0;
            end;
            else
    loop:   do;
                if (altHead := altHead + 1) > 4 then
                do;
                    altHead = 0;
                    if (altCyl := altCyl + 1) >= 522 then
                    do;
                        call Write(CONSOLE$OUTPUT, .altMapTooBig, size(altMapTooBig), .status);
                        return;
                    end;
                end; 
               
                do j = 0 to badTrackCount - 1; 
                    /* check altCyl-altHead are not bad */
                    if badTrackInfo(j + 1).cyl = altCyl and badTrackInfo(j + 1).head = altHead then
                        goto loop;
                end;
                altTrackInfo(i + 1).cyl = altCyl;
                altTrackInfo(i + 1).head = altHead;
            end;
        end;
    end;


    List: procedure;
        declare i word;

        do i = 0 to badTrackCount - 1;
            call NumOut(badTrackInfo(i + 1).cyl, 10, ' ', .mapping + 1, 3);
            call NumOut(badTrackInfo(i + 1).head, 10, ' ', .mapping + 5, 2);
            if altTrackInfo(i + 1).cyl = 0FFFFh and altTrackInfo(i + 1).head = 0FFh then
            do;
                mapping(8) = '*';
                mapping(9) = '*';
                mapping(10) = '*';
                mapping(12) = '*';
                mapping(13) = '*';
            end;
            else
            do;
                call NumOut(altTrackInfo(i + 1).cyl, 10, ' ', .mapping + 8, 3);
                call NumOut(altTrackInfo(i + 1).head, 10, ' ', .mapping + 12, 2);
            end;
            call Write(aftOut, .mapping, size(mapping), .status);
        end;
        if aftOut <> CONSOLE$OUTPUT then
            call Write(CONSOLE$OUTPUT, .aListWritten, size(aListWritten), .status);
    end;

    InvalidSyntaxError: procedure;
        call FileError(0CBH, cmdPtr, FALSE);
    end;

    GetCylHead: procedure bool;
        declare flag byte;

        /* get defect cylinder */
        if cmdch - '0' > 9 then
        do;
            call InvalidSyntaxError;
            return FALSE;
        end;
        scanPtr = cmdPtr;
        if (badCyl := ScanInteger(.scanPtr)) > maxCyl then
        do;
            call Write(CONSOLE$OUTPUT, .badDefCyl, size(badDefCyl), .status); 
            return FALSE;
        end;
        flag = FALSE;
        if badCyl > maxUsrCyl then
            flag = TRUE;
        
        /* get defect head */
        cmdPtr = Deblank(scanPtr);
        if cmdch - '0' > 9 then
        do;
            call InvalidSyntaxError;
            return FALSE;
        end;
        if (badHead := ScanInteger(.scanPtr)) > 4 then
        do;
            call Write(CONSOLE$OUTPUT, .badDefHead, size(badDefHead), .status); 
            return FALSE;
        end;

        /* check for alternate info */
        cmdPtr = Deblank(scanPtr);
        if cmdCh = CR then  /* no alternate info */
        do;
            altCyl = 0ffffh;
            altHead = 0ffh;
            return TRUE;
        end;

        /* check for : separator */
        if cmdCh <> ':' then
        do;
            call InvalidSyntaxError;
            return FALSE;
        end;

        /* check alternate cylinder */
        cmdPtr = Deblank(cmdPtr + 1);
        if cmdCh - '0' > 9 then
        do;
            call InvalidSyntaxError;
            return FALSE;
        end;

        scanPtr = cmdPtr;
        if ((altCyl := ScanInteger(.scanPtr)) > maxCyl or altCyl < minAltCyl) and
                not (altCyl = 0 and flag) then
        do;
            call Write(CONSOLE$OUTPUT, .badAltCyl, size(badAltCyl), .status); 
            return FALSE;
        end;

        /* check alternate head */
        cmdPtr = Deblank(scanPtr);
        if cmdch - '0' > 9 then
        do;
            call InvalidSyntaxError;
            return FALSE;
        end;
        if (altHead := ScanInteger(.scanPtr)) > 4 then
        do;
            call Write(CONSOLE$OUTPUT, .badAltHead, size(badAltHead), .status); 
            return FALSE;
        end;
     
        /* defective alternate tracks must be mapped to 0 0 */
        if (altCyl <> 0 or altHead <> 0) and flag then
        do;
            call Write(CONSOLE$OUTPUT, .badAlternate, size(badAlternate), .status); 
            return FALSE;
        end;

        cmdPtr = Deblank(scanPtr);
        if cmdCh = CR then
            return TRUE;
        else
        do;
            call InvalidSyntaxError;
            return FALSE;
        end;
    end;


    Mark: procedure;
        declare i word;

        if badTrackCount <> 0 then

            do i = 0 to badTrackCount - 1;
                if badTrackInfo(i + 1).cyl = badCyl and badTrackInfo(i + 1).head = badHead then
                do;
                    if altTrackInfo(i + 1).cyl = 0FFFFh and altTrackInfo(i + 1).head = 0FFh and
                       altCyl <> 0FFFFh and altHead <> 0FFh then
                    do; 
                        altTrackInfo(i + 1).cyl = altCyl;
                        altTrackInfo(i + 1).head = altHead;
                        dirty = TRUE;
                        call Write(CONSOLE$OUTPUT, .altProcessed, size(altProcessed), .status);
                        return;
                    end;
                    call Write(CONSOLE$OUTPUT, .altAlreadyMarked, size(altAlreadyMarked), .status);
                    return;
                end;
                if altTrackInfo(i + 1).cyl = altCyl and altTrackInfo(i + 1).head = altHead and
                    (altCyl <> 0 or altHead <> 0) and (altCyl <> 0FFFFh or altHead <> 0FFh) then
                do;
                    call Write(CONSOLE$OUTPUT, .altInUse, size(altInUse), .status);
                    return;
                end;

                if badTrackInfo(i + 1).cyl = altCyl and badTrackInfo(i + 1).head = altHead then
                do;
                    call Write(CONSOLE$OUTPUT, .altTrackBad, size(altTrackBad), .status);
                    return;
                end;

                if altTrackInfo(i + 1).cyl = badCyl and altTrackInfo(i + 1).head = badHead then
                do;
                    call Write(CONSOLE$OUTPUT, .badTrackAlreadyAlt, size(badTrackAlreadyAlt), .status);
                    return;
                end;
            end;
        badTrackInfo(badTrackCount + 1).cyl = badCyl;
        badTrackInfo(badTrackCount + 1).head = badHead;
        altTrackInfo(badTrackCount + 1).cyl = altCyl;
        altTrackInfo(badTrackCount + 1).head = altHead;
        badTrackCount, altTrackCount = badTrackCount + 1;
        dirty = TRUE;
        call Write(CONSOLE$OUTPUT, .aTrackProcessed, size(aTrackProcessed), .status);
    end;


    Free: procedure;
        declare (i, j) word;
        if badTrackCount = 0 then
        do;
            call Write(CONSOLE$OUTPUT, .noDefects, size(noDefects), .status);
            return;
        end;

        do i = 0 to badTrackCount - 1;
            if badTrackInfo(i + 1).cyl = badCyl and badTrackInfo(i + 1).head = badHead then
            do;
                if i < badTrackCount - 1 then
                    do j = i to badTrackCount - 2;
                        badTrackInfo(j + 1).cyl = badTrackInfo(j + 2).cyl;
                        badTrackInfo(j + 1).head = badTrackInfo(j + 2).head;
                        badTrackInfo(j + 1).res = badTrackInfo(j + 2).res;
                        altTrackInfo(j + 1).cyl = altTrackInfo(j + 2).cyl;
                        altTrackInfo(j + 1).head = altTrackInfo(j + 2).head;
                        altTrackInfo(j + 1).res = altTrackInfo(j + 2).res;
                    end;
                badTrackCount, altTrackCount = badTrackCount - 1;
                dirty = TRUE;
                call Write(CONSOLE$OUTPUT, .aTrackProcessed1, size(aTrackProcessed1), .status);
                return;
            end;
        end;
        call Write(CONSOLE$OUTPUT, .aTrackFree, size(aTrackFree), .status);
    end;

    testToken: procedure(ptr, cnt) bool;
        declare ptr pointer, cnt byte;
        declare cmdch based cmdPtr byte,
                ch based ptr byte;

        do while cmdch = ch and cnt <> 0;
            cmdPtr = cmdPtr + 1;
            ptr = ptr + 1;
            cnt = cnt - 1;
        end; 
        if 'A' <= cmdch and cmdch <= 'Z' or cmdPtr = tokStart then
        do;
            cmdPtr = tokStart;
            return FALSE;
        end;
        else
        do;
            cmdPtr = Deblank(cmdPtr);
            return TRUE;
        end;

    end;



/* main program entry point */
start:
    call InitBadTrackMap;
    call Write(CONSOLE$OUTPUT, .signon, size(signon), .status);

    call Read(CONSOLE$INPUT, .cmdBuf, 128, .actual, .status);
    cmdBuf(actual) = CR;
    call ForceUpper(.cmdBuf);
    cmdPtr = Deblank(.cmdBuf);
    if cmdCh <> CR then     /* check for spurious paramaters on cmd line */
        call FileError(0CBH, cmdPtr, TRUE);

    call SPath(.aA, .pn, .status);
    if pn(11) <> 9 then
    do;
        call Write(CONSOLE$OUTPUT, .winOnly, size(winOnly), .status);
        call Exit;
    end;

    call Write(CONSOLE$OUTPUT, .checkingWin, size(checkingWin), .status);

    if wiCcb.busy1 <> 0 then
    do;
        call Write(CONSOLE$OUTPUT, .notResponding, size(notResponding), .status);
        call Write(CONSOLE$OUTPUT, .checkInserted, size(checkInserted), .status);
        call Exit;
    end;

    wiopb.function = WINDIAG;
    wiopb.modifier = 101h;  /* perform ROM check - no interrupt */
    call WDiskio(.wiopb, .status);
    wiopb.modifier = 1;     /* no interrupt */
    if status <> 0 then
    do;
        call Write(CONSOLE$OUTPUT, .failedRom, size(failedRom), .status);
        call Exit;
    end;

    do i = 0 to 127;    /* fill buffer with 0-127 */
        pattern(i) = i;
    end;

    /* write pattern to controller */

    wiopb.function = WINBUFFERIO;
    wiopb.cyl = 4000h;     /* controller ram location */
    wiopb.head = 0FFH;          /* copy host to controller */
    wiopb.buffer(0) = .pattern;
    wiopb.count(0) = 128;
    call WDiskio(.wiopb, .status);
    if status <> 0 then
        goto controllerProblem;

    do i = 0 to 127;            /* clear buffer */
        pattern(i) = 0;
    end;

    /* read the pattern back */
    wiopb.function = WINBUFFERIO;
    wiopb.cyl = 4000h;     /* controller ram location */
    wiopb.head = 0;            /* copy controller to host */
    wiopb.buffer(0) = .pattern;
    wiopb.count(0) = 128;
    call WDiskio(.wiopb, .status);
    if status <> 0 then
        goto controllerProblem;

    /* check pattern read back ok */
    do i = 0 to 127;
        if pattern(i) <> i then
            goto controllerProblem;
    end;

    /* access diagnostic track */
    wiopb.function = WINDIAG;
    wiopb.modifier = 0;        /* check diagnostic track */
    call WDiskio(.wiopb, .status);
    if status <> 0 then
    do;
        call Write(CONSOLE$OUTPUT, .noDiagnostic, size(noDiagnostic), .status);
        call Read(CONSOLE$INPUT, .queryBuf, 128, .actual, .status);
        queryBuf(actual) = CR;
        call ForceUpper(.queryBuf);
        if queryBuf(0) <> 'Y' then
                goto main;
        if not FormatDiagnosticTrack then
            call Exit;
    end;
    goto main;

controllerProblem:
    call Write(CONSOLE$OUTPUT, .badController, size(badController), .status);
    call Exit;

main:
    call Help;

    do while (1);
        call Write(CONSOLE$OUTPUT, .aPrompt, size(aPrompt), .status);
        call Read(CONSOLE$INPUT, .cmdBuf, 128, .actual, .status);
        cmdBuf(actual) = CR;
        call ForceUpper(.cmdBuf);
        cmdPtr, tokStart = Deblank(.cmdBuf);

        if testToken(.aHelp, size(aHelp)) then
            call Help;
        else if testToken(.aMark, size(aMark)) then
        do;
            if GetCylHead then
                call Mark;
        end;
        else if testToken(.aFree, size(aFree)) then
        do;
            if GetCylHead then
                call Free;
        end;
        else if testToken(.aExit, size(aExit)) or testToken(.aQuit, size(aQuit)) then
        do;
            if cmdCh <> CR then
                call InvalidSyntaxError;
            else if dirty then
            do;
                call Write(CONSOLE$OUTPUT, .notWritten, size(notWritten), .status);
                call Write(CONSOLE$OUTPUT, .useWrite, size(useWrite), .status);
                call Write(CONSOLE$OUTPUT, .exitNoWrite, size(exitNoWrite), .status);
                call Read(CONSOLE$INPUT, .queryBuf, 128, .actual, .status);
                queryBuf(actual) = CR;
                call ForceUpper(.queryBuf);
                if queryBuf(0) =  'Y' then
                    call Exit;
            end;
            else
                call Exit;
        end;
        else if testToken(.aInit, size(aInit)) then
        do;
            if cmdCh <> 'A' and cmdCh <> 'D' and cmdCh <> 'B' then
                call InvalidSyntaxError;
            else
            do;
                subCmd = cmdCh;
                call Write(CONSOLE$OUTPUT, .confirmInit, size(confirmInit), .status);
                call Read(CONSOLE$INPUT, .queryBuf, 128, .actual, .status);
                queryBuf(actual) = CR;
                call ForceUpper(.queryBuf);
                if queryBuf(0) =  'Y' then
                do;
                    if subCmd = 'D' or subCmd = 'B' then
                        if FormatBadTrackMap then
                            call WriteBadTrackMap;
                    if subCmd = 'A' or subCmd = 'B' then
                        if FormatAltTrackMap then
                            call WriteAltTrackMap;
                end;
            end;
        end;
        else if testToken(.aRead, size(aRead)) then
        do;
            if cmdCh <> 'A' and cmdCh <> 'D' and cmdCh <> 'B' then
                call InvalidSyntaxError;
            else
            do;
                if cmdCh = 'D' or cmdCh = 'B' then
                    call ReadDefectiveTrackMap;
                if cmdCh = 'A' or cmdCh = 'B' then
                    call ReadAlternateTrackMap;
            end;
        end;
        else if testToken(.aWrite, size(aWrite)) then
        do;
            if cmdCh <> 'A' and cmdCh <> 'D' and cmdCh <> 'B' then
                call InvalidSyntaxError;
            else
            do;
                if cmdCh = 'D' or cmdCh = 'B' then
                    call WriteBadTrackMap;
                if cmdCh = 'A' or cmdCh = 'B' then
                    call WriteAltTrackMap;
            end;
        end;
        else if testToken(.aAuto, size(aAuto)) then
            call Auto;
        else if testToken(.aCount, size(aCount)) then
        do;
            if cmdCh <> CR then
                call InvalidSyntaxError;
            else if badTrackCount = 0 then
                call Write(CONSOLE$OUTPUT, .noDefects1, size(noDefects1), .status);
            else
            do;
                call NumOut(badTrackCount, 10, 0, .defectiveTracks + 1, 5);
                call Write(CONSOLE$OUTPUT, .defectiveTracks, size(defectiveTracks), .status);
            end;
        end;
        else if testToken(.aList, size(aList)) then
        do;
            if cmdCh = CR then
                cmdPtr = .aCo;  /* :CO: \r */
            call Spath(cmdPtr, .pn, .status);
            if status <> 0 then
                call FileError(status, cmdPtr, FALSE);
            else if pn(0) = b64DB  then      /* BUG - b64DB is never initialised */
                call Write(CONSOLE$OUTPUT, .cannotList, size(cannotList), .status);
            else if pn(10) = 0 then
                call FileError(16h, cmdPtr, FALSE);
            else
            do;
                cmdPtr = Deblank(Delimit(tokStart := cmdPtr));
                if cmdCh <> CR then
                    call InvalidSyntaxError;
                else if badTrackCount = 0 then
                    call Write(CONSOLE$OUTPUT, .emptyList, size(emptyList), .status);
                else
                do;
                    call Open(.aftOut, tokStart, WRITE$MODE, 0, .status);
                    if status <> 0 then
                        call FileError(status, tokStart, FALSE);
                    else
                    do;
                        call Write(CONSOLE$OUTPUT, .listOfDefects, size(listOfDefects), .status);
                        call List;
                    end;
                    call Close(aftOut, .status);
                end;
            end;
        end;
        else if cmdCh <> CR then
            call InvalidSyntaxError;
    end;    /* of while 1 */
    call Exit;
end;
dblank.plm
deblank: do;

Deblank: procedure(ptr) address public;
    declare ptr address;
    declare c based ptr byte;

    do while (c = ' ');
        ptr = ptr + 1;
    end;
    return ptr;
end;
end;
direct.plm
direct: do;
$include(direct.ipx)
declare direct DIRECT$T public;
declare directINO address public;
end;
diskio.plm
Diskio: do;
$include(diskio.ipx)
Diskio: procedure(disk, dcb$p) public;
    declare disk address, dcb$p address;
    declare (param1, param2) address;

    param1 = disk;
    param2 = dcb$p;
    call ISIS('D', .param1);
end;
end;
wdskio.plm
WDiskio: do;
$include(wdskio.ipx)
WDiskio: procedure(wiopb$p, status$p) public;
    declare wiopb$p pointer, status$p wpointer;
    declare status based status$p word;
 
    call StrtWD(wiopb$p);
    status = StatWD;
end;
end;
dlimit.plm
delimit: do;

Delimit: procedure(ptr) address public;
    declare ptr address;
    declare c based ptr byte;

    do while (c = ':' or c = '.' or ('0' <= c and c <= '9') or ('A' <= c and c <= 'Z'));
        ptr = ptr + 1;
    end;
    return ptr;
end;
end;
ferror.plm
fileerror: do;
$include(ferror.ipx)

FileError: procedure(status, ptr, callExit) public;
    declare (status, ptr) address, callExit byte;
    declare actual address;

    if status <> 0 then
    do;
        ptr = deblank(ptr);
        call write(0, .(' '), 1, .actual);
        call write(0, ptr, wdelimit(ptr) - ptr, .actual);
        call write(0, .(','), 1, .actual);
        call reporterror(status);
        if callExit then
            call exit;
    end;
end;
end;
fmttrk.plm
formatTrack: do;
$include(fmttrk.ipx)

declare INFOSIG literally '0ABCDH'; 

declare fmtErrMsg(*) byte initial('FORMAT ERROR: **', CR, LF),
        status word,
        wiopb WDCB$T initial(0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0);
declare (badTrkInfo, altTrkInfo) (256) structure(cyl address, head byte, unk byte);
/* first info slot is reserved for signature and count */
declare (badTrkSig, badTrkCnt) address at(.badTrkInfo) initial(INFOSIG, 0);
declare (altTrkSig, altTrkCnt) address at(.altTrkInfo) initial(INFOSIG, 0);

LoadBadTrackInfo: procedure;
    declare i word;

    do i = 0 to 3;
        wiopb.function = WINREAD;
        wiopb.cyl = 523;    /* location of bad track list */
        wiopb.head = 4;
        wiopb.sector = i * 16;  /* try all 4 copies */
        wiopb.buffer(0) = .badTrkInfo;
        wiopb.count(0) = 1024;
        call WDiskio(.wiopb, .status);
        if status = 0 then
            goto gotBadInfo;
    end;
    goto badinfo;

gotBadInfo:
    do i = 0 to 3;
        wiopb.function = WINREAD;
        wiopb.cyl = 522;     /* location of alt track list */
        wiopb.head = 4;
        wiopb.sector = i * 16;  /* try all 4 copies */
        wiopb.buffer(0) = .altTrkInfo;
        wiopb.count(0) = 1024;
        call WDiskio(.wiopb, .status);
        if status = 0 then
            goto gotAltInfo;
    end;
    goto badinfo;

    gotAltInfo:
    if badTrkSig = INFOSIG and altTrkSig = INFOSIG then
        return;

    badInfo:
    call Write(CONSOLE$OUTPUT,
               .(' CANNOT READ DEFECTIVE TRACK INFORMATION', CR, LF),
               42, .status);
    call Exit;
end;

FormatTrack: procedure(disk,sTrack,eTrack,interleave) public;
    declare (disk,interleave) byte, (sTrack, eTrack) address;
    declare (wCyl, wHead) address;
    declare curTrack address, (sectors, vTracks) address;
    declare (i,j,interTrackSkew) address,
            wDisk address, trackBuf(104) byte, dcb DCB$T;

    if diskType = 9 then    /* Winchester */
    do;
        call LoadBadTrackInfo;
        sTrack = 3 * sTrack;
        eTrack = 3 * eTrack + 2;
        do curTrack = sTrack to eTrack;
            trackBuf(0) = 0;        /* format data track */
            trackBuf(1) = 0c7h;
            trackBuf(2) = 0c7h;
            trackBuf(3) = 0c7h;
            trackBuf(4) = 0c7h;
            trackBuf(5) = interleave;
            wDisk = disk;
            wDisk = disk * 128;
            wCyl = curTrack / 5 + wDisk;
            wHead = curTrack mod 5;
            if badTrkCnt <> 0 then
                do i = 0 to badTrkCnt - 1;
                    /* see if current track is on bad list */
                    if badTrkInfo(i + 1).cyl = wCyl and
                       badTrkInfo(i + 1).head = wHead then
                    do;
                        trackBuf(0) = 40h;  /* format assigned alternate track */
                        wiopb.function = WINFORMAT;
                        wiopb.buffer(0) = .trackBuf;
                        wiopb.cyl = altTrkInfo(i + 1).cyl;
                        wiopb.head = altTrkInfo(i + 1).head;
                        call WDiskio(.wiopb, .status);
                        if status <> 0 then
                            goto fmtErr;
                        trackBuf(0) = 80h;  /* format defective track */
                        trackBuf(1) = low(altTrkInfo(i + 1).cyl);
                        trackBuf(2) = high(altTrkInfo(i + 1).cyl);
                        trackBuf(3) = altTrkInfo(i + 1).head;
                        trackBuf(4) = 0;    /* no user pattern */
                        goto break;
                    end;
                end;
        break:
            wiopb.function = WINFORMAT;
            wiopb.buffer(0) = .trackBuf;
            wiopb.cyl = wCyl;
            wiopb.head = wHead;
            call WDiskio(.wiopb, .status);
            if status <> 0 then
                goto fmtErr;
        end;
        return;
    end;

    if diskType = 1 then    /* DD */ 
    do;
        sectors = 52;
        interTrackSkew = 7;
    end;
    else
    do;
        sectors = 26;
        interTrackSkew = 4;
    end;

    dcb.iocw = 0c0h;
    vTracks = sectors * 2 - 1;
    do i = 1 to vTracks by 2;
        trackBuf(i) = 0c7h;
    end;

    j = 0;

    do curTrack = sTrack to eTrack;
        dcb.ioins = 2;
        do i = 0 to vTracks by 2;
            trackBuf(i) = 0;
        end;
        do i = 1 to sectors;
            j = (j + interleave) mod sectors;
            do while trackBuf(j * 2) <> 0;
                j = (j + 1) mod sectors;
            end;
            trackBuf(j + j) = i;
        end;
    
        dcb.tadr = curTrack;
        dcb.buf = .trackBuf;
        call Diskio(disk, .dcb);
        j = j + interTrackSkew;
    end;
    return;

fmtErr:
    call NumOut(status, 16, '0', .fmtErrMsg + 14, 2);
    call Write(0, .fmtErrMsg, 18, .status);
    call Exit;
end;

end;
forupp.plm
FORCEUPPER: DO;
$include(forupp.ipx)

ForceUpper: procedure(bufferPtr) public;
    declare bufferPtr address, ch based bufferPtr byte;

    do while ch <> CR;
        ch = uppercase(ch);
        bufferPtr = bufferPtr + 1;
    end;
end;
end;
getdsk.plm
GetDisk: do;
$include(getdsk.ipx)

declare source(3) structure(name(6) byte) data('SYSTEM', 'SOURCE', 'OUTPUT');

GetDisk: procedure(n) public;
    declare n byte;
    declare buf(128) byte, status address, junk address, actual address;

    call Write(0, .('LOAD '), 5, .status);
    call Write(0, .source(n), 6, .status);
    call Write(0, .(' DISK, THEN TYPE (CR)'), 21, .status);
    call Read(1, .buf, 128, .actual, .status);
end;
end;
format.plm
format: do;
Seek: procedure(conn, mode, block$p, byte$p, status$p) external; /* force load */
	declare (conn, mode, block$p, byte$p, status$p) address;
end;

$include(format.ipx)
declare copyright(*) byte data('(C) 1976,1977,1978,1979,1980,1981,1982 INTEL CORP'),
	version(*) byte data(4, 0, 'program_version_number=', 1, 'V4.3W', 0);
/*
	the code block below is loaded into isis.t0 on non system disks to print a message
	the corresponding asm code is

		ASEG
		org 3000h

		in	79h
		in	7Bh
	L3004:	in	0FFh
		ani	2
		jnz	L3004
		lxi	h, Msg
		mvi	b, 32
	L3010:	mov	c, m
		call	0F809h	; CO
		inx	h
		dcr	b
		jnz	L3010
		rst	0
	Msg:	db	0Dh, 0Ah
		db	'NON-SYSTEM DISK, TRY ANOTHER'
		db	0Dh, 0Ah
		end
*/
declare codeBlock(*) byte data(0DBh, 79h, 0DBh, 7Bh, 0DBh, 0FFh, 0E6h, 2,
			       0C2h, 4, 30h, 21h, 1Ah, 30h, 6, 20h, 4Eh,
			       0CDh, 9, 0F8h, 23h, 5, 0C2h, 10h, 30h, 0C7h,
			       CR, LF, 'NON-SYSTEM DISK, TRY ANOTHER', CR, LF);

declare buffer(384) byte;
declare	memSize address;
declare	actual address;
declare	pn(12) byte;
declare	buffer$ptr address, char based buffer$ptr byte;
declare	(i, j, k) address;	/* k no longer used !! */
declare	(system, copyAll, copy) bool;
declare	(targetDisk, srcDisk) byte;
declare unused address;
declare	(aftIn, aftOut, dirAft) address;
declare	status address;
declare	attributeList(*) byte data(1, 2, 4);	/* no longer used */
declare crlf(2) byte data(CR, LF);
declare	inputString(16) byte,
        outputString(16) byte;

declare confirmMsg(*) byte initial(
        'FORMATTING WILL DESTROY ALL FILES AND DATA ON DEVICE :F*:', CR, LF,
        ' DO YOU WANT TO CONTINUE? ');

declare	t0File(*) byte initial(':FX:ISIS.T0 '),
	cliFile(*) byte initial(':FX:ISIS.CLI '),
	binFile(*) byte initial(':FX:ISIS.BIN '),
	ov0File(*) byte initial(':FX:ISIS.OV0 '),
	mapFile(*) byte initial(':FX:ISIS.MAP '),
	labFile(*) byte initial(':FX:ISIS.LAB '),
	dirFile(*) byte initial(':FX:ISIS.DIR '),
	badFile(*) byte initial(':FX:ISIS.BAD '),
	t0File2(*) byte initial(':FX:ISIS.T0 '),
	labFile2(*) byte initial(':FX:ISIS.LAB '),
	dirFile2(*) byte initial(':FX:ISIS.DIR ');

declare	diskType byte public;

declare	fmtTable(10) structure(t0Interleave byte, t1Interleave byte, interleave  byte,
		   	      tracks address, labBlkSize address)
        initial(0,  0, 0,   0,    0, /* controller not present */
                1,  4, 5,  76,  80h, /* 2 board DD */
                1, 12, 6,  76,  80h, /* 2 board SD */
                1, 12, 6,  76,  80h, /* integrated SD */
                7, 16, 9, 199,  251, /* 2 board HD */
                0,  0, 0,   0,    0, /* controller not present */
                0,  0, 0,   0,    0, /* controller not present */
                1,  1, 1, 131,  128, /* type 7? */
                0,  0, 0,   0,    0, /* controller not present */
                1, 50,25, 211,  263  /* winchester */
        );



declare labBlk structure(name(9) byte,
			 version(2) byte,
			 leftOver(38) byte,
			 crlf(2) byte,
		         fmtTable(200) byte) at (.buffer);

start:
	call Read(CONSOLE$INPUT, .buffer, size(buffer), .actual, .status);
	buffer(actual) = CR;
	call ForceUpper(.buffer);
	bufferPtr = Deblank(.buffer);
	call Spath(bufferPtr, .pn, .status);
	if pn(11) = 5 or 6 then
		status = 0ECh;
	if pn(11) = 8 then
		status = 3Dh;

	call FileError(status, bufferPtr, TRUE);
	targetDisk = TestRange(pn(0), bufferPtr);
	diskType = pn(11);
	t0File(2), cliFile(2), binFile(2), ov0File(2),
	mapFile(2), labFile(2), dirFile(2), badFile(2) = targetDisk + '0';
	srcDisk = 0;
	system = FALSE;
	copyAll = FALSE;

	bufferPtr = Deblank(Delimit(bufferPtr));

	do while char <> CR;
		if char = 'S' then
			system = TRUE;
		else if char = 'A' then
			copyAll = TRUE;
		else if Seq(bufferPtr, .('FROM '), 5) then
		do;
			bufferPtr = Deblank(bufferPtr + 5);
			srcDisk = char - '0';
			if srcDisk > F9DEV then
				call FileError(UNRECOG$SWITCH, bufferPtr, TRUE);
		end;
		else if char <> '$' then
			call FileError(UNRECOG$SWITCH, bufferPtr, TRUE);
		bufferPtr = Deblank(bufferPtr + 1);
	end;

	if srcDisk = targetDisk then
	do;
		call ReportError(0EAh);
		call Exit;
	end;
	else
		labFile2(2), dirFile2(2), t0File2(2) = srcDisk + '0';

	if targetDisk = 0 and diskType = 9 and not system and not copyAll then
	do;
		call Write(0, .('NON-SYSTEM WINCHESTER DISK DRIVE 0 NOT ALLOWED', CR, LF), 48, .status);
		call Exit;
	end;

    if diskType = 9 then
    do;
        call NumOut(targetDisk, 10, 0, .confirmMsg + 55, 1);
        call Write(CONSOLE$OUTPUT, .confirmMsg, 85, .status);
        call Read(CONSOLE$INPUT, .buffer, size(buffer), .actual, .status);
        buffer(actual) = CR;
        call ForceUpper(.buffer);
        if buffer(0) <> 'Y' then
            call Exit;
    end;

	call Open(.aftIn, .labFile2, READ$MODE, 0, .status);
	call FileError(status, .labFile2, TRUE);
	call Read(aftIn, .buffer, 263, .actual, .status);
	call FileError(status, .labFile2, TRUE);
	call Close(aftIn, .status);
	call FileError(status, .labFile2, TRUE);

	labBlk.fmtTable(0) = fmtTable(diskType).t0Interleave + '0';
	labBlk.fmtTable(1) = fmtTable(diskType).t1Interleave + '0';
	do i = 2 to fmtTable(diskType).tracks;
		labBlk.fmtTable(i) = fmtTable(diskType).interleave + '0';
	end;

    if diskType = 9 then    /* winchester is quiet and takes a long time */
        call Write(CONSOLE$OUTPUT, .(' FORMATTING ...', CR, LF), 17, .status);

	call FormatTrack(targetDisk, 0, 0, labBlk.fmtTable(0) - '0');
	call FormatTrack(targetDisk, 1, 1, labBlk.fmtTable(1) - '0');
	call FormatTrack(targetDisk, 2, fmtTable(diskType).tracks, labBlk.fmtTable(2) - '0');

	mapBase = .MEMORY;
	unused = SetupMap(targetDisk) + 44;
	call WriteDirectory(targetDisk);
	call Open(.aftOut, .labFile, UPDATE$MODE, 0, .status);
	call FileError(status, .labFile, TRUE);
	call moveAscii(.labBlk, .pn(1), 9);

	call Write(aftOut, .buffer, fmtTable(diskType).labBlkSize, .status);
	call Close(aftout, .status);
	call FileError(status, .labFile, TRUE);

	if system or copyAll then
	do;
		if copyAll then
			call Write(0, .('COPYING ALL FILES', CR, LF), 19, .status);
		else
			call Write(0, .('COPYING SYSTEM FILES', CR, LF), 22, .status);

		memSize = (Memck - .Memory) and 0ff80h;
		call Open(.dirAFT, .dirFile2, READ$MODE, 0, .status);
		call FileError(status, .dirFile2, TRUE);
		do while TRUE;
			call Read(dirAft, .direct, size(direct), .actual, .status);
			call FileError(status, .dirFile2, TRUE);
			if actual < size(direct) then
				goto break;
			else if not direct.empty then
			do;
				if (direct.attrib and 80h) <> 0 then
				do;
					copy = FALSE;
					if Seq(.direct.file, .('ISIS',0,0,'BIN'), 9) or
					   Seq(.direct.file, .('ISIS',0,0,'CLI'), 9) or
					   Seq(.direct.file, .('ISIS',0,0,'T0'), 8) or
					   Seq(.direct.file, .('ISIS',0,0,'OV0'), 9) then
						copy = TRUE;
				end;
				else
					copy = (direct.attrib and 2) <> 0 or copyAll;

				if copy then
				do;
					direct.empty = srcDisk;
					call Ypath(.direct, .inputString);
					direct.empty = targetDisk;
					call Ypath(.direct, .outputString);
					call Open(.aftOut, .outputString, UPDATE$MODE, 0, .status);
					call FileError(status, .outputString, TRUE);
					call Open(.aftIn, .inputString, READ$MODE, 0, .status);
					call FileError(status, .inputString, TRUE);
					actual = memSize;
					do while actual = memSize;
						call Read(aftIn, .MEMORY, memSize, .actual, .status);
						call FileError(status, .inputString, TRUE);
						call Write(aftOut, .MEMORY, actual, .status);
					end;

					call Close(aftOut, .status);
					call FileError(status, .outputString, TRUE);
					call Close(aftIn, .status);
					call FileError(status, .inputString, TRUE);
					do i = 0 to 2;
						if (attributeList(i) and direct.attrib) <> 0 then
						do;
							call Attrib(.outputString, i, TRUE, .status);
							call FileError(status, .outputString, TRUE);
						end;
					end;
					/* find end of file name skipping :Fx: */
					k = Delimit(.inputString + 4) - .inputString - 4;
					call Write(0, .inputString + 4, k, .status);
					call Write(0, .crlf, 2, .status);
				end;
			end;
		end;
break:
		call Close(dirAft, .status);
	end;
	else
	do;
		call Open(.aftOut, .t0File, UPDATE$MODE, 0, .status);
		call Write(aftOut, .codeBlock, 58, .status);
		call Close(aftOut, .status);
		call Delete(.binFile, .status);
		call Write(0, .('NON-SYSTEM DISK', CR, LF), 17, .status);
	end;

	call Attrib(.dirFile, 3, 0ffh, .status);
	call Attrib(.t0File, 3, 0ffh, .status);
	call Attrib(.labFile, 3, 0ffh, .status);
	call Attrib(.mapFile, 3, 0ffh, .status);
	if diskType = 9 then
		call Attrib(.badFile, 3, 0ffh, .status);

	if system or copyAll then
	do;
		call Attrib(.binFile, 3, 0ffh, .status);
		call Attrib(.cliFile, 3, 0ffh, .status);
		call Attrib(.ov0File, 3, 0ffh, .status);
	end;
	call Exit;
end;
idisk.plm
idisk: do;
$include(idisk.ipx)
declare copyright(*) byte data('(C) 1976,1977,1978,1979,1980,1981,1982 INTEL CORP'),
    version(*) byte data(4, 0, 'program_version_number=', 1, 'V4.3W', 0);
/*
    the code block below is loaded into isis.t0 on non system disks to print a message
    the corresponding asm code is

        ASEG
        org 3000h

        in  79h
        in  7Bh
    L3004:  in  0FFh
        ani 2
        jnz L3004
        lxi h, Msg
        mvi b, 32
    L3010:  mov c, m
        call    0F809h  ; CO
        inx h
        dcr b
        jnz L3010
        rst 0
    Msg:    db  0Dh, 0Ah
        db  'NON-SYSTEM DISK, TRY ANOTHER'
        db  0Dh, 0Ah
        end
*/
declare codeBlock(*) byte data(0DBh, 79h, 0DBh, 7Bh, 0DBh, 0FFh, 0E6h, 2,
                   0C2h, 4, 30h, 21h, 1Ah, 30h, 6, 20h, 4Eh,
                   0CDh, 9, 0F8h, 23h, 5, 0C2h, 10h, 30h, 0C7h,
                   CR, LF, 'NON-SYSTEM DISK, TRY ANOTHER', CR, LF);

declare memSize address;
declare actual address;
declare pn(12) byte;
declare buffer$ptr address, char based buffer$ptr byte;
declare (i, j, k) address; /* j, k no longer used !! */
declare (fileNumber, hadPrint) byte;
declare next address;
declare w5933 address;
declare (system, first, copy) bool;
declare (aftIn, aftOut, dirAft) address;
declare status address;
declare attributeList(*) byte data(1, 2, 4);    /* no longer used */
declare tracks byte;
declare (srcDisk, targetDisk) byte;
declare unused address;
declare diskType byte public;
declare fmtTable(10) structure(t0Interleave byte, t1Interleave byte, interleave  byte,
                  tracks address, bitmapSize address, labBlkSize address)
        initial(0,  0, 0,   0,     0,    0, /* controller not present */
                1,  4, 5,  76,  200h,  80h, /* 2 board DD */
                1, 12, 6,  76,  100h,  80h, /* 2 board SD */
                1, 12, 6,  76,  100h,  80h, /* integrated SD */
                7, 16, 9, 199,  4570,  251, /* 2 board HD */
                0,  0, 0,   0,     0,    0, /* controller not present */
                0,  0, 0,   0,     0,    0, /* controller not present */
                1,  1, 1, 131,   512,  128, /* type 7? */
                0,  0, 0,   0,     0,    0, /* controller not present */
                1, 50,25, 212,  6490,  263  /* winchester */
        );
declare inputString(16) byte,   /* no longer used */
        outputString(16) byte;  /* no longer used */

declare confirmMsg(*) byte initial(
        'FORMATTING WILL DESTROY ALL FILES AND DATA ON DEVICE :F*:', CR, LF,
        ' DO YOU WANT TO CONTINUE? ');
declare file(8) structure(name(13) byte)
    initial(':FX:ISIS.BIN ',
        ':FX:ISIS.T0  ',
        ':FX:ISIS.CLI ',
        ':FX:ISIS.OV0 ',
        ':FX:ISIS.MAP ',
        ':FX:ISIS.DIR ',
        ':FX:ISIS.LAB ',
        ':FX:ISIS.BAD ');
declare buffer(384) byte;

declare labBlk structure(name(9) byte,
             version(2) byte,
             leftOver(38) byte,
             crlf(2) byte,
                 fmtTable(1) byte) at (.buffer);
declare singleDrive bool public;
declare info based next structure(length address, offset address, begin address);


Initialize: procedure;
    if diskType = 9 then    /* winchester is quiet and takes a long time */
        call Write(CONSOLE$OUTPUT, .(' FORMATTING ...', CR, LF), 17, .status);
    call FormatTrack(targetDisk, 0, 0, labBlk.fmtTable(0) - '0');
    call FormatTrack(targetDisk, 1, 1, labBlk.fmtTable(1) - '0');
    call FormatTrack(targetDisk, 2, tracks, labBlk.fmtTable(2) - '0');
    mapBase = .MEMORY;
    unused = SetupMap(targetDisk) + 44;
    call WriteDirectory(targetDisk);
    file(6).name(2) = targetDisk + '0';
    call Open(.aftOut, .file(6), UPDATE$MODE, 0, .status);
    call SFileError(status, .file(6));
    call MoveAscii(.labBlk, .pn + 1, 9);
    call Write(aftOut, .labBlk, fmtTable(diskType).labBlkSize, .status);
    call SFileError(status, .file(6));
    call Close(aftOut, .status);
    call SFileError(status, .file(6));
end;


entry:
    call Read(CONSOLE$INPUT, .buffer, size(buffer), .actual, .status);
    buffer(actual) = CR;
    call ForceUpper(.buffer);
    bufferPtr = Deblank(.buffer);
    call Spath(bufferPtr, .pn, .status);
    if (diskType := pn(11)) = 5 or 6 then   /* 6 is pointless as it does not impact test */
        status = 0ECh;
    if pn(11) = 8 then
        status = 3Dh;
    call FileError(status, bufferPtr, TRUE);
    targetDisk = TestRange(pn(0), bufferPtr);
    srcDisk = 0;
    system = 0;
    singleDrive = 0;
    bufferPtr = Deblank(Delimit(bufferPtr));

    do while char <> CR;
        if char = 'P' then
            singleDrive = TRUE;
        else if char = 'S' then
            system = TRUE;
        else if Seq(bufferPtr, .('FROM '), 5) then
        do;
            bufferPtr = Deblank(bufferPtr + 5);
            if (srcDisk := char - '0') > 9 then
                call FileError(UNRECOG$SWITCH, bufferptr, TRUE);

        end;
        else if char <> '$' then
            call FileError(UNRECOG$SWITCH, bufferPtr, TRUE);
        bufferPtr = Deblank(bufferPtr + 1);
    end;
    if srcDisk = targetDisk then
        singleDrive = TRUE;
    if targetDIsk = 0 and diskType = 9 and not system then
    do;
        call Write(0, .('NON-SYSTEM WINCHESTER DRIVE 0 NOT ALLOWED', CR, LF), 2Bh, .status);
        call Exit;
    end;
    if diskType = 9 then
    do;
        call NumOut(targetDisk, 10, 0, .confirmMsg + 55, 1);
        call Write(CONSOLE$OUTPUT, .confirmMsg, 85, .status);
        call Read(CONSOLE$INPUT, .buffer, size(buffer), .actual, .status);
        buffer(actual) = CR;
        call ForceUpper(.buffer);
        if buffer(0) <> 'Y' then
            call Exit;
    end;
    file(6).name(2) = srcDisk + '0';
    call Open(.aftIn, .file(6), 1, 0, .status);
    call FileError(status, .file(6), TRUE);
    call Read(aftIn, .buffer, 263, .actual, .status);
    call FileError(status, .file(6), TRUE);
    call Close(aftIn, .status);
    call FileError(status, .file(6), TRUE);
    tracks = fmtTable(diskType).tracks;
    labBlk.fmtTable(0) = fmtTable(diskType).t0Interleave + '0';
    labBlk.fmtTable(1) = fmtTable(diskType).t1Interleave + '0';
    do i = 2 to tracks;
        labBlk.fmtTable(i) = fmtTable(diskType).interleave + '0';
    end;

    if system then
    do;
        call Write(0, .('SYSTEM DISK', CR, LF), 13, .status);
        first = TRUE;
        next = fmtTable(diskType).bitmapSize + .MEMORY;
        memSize = Memck - next;
        fileNumber = 0;
        hadPrint = 0;
        info.offset, i = 0;
        do while fileNumber < 4;
            memSize = memSize - 8;
            file(fileNumber).name(2) = srcDisk + '0';
            call Open(.aftIn, .file(fileNumber), READ$MODE, 0, .status);
            call SFileError(status, .file(fileNumber));
            call Seek(aftIn, SEEK$ABS, .i, .info.offset, .status);
            call SFileError(status, .file(fileNumber));
            call Read(aftIn, .info.begin, memSize, .actual, .status);
            call SFileError(status, .file(fileNumber));
            call Close(aftIn, .status);
            call SFileError(status, .file(fileNumber));
            info.length = actual;
            next = .info.begin + actual;
            if fileNumber = 3 or (memSize := memSize - actual) < 8 then
            do;
                if singleDrive then
                    call GetDisk(2);

                if first then
                do;
                    call Initialize;
                    next = .MEMORY + fmtTable(diskType).bitmapSize;
                    first = FALSE;
                end;
                else
                    next = .MEMORY;

                do while hadPrint <= fileNumber;
                    file(hadPrint).name(2) = targetDisk + '0';
                    call Open(.aftOut, .file(hadPrint), UPDATE$MODE, 0, .status);
                    call SFileError(status, .file(hadPrint));
                    call Seek(aftOut, SEEK$ABS, .i, .info.offset, .status);
                    call SFileError(status, .file(hadPrint));
                    call Write(aftOut, .info.begin, info.length, .status);
                    call SFileError(status, .file(hadPrint));
                    call Close(aftOut, .status);
                    call SFileError(status, .file(hadPrint));
                    if hadPrint < fileNumber then
                        next = .info.begin + info.length;
                    hadPrint = hadPrint + 1;
                end;
                w5933 = info.offset + info.length;
                next = .MEMORY;
                if memSize = 0 then
                do;
                    hadPrint = fileNumber;
                    fileNumber = fileNumber - 1;
                    info.offset = w5933;
                end;
                else
                    info.offset = 0;

                memSize = Memck - next;
                if fileNumber + 1 < 4 and singleDrive then
                    call GetDisk(0);
            end;
            else
                info.offset = 0;
            fileNumber = fileNumber + 1;
        end;
    end;
    else
    do;
        call Write(0, .('NON-SYSTEM DISK', CR, LF), 17, .status);
        if singleDrive then
            call GetDisk(2);
        call Initialize;
        file(0).name(2) = targetDisk + '0';
        file(1).name(2) = targetDisk + '0';
        call Open(.aftOut, .file(1), UPDATE$MODE, 0, .status);
        call SFileError(status, .file(1));
        call Write(aftOut, .codeBlock, 3Ah, .status);   /* code to write non system disk */
        call SFileError(status, .file(1));
        call close(aftOut, .status);
        call SFileError(status, .file(1));
        call Delete(.file(0), .status);
    end;
    do i = 0 to 7;
        file(i).name(2) = targetDisk + '0';
        call Attrib(.file(i), 3, TRUE, .status);
    end;

    call Attrib(.file(2), 0, TRUE, .status);
    call Attrib(.file(2), 1, TRUE, .status);
    call Attrib(.file(3), 0, TRUE, .status);
    call Attrib(.file(3), 1, TRUE, .status);
    if singleDrive then
        call GetDisk(0);
    call Exit;
end;
isisutil_4.3w.pex
# common literals
TRUE            '0FFh'
FALSE           '0'
CR              '0Dh'
LF      '0Ah'
BELL            '7'
TAB             '9'
CONTROL$P   '10h'
FOREVER     'WHILE TRUE'


# my user types
pointer     'address'
bool        'byte'
wpointer    'address'
word        'address'

# typedefs
DCB$T   'STRUCTURE (iocw BYTE, ioins BYTE, nsec BYTE, tadr BYTE, sadr BYTE, buf ADDRESS)'
DIRECT$T 'structure(empty byte, file(9) byte, attrib byte, eof$count byte, blk address, hdrBlk address)'
CONFIG$T1   'slot byte, endslot byte, ctlId byte, dtype byte'
CONFIG$T2   'trk byte, sec byte, unitmap(4) byte, rdymsk(4) byte'
CONFIG$T 'STRUCTURE(CONFIG$T1,CONFIG$T2)'
WSTATUS$T 'structure(status(3) byte, cyl word, head byte, sector byte, aCyl word, ahead byte, aSec byte, retries byte)'
WWAKE$T 'structure(wake byte, reserved byte, ccb(2) address)'
WCCB$T 'structure(ccw1 byte, busy1 byte, cib(2) address, res word, ccw2 byte, busy2 byte, cp(2) address, cptr word)'
WCONTROL$T 'structure(res1 byte, opStatus byte, cmdSem byte, stSem byte, csa(2) address, iopb(2) address, res2(2) word)'
WDCB$T1 'reserved(2) word, actual(2) word, device word, unit byte, function byte, modifier word'
WDCB$T2 'cyl word, head byte, sector byte, buffer(2) address, count(2) word, gaptr(2) address'
WDCB$T 'STRUCTURE(WDCB$T1, WDCB$T2)';

# standard ISIS system calls
Attrib      P("pointer" path$p,"word" attrib,"word" on$off,"wpointer" status$p)
Close           P("word" conn,"wpointer" status$p)
Co          P(B char)
Consol      P(A ci$p,A co$p,A status$p)
Delete          P(A path$p,A status$p)
Error       P("word" errnum)
Exit        P
Isis            P(B type,A parameter$ptr)
Memck           P"pointer"
Open            P("wpointer" conn$p,"pointer" path$p,"word" access,"word" echo,"wpointer" status$p)
Read            P("word" conn,"pointer" buff$p,"word" count,"wpointer" actual$p,"wpointer" status$p)
Rename          P(A old$p,A new$p,A status$p)
Rescan      P(A conn,A status$p)
Seek            P(A conn,A mode,A block$p,A byte$p,A status$p)
Spath       P("pointer" path$p,"pointer" info$p,"wpointer" status$p)    
whocon      P(A conn,A buff$p)
Write           P(A conn,A buff$p,A count,A status$p)


F9DEV       '9'

# error codes
OK  '0'
NO$FREE$BUFFER  '1'
BAD$AFT$NO  '2'
AFT$FULL    '3'
BAD$PATH    '4'
BAD$DEVICE  '5'
CANT$WRITE  '6'
DISK$FULL   '7'
CANT$READ   '8'
DIRECTORY$FULL  '9'
DIFFERENT$DISK  '10'
MULTIDEFINED    '11'
ALREADY$OPEN    '12'
NO$SUCH$FILE    '13'
WRITE$PROTECT   '14'
ISIS$OVERWRITE  '15'
BAD$LOAD$FORMAT '16'
NON$DISK$FILE   '17'
BAD$COMMAND '18'
NON$DISK$SEEK   '19'
LONG$BACK$SEEK  '20'
CANT$RESCAN '21'
ILLEGAL$ACCESS  '22'
NULL$FILENAME   '23'
DISK$IO$ERROR   '24'
BAD$ECHO    '25'
BAD$ATTRIB  '26'
BAD$SEEK$ARG    '27'
NULL$EXTENSION  '28'
CONSOLE$EOF '29'
DRIVE$NOT$READY '30'
SEEK$ON$WRITE   '31'
CANT$DELETE '32'
ILLEGAL$PARAM   '33'
BAD$RETSW   '34'
SEEK$PAST$EOF   '35'
UNRECOG$SWITCH  '201'
UNRECOG$DELIM   '202'
INVALID$SYNTAX  '203'
EARLY$EOF   '204'
BAD$LABEL   '206'
NO$END$STAT '207'
CHECKSUM$ERROR  '208'
RELO$SEQ$ERR    '209'
INSUFF$MEMORY   '210'
REC$TOO$LONG    '211'
BAD$REC$TYP '212'
FIXUP$BOUNDS    '213'
BAD$PARAM   '214'
ARG$TOO$LONG    '215'
TOO$MANY$PARAMS '216'
REC$TOO$SHORT   '217'
ILL$REC$FMT '218'
PHASE$ERROR '219'
NO$EOF      '220'
SEG$OVERFLOW    '221'
UNRECOG$REC '222'
FIXUP$ERROR '223'
ILL$REC$SEQ '224'
BAD$MOD$NAME    '225'
LONG$MOD$NAME   '226'
NO$L$PAREN  '227'
NO$R$PAREN  '228'
UNRECOG$CONTROL '229'
DUP$SYMBOL  '230'
FILE$EXISTS '231'
UNRECOG$COM '232'
NO$TO       '233'
DUP$FILE$NAME   '234'
NOT$LIB$FILE    '235'
TOO$MANY$CMNS   '236'
MISSING$COMMON  '237'
STACK$CONTENT   '238'
NO$MODHDR   '239'
OUT$OF$RANGE    '240'
INV$OBJ$FILE    '241'

# supported record types
RELOC$TYPE  '22h'
MODHDR$TYPE '2'
MODEND$TYPE '4'
CONTENT$TYPE    '6'
EOF$TYPE    '0eh'

ABS$SEG     '0'

# aftn for console devices
CONSOLE$OUTPUT  '0'
CONSOLE$INPUT   '1'

# open modes
READ$MODE   '1'
WRITE$MODE  '2'
UPDATE$MODE '3'
OPEN$FOR$READ   '1'
OPEN$FOR$WRITE  '2'
NO$LINE$EDIT    '0'

# seek modes
SEEK$RETURN '0'
SEEK$ABS    '2'

# public variables
direct      "DIRECT$T"
directINO   A
diskType        B
mapBase         A
maskArray       BS
pn          BS
singleDrive B

# winchester modes
WININIT     '0'
WINSTATUS   '1'
WINFORMAT   '2'
WINREADID   '3'
WINREAD     '4'
WINREADBUF  '5'
WINWRITE    '6'
WINWRITEBUF '7'
WINSEEK     '8'
WINBUFFERIO '14'
WINDIAG     '15'

# public procedures
Absio           P(B cmd,B disk,A block,A buffer)
ClearBuffer     P(A buf$ptr)
Deblank     P("pointer" ptr)"pointer"
Delimit     P("pointer" ptr)"pointer"
Diskio          P(A disk,A dcb$p)
FileError   P("word" status,"pointer" ptr,"bool" fatal)
FlushBlock      P(A adr)
ForceUpper  P("pointer" ptr)
FormatTrack     P(B disk,A sTrack,A eTrack,B interleave)
GetDisk         P(B n)
MoveAscii   P("pointer" dst,"pointer" src,B cnt)
NumOut      P("word" val,B base,B lc,"pointer" buf,B width)
Path        P("pointer" filename,"pointer" pn)B
ReportError P("word" errNum)
ScanInteger P("pointer" buf$p)"word"
Seq     P("pointer" str1,"pointer" str2,B cnt)"bool"
SetBlock        P(A adr)
SetupMap   P(B disk)A
SFileError      P(A status,A name$p)
StrtWD      P("pointer" wiopb$p)
StatWD      PB
TestRange       P(B device,A buffer$p)B
unpath      P(A int, A ext)
UpperCase       P(B char)B
WDelimit    P("pointer" ptr)"pointer"
WDiskIo          P(A wiopb$p, "wpointer" status$p)
WriteDirectory  P(B disk)
Ypath       P(A int,A ext)

mvasci.plm
MOVEASCII: DO;
MoveAscii: procedure(dst, src, cnt) public;
    declare (dst, src) address, cnt byte, i byte;
    declare dch based dst (1) byte, sch based src (1) byte;

    do i = 0 to cnt - 1;
        dch(i) = sch(i);
    end;
end;
end;
numout.plm
numout: do;
declare digits(*) byte data('0123456789ABCDEF');

NumOut: procedure(value, base, lc, bufAdr, width) public;
    declare (value, bufAdr) address, (base, lc, width) byte;
    declare i byte;
    declare buf based bufAdr (1) byte;

    do i = 1 to width;
        buf(width - i) = digits(value mod base);
        value = value / base;
    end;

    i = 0;
    do while buf(i) = '0' and i < width - 1;
        buf(i) = lc;
        i = i + 1;
    end;
end;
end;
rpterr.plm
ReportError: do;
$include(rpterr.ipx)
declare msg(*) byte DATA(0, 0,
    2, 'ILLEGAL AFTN ARGUMENT', 0,
    4, 'INCORRECTLY SPECIFIED FILE', 0,
    5, 'UNRECOGNIZED DEVICE NAME', 0,
    6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
    8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
    9, 'DISK DIRECTORY FULL', 0,
    0AH, 'NOT ON SAME DISK', 0,
    0BH, 'FILE ALREADY EXISTS', 0,
    0CH, 'FILE IS ALREADY OPEN', 0,
    0DH, 'NO SUCH FILE', 0,
    0EH, 'WRITE PROTECTED', 0,
    11H, 'NOT A DISK FILE', 0,
    12H, 'ILLEGAL ISIS COMMAND', 0,
    13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
    14H, 'ATTEMPTED BACK SEEK TOO FAR', 0,
    15H, 'CAN', 27H, 'T RESCAN', 0,
    16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
    17H, 'MISSING FILENAME', 0,
    19H, 'ILLEGAL ECHO FILE', 0,
    1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
    1BH, 'ILLEGAL SEEK COMMAND', 0,
    1CH, 'MISSING EXTENSION', 0,
    1FH, 'CAN', 27H, 'T SEEK ON WRITE ONLY FILE', 0,
    20H, 'CAN', 27H, 'T DELETE OPEN FILE', 0,
    23H, 'SEEK PAST EOF', 0,
    0C9H, 'UNRECOGNIZED SWITCH', 0,
    0CAH, 'UNRECOGNIZED DELIMITER', 0,
    0CBH, 'INVALID SYNTAX', 0,
    0CCH, 'PREMATURE EOF', 0,
    0CEH, 'ILLEGAL DISKETTE LABEL', 0,
    0D0H, 'CHECKSUM ERROR', 0,
    0D1H, 'RELO FILE SEQUENCE ERROR', 0,
    0D2H, 'INSUFFICIENT MEMORY', 0,
    0D3H, 'RECORD TOO LONG', 0,
    0D4H, 'ILLEGAL RELO RECORD', 0,
    0D5H, 'FIXUP BOUNDS ERROR', 0,
    0D6H, 'ILLEGAL SUBMIT PARAMETER', 0,
    0D7H, 'ARGUMENT TOO LONG', 0,
    0D8H, 'TOO MANY PARAMETERS', 0,
    0D9H, 'OBJECT RECORD TOO SHORT', 0,
    0DAH, 'ILLEGAL RECORD FORMAT', 0,
    0DBH, 'PHASE ERROR', 0,
    0EAH, 'CANNOT FORMAT FROM TARGET DRIVE', 0,
    0EBH, 'NON-DISK DEVICE', 0,
    3DH, 'UNASSIGNED DEVICE', 0,
    0ECH, 'ILLEGAL FORMAT ON REMOTE DEVICE', 0
    );

ReportError: procedure(errNum) public;
    declare errNum address;
    declare numberBuffer(3) byte, i address, status address;


    if errNum <> 0 then
    do;
        i = 0;
        do while i < size(msg);
            if errNum = msg(i) and msg(i + 1) <> 0 then
            do;
                i = i + 1;
                call write(0, .(' '), 1, .status);
                do while msg(i) <> 0;
                    call write(0, .msg(i), 1, .status);
                    i = i + 1;
                end;
                call write(0, .(CR, LF), 2, .status);
                return;
            end;
            else
            do;
                do while msg(i) <> 0;
                    i = i + 1;
                end;
                i = i + 1;
            end;
        end;
    call error(errNum);
    end;
end;
end;
seq.plm
Seq: do;
$include(seq.ipx)

Seq: procedure(s1, s2, len) bool public;
    declare (s1,s2) address, len byte;
    declare chrs1 based s1(1) byte;
    declare chrs2 based s2(1) byte;
    declare i byte;
    len = len - 1;
    do i = 0 to len;
        if chrs1(i) <> chrs2(i) then
            return FALSE;
    end;
    return TRUE;
end;
end;

serror.plm
SFileError: do;
$include(serror.ipx)

declare singleDrive bool external;
SFileError: procedure(status, name$p) public;
    declare (status, name$p) address;
    declare lStatus address;

    if status <> 0 then
    do;
        if singleDrive then
            call GetDisk(0);
        name$p = Deblank(name$p);
        call Write(0, .(' '), 1, .lStatus);
        call Write(0, name$p, WDelimit(name$p) - name$p, .lStatus);
        call Write(0, .(','), 1, .lStatus);
        call ReportError(status);
        call Exit;
    end;
end;
end;
setblk.plm
SetBlock: do;
$include(setblk.ipx)
declare mapBase address external;
SetBlock: procedure(adr) public;
    declare adr address;
    declare (bit, byt) address, spt byte;
    declare bitmap based mapBase (1) byte;

    if diskType = 9 then
        spt = 210;
    else if diskType = 1 then
        spt = 52;
    else
        spt = 26;

    byt = shr(bit := double(high(adr)) * spt + low(adr) - 1, 3);
    bitmap(byt) = bitmap(byt) or maskArray(low(bit) and 7);
end;
end;
setmap.plm
SetupMap: do;
$include(setmap.ipx)

declare fatalMsg(*) byte initial(' FATAL',
/* 6 */                    ' BAD SPOT AT LOGICAL ADDRESS ( ',
/* 37 */               '***, ',
/* 42 */               '*** ), STATUS = ',
/* 58 */               '****', CR, LF);

declare trap0B structure(jmp byte, target address) at (0bh),
    trap0E address at (0eh);

declare bitmap based mapBase (1) byte;

SetupMap: procedure(disk) address public;
    declare disk byte;
    declare logicalTrackSector address,
        (logicalSector, logicalTrack) byte at (.logicalTrackSector),
        (readBuf, savedSP) address,
        savedTrap0B structure(jmp byte, target address),
        (badSectorCount, headFixItemPtr, nextFixItemPtr, fixItemPtr) address,
        j byte, (i, bitmapLast, status) address;
    declare fixItem based fixItemPtr structure(sector byte, driveErr address, next address);

    declare trap0BCodeLocation address data(.newTrap0B);    /* used for error intercept handler */

    ChkFixedSectors: procedure;
        if (logicalTrack = 0 and (logicalSector < 1Ch or logicalSector = 58h
                                  or logicalSector = 97h or logicalSector > 0A5h))
          or (logicalTrack = 1 and (logicalSector < 40h or (48h < logicalSector and logicalSector < 88h)
                                    or logicalSector = 0AFh))
          or (logicalTrack = 2 and logicalSector < 2Eh) then
        do;
            call NumOut(logicalTrack, 10, 0, .fatalMsg(37), 3);
            call NumOut(logicalSector, 10, 0, .fatalMsg(42), 3);
            call NumOut(trap0E, 16, 0, .fatalMsg(58), 4);
            call Write(0, .fatalMsg, 64, .status);
            call Exit;
        end;
    end;


    AddBadSector: procedure;
        declare (p, q) address;
        call ChkFixedSectors;
        call SetBlock(logicalTrackSector);
        fixItemPtr, p = headFixItemPtr;
        fixItemPtr = fixItem.next;

        /* look for insert point p->sector <  logicalsector and logicalsector <= *fixItemPtr */
        do while fixItem.sector < logicalSector;
            p = fixItemPtr;
            fixItemPtr = fixItem.next;
        end;
        if fixItem.sector = logicalSector then  /* already in list */
            return;

        q = fixItemPtr;             /* insert into list and set values */
        fixItemPtr = p;
        fixItem.next = nextFixItemPtr;
        fixItemPtr = nextFixItemPtr;
        fixItem.sector = logicalSector;
        fixItem.driveErr = trap0E;
        fixItem.next = q;
        nextFixItemPtr = nextFixItemPtr + size(fixItem);    /* set up next item */
    end;


    if diskType = 9 then    /* WD */
        bitmapLast = 15FFh;
    else if diskType = 1 then   /* DD */
        bitmapLast = 1FFh;
    else
        bitmapLast = 0FFh;  /* SD */

    do i = 0 to bitmapLast;
        bitmap(i) = 0;
    end;

    if diskType <> 9 then
        return 0;
    call Write(CONSOLE$OUTPUT, .(' CHECK READ ... ', CR, LF), 18, .status);
    
    badSectorCount = 0;
    headFixItemPtr = (readBuf := mapBase + 1600h) + 128;
    savedSP = STACKPTR;
    savedTrap0B.jmp = trap0B.jmp;
    trap0B.jmp = 0c3h;
    savedTrap0B.target = trap0B.target;
    trap0B.target = trap0BCodeLocation;
    logicalTrack = 0;

nextTrack:
    fixItemPtr = headFixItemPtr;
    fixItem.next = fixItemPtr + size(fixItem);
    fixItemPtr = headFixItemPtr + size(fixItem);
    fixItem.sector = 211;   /* max sector + 1 */
    nextFixItemPtr = fixItemPtr + size(fixItem);
    logicalSector = 1;

nextSector:
    call Absio(4, disk, logicalTrackSector, readBuf);
    goto skipTrap;

newTrap0B:
    STACKPTR = savedSP;
    trap0B.jmp = savedTrap0B.jmp;
    trap0B.target = savedTrap0B.target;
    if (trap0E and 40h)  <> 40h and (trap0E and 1Fh) <> 9 and (trap0E and 1Fh) <> 1 then
        call AddBadSector;
    else
    do;
        /* mark all of the track under this head as bad */
        logicalSector = (logicalSector - 1) - ((logicalSector - 1) mod 70); /* first sector for head */
        do j = 1 to 70;
            logicalSector = logicalSector + 1;
            call AddBadSector;
        end;
    end;

    trap0B.jmp = 0c3h;
    trap0B.target = trap0BCodeLocation;

skipTrap:
    if (logicalSector := logicalSector + 1) < 211 then
        goto nextSector;

    fixItemPtr = headFixItemPtr;
    fixItemPtr = fixItem.next;

    do while fixItem.sector < 211;
        call NumOut(logicalTrack, 10, 0, .fatalMsg(37), 3);
        call NumOut(fixItem.sector, 10, 0, .fatalMsg(42), 3);
        call NumOut(fixItem.driveErr, 16, 0, .fatalMsg(58), 4);
        call Write(0, .fatalMsg(6), 58, .status);
        if logicalTrack > 1 then
            badSectorCount = badSectorCount + 1;
        fixItemPtr = fixItem.next;
    end;
    if (logicalTrack := logicalTrack + 1) < 212 then
        goto nextTrack;

    trap0B.jmp = savedTrap0B.jmp;
    trap0B.target = savedTrap0B.target;
    return badSectorCount;
end;
end;
trange.plm
TestRange: do;
$include(trange.ipx)
TestRange: procedure(device, buffer$p) byte public;
    declare device byte, buffer$p address;

    if device >= 25 then    /* diskdrive 6-9 */
        device = device - 19;   /* bring disks together */
    else if device > 5 then     /* shift others above disks */
        device = device + 4;

    if device <=  9 or buffer$p = 1 then
        return device;
    if buffer$p <> 0 then
        call FileError(0EBh, buffer$p, TRUE);
    else
    do;
        call ReportError(0EBh);
        call exit;
    end;
end;
end;
ucase.plm
UpperCase: do;
UpperCase: procedure(char) byte public;
    declare char byte;
    if char < 'a' then
        return char;
    if char > 'z' then
        return char;
    return char and 0dfh;
end;
end;
wd.plm
WriteDirectory: do;
$include(wd.ipx)
declare mapBase address external;
declare bitmap based mapBase (1) byte;

declare file(6) structure(name(9) byte) data('ISIS',0,0,'DIR',
                         'ISIS',0,0,'MAP',
                         'ISIS',0,0,'T0',0,
                         'ISIS',0,0,'BIN',
                         'ISIS',0,0,'LAB',
                         'ISIS',0,0,'BAD');

WriteDirectory: procedure(disk) public;
    declare disk byte, binIdx byte, i byte, jj address, dirBuf(64) address,
        direct(8) structure(empty byte, file(9) byte, attrib byte,
                    eof$count byte, blk address, hdrBlk address) at(.dirBuf),
        countBitMapSectors byte, binHdrBlk address, countDirSectors byte;

    SetLinks: procedure(start, count, firstBlock);
        declare (start, count, firstBlock, ii) address;

        do ii = 0 to count - 1;
            dirBuf(start + ii) = firstBlock + ii;
            call setBlock(firstBlock + ii);
        end;
    end;

    FlushBlock: procedure(adr);
        declare adr address;

        call Absio(6, disk, adr, .dirBuf);
        call SetBlock(adr);
        call ClearBuffer(.dirBuf);
    end;

    countDirSectors =  25;
    if diskType = 1 then
    do;
        countBitMapSectors = 4;
        binHdrBlk = 206h;
    end;
    else if diskType = 9 then
    do;
        countBitMapSectors = 44;
        binHdrBlk = 22Eh;
        countDirSectors = 62;
    end;
    else
    do;
        countBitMapSectors = 2;
        binHdrBlk = 204h;
    end;

    jj = .bitmap - 128;
    if diskType = 9 then
        do i = 0 to countBitMapSectors - 1;
            call Absio(6, disk, i + 0A7h, (jj := jj + 128));
        end;
    /* set linkage for isis.t0 */
    call ClearBuffer(.dirBuf);
    call SetLinks(2, 23, 1);
    call FlushBlock(18h);       
    /* set linkage for isis.lab */
    if diskType = 9 then        /* hard disk */
    do;
        dirBuf(1) = 58h;    /* next linkage is sector 58h */
        call SetLinks(2, 3Eh, 1Ah); /* first part of isis.lab */ 
    end;
    else if diskType = 1 then
    do;
        call SetLinks(2, 27, 1Ah);  /* allocate 53 blocks in 2 groups */
        call SetLinks(1Dh, 26, 11Bh);
    end;
    else
        call SetLinks(2, 1, 1Ah);   /* allocate 1 block */

    call FlushBlock(19h);       /* write label linkage */
    if diskType = 9 then
    do;
        dirBuf(0) = 19h;    /* link to previous */
        dirBuf(1) = 97h;    /* link to next */
        call SetLinks(2, 3Eh, 59h);
        call FlushBlock(58h);   /* write label linkage */
        dirBuf(0) = 58h;    /* link to previous */
        dirBuf(1) = 1AFh;   /* link to next */
        call SetLinks(2, 0Eh, 98h);
        call SetLinks(10h, 9, 140h);
        call SetLinks(19h, 27h, 188h);
        call FlushBlock(97h);   /* write label linkage */
        dirBuf(0) = 97h;
        call SetLinks(2, 23h, 1B0h);
        call FlushBlock(1AFh);  /* write label linkage */
    end;
    /* set linkage for isis.bad for hd only */
    if diskType = 9 then
    do;
        call SetLinks(2, countBitMapSectors, 0A7h);
        call FlushBlock(0A6h);
    end;

    /* set linkage for isis.dir */
    call SetLinks(2, countDirSectors, 102h);
    if diskType = 9 then
        dirBuf(1) = 149h;   /* link to next */
    call FlushBlock(101h);
    if diskType = 9 then
    do;
        dirBuf(0) = 101h;   /* link to previous */
        call SetLinks(2, countDirSectors, 14Ah);
        call FlushBlock(149h);
    end;

    /* set linkage for isis.map */
    call SetLinks(2, countBitMapSectors, 202h);
    call FlushBlock(201h);
    call FlushBlock(binHdrBlk);

    /* isis.dir */
    call MoveAscii(.direct(0).file, .file(0), 9);
    if diskType = 9 then
        direct(0).blk = 124;    /* larger size */
    else
        direct(0).blk = 25;

    direct(0).hdrBlk = 101h;    /* linkage at t1 s1 */
    direct(0).attrib = 1;
    direct(0).eof$count = 128;

    /* isis.map */
    call MoveAscii(.direct(1).file, .file(1), 9);
    direct(1).blk = countBitMapSectors;
    direct(1).hdrBlk = 201h;    /* linkage at t2 s1 */
    direct(1).attrib = 1;
    direct(1).eof$count = 128;

    /* isis.t0 */
    call MoveAscii(.direct(2).file, .file(2), 9);
    direct(2).blk = 17h;
    direct(2).hdrBlk = 18h;     /* linkage at t0 s24 */
    direct(2).attrib = 1;
    direct(2).eof$count = 128;

    /* isis.lab */
    call MoveAscii(.direct(3).file, .file(4), 9);
    if diskType = 1 then
        direct(3).blk = 35h;
    else if diskType = 9 then
        direct(3).blk = 0DDh;
    else
        direct(3).blk = 1;
    direct(3).hdrBlk = 19h;     /* linkage at t0 s25 */
    direct(3).attrib = 1;
    direct(3).eof$count = 128;

    /* isis.bad */
    if diskType = 9 then
    do;
        call MoveAscii(.direct(4).file, .file(5), 9);
        direct(4).blk = countBitMapSectors;
        direct(4).hdrBlk = 0A6h;
        direct(4).attrib = 1;
        direct(4).eof$count = 128;
        binIdx = 5;
    end;
    else
        binIdx = 4;

    /* isis.bin */
    call MoveAscii(.direct(binIdx).file, .file(3), 9);
    direct(binIdx).hdrBlk = binHdrBlk;
    direct(binIdx).attrib = 3;
    direct(binIdx).eof$count = 128;

    /* flag as no further entries */
    do i = binIdx + 1 to 7;
        direct(i).empty = 7fh;
    end;

    call FlushBlock(102h);
    do i = 0 to 7;
        direct(i).empty = 7fh;
    end;

    do i = 1 to countDirSectors - 1;
        call Absio(6, disk, 102h + i, .dirBuf);
    end;

    if diskType = 9 then
        do i = 0 to countDirSectors - 1;
            call Absio(6, disk, 14Ah + i, .dirBuf);
        end;

    jj = .bitmap - 128;
    do i = 0 to countBitMapSectors - 1;
        call Absio(6, disk, 202h + i, (jj := jj + 128));
    end;
end;
end;

wdelim.plm
WDelimit: do;
WDelimit: procedure(ptr) address public;
    declare ptr address;
    declare ch based ptr byte;

    do while (ch = ':' or ch = '.' or ch = '*' or ch = '?' or
          ('0' <= ch and ch <= '9') or ('A' <= ch and ch <= 'Z'));
        ptr = ptr + 1;
    end;
    return ptr;
end;
end;
wdisk.asm
    name    wdisk
    aseg
; declare the winchester interface structure locations
    org 44h
wiSBuf: ds  12
wiWake: ds  6 
wiCcb:  ds  16
wiCtlb: ds  16
wiIopb: ds  30

    cseg

dkstat:
    lda wiCtlb+3        ; read the status semaphore
    ana a
    jz  dk1
    mvi a,4             ; flag as complete
dk1:
    ori 1
    ret

    public  StatWD
StatWD:
    lda wiCtlb+1        ; op status
    ani 40h
    rz
    lxi     h,wiSbuf    ; read in the status buffer
    shld    wiIopb+18   ; buffer (low address)
    mvi     a,1         ; transfer status
    sta     wiIopb+11    ; function
    lxi     b,wiIopb
    call    StrtWD
    lda     wiSbuf+2    ; read status byte 2
    ani     38h         ; drive fault, id field ecc error, data field ecc error
    rlc                 ; * 4
    rlc
    mov     b,a
    lhld    wiSbuf      ; status bytes 0 & 1
    mov     a,l         ; status byte 0
    ani     0f8h
    mov     l,a
    lda     wiSbuf+2    ; status byte 2
    ani     0c0h        ; merge top 2 bits as low 2 bits of status byte 0
    rlc
    rlc
    ora     l
    mov     l,a
; at this point
; hl has from high to low bit
; write protect, unit not ready, invalid address, sector not found,
; invalid  function, no index, diagnostic fault, illegal sector size
; end of medium, illegal format type, seek in progress, isbc rom error
; isbc ram error, 0, seek error, cylinder address miscompare
; and b has from high to low bit
; drive fault, id field ecc error, data field ecc error

    mvi     c,10h
stat1:
    mvi     a,80h       ; find first set bit
    ana     h
    jnz     stat2
    dad     h
    dcr     c
    jnz     stat1
stat2:
    mov     a,c
    ora     b
    ret


    public StrtWD
StrtWD:
    mov     a,c
    sta     wiCtlb+8        ; save iopb
    mov     a,b
    sta     wiCtlb+9
    xra     a
    sta     wiCtlb+3        ; reset the status sepahore
    mvi     a,1             ; wake up the controller
    out     5

strt1:
    call    dkstat          ; wait till done
    ani     4
    jz      strt1
    ret

    end
ypath.plm
ypath: do;
declare devTab(*) byte data('F0F1F2F3F4F5TITOVIVOI1O1TRHRR1R2TPHPP1P2LPL1BBCICOF6F7F8F9');


Ypath: procedure(int, ext) public;
	declare (int, ext) address;
	declare i byte;
	declare intName based int (1) byte,
		extName based ext (1) byte;

	extName(0) = ':';
	i = intName(0);
	/* map internal device to formal device index */
	if i > 9 then
		i = i - 4;
	else if i > 5 then
		i = i + 19;

	extName(1) = devTab(i + i);
	extName(2) = devTab(i + i + 1);
	extName(3) = ':';
	ext = ext + 4;

	do i = 0 to 5;
		if (extName(0) := intName(i + 1)) <> 0 then
			ext = ext + 1;
	end;
	if intName(7) <> 0 then
	do;
		extName(0) = '.';
		ext = ext + 1;
	end;
	do i = 0 to 2;
		if (extName(0) := intName(i + 7)) <> 0 then
			ext = ext + 1;
	end;
	extName(0) = ' ';
end;
end; 
popul.plm
population: do;

declare bitCnt(*) byte initial(
	0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
	4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8);

Population: procedure(bufferLoc, length) address;
	declare (bufferLoc, length, total) address,
	(i, t, l) byte;
	declare buffer based bufferLoc (1) byte;

	total = 0;
	do while length > 31;
		t = 0;
		do i = 0 to 30;
			t = t + bitCnt(buffer(i));
		end;
		total = total + t;
		bufferLoc = bufferLoc + 31;
		length = length - 31;
	end;
	l = length - 1;
	t = 0;
	do i = 0 to l;
		t = t + bitCnt(buffer(i));
	end;
	return total + t;
end;
end;
scanin.plm
ScanInteger: do;

declare digits(*) byte data('0123456789ABCDEF');

ScanInteger: procedure(ptrPtr) address public;
	declare ptrPtr address;
	declare ptr based ptrPtr address;
	declare (scanPtr, updatePtr, stopPtr) address;
	declare (i, radix, increment) byte;
	declare (nVal, oVal) address;
	declare c based scanPtr byte;

	scanPtr = ptr;
	do while c = ' ';
		scanPtr = scanPtr + 1;
	end;
	ptr = scanPtr;
	do while '0' <= c and c <= '9' or 'A' <= c and c <= 'F';
		scanPtr = scanPtr + 1;
	end;

	stopPtr = scanPtr;
	updatePtr = scanPtr + 1;
	if c = 'H' then
		radix = 16;
	else if c = 'O' or c = 'Q' then
		radix = 8;
	else
	do;
		updatePtr = scanPtr;
		stopPtr, scanPtr = scanPtr - 1;
		if c = 'B' then
			radix = 2;
		else
		do;
			radix = 10;
			if c <> 'D' then	/* include last increment */
				stopPtr = stopPtr + 1;
		end;
	end;
	scanPtr = ptr;
	nVal, oVal = 0;
	do while scanPtr < stopPtr;
		do i = 0 to 15;
			if c = digits(i) then
				increment = i;
		end;
		if increment >= radix then
			return 0;
		nVal = oVal * radix + increment;
		if nVal < oVal then
			return 0;
		oVal = nVal;
		scanPtr = scanPtr + 1;
	end;
	ptr = updatePtr;
	return nVal;
end;
end;

rpter2.plm
/* version of report error for altmap */
ReportError: do;
$include(rpter2.ipx)
declare msg(*) byte DATA(0, 0,
    2, 'ILLEGAL AFTN ARGUMENT', 0,
    4, 'INCORRECTLY SPECIFIED FILE', 0,
    5, 'UNRECOGNIZED DEVICE NAME', 0,
    6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
    8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
    9, 'DISK DIRECTORY FULL', 0,
    0AH, 'NOT ON SAME DISK', 0,
    0BH, 'FILE ALREADY EXISTS', 0,
    0CH, 'FILE IS ALREADY OPEN', 0,
    0DH, 'NO SUCH FILE', 0,
    0EH, 'WRITE PROTECTED', 0,
    11H, 'NOT A DISK FILE', 0,
    12H, 'ILLEGAL ISIS COMMAND', 0,
    13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
    14H, 'ATTEMPTED BACK SEEK TOO FAR', 0,
    15H, 'CAN', 27H, 'T RESCAN', 0,
    16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
    17H, 'MISSING FILENAME', 0,
    19H, 'ILLEGAL ECHO FILE', 0,
    1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
    1BH, 'ILLEGAL SEEK COMMAND', 0,
    1CH, 'MISSING EXTENSION', 0,
    1FH, 'CAN', 27H, 'T SEEK ON WRITE ONLY FILE', 0,
    20H, 'CAN', 27H, 'T DELETE OPEN FILE', 0,
    21H, 'ILLEGAL PARAMETER', 0,
    23H, 'SEEK PAST EOF', 0,
    0C9H, 'UNRECOGNIZED SWITCH', 0,
    0CAH, 'UNRECOGNIZED DELIMITER', 0,
    0CBH, 'INVALID SYNTAX', 0,
    0CCH, 'PREMATURE EOF', 0,
    0CEH, 'ILLEGAL DISKETTE LABEL', 0,
    0D0H, 'CHECKSUM ERROR', 0,
    0D1H, 'RELO FILE SEQUENCE ERROR', 0,
    0D2H, 'INSUFFICIENT MEMORY', 0,
    0D3H, 'RECORD TOO LONG', 0,
    0D4H, 'ILLEGAL RELO RECORD', 0,
    0D5H, 'FIXUP BOUNDS ERROR', 0,
    0D6H, 'ILLEGAL SUBMIT PARAMETER', 0,
    0D7H, 'ARGUMENT TOO LONG', 0,
    0D8H, 'TOO MANY PARAMETERS', 0,
    0D9H, 'OBJECT RECORD TOO SHORT', 0,
    0DAH, 'ILLEGAL RECORD FORMAT', 0,
    0DBH, 'PHASE ERROR', 0,
    0EAH, 'CANNOT FORMAT FROM TARGET DRIVE', 0,
    0EBH, 'NON-DISK DEVICE', 0,
    3DH, 'UNASSIGNED DEVICE', 0,
    0ECH, 'ILLEGAL FORMAT ON REMOTE DEVICE', 0
    );

ReportError: procedure(errNum) public;
    declare errNum address;
    declare numberBuffer(3) byte, i address, status address;


    if errNum <> 0 then
    do;
        i = 0;
        do while i < size(msg);
            if errNum = msg(i) and msg(i + 1) <> 0 then
            do;
                i = i + 1;
                call write(0, .(' '), 1, .status);
                do while msg(i) <> 0;
                    call write(0, .msg(i), 1, .status);
                    i = i + 1;
                end;
                call write(0, .(CR, LF), 2, .status);
                return;
            end;
            else
            do;
                do while msg(i) <> 0;
                    i = i + 1;
                end;
                i = i + 1;
            end;
        end;
    call error(errNum);
    end;
end;
end;
