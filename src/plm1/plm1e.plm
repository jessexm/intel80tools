plm1e: DO;
declare LIT LITERALLY 'LITERALLY',
    CR  LIT '0DH',
    LF LIT '0AH',
    TRUE LIT '0FFH',
    FALSE LIT '0';

$nolist
$include(:f3:lex.inc)
declare
	ERR116 LIT '116',	/* MISSING '=' IN ASSIGNMENT STATEMENT */
	ERR117 LIT '117',	/* MISSING PROCEDURE NAME IN CALL STATEMENT */
	ERR118 LIT '118',	/* INVALID INDIRECT CALL, IDENTIFIER NOT AN ADDRESS SCALAR */
	ERR128 LIT '128',	/* INVALID LEFT-HAND OPERAND OF ASSIGNMENT */
	ERR129 LIT '129',	/* ILLEGAL 'CALL' WITH TYPED PROCEDURE */
	ERR136 LIT '136',	/* INVALID RETURN FOR UNTYPED PROCEDURE, VALUE ILLEGAL */
	ERR137 LIT '137',	/* MISSING VALUE IN RETURN FOR TYPED PROCEDURE */
	ERR138 LIT '138',	/* MISSING INDEX VARIABLE */
	ERR139 LIT '139',	/* INVALID INDEX VARIABLE TYPE, NOT BYTE OR ADDRESS */
	ERR140 LIT '140',	/* MISSING '=' FOLLOWING INDEX VARIABLE */
	ERR141 LIT '141',	/* MISSING 'TO' CLAUSE */
	ERR142 LIT '142',	/* MISSING IDENTIFIER FOLLOWING GOTO */
	ERR143 LIT '143',	/* INVALID REFERENCE FOLLOWING GOTO, NOT A LABEL */
	ERR144 LIT '144', /* INVALID GOTO LABEL, NOT AT LOCAL OR MODULE LEVEL */
	ERR145 LIT '145', 	/* MISSING 'TO' FOLLOWING 'GO' */
	ERR146 LIT '146',	/* MISSING ') ' AFTER 'AT' RESTRICTED EXPRESSION */
	ERR155 LIT '155',	/* INVALID RETURN IN MAIN PROGRAM */
	ERR156 LIT '156',	/* MISSING RETURN STATEMENT IN TYPED PROCEDURE */
	ERR164 LIT '164',	/* COMPILER ERROR: SCOPE STACK OVERFLOW */
	ERR165 LIT '165',	/* COMPILER ERROR: SCOPE STACK UNDERFLOW */
	ERR167 LIT '167',	/* COMPILER ERROR: CONTROL STACK UNDERFLOW */
	ERR168 LIT '168',  /* COMPILER ERROR: BRANCH MISSING IN 'IF' STATEMENT */
	ERR32 LIT '32',	/* INVALID SYNTAX, TEXT IGNORED UNTIL ';' */
	ERR84 LIT '84';	/*  LIMIT EXCEEDED: BLOCK NESTING */
$include(icodes.inc)
$include(t2code.inc)
$include(:f3:flags.inc)
declare	ATI$AHDR LIT '0',
	ATI$DHDR LIT '1',
	ATI$2 LIT '2',
	ATI$STRING LIT '3',
	ATI$DATA LIT '4',
	ATI$END LIT '5',
	ATI$EOF LIT '6';

declare procChains(35) ADDRESS EXTERNAL,
	procInfo(255) ADDRESS EXTERNAL,
	curInfo$p address external,
	botInfo address external,
	blockDepth ADDRESS EXTERNAL,
	localLabelCnt ADDRESS EXTERNAL;

$include(:f3:info.inc)
$list 

pushOperator: procedure(op) external; declare op byte; end;
matchTx2Item: PROCEDURE(arg1b) BYTE external; declare arg1b byte; end;
pushParseWord: PROCEDURE(arg1w) external; declare arg1w address; end;
pushParseByte: PROCEDURE(arg1b) external; declare arg1b byte; end;
sub$45E0: PROCEDURE external; end;
sub$512E: PROCEDURE(arg1w) BYTE external; declare arg1w address; end;
wrTx2ExtError: PROCEDURE(arg1b) external; declare arg1b byte; end;
exprPop: PROCEDURE external; end;
wrTx2Error: PROCEDURE(arg1b) external; declare arg1b byte; end;
exprPush2: PROCEDURE(arg1b, arg2w) external; declare arg1b byte, arg2w address; end;
exprMakeNode: PROCEDURE(arg1b, arg2b) external; declare (arg1b, arg2b) byte; end;
matchTx2AuxFlag: PROCEDURE(arg1b) BYTE external; declare arg1b byte; end;
popOperatorStack: PROCEDURE external; end;
$include(:f3:gitype.pex)
expectRPAREN: PROCEDURE(arg1b) external; declare arg1b byte; end;
popParseStack: PROCEDURE external; end;
$include(:f3:tiflag.pex)
$include(:f3:siflag.pex)
notMatchTx2Item: PROCEDURE(arg1b) BYTE external; declare arg1b byte; end;
sub$50D5: PROCEDURE external; end;
$include(:f3:gipcnt.pex)
$include(:f3:gibin.pex)
wrTx2Item: PROCEDURE(arg1b) ADDRESS external; declare arg1b byte; end;
wrTx2Item1Arg: PROCEDURE(arg1b, arg2w) ADDRESS external; DECLARE arg1b BYTE, arg2w ADDRESS; end;
wrTx2Item2Arg: PROCEDURE(arg1b, arg2w, arg3w) ADDRESS external; DECLARE arg1b BYTE, (arg2w, arg3w) ADDRESS; end;
wrTx2Item3Arg: PROCEDURE(arg1b, arg2w, arg3w, arg4w) ADDRESS external;
	DECLARE arg1b BYTE, (arg2w, arg3w, arg4w) ADDRESS;
end;
sub$42EF: PROCEDURE(arg1w) ADDRESS external; declare arg1w address; end;
wrAtFileByte: PROCEDURE(arg1b) external; declare arg1b byte; end;
wrAtFileWord: PROCEDURE(arg1w) external; declare arg1w address; end;
resetStacks: PROCEDURE external; end;
exprParse: PROCEDURE external; end;
moveExpr2Stmt: PROCEDURE external; end;
sub$467D: procedure external; end;
sub$4D2C: PROCEDURE external; end;
mapLtoT2: PROCEDURE external; end;
getTx1Item: PROCEDURE external; end;
getRestrictedExpr: PROCEDURE external; end;
$include(:f3:giscop.pex)
$include(:f3:adninf.pex)
$include(:f3:ftlerr.pex)
$include(:f3:alloc.pex)
$include(:f3:giparo.pex)
$include(:f3:gibseo.pex)
$include(:f3:sidim.pex)
$include(:f3:gidtyp.pex)
setRegetTx1Item: PROCEDURE external; end;
parseDataItems: PROCEDURE(arg1w) ADDRESS external; declare arg1w address; end;

declare markedStSP address external,
	T2CntForStmt address external,
	curProcInfo$p address external,
	curStmtNum address external,
	(varInfoOffset, varArrayIndex, varNestedArrayIndex, val) address external,
	regetTx1Item byte external,
	b88B3 byte external,
	tx1Item structure(type byte, dataw(129) address) external,
	linfo structure(itemType byte, lineCnt address, stmtCnt address, blkCnt address) external,
	tx1Aux2 byte external,
	tx1Aux1 byte external,
	tx1RdBuf(512) byte external,
	tx2Buf(512) byte external,
	xrfBuf(512) byte external,
	atBuf(512) byte external,
	b91C0 byte external,
	parseSP address external,
	parseStack(100) address external,
	operatorSP address external,
	operatorStack(50) address external,
	exSP address external,
	stSP address external,
	st1Stack(300) byte external,
	st2Stack(300) byte external,
	st3Stack(300) address external,
	b4172(1) byte external,
	builtinsMap(1) byte external,
	b413F(1) byte external,
	b40B7(1) byte external;


sub$5945: PROCEDURE BYTE public;
	declare i byte;

	call resetStacks;
	i = 0;
	do while 1;
		if notMatchTx2Item(L$VARIABLE) then
		do;
			call wrTx2ExtError(ERR128);	/* INVALID LEFT-HAND OPERAND OF ASSIGNMENT */
			return 0;
		end;
		call sub$45E0;
		call pushParseByte(11);
		call exprParse;
		if sub$512E(exSP) then
		do;
			call wrTx2ExtError(ERR128);	/* INVALID LEFT-HAND OPERAND OF ASSIGNMENT */
			call exprPop;
		end;
		else
			i = i + 1;
		if notMatchTx2Item(L$COMMA) then
			goto done;
	end;
done:	
	if matchTx2Item(L$EQ) then
	do;
		call pushParseByte(0);
		call exprParse;
		if i <> 0 then
		do;
			call exprMakeNode(I$COLONEQUALS, i + 1);
			call moveExpr2Stmt;
			markedStSP = stSP;
			return TRUE;
		end;
		else
			return FALSE;
	end;
	else
	do;
		call wrTx2ExtError(ERR116);	/* MISSING '=' IN ASSIGNMENT STATEMENT */
		return FALSE;
	end;
end;

sub$59D4: PROCEDURE BYTE public;
	declare i byte;
	call resetStacks;
	if notMatchTx2Item(L$VARIABLE) then
	do;
		call wrTx2ExtError(ERR117);	/* MISSING PROCEDURE NAME IN CALL STATEMENT */
		return FALSE;
	end;
	call sub$467D;
	i = getType;
	if i = PROC$T then
	do;
		call sub$50D5;
		if getDataType <> 0 then
			call wrTx2ExtError(ERR129);	/* ILLEGAL 'CALL' WITH TYPED PROCEDURE */
		call exprPush2(I$VARIABLE, curInfo$p);
		call pushParseWord(getParamCnt);
		call pushOperator(0);
		call pushParseByte(16);
		if matchTx2Item(L$LPAREN) then
		do;
			call pushParseByte(15);
			call pushParseByte(0);
		end;
	end;
	else if i = BUILTIN$T then
	do;
		if getDataType <> 0 then
		do;
			call wrTx2ExtError(ERR129);	/* ILLEGAL 'CALL' WITH TYPED PROCEDURE */
			return FALSE;
		end;
		call pushParseWord(builtinsMap(getBuiltinId));
		call pushParseWord(getParamCnt);
		call pushOperator(0);
		call pushParseByte(17);
		if matchTx2Item(L$LPAREN) then
		do;
			call pushParseByte(15);
			call pushParseByte(0);
		end;
	end;
	else
	do;
	    if i <> ADDRESS$T or testInfoFlag(F$ARRAY) then
	    do;
		call wrTx2ExtError(ERR118);	/* INVALID INDIRECT CALL, IDENTIFIER NOT AN ADDRESS SCALAR */
		return FALSE;
	    end;
	    call sub$4D2C;
	    call pushOperator(0);
	    call pushParseByte(18);
	    if matchTx2Item(L$LPAREN) then
	    do;
	    	call pushParseByte(15);
	    	call pushParseByte(0);
	    end;
	end;
	call exprParse;
	call moveExpr2Stmt;
	markedStSP = stSP;
	return TRUE;
end;

sub$5AD8: PROCEDURE public;
	call resetStacks;
	call pushParseByte(0);
	call exprParse;
	call moveExpr2Stmt;
	markedStSP = stSP;
end;

stmtParse: PROCEDURE(arg1w) ADDRESS public;
	declare arg1w address;
	declare i byte, (w99BF, w99C1, p) address;


	flgVisited: PROCEDURE(arg1w, arg2w);
		declare (arg1w, arg2w) address;
		st1Stack(arg1w) = 255;
		st3Stack(arg1w) = arg2w;
	end;

	sub$5BF5: PROCEDURE(arg1w);
	    declare arg1w address;
	    declare i byte, p address, j byte;

	    p = st3Stack(arg1w);
	    if (i := st1Stack(arg1w)) = I$VARIABLE then 
		w99C1 = wrTx2Item1Arg(T2$VARIABLE, p - botInfo);
	    else if i = I$NUMBER then
	    do;
		if high(p) = 0 then
			j = T2$NUMBER;
		else
			j = T2$BIGNUMBER;
		w99C1 = wrTx2Item1Arg(j, p);
	    end;
	    else if i = I$INPUT then
		w99C1 = wrTx2Item1Arg(T2$INPUT, p);
	    else if i = I$LENGTH or i = I$LAST or i = I$SIZE then
		w99C1 = wrTx2Item1Arg(b413F(i), p - botInfo);
	    else
		w99C1 = wrTx2Item(b413F(i));
	    call flgVisited(arg1w, w99C1);
	end;

	stmtParse0: PROCEDURE;
		declare i byte;
		w99BF = parseStack(parseSP);
		call popParseStack;
		if (i := st1Stack(w99BF)) = I$OUTPUT then
			return;
		if st2Stack(w99BF) = 0 then
			call sub$5BF5(w99BF);
		else
		do;
			call pushParseWord(w99BF);
			if i = I$CALL then
				call pushParseByte(3);
			else if i = I$CALLVAR then
			do;
				call pushParseByte(6);
				call pushParseWord(st3Stack(w99BF));
				call pushParseByte(0);
			end;
			else if i = I$COLONEQUALS then
				call pushParseByte(9);
			else if i = I$MOVE then
			do;
				call pushParseByte(14);
				call pushParseWord(st3Stack(w99BF));
				call pushParseByte(0);
			end;
			else if i = I$BYTEINDEX or i = I$WORDINDEX then
			do;
				call pushParseByte(8);
				call pushParseWord(2);		/* serialise 2 leaves */
				call pushParseWord(st3Stack(w99BF));
				call pushParseByte(1);
			end;
			else
			do;
				call pushParseByte(13);					/* post serialisation */
				call pushParseWord(st2Stack(w99BF));	/* num args */
				call pushParseWord(st3Stack(w99BF));	/* loc of args */
				call pushParseByte(1);
			end;
		end;
	end;


	stmtParse1: PROCEDURE;	/* serialise 1 leaf then check */
		w99BF = parseStack(parseSP);
		call pushParseByte(2);	/* flag to check for more leaves */
		call pushParseWord(w99BF);	/* serialise this leaf */
		call pushParseByte(0);
	end;

	stmtParse2: PROCEDURE;	/* check for any more leaves */
		declare p address;
		p = parseSP - 1;
		parseStack(p) = parseStack(p) - 1;
		if parseStack(p) = 0 then
		do;
			call popParseStack;
			call popParseStack;
		end;
		else
		do;
			parseStack(parseSP) = parseStack(parseSP) + 1;
			call pushParseByte(1);
		end;
	end;

	stmtParse3: PROCEDURE;	/* parse call args */
		w99BF = parseStack(parseSP);
		call pushParseByte(5);	/* final call wrap up */
		if st2Stack(w99BF) > 1 then
		do;	/* any args */
			call pushParseWord(st2Stack(w99BF) - 1);	/* num args  */
			call pushParseWord(st3Stack(w99BF) + 1);	/* index of arg info */
			curInfo$p = st3Stack(st3Stack(w99BF));	/* info of procedure */
			call advNxtInfo;							/* adv to arginfo */
			call pushParseWord(curInfo$p);
			call pushParseByte(4);
			call pushParseWord(st3Stack(w99BF) + 1);	/* index of arg info */
			call pushParseByte(0);						/* serialise the arg */
		end;
		w99C1 = wrTx2Item(T2$BEGCALL);
	end;

	stmtParse4: PROCEDURE;
		declare (p, q) address, (i, j) byte;

		q = (p := parseSP - 1) - 1;
		curInfo$p = parseStack(parseSP);
		w99BF = parseStack(p);
		i = parseStack(q);
		if i > 2 then
		do;	/* all bar first 2 args to stack */
			if curInfo$p = 0 then 
				w99C1 = wrTx2Item1Arg(T2$STKARG, sub$42EF(st3Stack(w99BF)));
			else
			do;
				if getType = BYTE$T then
					j = T2$STKBARG;
				else
					j = T2$STKWARG;
				w99C1 = wrTx2Item1Arg(j, sub$42EF(st3Stack(w99BF)));
				call advNxtInfo;
				parseStack(parseSP) = curInfo$p;
			end;
			call flgVisited(w99BF, w99C1);
		end;
		i = i - 1;
		if i = 0 then
		do;			/* all done, clear working data */
			call popParseStack;
			call popParseStack;
			call popParseStack;
		end;
		else
		do;
			parseStack(q) = i;
			w99BF = w99BF + 1;
			parseStack(p) = w99BF;
			call pushParseByte(4);
			call pushParseWord(w99BF);	/* serialise the arg */
			call pushParseByte(0);
		end;
	end;


	stmtParse5: PROCEDURE;
		declare (p, q) address, i byte, r address;
		w99BF = parseStack(parseSP);
		call popParseStack;
		r = st3Stack(w99BF);
		i = st2Stack(w99BF) - 1;
		p, q = 0;
		if i > 1 then
		do;
			p = sub$42EF(st3Stack(r + i - 1));
			q = sub$42EF(st3Stack(r + i));
		end;
		else if i > 0 then
			p = sub$42EF(st3Stack(r + i));
		w99C1 = wrTx2Item3Arg(T2$CALL, p, q, st3Stack(r) - botInfo);
		call flgVisited(w99BF, w99C1);
	end;

	stmtParse6: PROCEDURE;
		declare i byte, p address;
		w99C1 = wrTx2Item(T2$BEGCALL);
		w99BF = parseStack(parseSP);
		call pushParseByte(7);
		if (i := st2Stack(w99BF) - 1) <> 0 then
		do;
			call pushParseWord(i);
			p = st3Stack(w99BF) + 1;
			call pushParseWord(p);
			call pushParseWord(0);	/* no arg info */
			call pushParseByte(4);
			call pushParseWord(p);
			call pushParseByte(0);
		end;
	end;

	stmtParse7: PROCEDURE;
		declare i byte;
		declare (p, q, r) address;
		w99BF = parseStack(parseSP);
		call popParseStack;
		i = st2Stack(w99BF) - 1;
		p = st3Stack(w99BF);
		q, r = 0;
		if i > 1 then
		do;
			q = sub$42EF(st3Stack(p + i - 1));
			r = sub$42EF(st3Stack(p + i));
		end;
		else if i > 0 then
			q = sub$42EF(st3Stack(p + i));
		w99C1 = wrTx2Item3Arg(T2$CALLVAR, q, r, sub$42EF(st3Stack(p)));
		call flgVisited(w99BF, w99C1);
	end;

	stmtParse8: PROCEDURE;
		declare i byte, p address;
		w99BF = parseStack(parseSP);
		call popParseStack;
		i = st1Stack(w99BF);
		p = st3Stack(w99BF);
		w99C1 = wrTx2Item3Arg(b413F(i), sub$42EF(st3Stack(p)),
					sub$42EF(st3Stack(p+1)), st3Stack(p+2));
		call flgVisited(w99BF, w99C1);
	end;


	stmtParse9: PROCEDURE;
		w99BF = parseStack(parseSP);
		call pushParseByte(10);	/* post serialise LHS */
		call pushParseWord(st3Stack(w99BF) + st2Stack(w99BF) - 1);
		call pushParseByte(0);
	end;


	stmtParse10: PROCEDURE;
		declare i byte, p address;
		w99BF = parseStack(parseSP);
		call pushParseByte(12);		/* mark LHS as used at end */
		i = st2Stack(w99BF) - 1;	/* num RHS */
		p = st3Stack(w99BF);		/* base RHS */
		call pushParseWord(i);
		call pushParseWord(p);
		call pushParseWord(p + i);			/* LHS */
		call pushParseByte(11);				/* after serialised leaf */
		call pushParseWord(p);				/* do the leaf */
		call pushParseByte(0);
	end;


	stmtParse11: PROCEDURE;		/* do one RHS assignment */
		declare (p, q) address, i byte;
		declare (r, s) address;

		i = parseStack(q := (p := parseSP - 1) - 1);
		s = parseStack(parseSP);
		if st1Stack(r := parseStack(p)) = I$OUTPUT then
		do;
			w99C1 = wrTx2Item1Arg(T2$NUMBER, st3Stack(r));
			w99C1 = wrTx2Item2Arg(T2$OUTPUT, sub$42EF(w99C1), sub$42EF(st3Stack(s)));
		end;
		else 
			w99C1 = wrTx2Item2Arg(T2$STORE, sub$42EF(st3Stack(r)), sub$42EF(st3Stack(s)));
		i = i - 1;
		if i = 0 then
		do;		/* all done */
			call popParseStack;
			call popParseStack;
			call popParseStack;
		end;
		else
		do;			/* no so do another */
			parseStack(q) = i;
			r = r + 1;
			parseStack(p) = r;
			call pushParseByte(11);	/* state 11 after serialise */
			call pushParseWord(r);	/* serialise leaf */
			call pushParseByte(0);
		end;
	end;

	stmtParse12: PROCEDURE;		/* mark LHS as used */
		w99BF = parseStack(parseSP);
		call popParseStack;
		w99C1 = st3Stack(st3Stack(w99BF) + st2Stack(w99BF) - 1);
		call flgVisited(w99BF, w99C1);
	end;


	stmtParse13: PROCEDURE;	/* binary or unary op */
		declare p address, i byte;

		w99BF = parseStack(parseSP);
		call popParseStack;
		p = st3Stack(w99BF);
		i = b413F(st1Stack(w99BF));
		if st2Stack(w99BF) = 1 then 
			w99C1 = wrTx2Item1Arg(i, sub$42EF(st3Stack(p)));
		else 
			w99C1 = wrTx2Item2Arg(i, sub$42EF(st3Stack(p)), sub$42EF(st3Stack(p+1)));
		call flgVisited(w99BF, w99C1);
	end;


	stmtParse14: PROCEDURE;
		declare p address;
		p = st3Stack(w99BF := parseStack(parseSP));
		/* emit the count leaf */
		w99C1 = wrTx2Item1Arg(T2$BEGMOVE, sub$42EF(st3Stack(p)));
		call flgVisited(p, w99C1);
		call pushParseByte(15);		/* MOVE post serialise */
		call pushParseWord(2);		/* serialise the address leaves */
		call pushParseWord(p + 1);
		call pushParseByte(1);
	end;

	stmtParse15: PROCEDURE;		/* rest of MOVE */
		declare p address;
		w99BF = parseStack(parseSP);
		call popParseStack;
		p = st3Stack(w99BF);
		w99C1 = wrTx2Item3Arg(T2$MOVE, sub$42EF(st3Stack(p+1)),
				sub$42EF(st3Stack(p+2)), sub$42EF(st3Stack(p)));
		call flgVisited(w99BF, w99C1);
	end;

	p = curInfo$p;
	parseSP = 0;
	call pushParseWord(arg1w);
	call pushParseByte(0);
	do while parseSP <> 0;
		i = parseStack(parseSP);
		parseSP = parseSP - 1;
		do case i;
			call stmtParse0;
			call stmtParse1;
			call stmtParse2;
			call stmtParse3;
			call stmtParse4;
			call stmtParse5;
			call stmtParse6;
			call stmtParse7;
			call stmtParse8;
			call stmtParse9;
			call stmtParse10;
			call stmtParse11;
			call stmtParse12;
			call stmtParse13;
			call stmtParse14;
			call stmtParse15;
		end;
	end;
	curInfo$p = p;
	return st3Stack(arg1w);
end;



sub$6523: PROCEDURE public;

declare b99FF(20) byte,
	b9A13(20) byte,
	procInfoStack(20) address,
	hNodes(20) address,
	eNodes(20) address,
	w9A9F(20) address,
	w9AC7(20) address,
	controlSP address;



	pushScope: PROCEDURE(arg1w);
		declare arg1w address;
		if blockDepth = 22h then
			call fatalError(ERR164);	/* COMPILER ERROR: SCOPE STACK OVERFLOW */
		else 
			procChains(blockDepth := blockDepth + 1) = arg1w;
	end;

	popScope: PROCEDURE;
		if blockDepth = 0 then
			call fatalError(ERR165);	/* COMPILER ERROR: SCOPE STACK UNDERFLOW */
		else
			blockDepth = blockDepth - 1;
	end;

	pushControl: PROCEDURE(arg1b);
		declare arg1b byte;
		if controlSP = 13h then
			call fatalError(ERR84);	/*  LIMIT EXCEEDED: BLOCK NESTING */
		else
		do;
			b99FF(controlSP := controlSP + 1) = arg1b;
			b9A13(controlSP) = 0;
			procInfoStack(controlSP) = 0;
			hNodes(controlSP) = 0;
			eNodes(controlSP) = 0;
			w9A9F(controlSP) = 0;
			w9A9F(controlSP) = 0;	/* duplicate !! */
		end;
	end;


	popControl: PROCEDURE;
		if controlSP = 0 then
			call fatalError(ERR167);	/* COMPILER ERROR: CONTROL STACK UNDERFLOW */
		else
		do;
			if b99FF(controlSP) <> 0 then 
				b9A13(controlSP-1) = b9A13(controlSP) or b9A13(controlSP-1);
			controlSP = controlSP - 1;
		end;
	end;

	genLocalLabel: PROCEDURE ADDRESS;
		call alloc(3, 3);
		return (localLabelCnt := localLabelCnt + 1);
	end;


	sub$671D: PROCEDURE(arg1w) ADDRESS;
		declare arg1w address, (p, q) address;
		curInfo$p = arg1w;
		q = wrTx2Item1Arg(T2$VARIABLE, arg1w - botInfo);
		if testInfoFlag(F$MEMBER) then
		do;
			curInfo$p = getParentOffset;
			p = wrTx2Item1Arg(T2$VARIABLE, curInfo$p - botInfo);
			q = wrTx2Item2Arg(T2$MEMBER, sub$42EF(p), sub$42EF(q));
		end;
		return q;
	end;

	sub$677C: PROCEDURE(arg1w) ADDRESS;
		declare arg1w address, (p, q) address;
		q = sub$671D(arg1w);
		if testInfoFlag(F$BASED) then
		do;
			p = sub$671D(getBaseOffset);
			q = wrTx2Item2Arg(T2$BASED, sub$42EF(p), sub$42EF(q));
		end;
		return q;
	end;

	chkEndOfStmt: PROCEDURE;
		if matchTx2AuxFlag(128) then
		do;
			call wrTx2ExtError(ERR32);	/* INVALID SYNTAX, TEXT IGNORED UNTIL ';' */
			do while (tx1Aux2 and 80h) <> 0;
				call getTx1Item;
			end;
			call setRegetTx1Item;
		end;
	end;


	sub$67E3: PROCEDURE;
		declare (p, q, r, s, t, u ,v, w) address;

		p = procInfoStack(controlSP);
		u = hNodes(controlSP);
		v = eNodes(controlSP);
		if (w := w9A9F(controlSP)) = 0 then
		do;
			curInfo$p = p;
			if getType = BYTE$T then
				t = wrTx2Item1Arg(T2$LOCALLABEL, genLocalLabel);
			q = sub$677C(p);
			r = sub$677C(p);
			s = wrTx2Item1Arg(T2$NUMBER, 1);
			if getType = BYTE$T then
			do;
				r = wrTx2Item2Arg(T2$ADDB, sub$42EF(r), sub$42EF(s));
				q = wrTx2Item2Arg(T2$STORE, sub$42EF(q), sub$42EF(r));
				q = wrTx2Item2Arg(T2$JNZ, u, 3);
			end;
			else
			do;
				r = wrTx2Item2Arg(T2$ADDW, sub$42EF(r), sub$42EF(s));
				q = wrTx2Item2Arg(T2$STORE, sub$42EF(q), sub$42EF(r));
				q = wrTx2Item1Arg(T2$JNC, u);
			end;
		end;
		else 
			q = wrTx2Item1Arg(T2$JMP, w);
		q = wrTx2Item1Arg(T2$LOCALLABEL, v);
	end;


	sub$6917: PROCEDURE ADDRESS;
		call sub$5AD8;
		return stmtParse(markedStSP);
	end;


	sub$6923: PROCEDURE;
		declare p address;
		p = sub$6917;
		call chkEndOfStmt;
		if matchTx2Item(L$JMPFALSE) then
			p = wrTx2Item2Arg(T2$JMPFALSE, tx1Item.dataw(0), sub$42EF(p));
		else
			call fatalError(ERR168);  /* COMPILER ERROR: BRANCH MISSING IN 'IF' STATEMENT */
	end;

	parseSTMTCNT: PROCEDURE;
		T2CntForStmt = 0;
		call mapLtoT2;
		curStmtNum = tx1Item.dataw(0);
	end;


	parseIF: PROCEDURE;
		call sub$6923;
	end;

	parsePROCEDURE: PROCEDURE;
		tx1Item.dataw(0) = tx1Item.dataw(0) - botInfo;
		call mapLtoT2;
		call pushControl(0);
		procInfoStack(controlSP) = curProcInfo$p;
		curProcInfo$p, curInfo$p = tx1Item.dataw(0) + botInfo;
		call setInfoFlag(F$DECLARED);
	end;

	parseWHILE: PROCEDURE;
		declare (p, q, r) address;
		call pushControl(2);
		p = genLocalLabel;
		q = genLocalLabel;
		hNodes(controlSP) = p;
		eNodes(controlSP) = q;
		r = wrTx2Item1Arg(T2$LOCALLABEL, p);
		r = sub$6917;
		r = wrTx2Item2Arg(T2$JMPFALSE, q, sub$42EF(r));
		call chkEndOfStmt;
	end;

	parseCASE: PROCEDURE;
		declare (p, q) address;
		call pushControl(3);
		call mapLtoT2;
		q = sub$6917;
		p = genLocalLabel;
		q = wrTx2Item2Arg(T2$63, p, sub$42EF(q));
		hNodes(controlSP) = p;
		call chkEndOfStmt;
	end;

	parseDOLOOP: PROCEDURE;
		declare (p, q, r, s, t, u, v, w) address;

		call pushControl(1);
		if notMatchTx2Item(L$VARIABLE) then
		do;
			call wrTx2Error(ERR138);	/* MISSING INDEX VARIABLE */
			return;
		end;
		call sub$467D;
		w = curInfo$p;
		procInfoStack(controlSP) = w;
		if (getType <> BYTE$T and getType <> ADDRESS$T) or testInfoFlag(F$ARRAY) then
		do;
			call wrTx2ExtError(ERR139);	/* INVALID INDEX VARIABLE TYPE, NOT BYTE OR ADDRESS */
			return;
		end;
		if notMatchTx2Item(L$EQ) then
		do;
			call wrTx2ExtError(ERR140);	/* MISSING '=' FOLLOWING INDEX VARIABLE */
			return;
		end;
		b99FF(controlSP) = 4;
		p = sub$677C(w);
		q = sub$6917;
		p = wrTx2Item2Arg(T2$STORE, sub$42EF(p), sub$42EF(q));
		s = genLocalLabel;
		hNodes(controlSP) = s;
		p = wrTx2Item1Arg(T2$LOCALLABEL, s);
		p = sub$677C(w);

		if matchTx2Item(L$TO) then
			q = sub$6917;
		else
		do;
			call wrTx2ExtError(ERR141);	/* MISSING 'TO' CLAUSE */
			q = wrTx2Item1Arg(T2$NUMBER, 0);
		end;

		p = wrTx2Item2Arg(T2$LE, sub$42EF(p), sub$42EF(q));
		t = genLocalLabel;
		eNodes(controlSP) = t;
		p = wrTx2Item2Arg(T2$JMPFALSE, t, sub$42EF(p));

		if notMatchTx2Item(L$BY) then
			return;
		v = genLocalLabel;
		w9AC7(controlSP) = v;
		p = wrTx2Item1Arg(T2$JMP, v);
		u = genLocalLabel;
		w9A9F(controlSP) = u;
		p = wrTx2Item1Arg(T2$LOCALLABEL, u);
		p = sub$677C(w);
		q = sub$677C(w);
		r = sub$6917;
		q = wrTx2Item2Arg(T2$ADDW, sub$42EF(q), sub$42EF(r));
		p = wrTx2Item2Arg(T2$STORE, sub$42EF(p), sub$42EF(q));
		p = wrTx2Item1Arg(T2$JNC, s);
		p = wrTx2Item1Arg(T2$JMP, t);
		p = wrTx2Item1Arg(T2$LOCALLABEL, v);
	end;

	parseEND: PROCEDURE;
		declare p address;
		do case b99FF(controlSP);
			do;
				curInfo$p = curProcInfo$p;
				call setInfoFlag(F$DEFINED);
				if getDataType <> 0 and not b9A13(controlSP) then
					call wrTx2Error(ERR156);	/* MISSING RETURN STATEMENT IN TYPED PROCEDURE */
				p = wrTx2Item(T2$ENDPROC);
				curProcInfo$p = procInfoStack(controlSP);
			end;
			;
			do;
				p = wrTx2Item1Arg(T2$JMP, hNodes(controlSP));
				p = wrTx2Item1Arg(T2$LOCALLABEL, eNodes(controlSP));
			end;
			do;
				p = wrTx2Item1Arg(T2$LOCALLABEL, hNodes(controlSP));
				p = wrTx2Item(T2$ENDCASE);
			end;
			call sub$67E3;
		end;
		call popControl;
		call popScope;
	end;

	parseSTATEMENT: PROCEDURE;
		declare p address;
		if sub$5945 then 
			p = stmtParse(markedStSP);
		call chkEndOfStmt;
	end;


	parseCALL: PROCEDURE;
		declare p address;
		if sub$59D4 then
			p = stmtParse(markedStSP);
		call chkEndOfStmt;
	end;

	parseRETURN: PROCEDURE;
		declare p address, i byte;
		if curProcInfo$p = 0 then
		do;
			call wrTx2Error(ERR155);	/* INVALID RETURN IN MAIN PROGRAM */
			return;
		end;
		curInfo$p = curProcInfo$p;
		i = getDataType;
		if matchTx2AuxFlag(128) then	/* there is an expression */
		do;
			call setRegetTx1Item;
			if i = 0 then
				call wrTx2Error(ERR136);	/* INVALID RETURN FOR UNTYPED PROCEDURE, VALUE ILLEGAL */
			p = sub$6917;
			if i = 2 then 
				p = wrTx2Item1Arg(T2$RETURNBYTE, sub$42EF(p));
			else
				p = wrTx2Item1Arg(T2$RETURNWORD, sub$42EF(p));
		end;
		else
		do;
			if i <> 0 then
				call wrTx2Error(ERR137);	/* MISSING VALUE IN RETURN FOR TYPED PROCEDURE */
			p = wrTx2Item(T2$RETURN);
		end;
		b9A13(controlSP) = 0ffh;
		call chkEndOfStmt;
	end;

	parseEIDIHLT: PROCEDURE;
		call mapLtoT2;
		call chkEndOfStmt;
	end;

	parseGOTO: PROCEDURE;
		declare p address;
		if notMatchTx2Item(L$VARIABLE) then 
			call wrTx2Error(ERR142);	/* MISSING IDENTIFIER FOLLOWING GOTO */
		else
		do;
			call sub$45E0;
			if getType <> LABEL$T then 
				call wrTx2ExtError(ERR143);	/* INVALID REFERENCE FOLLOWING GOTO, NOT A LABEL */
			else
			do;
				if high(getScope) = 1 and high(procChains(blockDepth)) <> 1 then
					call setInfoFlag(F$MODGOTO);
				if high(getScope) = 1 or high(getScope) = high(procChains(blockDepth)) then
				do;
					p = wrTx2Item1Arg(T2$GO$TO, curInfo$p - botInfo);
					call chkEndOfStmt;
				end;
				else 
					call wrTx2ExtError(ERR144); /* INVALID GOTO LABEL, NOT AT LOCAL OR MODULE LEVEL */
			end;
		end;
	end;


	parseGO: PROCEDURE;
		if notMatchTx2Item(L$TO) then
			call wrTx2Error(ERR145); 	/* MISSING 'TO' FOLLOWING 'GO' */
		call parseGOTO;
	end;

	parseAT: PROCEDURE;
		declare p address;
		p = tx1Item.dataw(0);
		call getTx1Item;
		call getRestrictedExpr;
		call wrAtFileByte(ATI$AHDR);
		call wrAtFileWord(p - botInfo);
		call wrAtFileWord(curStmtNum);
		call wrAtFileWord(varInfoOffset);
		call wrAtFileWord(varArrayIndex);
		call wrAtFileWord(varNestedArrayIndex);
		call wrAtFileWord(val);
		call expectRPAREN(ERR146);	/* MISSING ') ' AFTER 'AT' RESTRICTED EXPRESSION */
	end;

	parseDATA$INITIAL: PROCEDURE;
		declare (p, q) address;
		p = tx1Item.dataw(0);
		call getTx1Item;
		q = parseDataItems(p);
		if (curInfo$p := p) <> botInfo then
		    if testInfoFlag(F$STARDIM) then
			call setDimension(q);
	end;

	controlSP = 0;
	call getTx1Item;
	do while tx1Item.type <> L$EOF;
        	curInfo$p = 0;
		do case b40B7(tx1Item.type);
			call parseSTMTCNT; 	/* L$STMTCNT */
			call pushScope(tx1Item.dataw(0));  /* L$SCOPE */
			call parseEND;	/* L$END */
			call parseIF;	/* L$IF */
			do;
				call parseDOLOOP;		/* L$DOLOOP */
				call chkEndOfStmt;
			end;
			call parseWHILE;	/* L$WHILE */
			call pushControl(1);	/* L$DO */
			call parsePROCEDURE;	/* L$PROCEDURE */
			call parseCASE;	/* L$CASE */
			call parseSTATEMENT;	/* L$STATEMENT */
			call parseCALL;	/* L$CALL */
			call parseRETURN;	/* L$RETURN */
			call parseGOTO;	/* L$GOTO */
			call parseGO;	/* L$GO */
			;			/* L$SEMICOLON */
			call parseEIDIHLT;	/* L$ENABLE, L$DISABLE, L$HALT */
			call parseAT;	/* L$AT */
			call parseDATA$INITIAL;	/* L$DATA, L$INITIAL */
			;		/* expression items */
			call mapLtoT2;	/* L$LABELDEF, L$LOCALLABEL, L$JMP, L$JMPFALSE, L$CASELABEL */
			do;
				curInfo$p = tx1Item.dataw(0);	/* L$EXTERNAL */
				call setInfoFlag(F$DECLARED);
				call setInfoFlag(F$DEFINED);
			end;
		end;
		call getTx1Item;
	end;
end;
END;
