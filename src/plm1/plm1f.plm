plm1f: DO;
$include(plm1f.ipx)



declare externalsCnt byte initial(0),
	atStmtNum address initial(0),
	b9B40 byte;

sub$6EE0: PROCEDURE public;

    sub$6EF6: PROCEDURE(arg);
	DECLARE arg ADDRESS;
	DECLARE p ADDRESS;

	hasErrors = TRUE;
	p = curInfo$p - botInfo;
	call fwrite(.tx2File, .(T2$ERROR), 1);
	call fwrite(.tx2File, .arg, 2);
	call fwrite(.tx2File, .p, 2);
	call fwrite(.tx2File, .atStmtNum, 2);
    end;

    getElementSize: PROCEDURE ADDRESS;
	DECLARE i BYTE;
	i = getType - 2;
	if i > 2 then
	    return 0;
	do case i;
	    return 1;		/* byte */
	    return 2;		/* address */
	    return getParentOffset; /* structure. Returns val not offeset for struct */
	end;
    end;

    getVarSize: PROCEDURE ADDRESS;
	if testInfoFlag(F$ARRAY) then
	    return getDimension * getElementSize;
	else
	    return getElementSize;
    end;

    revmemmov: PROCEDURE(srcp, dstp, cnt);
	DECLARE (srcp, dstp, cnt) ADDRESS;
	DECLARE srcw BASED srcp ADDRESS,
	    dstw BASED dstp ADDRESS;

	srcp = srcp + cnt - 2;
	dstp = dstp + cnt - 2;
	do while cnt > 1;
	    dstw = srcw;
	    cnt = cnt - 2;
	    dstp = dstp - 2;
	    srcp = srcp - 2;
	end;
	if cnt = 1 then
	    dstw = (dstw and 0ffh) or (srcw and 0ff00h);
    end;

    advNextDataInfo: PROCEDURE;
	do while 1;
	    call advNxtInfo;
	    if curInfo$p = 0 then
		return;
	    if getType >= BYTE$T and getType <= STRUCT$T then
		return;
	end;
    end;

    sub$7049: PROCEDURE;
	DECLARE p ADDRESS, i BYTE;
	DECLARE hashChains BASED hashChains$p(1) ADDRESS;

	if  not b9B40 and not IXREF then
	    return;
	p = topSymbol - 1;
	do i = 0 to 63;
	    curSymbol$p = hashChains(i);
	    do while curSymbol$p <> 0;
		if (curInfo$p := cursym.info$p) <> 0 and high(curInfo$p) <> 0ffh then
		do;
			p = p - cursym.name(0) - 1;
			do while curInfo$p <> 0; 
				call setSymbol(p);
				curInfo$p = getLinkOffset;
			end;
			call fwrite(.nmsFile, .cursym.name, cursym.name(0) + 1);
		end;
		curSymbol$p = cursym.link;
	    end;
	end;
	call fwrite(.nmsFile, .(0), 1);
    end;


    sub$711F: PROCEDURE;
	DECLARE (p, q, r, s) ADDRESS;

	curInfo$p = botInfo + 2;

	call advNextDataInfo;
	do while curInfo$p <> 0;
	    if getType = STRUCT$T then
		call setParentOffset(0);	/* struct size is 0 */
	    else if testInfoFlag(F$MEMBER) then
	    do;
		r = getVarSize;
		p = curInfo$p;
		curInfo$p = getParentOffset;	/* get structure info */
		q = getParentOffset;		/* this gets size so far */
		if (s := q + r) < r then	/* add in the new element */
			call sub$6EF6(ERR208);	/* LIMIT EXCEEDED: STRUCTURE SIZE */
		call setParentOffset(s);	/* store the running size */
		curInfo$p = p;
		call setLinkVal(q);		/* use link value for offset of this memeber */
	    end;
	    call advNextDataInfo;
	end;
    end;

    sub$719D: PROCEDURE;
        DECLARE i BYTE, p ADDRESS;


	allocVarAddress: PROCEDURE(arg1w$p);
	    DECLARE arg1w$p ADDRESS,
		arg1w BASED arg1w$p ADDRESS;

	    call setLinkVal(arg1w);		/* allocate this var's address */
	    arg1w = arg1w + getVarSize;		/* reserve it's space */
	    if arg1w < getVarSize then
		call sub$6EF6(ERR207);	/* LIMIT EXCEEDED: SEGMENT SIZE */
	end;


	sub$7323: PROCEDURE;
	    DECLARE (p, q) ADDRESS;

	    p = curInfo$p;
	    curInfo$p = procInfo(high(getScope));
	    q = .info.parent;		/* varsize union with parent */
	    curInfo$p = p;
	    call allocVarAddress(q);
	end;



	/* allocate external data ids */
        curInfo$p = botInfo + 2;
        standAlone = haveModule;
        
        do while curInfo$p <> 0;
		if getType >= BYTE$T and getType <= STRUCT$T 
		    or getType = PROC$T or getType = LABEL$T then
		do;
		    if testInfoFlag(F$EXTERNAL) then
		    do;
			    call setExternId(externalsCnt);
			    externalsCnt = externalsCnt + 1;
			    if externalsCnt = 0 then
				call sub$6EF6(ERR219);	/* LIMIT EXCEEDED: NUMBER OF EXTERNALS > 255 */
			    call setLinkVal(0);
			    standAlone = false;
		    end;
		    else if testInfoFlag(F$PUBLIC) then
			    standAlone = false;
		end;
		call advNxtInfo;
        end;
        
	/* allocate data variables */
        curInfo$p = botInfo + 2;	/* start at bottom */
        call advNextDataInfo;			/* find next data */
        
        do while curInfo$p <> 0;
		if not (testInfoFlag(F$MEMBER) or testInfoFlag(F$AT) or testInfoFlag(F$EXTERNAL)) then
		do;
		    if testInfoFlag(F$PARAMETER) then
		    do;
			    p = curInfo$p;
			    curInfo$p = procInfo(high(getScope));
			    i = testInfoFlag(F$EXTERNAL);	/* only allocate parameter if not external */
			    curInfo$p = p;
		    end;
		    else 
			    i = FALSE;
		    if i then
			    call setLinkVal(0);		/* external parameter has 0 offset */
		    else if testInfoFlag(F$BASED) then
			    call setLinkVal(0);		/* based var has 0 offset */
		    else if testInfoFlag(F$DATA) then
			    call allocVarAddress(.csegSize);	/* allocate initialised data var */
		    else if testInfoFlag(F$MEMORY) then
			    ;				/* memory is predefined */
		    else if testInfoFlag(F$AUTOMATIC) then	/* allocate stack var */
			    call sub$7323;
		    else
			    call allocVarAddress(.dsegSize);	/* allocate uninitalised data */
		end;
		call advNextDataInfo;		/* get next data */
        end;
    end;



    procAtFile: PROCEDURE;
	   declare atFData STRUCTURE(type byte, info$p address, stmtNum address,
		varInfoOffset address, varArrayIndex address, varNestedArrayIndex address,
		val address, pad(242) byte); 

	    sub$73DC: PROCEDURE;
		declare atOffset address;

		    sub$7486: PROCEDURE;
			DECLARE (i, j) BYTE;
			if atFData.varInfoOffset = 0 then
			    i = 0;
			else if getType > STRUCT$T or getType < BYTE$T then
			do;
			    i = 0;
			    call sub$6EF6(ERR211);	/* INVALID IDENTIFIER IN 'AT' RESTRICTED REFERENCE */
			end;
			else if testInfoFlag(F$EXTERNAL) then
			do;
			    i = 1;
			    j = getExternId;
			end;
			else if testInfoFlag(F$DATA) then
			    i = 2;
			else if testInfoFlag(F$AUTOMATIC) then
			    i = 3;
			else if testInfoFlag(F$MEMORY) then
			    i = 4;
			else if testInfoFlag(F$BASED) then
			do;
			    i = 0;
			    call sub$6EF6(ERR212);	/* INVALID RESTRICTED REFERENCE IN 'AT' , BASE ILLEGAL */
			end;
			else if testInfoFlag(F$ABSOLUTE) then
			    i = 0;
			else
			    i = 5;
			curInfo$p = atFData.info$p;

			do while 1;
			    if not testInfoFlag(F$MEMBER) then
			    do;
				if testInfoFlag(F$DATA) then
				do;
					call clrFlag(.info.flag, F$DATA);
					call setInfoFlag(F$INITIAL);
				end;
				call setLinkVal(atOffset);
				atOffset = atOffset + getVarSize;
				do case i;
				call setInfoFlag(F$ABSOLUTE); 
				do;
				    if testInfoFlag(F$PUBLIC) then
					call sub$6EF6(ERR178); /* INVALID 'AT' RESTRICTED REFERENCE, EXTERNAL
							    ATTRIBUTE CONFLICTS WITH PUBLIC ATTRIBUTE */
				    call setInfoFlag(F$EXTERNAL);
				    call setExternId(j);
				end;
				call setInfoFlag(F$DATA);
				call setInfoFlag(F$AUTOMATIC); 
				call setInfoFlag(F$MEMORY);
				;
				end;
			    end;
			    call advNextDataInfo;
			    if curInfo$p = 0 then
				return;
			    if not (testInfoFlag(F$PACKED) or testInfoFlag(F$MEMBER)) then
				return;
			end;
		    end;


		call fread(.atFile, .atFData.info$p, 12);
		if atFData.info$p = 0 then
		    return;
		atFData.info$p = atFData.info$p + botInfo;
		atStmtNum = atFData.stmtNum;
		atOffset = atFData.val;
		if atFData.varInfoOffset <> 0 then
		do;
		    curInfo$p = atFData.varInfoOffset + botInfo;
		    if testInfoFlag(F$MEMBER) then
		    do;
			atOffset = getElementSize * atFData.varNestedArrayIndex + atOffset + getLinkVal;
			curInfo$p = getParentOffset;
		    end;
		    atOffset =  getLinkVal + getElementSize * atFData.varArrayIndex + atOffset;
		    if testInfoFlag(F$AT) then
			if curInfo$p >= atFData.info$p then
				call sub$6EF6(ERR213);	/* UNDEFINED RESTRICTED REFERENCE IN 'AT' */
		end;
		call sub$7486;
	    end;
	
	do while 1;
	    call fread(.atFile, .atFData.type, 1);
	    do case atFData.type;
	    call sub$73DC;					/* AT$AHDR */
	    call fread(.atFile, .atFData.info$p, 4);	/* AT$DHDR */
	    call fread(.atFile, .atFData.val, 2);		/* AT$2 */
	    do;						/* AT$STRING */
		call fread(.atFile, .atFData.val, 2);
		call fread(.atFile, .atFData.type, atFData.val);
	    end;
	    call fread(.atFile, .atFData.varInfoOffset, 8); /* AT$DATA */
	    ;						/* AT$END */
	    return;						/* AT$EOF */
	    end;
	end;
    end;





    sub$75F7: PROCEDURE;
	DECLARE w BASED w3822 ADDRESS;

	botInfo = botMem + topMem - topInfo;
	topInfo = topMem;
	call revmemmov(botMem, botInfo, topInfo - botInfo + 1);
	helpers$p = botInfo - shl(117,1);
	localLabels$p = helpers$p - (localLabelCnt+1) * 2;
	w381E = localLabels$p - (localLabelCnt+1);
	w3822 = botInfo - 2;
	do while w3822 >= w381E;
	    w = 0;
	    w3822 = w3822 - 2;
	end;
	if w3822 = w381E - 1 then
	    w = w and 0ffh;
	w3822 = w381E - 2;
    end;


    sub$7695: PROCEDURE;
	if (b9B40 := OBJECT or PRINT) or IXREF then
	do;
	    call openf(.nmsFile, 3);
	    call creatf(.nmsFile, .xrfBuf, 512, 2);
	end;
	call creatf(.atFile, .atBuf, 512, 1);
	csegSize, dsegSize = 0;
    end;


    sub$76D9: PROCEDURE;
        DECLARE i BYTE;
        
        if b9B40 or IXREF then
        do;
	call fflush(.nmsFile);
	call rewind(.nmsFile);
        end;
        call rewind(.atFile);		/* used for string data */
        call fwrite(.tx2File, .(T2$EOF), 1);
        call fflush(.tx2File);
        call rewind(.tx2File);
	do i = 1 to procCnt;
	    procInfo(i) = procInfo(i) - botMem;
	end;
    end;


    call sub$7695;
    call sub$7049;
    call sub$711F;
    call sub$719D;
    call procAtFile;
    call sub$75F7;
    call sub$76D9;
end sub$6EE0;

end;

