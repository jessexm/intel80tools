plm1b: DO;
declare LIT LITERALLY 'LITERALLY',
    CR  LIT '0DH',
    LF LIT '0AH',
    TRUE LIT '0FFH',
    FALSE LIT '0';

$nolist
$include(:f3:lex.inc)
/* $include(t2code.inc) */
declare	T2$LINEINFO LIT '152';
/* $include(icodes.inc) */

declare	I$BASED LIT '31',
	I$BYTEINDEX LIT '27',
	I$LAST LIT '36',
	I$LENGTH LIT '37',
	I$MEMBER LIT '30',
	I$NOT LIT '13',
	I$NUMBER LIT '2',
	I$OUTPUT LIT '24',
	I$PLUSSIGN LIT '3',
	I$SIZE LIT '48',
	I$STACKPTR LIT '22',
	I$STAR LIT '7',
	I$UNARYMINUS LIT '21',
	I$VARIABLE LIT '1',
	I$WORDINDEX LIT '28';

$include(:f3:flags.inc)
/*$include(:f3:data.inc) */
declare curSymbol$p ADDRESS EXTERNAL,
	sym based curSymbol$p STRUCTURE(link ADDRESS, info$p ADDRESS, name(1) BYTE),
	botInfo address external,
	CONTROLS(8) BYTE EXTERNAL,
	XREF	 LIT 'CONTROLS(1)',
	SYMBOLS	 LIT 'CONTROLS(2)',
	IXREF	 LIT 'CONTROLS(7)',
	curInfo$p address external,
	xrfFile(1) byte external,	/* saves symbol space !! */
	atFile(1) byte external;

$include(:f3:info.inc)

declare	ATI$DHDR LIT '1',
	ATI$STRING LIT '3',
	ATI$DATA LIT '4',
	ATI$END LIT '5';


$include(:f3:fwrite.aex)
$include(:f3:tiflag.pex)
$include(:f3:siflag.pex)
$include(:f3:fi.pex)
$include(:f3:gitype.pex)
$include(:f3:siparo.pex)
$include(:f3:creati.pex)
$include(:f3:findmi.pex)
mapLtoT2: PROCEDURE external; end;
optWrXrf: PROCEDURE external; end;
rdTx1Item: procedure external; end;
setRegetTx1Item: PROCEDURE external; end;
wrTx2Error: PROCEDURE(arg1b) external; DECLARE arg1b BYTE; end;
wrTx2ExtError: PROCEDURE(arg1b) external; declare arg1b byte; end;
wrTx2File: PROCEDURE(buf, cnt) external; DECLARE buf ADDRESS, cnt BYTE; end;

/*$list */





declare T2CntForStmt address external,
	curProcInfo$p address external,
	curStmtNum address external,
	(varInfoOffset, varArrayIndex, varNestedArrayIndex, val) address external,
	regetTx1Item byte external,
	b88B3 byte external,
	tx1Item structure(type byte, dataw(129) address) external,
	linfo structure(itemType byte, lineCnt address, stmtCnt address, blkCnt address) external,
	tx1Aux2 byte external,
	tx1Aux1 byte external,
	tx1RdBuf(512) byte external,
	tx2Buf(512) byte external,
	xrfBuf(512) byte external,
	atBuf(512) byte external,
	b91C0 byte external,
	parseSP address external,
	parseStack(100) address external,
	operatorSP address external,
	operatorStack(50) address external,
	exSP address external,
	ex1Stack(100) byte external,
	ex2Stack(100) byte external,
	ex3Stack(100) address external,
	stSP address external,
	st1Stack(300) byte external,
	st2Stack(300) byte external,
	st3Stack(300) address external;

getTx1Item: PROCEDURE public;

    if regetTx1Item then
    do;
	regetTx1Item = FALSE;
	return;
    end;
    do while 1;
	call rdTx1Item;
	if tx1Item.type = L$TOKENERROR then
	do;
	    if (curSymbol$p := tx1Item.dataw(1)) <> 0 then
	    do;
		if high(sym.info$p) = 0ffh then
			sym.info$p = 0;
		if (curInfo$p := sym.info$p) = 0 then
			call createInfo(0, UNK$T);
		tx1Item.dataw(1) = curInfo$p - botInfo;
	    end;
	    call mapLtoT2;
	end;
	else if (tx1Item.type = L$XREFINFO and XREF)
	      or (tx1Item.type = L$XREF and (IXREF or XREF or SYMBOLS)) then
	do;
	    tx1Item.dataw(1) = curStmtNum;
	    call fwrite(.xrfFile, .tx1Item, 5);
	end;
	else if tx1Item.type = L$LINEINFO then
	do;
	    if b88B3 then
		call wrTx2File(.linfo, 7);
	    call move(7, .tx1Item, .linfo);
	    linfo.itemType = T2$LINEINFO;
	    b88B3 = TRUE;
	end;
	else if (tx1Aux2 and 20h) <> 0 then
	    call mapLtoT2;
	else if tx1Item.type = L$STMTCNT and tx1Item.dataw(0) = 0 then
	    call mapLtoT2;
	else if tx1Item.type <> L$XREF and tx1Item.type <> L$XREFINFO then
	    goto done;
    end;
done:	if tx1Item.type = L$VARIABLE then
	curSymbol$p = tx1Item.dataw(0);
    if (tx1Aux2 and 10h) <> 0 then
	tx1Item.dataw(0) = tx1Item.dataw(0) + botInfo;
end;

matchTx2Item: PROCEDURE(arg1b) BYTE public;
    declare arg1b byte;
    call getTx1Item;
    if tx1Item.type = arg1b then
	return TRUE;
    else
    do;
	call setRegetTx1Item;
	return FALSE;
    end;
end;

notMatchTx2Item: PROCEDURE(arg1b) BYTE public;
    declare arg1b byte;
    return not matchTx2Item(arg1b);
end;

matchTx2AuxFlag: PROCEDURE(arg1b) BYTE public;
    declare arg1b byte;

    call getTx1Item;
    if (tx1Aux2 and arg1b) <> 0 then
	return TRUE;
    else
    do;
	call setRegetTx1Item;
	return FALSE;
    end;
end;


sub$4599: PROCEDURE public;
    do while 1;
	call getTx1Item;
	if (tx1Aux2 and 80h) = 0 then
	    goto done;
	else if tx1Item.type = L$RPAREN then
	    goto done;
    end;
done:
    call setRegetTx1Item;
end;

resyncRPAREN: PROCEDURE public;
    call sub$4599;
    if matchTx2Item(L$RPAREN) then
	;
end;

expectRPAREN: PROCEDURE(arg1b) public;
    declare arg1b byte;
    if notMatchTx2Item(L$RPAREN) then
    do;
	call wrTx2ExtError(arg1b);
	call resyncRPAREN;
    end;
end;

sub$45E0: PROCEDURE public;
    call findInfo;
    if curInfo$p = 0 or getType = LIT$T then
	call createInfo(256, BYTE$T);
    call optWrXrf;
    if getType <> BUILTIN$T then
	if  not testInfoFlag(F$LABEL) then
	    if not testInfoFlag(F$DECLARED) then
	    do;
		call wrTx2ExtError(105);	/* UNDECLARED IDENTIFIER */
		call setInfoFlag(F$DECLARED);
	    end;
end;

sub$4631: PROCEDURE public;
    declare tmp address;

    tmp = curInfo$p;
    call findMemberInfo;
    if curInfo$p = 0 then
    do;
	call createInfo(0, BYTE$T);
	call setParentOffset(tmp);
	call setInfoFlag(F$MEMBER);
    end;
    if not testInfoFlag(F$LABEL) then
	if not testInfoFlag(F$DECLARED) then
	do;
	    call wrTx2ExtError(112);	/* UNDECLARED STRUCTURE MEMBER */
	    call setInfoFlag(F$DECLARED);
	end;
    call optWrXrf;
end;

sub$467D: PROCEDURE public;
    call sub$45E0;
    if matchTx2Item(L$PERIOD) then
	if getType <> STRUCT$T then
	    call wrTx2ExtError(110);	/* INVALID LEFT OPERAND OF QUALIFICATION, NOT A STRUCTURE */
	else if notMatchTx2Item(L$VARIABLE) then
	    call wrTx2ExtError(111);	/* INVALID RIGHT OPERAND OF QUALIFICATION, NOT IDENTIFIER */
	else
	    call sub$4631;
end;

wrAtFile: PROCEDURE(buf, cnt) public;
    declare (buf, cnt) address;
    call fwrite(.atFile, buf, cnt);
end;

wrAtFileByte: PROCEDURE(arg1b) public;
    declare arg1b byte;
    call wrAtFile(.arg1b, 1);
end;

wrAtFileWord: PROCEDURE(arg1w) public;
    declare arg1w address;
    call wrAtFile(.arg1w, 2);
end;
end;
