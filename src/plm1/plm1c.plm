plm1c: DO;
$include(plm1c.ipx)

getRestrictedExpr: PROCEDURE public;
	declare rValue address,
		use8bit byte;


	simpleUExpr: PROCEDURE;
	    if matchTx2Item(L$NUMBER) then
		rValue = tx1Item.dataw(0);
	    else
	    do;
		if matchTx2Item(L$VARIABLE) then
		    call sub$45E0;
		call wrTx2ExtError(151);	/* INVALID OPERAND IN RESTRICTED EXPRESSION */
		rValue = 0;
	    end;
	    use8bit = use8bit and (high(rValue) = 0);
	end;

	simpleNExpr: PROCEDURE;
	    if matchTx2Item(L$MINUSSIGN) then
	    do;
		call simpleUExpr;
		if use8bit then 
		    rValue = - low(rValue);
		else
		    rValue = - rValue;
	    end;
	    else
		call simpleUExpr;
	end;

	evalSimpleExpr: PROCEDURE;
	    declare p address;
	    call simpleNExpr;
	    p = rValue;
	    do while 1;
		if matchTx2Item(L$PLUSSIGN) then
		do;
		    call simpleNExpr;
		    if use8bit then
		    do;
			p = (p := p + rValue) and 0ffh;
			
		    end;
		    else 
			p =  p + rValue;
		end;
		else if matchTx2Item(L$MINUSSIGN) then
		do;
		    call simpleNExpr;
		    if use8bit then
			p = (p := p - rValue) and 0ffh;
		    else
			p =  p - rValue;
		end;
		else
		    goto done;
	    end;
	done:
	    rValue = p;
	end;


	getRestrictedArrayIndex: PROCEDURE;
	    use8bit = TRUE;
	    if not(testInfoFlag(F$ARRAY)) then
		call wrTx2ExtError(149);	/* INVALID SUBSCRIPTING IN RESTRICTED REFERENCE */
	    call evalSimpleExpr;
	    call expectRPAREN(150);	/* MISSING ') ' AT END OF RESTRICTED SUBSCRIPT */
	end;

	getRestrictedVar: PROCEDURE;
	    if notMatchTx2Item(L$VARIABLE) then
	    do;
		call wrTx2Error(147);	/* MISSING IDENTIFIER FOLLOWING DOT OPERATOR */
		call sub$4599;
		return;
	    end;
	    call sub$45E0;
	    varInfoOffset = curInfo$p;
	    if getType = BUILTIN$T then
	    do;
		call wrTx2Error(123);	/* INVALID DOT OPERAND, BUILT-IN PROCEDURE ILLEGAL */
		call sub$4599;
		return;
	    end;
	    if matchTx2Item(L$LPAREN) then
	    do;
		call getRestrictedArrayIndex;
		varArrayIndex = rValue;
	    end;
	    if matchTx2Item(L$PERIOD) then
	    do;
		curInfo$p = varInfoOffset;
		if getType <> STRUCT$T then
		do;
		    call wrTx2ExtError(148);	/* INVALID QUALIFICATION IN RESTRICTED REFERENCE */
		    call sub$4599;
		    return;
		end;
		if notMatchTx2Item(L$VARIABLE) then
		do;
		    call wrTx2Error(147);	/* MISSING IDENTIFIER FOLLOWING DOT OPERATOR */
		    varInfoOffset = varInfoOffset - botInfo;
		    return;
		end;
		call sub$4631;
		varInfoOffset = curInfo$p;
		if matchTx2Item(L$LPAREN) then
		do;
		    call getRestrictedArrayIndex;
		    varNestedArrayIndex = rValue;
		end;
	    end;
	    varInfoOffset = varInfoOffset - botInfo;
	end;

    varInfoOffset, varArrayIndex, varNestedArrayIndex, varVal = 0;
    if matchTx2Item(L$PERIOD) then
    do;
	call getRestrictedVar;
	if matchTx2Item(L$PLUSSIGN) then
	    ;
	else if matchTx2Item(L$MINUSSIGN) then
	    call setRegetTx1Item;
	else
	    return;
	use8bit = FALSE;
	call evalSimpleExpr;
	varVal = rValue;
    end;
    else if matchTx2Item(L$RPAREN) then
	call setRegetTx1Item;
    else
    do;
	use8bit = TRUE;
	call evalSimpleExpr;
	varVal = rValue;
    end;
end;

parseDataItems: PROCEDURE(arg1w) ADDRESS public;
    declare arg1w address;
    declare p address;

    p = 0;
    call wrAtFileByte(ATI$DHDR);
    call wrAtFileWord(arg1w - botInfo);
    call wrAtFileWord(curStmtNum);
    do while 1;
	if matchTx2Item(L$STRING) then
	do;
	    call wrAtFileByte(ATI$STRING);
	    call wrAtFileWord(tx1Item.dataw(0));
	    call wrAtFile(.tx1Item.dataw(1), tx1Item.dataw(0));
	    curInfo$p = arg1w;
	    if getType = ADDRESS$T then 
		p = p + (tx1Item.dataw(0) + 1) / 2;
	    else 
		p = p + tx1Item.dataw(0);
	end;
	else
	do;
	    call getRestrictedExpr;
	    call wrAtFileByte(ATI$DATA);
	    call wrAtFile(.varInfoOffset, 8);
	    p = p + 1;
	end;
	if notMatchTx2Item(L$COMMA) then
	    goto done;
	else if matchTx2Item(L$RPAREN) then
	do;
	    call wrTx2Error(151);	/* INVALID OPERAND IN RESTRICTED EXPRESSION */
	    call setRegetTx1Item;
	    goto done;
	end;
    end;
done:
    call wrAtFileByte(ATI$END);
    call expectRPAREN(152);	/* MISSING ') ' AFTER CONSTANT LIST */
    curInfo$p = arg1w;;
    return p;
end;

resetStacks: PROCEDURE public;
    parseSP, exSP, operatorSP, stSP = 0;
end;

pushParseWord: PROCEDURE(arg1w) public;
    declare arg1w address;
    if parseSP = 63h then
	call fatalError(119);	/* LIMIT EXCEEDED: PROGRAM TOO COMPLEX */
    parseStack(parseSP := parseSP + 1) = arg1w;
end;


popParseStack: PROCEDURE public;
    if parseSP = 0 then
	call fatalError(159);	/* COMPILER ERROR: PARSE STACK UNDERFLOW */
    parseSP = parseSP - 1;
end;


pushParseByte: PROCEDURE(arg1b) public;
    declare arg1b byte;
    call pushParseWord(arg1b);
end;

exprPush3: PROCEDURE(arg1b, arg2b, arg3w);
    declare (arg1b, arg2b) byte, arg3w address;
    if exSP = 63h then
	call fatalError(121);	/* LIMIT EXCEEDED: EXPRESSION TOO COMPLEX */
    ex1Stack(exSP := exSP + 1) = arg1b;
    ex2Stack(exSP) = arg2b;
    ex3Stack(exSP) = arg3w;
end;

exprPop: PROCEDURE public;
    if exSP = 0 then
	call fatalError(160);	/* COMPILER ERROR: OPERAND STACK UNDERFLOW */
    exSP = exSP - 1;
end;


swapOperandStack: PROCEDURE;
    declare i address, (op1, op2) byte, op3 address;

    if exSP < 2 then
	call fatalError(161);	/* COMPILER ERROR: ILLEGAL OPERAND STACK EXCHANGE */
    i = exSP - 1;
    op1 = ex1Stack(exSP);
    op2 = ex2Stack(exSP);
    op3 = ex3Stack(exSP);
    ex1Stack(exSP) = ex1Stack(i);
    ex2Stack(exSP) = ex2Stack(i);
    ex3Stack(exSP) = ex3Stack(i);
    ex1Stack(i) = op1;
    ex2Stack(i) = op2;
    ex3Stack(i) = op3;
end;

exprPush2: PROCEDURE(arg1b, arg2w) public;
    declare arg1b byte, arg2w address;
    call exprPush3(arg1b, 0, arg2w);
end;

stmtPush3: PROCEDURE(arg1b, arg2b, arg3w);
    declare (arg1b, arg2b) byte, arg3w address;
    if stSP = 299 then
	call fatalError(122);	/* LIMIT EXCEEDED: PROGRAM TOO COMPLEX	 */
    st1Stack(stSP := stSP + 1) = arg1b;
    st2Stack(stSP) = arg2b;
    st3Stack(stSP) = arg3w;
end;

moveExpr2Stmt: PROCEDURE public;
    call stmtPush3(ex1Stack(exSP), ex2Stack(exSP), ex3Stack(exSP));
    call exprPop;
end;

pushOperator: PROCEDURE(arg1b) public;
    declare arg1b byte;
    if operatorSP = 31h then
	call fatalError(120);	/* LIMIT EXCEEDED: EXPRESSION TOO COMPLEX */
    operatorStack(operatorSP := operatorSP + 1) = arg1b;
end;


popOperatorStack: PROCEDURE public;
    if operatorSP = 0 then
	call fatalError(162);	/* COMPILER ERROR: OPERATOR STACK UNDERFLOW */
    operatorSP = operatorSP - 1;
end;


exprMakeNode: PROCEDURE(arg1b, arg2b) public;
    declare (arg1b, arg2b) byte;
    declare w address, (j, i) byte;

    w = stSP + 1;

    if exSP < arg2b then
	call fatalError(163);	/* COMPILER ERROR: GENERATION FAILURE  */
    j = exSP - arg2b + 1;
    i = arg2b;
    do while i <> 0;
	call stmtPush3(ex1Stack(j), ex2Stack(j), ex3Stack(j));
	i = i - 1;
	j = j + 1;
    end;

    exSP = exSP - arg2b;
    if arg2b = 0 then
	w = 0;
    call exprPush3(arg1b, arg2b, w);
end;

acceptOpAndArgs: PROCEDURE public;
    declare i byte;

    i = operatorStack(operatorSP);
    if i = I$NOT or i = I$UNARYMINUS then
	call exprMakeNode(i, 1);
    else
	call exprMakeNode(i, 2);
    call popOperatorStack;
end;


sub$4CC2: PROCEDURE;
    declare p address;
    if testInfoFlag(F$MEMBER) then
    do;
	p = curInfo$p;
	curInfo$p = getParentOffset;
	call exprPush2(I$VARIABLE, curInfo$p);
	call exprPush2(I$VARIABLE, p);
	call exprMakeNode(I$MEMBER, 2);
    end;
    else
	call exprPush2(I$VARIABLE, curInfo$p);
end;

sub$4CFD: PROCEDURE(arg1w) public;
    declare arg1w address;

    curInfo$p = arg1w;
    if testInfoFlag(F$BASED) then
    do;
	curInfo$p = getBaseOffset;
	call sub$4CC2;
	curInfo$p = arg1w;
	call swapOperandStack;
	call exprMakeNode(I$BASED, 2);
    end;
end;

sub$4D2C: PROCEDURE public;
    call sub$4CC2;
    call sub$4CFD(curInfo$p);
end;


sub$4D38: PROCEDURE public;
    if getDataType = 0 then
	call wrTx2ExtError(131);	/* ILLEGAL REFERENCE TO UNTYPED PROCEDURE */
end;


getCallArgCnt: PROCEDURE BYTE public;
    declare (i, j, k) byte;
    i = parseStack(parseSP);
    j = operatorStack(operatorSP);
    call popParseStack;
    call popOperatorStack;
    if i = j then
	return i;
    if i < j then
    do;
	call wrTx2ExtError(153);	/* INVALID NUMBER OF ARGUMENTS IN CALL, TOO MANY */
	k = j - i;
	do while k <> 0;
	    call exprPop;
	    k = k - 1;
	end;
    end;
    else
    do;
	call wrTx2ExtError(154);	/* INVALID NUMBER OF ARGUMENTS IN CALL, TOO FEW */
	k = i - j;
	do while k <> 0;
	    call exprPush2(I$NUMBER, 0);
	    k = k - 1;
	end;
    end;
    return i;
end;

sub$4DCF: PROCEDURE(arg1b) public;
    declare arg1b byte;

    if notMatchTx2Item(L$LPAREN) then
    do;
	call wrTx2ExtError(124);	/* MISSING ARGUMENTS FOR BUILT-IN PROCEDURE */
	call exprPush2(I$NUMBER, 0);
    end;
    else
    do;	if notMatchTx2Item(L$VARIABLE) then
	do;
	    call wrTx2Error(125);	/* ILLEGAL ARGUMENT FOR BUILT-IN PROCEDURE */
	    call exprPush2(I$NUMBER, 0);
	end;
	else
	do;
	    call sub$45E0;
	    if matchTx2Item(L$LPAREN) then
	    do;
		if testInfoFlag(F$ARRAY) then
		do;
			call resyncRPAREN;
			if matchTx2Item(L$RPAREN) then
			do;
				if arg1b = I$LENGTH or arg1b = I$LAST then
				do;
					call wrTx2ExtError(125); /*  ILLEGAL ARGUMENT FOR BUILT-IN PROCEDURE */
					call exprPush2(I$NUMBER, 0);
				end;
				else 
					call exprPush2(arg1b, curInfo$p);
				return;
			end;
		end;
		else 
			call wrTx2ExtError(127);	/* INVALID SUBSCRIPT ON NON-ARRAY */
	    end; 
	    if matchTx2Item(L$PERIOD) then
	    do;
		if getType <> STRUCT$T then
			call wrTx2ExtError(110); /* INVALID LEFT OPERAND OF QUALIFICATION, NOT A STRUCTURE */
		else if notMatchTx2Item(L$VARIABLE) then
			call wrTx2ExtError(111); /* INVALID RIGHT OPERAND OF QUALIFICATION, NOT IDENTIFIER */
		else
			call sub$4631;
	    end;
	    if matchTx2Item(L$LPAREN) then
	    do;
		if testInfoFlag(F$ARRAY) then
		do;
			call resyncRPAREN;
			if arg1b = I$LENGTH or arg1b = I$LAST then
			do;
				call wrTx2ExtError(125);	/* ILLEGAL ARGUMENT FOR BUILT-IN PROCEDURE */
				call exprPush2(I$NUMBER, 0);
			end;
			else 
				call exprPush2(arg1b, curInfo$p);
		end;
		else
		do;
			call wrTx2ExtError(127);	/* INVALID SUBSCRIPT ON NON-ARRAY */
			call exprPush2(I$NUMBER, 0);
		end;
	    end;
	    else if arg1b = I$LENGTH or arg1b = I$LAST then
	    do;
		if testInfoFlag(F$ARRAY) then 
			call exprPush2(arg1b, curInfo$p);
		else
		do;
			call wrTx2ExtError(157);
				/* INVALID ARGUMENT, ARRAY REQUIRED FOR LENGTH OR LAST */
			call exprPush2(I$NUMBER, 0);
		end;
	    end;
	    else
	    do;
		call exprPush2(arg1b, curInfo$p);
		call exprPush2(I$LENGTH, curInfo$p);
		call exprMakeNode(I$STAR, 2);
	    end;
	end;
	call expectRPAREN(126);	/* MISSING ') ' AFTER BUILT-IN PROCEDURE ARGUMENT LIST */
    end;
end;


mkIndexNode: PROCEDURE public;
    declare (p, q) address;
    declare i byte, r address;

    curInfo$p = ex3Stack(exSP-1);	/* get var */
    if ex1Stack(exSP) = I$PLUSSIGN then
    do;	/* see if index is of form expr + ?? */
	p = ex3Stack(exSP) + 1;
	if st1Stack(p) = I$NUMBER then
	do;	/* expr + number */
	    ex1Stack(exSP) = st1Stack(q := p - 1);	/* pull up expression */
	    ex2Stack(exSP) = st2Stack(q);
	    ex3Stack(exSP) = st3Stack(q);
	    call exprPush2(I$NUMBER, st3Stack(p));	/* and get the number as an offset */
	end;
	else 
	    call exprPush2(I$NUMBER, 0);		/* no simple 0 offset */
    end;
    else
	call exprPush2(I$NUMBER, 0);			/* 0 offset */

    if getType = ADDRESS$T then		/* simple word array */
	i = I$WORDINDEX;
    else
    do;
	i = I$BYTEINDEX;
	if getType = STRUCT$T then
	do;	/* scale structure index */
	    r = exSP - 1;					/* the index expr (ex offset) */
	    call exprPush3(ex1Stack(r), ex2Stack(r), ex3Stack(r));	/* calc dimension */
	    call exprPush2(I$SIZE, curInfo$p);
	    call exprMakeNode(I$STAR, 2);
	    ex1Stack(r) = ex1Stack(exSP);	/* replace index expr */
	    ex2Stack(r) = ex2Stack(exSP);
	    ex3Stack(r) = ex3Stack(exSP);
	    call exprPop;						/* waste intermediate */
	end;
    end;
    call exprMakeNode(i, 3);
end;


parsePortNum: PROCEDURE(arg1b) public;
    declare arg1b byte;
    declare p address;

    p = 0;
    if matchTx2Item(L$LPAREN) then
    do;
	if matchTx2Item(L$NUMBER) then
	do;
	    if tx1Item.dataw(0) <= 255 then
		p = tx1Item.dataw(0);
	    else
		call wrTx2ExtError(106);	/* INVALID INPUT/OUTPUT PORT NUMBER */
	end;
	else
	    call wrTx2ExtError(107);/* ILLEGAL INPUT/OUTPUT PORT NUMBER, NOT NUMERIC CONSTANT */
	call expectRPAREN(108);	/* MISSING ') ' AFTER INPUT/OUTPUT PORT NUMBER */
    end;
    else
	call wrTx2ExtError(109);	/* MISSING INPUT/OUTPUT PORT NUMBER */

    call exprPush2(arg1b, p);
end;


sub$50D5: PROCEDURE public;
    declare p address, i byte;

    p = curInfo$p;
    if (curInfo$p := curProcInfo$p) = 0 then
	i = FALSE;
    else
	i = testInfoFlag(F$REENTRANT);
    curInfo$p = p;
    if testInfoFlag(F$REENTRANT) and i then
	return;
    if not testInfoFlag(F$DECLARED) then 
	call wrTx2ExtError(169);		/* ILLEGAL FORWARD CALL */
    else if not testInfoFlag(F$DEFINED) then
	call wrTx2ExtError(170);		/* ILLEGAL RECURSIVE CALL */
end;


sub$512E: PROCEDURE(arg1w) BYTE public;
    declare arg1w address, c byte;
    if (c := ex1Stack(arg1w)) = I$OUTPUT or c = I$STACKPTR or c = I$BASED then
	return FALSE;
    if c = I$VARIABLE then 
	curInfo$p = ex3Stack(arg1w);
    else if c = I$BYTEINDEX or c = I$WORDINDEX then
	curInfo$p = st3Stack(ex3Stack(arg1w));
    else if c = I$MEMBER then
    do;
	if st1Stack(ex3Stack(arg1w)) = I$VARIABLE then
	    curInfo$p = st3Stack(ex3Stack(arg1w));
	else
	    curInfo$p = st3Stack(st3Stack(ex3Stack(arg1w)));
    end;
    else
	return TRUE;
    if testInfoFlag(F$DATA) then
	call wrTx2ExtError(173);
    /*  INVALID LEFT SIDE OF ASSIGNMENT: VARIABLE DECLARED WITH DATA ATTRIBUTE */
    return FALSE;
end;

sub$521B: PROCEDURE public;
    declare (q, p) address;

    p = curSymbol$p;
    curSymbol$p = 0;
    call createInfo(256, BYTE$T);
    call setInfoFlag(F$DATA);
    curSymbol$p = p;
    call exprPush2(I$VARIABLE, curInfo$p);
    call setInfoFlag(F$ARRAY);
    call setInfoFlag(F$STARDIM);
    q = parseDataItems(curInfo$p);
    call setDimension(q);
end;
end;
