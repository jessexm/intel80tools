PL/M-80 COMPILER                                                                                                PAGE   1


ISIS-II PL/M-80 V4.0 COMPILATION OF MODULE DELETE
OBJECT MODULE PLACED IN DELETE.OBJ
COMPILER INVOKED BY:  :F1:plm80 delete.plm PRINT(DELETE.LST) OBJECT(DELETE.OBJ) DEBUG OPTIMIZE CODE



   1          delete:
              DO;
              $include(delete.ipx)
   2   1  =   declare a$empty$p literally 'aEmtyP';
   3   1  =   declare Aft$Window literally 'AWindo';
   4   1  =   declare Chk$pn$disk$file literally 'ckpndf';
   5   1  =   declare Chk$Write$Protect literally 'CkWriP';
   6   1  =   declare direct$i$no literally 'dirINo';
   7   1  =   declare Dlook$pn literally 'dlokpn';
   8   1  =   declare Map$Write literally 'MapWri';
   9   1  =   declare AFT$BOTTOM literally '10';
  10   1  =   declare AFT$LAST literally '17';
  11   1  =   declare BOOLEAN literally 'BYTE';
  12   1  =   declare CANT$DELETE literally '32';
  13   1  =   declare CMD$READ literally '4';
  14   1  =   declare DIRECT$T literally 'structure(DIRECT$T1, DIRECT$T2)';
  15   1  =   declare DIRECT$T1 literally 'empty BOOLEAN, file(6) BYTE, ext(3) BYTE, attrib BYTE';
  16   1  =   declare DIRECT$T2 literally 'eof$count BYTE, blk ADDRESS, hdr$blk ADDRESS';
  17   1  =   declare FLINK literally '1';
  18   1  =   declare NO$SUCH$FILE literally '13';
  19   1  =   declare TRUE literally '0ffh';
  20   1  =   declare a$data$blk$p address external;
  21   1  =   declare a$dbuf$p address external;
  22   1  =   declare a$dev$p address external;
  23   1  =   declare a$empty$p address external;
  24   1  =   declare a$i$no$p address external;
  25   1  =   declare direct DIRECT$T external;
  26   1  =   declare direct$i$no address external;
  27   1  =   declare pn(1) byte external;
  28   1  =   absio: procedure(command, disk, block, buffer$ptr) external;
  29   2  =            declare command byte, disk byte, block address, buffer$ptr address; end;
  31   1  =   Aft$Window: procedure(slot$number) external; declare slot$number byte; end;
  34   1  =   attrib: procedure(file$ptr, swid, value) external;
  35   2  =             declare file$ptr address, swid address, value BOOLEAN; end;
  37   1  =   chk$pn$disk$file: procedure(filename) external; declare filename address; end;
  40   1  =   ChkWriteProtect: procedure external; end;
  42   1  =   dir$close: procedure(aftn) external; declare aftn byte; end;
  45   1  =   dlook: procedure(fn) BOOLEAN external; declare fn address; end;
  48   1  =   free$block: procedure(diskNum, trackSector) external; declare diskNum byte, trackSector address; end;
  51   1  =   MapWrite: procedure(diskNum) external; declare diskNum byte; end;
  54   1  =   seek: procedure(aftn, mode, blockptr, byteptr) external;
  55   2  =           declare aftn byte, mode address, blockptr address, byteptr address; end;
  57   1  =   warn: procedure(errcode) external; declare errcode byte; end;
  60   1  =   declare a$data$blk based a$data$blk$p  address;
  61   1  =   declare a$dbuf based a$dbuf$p  address;
  62   1  =   declare a$device based a$dev$p  byte;
  63   1  =   declare a$empty based a$empty$p  byte;
  64   1  =   declare a$i$no based a$i$no$p  address;
        
  65   1      dlook$pn: PROCEDURE PUBLIC;
                                                 ; STATEMENT # 65
PL/M-80 COMPILER                                                                                                PAGE   2


                         ; PROC  DLOKPN
  66   2          if not dlook(.pn) then
                                                 ; STATEMENT # 66
           0004  010000          LXI     B,PN
           0007  CD0000          CALL    DLOOK
           000A  1F              RAR
           000B  DA1300          JC      @1
  67   2          call warn(NO$SUCH$FILE);
                                                 ; STATEMENT # 67
           000E  0E0D            MVI     C,0DH
           0010  CD0000          CALL    WARN
                         @1:
  68   2      end;
                                                 ; STATEMENT # 68
           0013  C9              RET
        
  69   1      DECLARE i BYTE;     /* shared temp counter */
        
  70   1      del: PROCEDURE(disknum) PUBLIC;
                                                 ; STATEMENT # 70
                         ; PROC  DEL
           0014  210100          LXI     H,DISKNUM
           0017  71              MOV     M,C
  71   2          DECLARE disknum BYTE;
  72   2          DECLARE blockno ADDRESS DATA (0);
  73   2          DECLARE byteno ADDRESS DATA(16 /* size(DIRECT) */);
  74   2          DECLARE temp ADDRESS;
  75   2          DECLARE buf based TEMP (64) ADDRESS;
        
                  /* internal delete routing
                  disknum = F0DEV .. F9DEV
                  direct must contain the directory entry for an existing file or disk.
                  aft slot for the appropriate directory must have buffers;
                  and these buffers must be setup for directory reading and
                  writing. These buffers will be clobbered
                  */
        
        
  76   2           direct.empty = TRUE;
                                                 ; STATEMENT # 76
           0018  210000          LXI     H,DIRECT
           001B  36FF            MVI     M,0FFH
  77   2           call dir$close(disknum);
                                                 ; STATEMENT # 77
           001D  2A0100          LHLD    DISKNUM
           0020  4D              MOV     C,L
           0021  CD0000          CALL    DIRCLOSE
  78   2           call seek(disknum, 1, .blockno, .byteno);  /* save location of directory entry */
                                                 ; STATEMENT # 78
           0024  2A0100          LHLD    DISKNUM
           0027  E5              PUSH    H       ; 1
           0028  010100          LXI     B,1H
           002B  C5              PUSH    B       ; 2
           002C  110200          LXI     D,BYTENO
           002F  010000          LXI     B,BLOCKNO
           0032  CD0000          CALL    SEEK
  79   2           temp = a$dbuf; /* temp -> a buffer we not exists based a$dbuf$p */
PL/M-80 COMPILER                                                                                                PAGE   3


                                                 ; STATEMENT # 79
           0035  2A0000          LHLD    ADBUFP
           0038  5E              MOV     E,M
           0039  23              INX     H
           003A  56              MOV     D,M
           003B  EB              XCHG
           003C  220200          SHLD    TEMP
  80   2           do while direct.hdr$blk <> 0;
                                                 ; STATEMENT # 80
                         @4:
           003F  3E00            MVI     A,0H
           0041  110E00          LXI     D,DIRECT+0EH
           0044  CD0000          CALL    @P0101 
           0047  B5              ORA     L
           0048  CAB600          JZ      @5
  81   3          call free$block(disknum, direct.hdr$blk);
                                                 ; STATEMENT # 81
           004B  2A0100          LHLD    DISKNUM
           004E  4D              MOV     C,L
           004F  2A0E00          LHLD    DIRECT+0EH
           0052  EB              XCHG
           0053  CD0000          CALL    FREEBLOCK
  82   3          call absio(CMD$READ, disknum, direct.hdr$blk, temp);
                                                 ; STATEMENT # 82
           0056  0E04            MVI     C,4H
           0058  C5              PUSH    B       ; 1
           0059  2A0100          LHLD    DISKNUM
           005C  E5              PUSH    H       ; 2
           005D  2A0E00          LHLD    DIRECT+0EH
           0060  44              MOV     B,H
           0061  4D              MOV     C,L
           0062  2A0200          LHLD    TEMP
           0065  EB              XCHG
           0066  CD0000          CALL    ABSIO
  83   3          direct.hdr$blk = buf(FLINK);
                                                 ; STATEMENT # 83
           0069  2A0200          LHLD    TEMP
           006C  23              INX     H
           006D  23              INX     H
           006E  5E              MOV     E,M
           006F  23              INX     H
           0070  56              MOV     D,M
           0071  EB              XCHG
           0072  220E00          SHLD    DIRECT+0EH
  84   3          do i = 2 to 63;
                                                 ; STATEMENT # 84
           0075  210000          LXI     H,I
           0078  3602            MVI     M,2H
                         @6:
           007A  3E3F            MVI     A,3FH
           007C  210000          LXI     H,I
           007F  BE              CMP     M
           0080  DAB300          JC      @7
  85   4              if buf(i) <> 0 then
                                                 ; STATEMENT # 85
           0083  2A0000          LHLD    I
           0086  2600            MVI     H,0
PL/M-80 COMPILER                                                                                                PAGE   4


           0088  29              DAD     H
           0089  EB              XCHG
           008A  2A0200          LHLD    TEMP
           008D  19              DAD     D
           008E  3E00            MVI     A,0H
           0090  CD0000          CALL    @P0103 
           0093  B5              ORA     L
           0094  CAAC00          JZ      @2
  86   4              call free$block(disknum, buf(i));
                                                 ; STATEMENT # 86
           0097  2A0000          LHLD    I
           009A  2600            MVI     H,0
           009C  29              DAD     H
           009D  EB              XCHG
           009E  2A0200          LHLD    TEMP
           00A1  19              DAD     D
           00A2  5E              MOV     E,M
           00A3  23              INX     H
           00A4  56              MOV     D,M
           00A5  2A0100          LHLD    DISKNUM
           00A8  4D              MOV     C,L
           00A9  CD0000          CALL    FREEBLOCK
                         @2:
  87   4          end;
                                                 ; STATEMENT # 87
                         @8:
           00AC  210000          LXI     H,I
           00AF  34              INR     M
           00B0  C27A00          JNZ     @6
                         @7:
  88   3           end;
                                                 ; STATEMENT # 88
           00B3  C33F00          JMP     @4
                         @5:
  89   2           call absio(CMD$READ, disknum, a$data$blk, a$dbuf); /* last 2 based vars */
                                                 ; STATEMENT # 89
           00B6  0E04            MVI     C,4H
           00B8  C5              PUSH    B       ; 1
           00B9  2A0100          LHLD    DISKNUM
           00BC  E5              PUSH    H       ; 2
           00BD  2A0000          LHLD    ADATABLKP
           00C0  E5              PUSH    H       ; 3
           00C1  2A0000          LHLD    ADBUFP
           00C4  5E              MOV     E,M
           00C5  23              INX     H
           00C6  56              MOV     D,M
           00C7  E1              POP     H       ; 3
           00C8  4E              MOV     C,M
           00C9  23              INX     H
           00CA  46              MOV     B,M
           00CB  CD0000          CALL    ABSIO
  90   2           call map$write(disknum);
                                                 ; STATEMENT # 90
           00CE  2A0100          LHLD    DISKNUM
           00D1  4D              MOV     C,L
           00D2  CD0000          CALL    MAPWRI
  91   2      end;
PL/M-80 COMPILER                                                                                                PAGE   5


                                                 ; STATEMENT # 91
           00D5  C9              RET
        
        
  92   1      delete: PROCEDURE(pathname) PUBLIC;
                                                 ; STATEMENT # 92
                         ; PROC  DELETE
           00D6  210500          LXI     H,PATHNAME+1H
           00D9  70              MOV     M,B
           00DA  2B              DCX     H
           00DB  71              MOV     M,C
  93   2          DECLARE pathname ADDRESS;
        
  94   2          call chk$pn$disk$file(pathname);
                                                 ; STATEMENT # 94
           00DC  2A0400          LHLD    PATHNAME
           00DF  44              MOV     B,H
           00E0  4D              MOV     C,L
           00E1  CD0000          CALL    CKPNDF
  95   2          call dlook$pn;
                                                 ; STATEMENT # 95
           00E4  CD0400          CALL    DLOKPN
  96   2          call chk$write$protect;
                                                 ; STATEMENT # 96
           00E7  CD0000          CALL    CKWRIP
  97   2          do i = AFT$BOTTOM to AFT$LAST;
                                                 ; STATEMENT # 97
           00EA  210000          LXI     H,I
           00ED  360A            MVI     M,0AH
                         @9:
           00EF  3E11            MVI     A,11H
           00F1  210000          LXI     H,I
           00F4  BE              CMP     M
           00F5  DA3301          JC      @10
  98   3              call aft$window(i);
                                                 ; STATEMENT # 98
           00F8  2A0000          LHLD    I
           00FB  4D              MOV     C,L
           00FC  CD0000          CALL    AWINDO
  99   3              if (not a$empty) and (a$device = pn(0)) and (a$i$no = direct$i$no) then
                                                 ; STATEMENT # 99
           00FF  2A0000          LHLD    AEMTYP
           0102  7E              MOV     A,M
           0103  2F              CMA
           0104  2A0000          LHLD    ADEVP
           0107  F5              PUSH    PSW     ; 1
           0108  3A0000          LDA     PN
           010B  96              SUB     M
           010C  D601            SUI     1
           010E  9F              SBB     A
           010F  C1              POP     B       ; 1
           0110  48              MOV     C,B
           0111  A1              ANA     C
           0112  2A0000          LHLD    AINOP
           0115  110000          LXI     D,DIRINO
           0118  F5              PUSH    PSW     ; 1
           0119  CD0000          CALL    @P0099 
PL/M-80 COMPILER                                                                                                PAGE   6


           011C  B5              ORA     L
           011D  D601            SUI     1
           011F  9F              SBB     A
           0120  C1              POP     B       ; 1
           0121  48              MOV     C,B
           0122  A1              ANA     C
           0123  1F              RAR
           0124  D22C01          JNC     @3
 100   3              call warn(CANT$DELETE); 
                                                 ; STATEMENT # 100
           0127  0E20            MVI     C,20H
           0129  CD0000          CALL    WARN
                         @3:
 101   3          end;
                                                 ; STATEMENT # 101
                         @11:
           012C  210000          LXI     H,I
           012F  34              INR     M
           0130  C2EF00          JNZ     @9
                         @10:
 102   2          call del(pn(0));
                                                 ; STATEMENT # 102
           0133  2A0000          LHLD    PN
           0136  4D              MOV     C,L
           0137  CD1400          CALL    DEL
 103   2      end;
                                                 ; STATEMENT # 103
           013A  C9              RET
 104   1      end;
              eof



MODULE INFORMATION:

     CODE AREA SIZE     = 013BH    315D
     VARIABLE AREA SIZE = 0006H      6D
     MAXIMUM STACK SIZE = 0008H      8D
     105 LINES READ
     0 PROGRAM ERRORS

END OF PL/M-80 COMPILATION
