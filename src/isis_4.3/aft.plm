aft:
do;

$include(:f0:aft.ipx)

DECLARE	aft$current BYTE INITIAL(0ffh);
DECLARE	pointer$base ADDRESS PUBLIC,
	datum$base ADDRESS PUBLIC,
	a$empty$p ADDRESS PUBLIC,
	a$dev$p ADDRESS PUBLIC,
	a$access$p ADDRESS PUBLIC,
	a$edit$p ADDRESS PUBLIC,
	a$lbuf$p ADDRESS PUBLIC,
	a$dbuf$p ADDRESS PUBLIC,
	a$data$ptr$p ADDRESS PUBLIC,
	a$i$no$p ADDRESS PUBLIC,
	a$pbuf$p ADDRESS PUBLIC,
	a$ptr$ptr$p ADDRESS PUBLIC,
	a$eof$data$ptr$p ADDRESS PUBLIC,
	a$ptr$change$p ADDRESS PUBLIC,
	a$data$change$p ADDRESS PUBLIC,
	a$blk$count$p ADDRESS PUBLIC,
	a$blk$seqno$p ADDRESS PUBLIC,
	a$ptr$blk$p ADDRESS PUBLIC,
	a$hdr$blk$p ADDRESS PUBLIC,
	a$data$blk$p ADDRESS PUBLIC,
	a$dbuf$read$p ADDRESS PUBLIC;

DECLARE aft(18) STRUCTURE (
		empty	BYTE,
		device	BYTE,
		access	BYTE,
		edit	BYTE,
		lbuf	ADDRESS,
		dbuf	ADDRESS,
		pbuf	ADDRESS,
		data$ptr BYTE,
		i$no	ADDRESS,
		ptr$ptr	BYTE,
		eofcnt	BYTE,
		ptr$change BYTE,
		data$change BYTE,
		blk ADDRESS,
		blk$seq	ADDRESS,
		ptr$blk	ADDRESS,
		hdr$blk	ADDRESS,
		data$blk$count ADDRESS,
		dbuf$read BYTE) PUBLIC INITIAL(
			0, 0, 3, 0, 0, 0, 0, 80h, 0, 0, 80h, 0, 0, 19h, 0, 101h, 101h, 102h, 0,
			0, 1, 3, 0, 0, 0, 0, 80h, 0, 0, 80h, 0, 0, 19h, 0, 101h, 101h, 102h, 0,
			0, 2, 3, 0, 0, 0, 0, 80h, 0, 0, 80h, 0, 0, 19h, 0, 101h, 101h, 102h, 0,
			0, 3, 3, 0, 0, 0, 0, 80h, 0, 0, 80h, 0, 0, 19h, 0, 101h, 101h, 102h, 0,
			0, 4, 3, 0, 0, 0, 0, 80h, 0, 0, 80h, 0, 0, 19h, 0, 101h, 101h, 102h, 0,
			0, 5, 3, 0, 0, 0, 0, 80h, 0, 0, 80h, 0, 0, 19h, 0, 101h, 101h, 102h, 0,
			0, 6, 3, 0, 0, 0, 0, 80h, 0, 0, 80h, 0, 0, 19h, 0, 101h, 101h, 102h, 0,
			0, 7, 3, 0, 0, 0, 0, 80h, 0, 0, 80h, 0, 0, 19h, 0, 101h, 101h, 102h, 0,
			0, 8, 3, 0, 0, 0, 0, 80h, 0, 0, 80h, 0, 0, 19h, 0, 101h, 101h, 102h, 0,
			0, 9, 3, 0, 0, 0, 0, 80h, 0, 0, 80h, 0, 0, 19h, 0, 101h, 101h, 102h, 0,
			0FFh, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0FFh, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0FFh, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0FFh, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0FFh, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0FFh, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0FFh, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0FFh, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);			

DECLARE a$dbuf BASED a$dbuf$p ADDRESS,
	a$pbuf BASED a$pbuf$p ADDRESS;


aft$window: PROCEDURE(slot$number) PUBLIC;
	DECLARE slot$number BYTE;

	if aft$current <> slot$number then
	do;	
		a$empty$p = .aft(aft$current := slot$number).empty;
		a$dev$p = a$empty$p + 1;
		a$access$p = a$dev$p + 1;
		a$edit$p = a$access$p + 1;
		a$lbuf$p = a$edit$p + 1;
		a$data$ptr$p = a$lbuf$p + 6;
		a$i$no$p = a$data$ptr$p + 1;
		a$ptr$ptr$p = a$i$no$p + 2;
		a$eof$data$ptr$p = a$empty$p + 14;
		a$ptr$change$p = a$eof$data$ptr$p + 1;
		a$data$change$p = a$ptr$change$p + 1;
		a$blk$count$p = a$data$change$p + 1;
		a$blk$seqno$p = a$blk$count$p + 2;
		a$ptr$blk$p = a$blk$seqno$p + 2;
		a$hdr$blk$p = a$ptr$blk$p + 2;
		a$data$blk$p = a$hdr$blk$p + 2;
		a$dbuf$read$p = a$data$blk$p + 2;
	end;
	a$dbuf$p = .aft(slot$number).dbuf;
	a$pbuf$p = a$dbuf$p + 2;
	pointer$base = a$pbuf;
	datum$base = a$dbuf;

end;


get$aft$slot: PROCEDURE BYTE PUBLIC;
	DECLARE i BYTE;

	do i = AFT$BOTTOM to AFT$LAST;
		if aft(i).empty then
			return i;
	end;
	call abortx(AFT$FULL);
end;
end;
eof;

