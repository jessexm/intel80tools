PL/M-80 COMPILER                                                                                                PAGE   1


ISIS-II PL/M-80 V4.0 COMPILATION OF MODULE RW
OBJECT MODULE PLACED IN RW.OBJ
COMPILER INVOKED BY:  :F1:plm80 rw.plm PRINT(RW.LST) OBJECT(RW.OBJ) DEBUG OPTIMIZE CODE



   1          rw:
              do;
        
              $include(rw.ipx)
   2   1  =   declare a$access$p literally 'aAcesP';
   3   1  =   declare a$blk$count$p literally 'aBCntP';
   4   1  =   declare a$eof$data$ptr$p literally 'aEoPP';
   5   1  =   declare Aft$Window literally 'AWindo';
   6   1  =   declare Clear$Buf literally 'ClrBuf';
   7   1  =   declare Get$Block literally 'GetBlk';
   8   1  =   declare Map$Write literally 'MapWri';
   9   1  =   declare absread literally 'abs$rd';
  10   1  =   declare abswrite literally 'abs$wr';
  11   1  =   declare AFT$CONSOLE literally '11';
  12   1  =   declare AFT$T literally 'structure(AFT$T1, AFT$T2, AFT$T3, AFT$T4)';
  13   1  =   declare AFT$T1 literally 'empty BYTE, device BYTE, access BYTE, edit BYTE, lbuf ADDRESS';
  14   1  =   declare AFT$T2 literally 'dbuf ADDRESS, pbuf ADDRESS, data$ptr BYTE, i$no ADDRESS, ptr$ptr BYTE';
  15   1  =   declare AFT$T3 literally 'eofcnt BYTE, ptr$change BYTE, data$change BYTE, blk ADDRESS, blk$seq ADDRESS';
  16   1  =   declare AFT$T4 literally 'ptr$blk ADDRESS, hdr$blk ADDRESS, data$blk$count ADDRESS, dbuf$read BYTE';
  17   1  =   declare BELL literally '7';
  18   1  =   declare BS literally '8';
  19   1  =   declare CANT$READ literally '8';
  20   1  =   declare CANT$WRITE literally '6';
  21   1  =   declare CONSOLE$EOF literally '29';
  22   1  =   declare CONTROL$E literally '5';
  23   1  =   declare CONTROL$P literally '10h';
  24   1  =   declare CONTROL$Q literally '11h';
  25   1  =   declare CONTROL$R literally '12h';
  26   1  =   declare CONTROL$S literally '13h';
  27   1  =   declare CONTROL$X literally '18h';
  28   1  =   declare CONTROL$Z literally '1ah';
  29   1  =   declare CR literally '0dh';
  30   1  =   declare DELKEY literally '7fh';
  31   1  =   declare ESC literally '1bh';
  32   1  =   declare F9DEV literally '9';
  33   1  =   declare FALSE literally '0';
  34   1  =   declare FLINK literally '1';
  35   1  =   declare LF literally '0ah';
  36   1  =   declare SEEK$PAST$EOF literally '35';
  37   1  =   declare TRUE literally '0ffh';
  38   1  =   declare a$access$p address external;
  39   1  =   declare a$blk$count$p address external;
  40   1  =   declare a$blk$seqno$p address external;
  41   1  =   declare a$data$blk$p address external;
  42   1  =   declare a$data$change$p address external;
  43   1  =   declare a$data$ptr$p address external;
  44   1  =   declare a$dbuf$p address external;
  45   1  =   declare a$dbuf$read$p address external;
  46   1  =   declare a$dev$p address external;
  47   1  =   declare a$edit$p address external;
  48   1  =   declare a$eof$data$ptr$p address external;
PL/M-80 COMPILER                                                                                                PAGE   2


  49   1  =   declare aft(18) AFT$T external;
  50   1  =   declare alt$cidev byte external;
  51   1  =   declare a$pbuf$p address external;
  52   1  =   declare a$ptr$blk$p address external;
  53   1  =   declare a$ptr$change$p address external;
  54   1  =   declare a$ptr$ptr$p address external;
  55   1  =   declare datum$base address external;
  56   1  =   declare pointer$base address external;
  57   1  =   abortx: procedure(errcode) external; declare errcode byte; end;
  60   1  =   abs$rd: procedure(block, buffer$ptr) external; declare block address, buffer$ptr address; end;
  63   1  =   abs$wr: procedure(block, buffer$ptr) external; declare block address, buffer$ptr address; end;
  66   1  =   Aft$Window: procedure(slot$number) external; declare slot$number byte; end;
  69   1  =   CI: procedure byte external; end;
  71   1  =   ClearBuf: procedure(buf$address) external; declare buf$address address; end;
  74   1  =   CO: procedure(val) external; declare val byte; end;
  77   1  =   CSTS: procedure byte external; end;
  79   1  =   get$block: procedure(diskNum) address external; declare diskNum byte; end;
  82   1  =   IOCHK: procedure byte external; end;
  84   1  =   IOSET: procedure(val) external; declare val byte; end;
  87   1  =   LO: procedure(val) external; declare val byte; end;
  90   1  =   MapWrite: procedure(diskNum) external; declare diskNum byte; end;
  93   1  =   PO: procedure(val) external; declare val byte; end;
  96   1  =   RI: procedure byte external; end;
  98   1  =   save$data$blk: procedure external; end;
 100   1  =   save$pointer$block: procedure external; end;
 102   1  =   sysUsr: procedure(buffer$p, buffer, datum$base) external;
 103   2  =             declare buffer$p address, buffer address, datum$base address; end;
 105   1  =   usrSys: procedure(buffer$p, buffer, datum$base) external;
 106   2  =             declare buffer$p address, buffer address, datum$base address; end;
 108   1  =   warn: procedure(errcode) external; declare errcode byte; end;
 111   1  =   declare a$access based a$access$p  byte;
 112   1  =   declare a$blk$count based a$blk$count$p  address;
 113   1  =   declare a$blk$seqno based a$blk$seqno$p  address;
 114   1  =   declare a$data$blk based a$data$blk$p  address;
 115   1  =   declare a$data$change based a$data$change$p  byte;
 116   1  =   declare a$data$ptr based a$data$ptr$p  byte;
 117   1  =   declare a$dbuf based a$dbuf$p  address;
 118   1  =   declare a$dbuf$read based a$dbuf$read$p  byte;
 119   1  =   declare a$device based a$dev$p  byte;
 120   1  =   declare a$edit based a$edit$p  byte;
 121   1  =   declare a$eof$data$ptr based a$eof$data$ptr$p  byte;
 122   1  =   declare a$pbuf based a$pbuf$p  address;
 123   1  =   declare a$ptr$blk based a$ptr$blk$p  address;
 124   1  =   declare a$ptr$change based a$ptr$change$p  byte;
 125   1  =   declare a$ptr$ptr based a$ptr$ptr$p  byte;
 126   1  =   declare links based pointer$base (64) address;
        
 127   1      DECLARE ACCESS$READ LITERALLY   '1',
                  ACCESS$WRITE    LITERALLY   '2';
        
 128   1      DECLARE MAXLL       LITERALLY   '122';  /* maximum line length */
        
 129   1      DECLARE iobyteMasks(*) BYTE DATA(0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh,
                               0FCh, 0FCh, 0FCh, 0FCh, 0FCh, 0FCh, 0F3h, 0F3h, 0F3h, 0F3h,
                               0CFh, 0CFh, 0CFh, 0CFh, 3Fh, 3Fh, 0FFh, 0FFh, 0FFh);
 130   1      DECLARE iobyteFlags(*) BYTE DATA(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                               0, 0, 1, 1, 3, 3, 0, 4, 8, 0Ch,
PL/M-80 COMPILER                                                                                                PAGE   3


                               0, 10h, 20h, 30h, 80h, 0C0h, 0, 0, 0);
 131   1      DECLARE devClass(*) BYTE DATA(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                0FFh, 1, 0FFh, 1, 0FFh, 1, 0EFh, 0EFh, 0EFh, 0EFh,
                                2, 2, 2, 2, 3, 3, 4, 0FFh, 0FFh);
 132   1      DECLARE specialChars(*) byte DATA(0, DELKEY, CONTROL$Z, CONTROL$R, CONTROL$X, CR, LF, ESC, CONTROL$E, CONT
           -   ROL$P);
        
        
 133   1      DECLARE count$diff ADDRESS,
                  eof$dif BYTE,
                  adp$dif BYTE PUBLIC,
                  datapp  ADDRESS PUBLIC, /* interface to usrSys & sysUsr asm routines */
                  create BYTE INITIAL(0),
                  newptrblk ADDRESS,
                  iostat BYTE;
                  
        
 134   1      chk$eof: PROCEDURE PUBLIC;
                                                 ; STATEMENT # 134
                         ; PROC  CHKEOF
 135   2          if a$access = ACCESS$READ then  /* 1 */
                                                 ; STATEMENT # 135
           168A  2ACE2A          LHLD    AACESP
           168D  7E              MOV     A,M
           168E  FE01            CPI     1H
           1690  C2B116          JNZ     @1
 136   2          do;
 137   3              a$blk$seqno = a$blk$count;
                                                 ; STATEMENT # 137
           1693  2AE42A          LHLD    ABCNTP
           1696  E5              PUSH    H       ; 1
           1697  2AE62A          LHLD    ABLKSEQNOP
           169A  E3              XTHL            ; 1
           169B  4E              MOV     C,M
           169C  23              INX     H
           169D  46              MOV     B,M
           169E  E1              POP     H       ; 1
           169F  71              MOV     M,C
           16A0  23              INX     H
           16A1  70              MOV     M,B
 138   3              a$data$ptr = a$eof$data$ptr;
                                                 ; STATEMENT # 138
           16A2  2ADE2A          LHLD    AEOPP
           16A5  E5              PUSH    H       ; 1
           16A6  2AD62A          LHLD    ADATAPTRP
           16A9  C1              POP     B       ; 1
           16AA  0A              LDAX    B
           16AB  77              MOV     M,A
 139   3              call WARN(SEEK$PAST$EOF);
                                                 ; STATEMENT # 139
           16AC  0E23            MVI     C,23H
           16AE  CD510B          CALL    WARN
        
 140   3          end;
                                                 ; STATEMENT # 140
                         @1:
 141   2      end;
PL/M-80 COMPILER                                                                                                PAGE   4


                                                 ; STATEMENT # 141
           16B1  C9              RET
        
 142   1      adjust$eof: PROCEDURE PUBLIC;
                                                 ; STATEMENT # 142
                         ; PROC  ADJUSTEOF
 143   2          if a$blk$seqno <> 0 AND a$data$ptr = 0 then
                                                 ; STATEMENT # 143
           16B2  2AE62A          LHLD    ABLKSEQNOP
           16B5  3E00            MVI     A,0H
           16B7  CD402A          CALL    @P0103 
           16BA  B5              ORA     L
           16BB  C6FF            ADI     255
           16BD  9F              SBB     A
           16BE  2AD62A          LHLD    ADATAPTRP
           16C1  F5              PUSH    PSW     ; 1
           16C2  7E              MOV     A,M
           16C3  D600            SUI     0H
           16C5  D601            SUI     1
           16C7  9F              SBB     A
           16C8  C1              POP     B       ; 1
           16C9  48              MOV     C,B
           16CA  A1              ANA     C
           16CB  1F              RAR
           16CC  D2FD16          JNC     @2
 144   2          do;
 145   3              if not ((a$eof$data$ptr < 128 AND a$blk$seqno - 1 = a$blk$count) OR a$blk$count < a$blk$seqno - 1)
           -    then
                                                 ; STATEMENT # 145
           16CF  2ADE2A          LHLD    AEOPP
           16D2  7E              MOV     A,M
           16D3  D680            SUI     80H
           16D5  9F              SBB     A
           16D6  2AE62A          LHLD    ABLKSEQNOP
           16D9  4E              MOV     C,M
           16DA  23              INX     H
           16DB  46              MOV     B,M
           16DC  0B              DCX     B
           16DD  2AE42A          LHLD    ABCNTP
           16E0  EB              XCHG
           16E1  F5              PUSH    PSW     ; 1
           16E2  CD2D2A          CALL    @P0100 
           16E5  B5              ORA     L
           16E6  D601            SUI     1
           16E8  9F              SBB     A
           16E9  E1              POP     H       ; 1
           16EA  6C              MOV     L,H
           16EB  A5              ANA     L
           16EC  1B              DCX     D
           16ED  F5              PUSH    PSW     ; 1
           16EE  CD2D2A          CALL    @P0100 
           16F1  9F              SBB     A
           16F2  C1              POP     B       ; 1
           16F3  48              MOV     C,B
           16F4  B1              ORA     C
           16F5  1F              RAR
           16F6  DAFA16          JC      @3
PL/M-80 COMPILER                                                                                                PAGE   5


 146   3                  return;
                                                 ; STATEMENT # 146
           16F9  C9              RET
                         @3:
 147   3          end;
                                                 ; STATEMENT # 147
           16FA  C32C17          JMP     @4
                         @2:
                  else
 148   2          do;
 149   3              if not ((a$eof$data$ptr < a$data$ptr AND a$blk$seqno = a$blk$count) OR a$blk$seqno > a$blk$count) 
           -   then
                                                 ; STATEMENT # 149
           16FD  2ADE2A          LHLD    AEOPP
           1700  E5              PUSH    H       ; 1
           1701  2AD62A          LHLD    ADATAPTRP
           1704  C1              POP     B       ; 1
           1705  0A              LDAX    B
           1706  96              SUB     M
           1707  9F              SBB     A
           1708  2AE62A          LHLD    ABLKSEQNOP
           170B  E5              PUSH    H       ; 1
           170C  2AE42A          LHLD    ABCNTP
           170F  D1              POP     D       ; 1
           1710  F5              PUSH    PSW     ; 1
           1711  E5              PUSH    H       ; 2
           1712  CD2A2A          CALL    @P0099 
           1715  B5              ORA     L
           1716  D601            SUI     1
           1718  9F              SBB     A
           1719  E1              POP     H       ; 2
           171A  C1              POP     B       ; 1
           171B  48              MOV     C,B
           171C  A1              ANA     C
           171D  EB              XCHG
           171E  2B              DCX     H
           171F  F5              PUSH    PSW     ; 1
           1720  CD2A2A          CALL    @P0099 
           1723  9F              SBB     A
           1724  C1              POP     B       ; 1
           1725  48              MOV     C,B
           1726  B1              ORA     C
           1727  1F              RAR
           1728  DA2C17          JC      @5
 150   3                  return;
                                                 ; STATEMENT # 150
           172B  C9              RET
                         @5:
 151   3          end;
                                                 ; STATEMENT # 151
                         @4:
 152   2          call chk$eof;
                                                 ; STATEMENT # 152
           172C  CD8A16          CALL    CHKEOF
 153   2          a$blk$count = a$blk$seqno;
                                                 ; STATEMENT # 153
           172F  2AE62A          LHLD    ABLKSEQNOP
PL/M-80 COMPILER                                                                                                PAGE   6


           1732  E5              PUSH    H       ; 1
           1733  2AE42A          LHLD    ABCNTP
           1736  E3              XTHL            ; 1
           1737  4E              MOV     C,M
           1738  23              INX     H
           1739  46              MOV     B,M
           173A  E1              POP     H       ; 1
           173B  71              MOV     M,C
           173C  23              INX     H
           173D  70              MOV     M,B
 154   2          a$eof$data$ptr = a$data$ptr;
                                                 ; STATEMENT # 154
           173E  2AD62A          LHLD    ADATAPTRP
           1741  E5              PUSH    H       ; 1
           1742  2ADE2A          LHLD    AEOPP
           1745  C1              POP     B       ; 1
           1746  0A              LDAX    B
           1747  77              MOV     M,A
 155   2      end;
                                                 ; STATEMENT # 155
           1748  C9              RET
        
        
        
 156   1      rw: PROCEDURE(aftn, buffer, count, actual$p, reading);
                                                 ; STATEMENT # 156
                         ; PROC  RW
           1749  21EA2D          LXI     H,READING
           174C  73              MOV     M,E
           174D  2B              DCX     H
           174E  70              MOV     M,B
           174F  2B              DCX     H
           1750  71              MOV     M,C
           1751  2B              DCX     H
           1752  D1              POP     D       
           1753  C1              POP     B       
           1754  70              MOV     M,B
           1755  2B              DCX     H
           1756  71              MOV     M,C
           1757  2B              DCX     H
           1758  C1              POP     B       
           1759  70              MOV     M,B
           175A  2B              DCX     H
           175B  71              MOV     M,C
           175C  2B              DCX     H
           175D  C1              POP     B       
           175E  71              MOV     M,C
           175F  D5              PUSH    D       
 157   2          DECLARE aftn BYTE, (buffer, count, actual$p) ADDRESS, reading BYTE;
 158   2          DECLARE actual BASED actual$p ADDRESS;
 159   2          DECLARE temp ADDRESS, non$sector$request BYTE, work$buf ADDRESS;
 160   2          DECLARE newlinks BASED temp (64) ADDRESS;
        
 161   2          do while count > actual;
                                                 ; STATEMENT # 161
                         @70:
           1760  2AE82D          LHLD    ACTUALP
PL/M-80 COMPILER                                                                                                PAGE   7


           1763  EB              XCHG
           1764  01E62D          LXI     B,COUNT
           1767  CD282A          CALL    @P0098 
           176A  D2171A          JNC     @71
 162   3              if a$blk$count <= a$blk$seqno AND reading AND a$data$ptr = a$eof$data$ptr then
                                                 ; STATEMENT # 162
           176D  2AE42A          LHLD    ABCNTP
           1770  E5              PUSH    H       ; 1
           1771  2AE62A          LHLD    ABLKSEQNOP
           1774  EB              XCHG
           1775  C1              POP     B       ; 1
           1776  CD282A          CALL    @P0098 
           1779  9F              SBB     A
           177A  2F              CMA
           177B  21EA2D          LXI     H,READING
           177E  A6              ANA     M
           177F  2AD62A          LHLD    ADATAPTRP
           1782  E5              PUSH    H       ; 1
           1783  2ADE2A          LHLD    AEOPP
           1786  C1              POP     B       ; 1
           1787  F5              PUSH    PSW     ; 1
           1788  0A              LDAX    B
           1789  96              SUB     M
           178A  D601            SUI     1
           178C  9F              SBB     A
           178D  C1              POP     B       ; 1
           178E  48              MOV     C,B
           178F  A1              ANA     C
           1790  1F              RAR
           1791  D29517          JNC     @6
 163   3                  return;
                                                 ; STATEMENT # 163
           1794  C9              RET
                         @6:
 164   3              if a$data$ptr = 128 then
                                                 ; STATEMENT # 164
           1795  2AD62A          LHLD    ADATAPTRP
           1798  7E              MOV     A,M
           1799  FE80            CPI     80H
           179B  C28218          JNZ     @7
 165   3              do;
 166   4                  call save$data$blk;
                                                 ; STATEMENT # 166
           179E  CDDC1E          CALL    SAVEDATABLK
 167   4                  a$data$ptr = 0;
                                                 ; STATEMENT # 167
           17A1  2AD62A          LHLD    ADATAPTRP
           17A4  3600            MVI     M,0H
 168   4                  a$dbuf$read = FALSE;
                                                 ; STATEMENT # 168
           17A6  2AEE2A          LHLD    ADBUFREADP
           17A9  3600            MVI     M,0H
 169   4                  a$blk$seqno = a$blk$seqno + 1;
                                                 ; STATEMENT # 169
           17AB  2AE62A          LHLD    ABLKSEQNOP
           17AE  4E              MOV     C,M
           17AF  23              INX     H
PL/M-80 COMPILER                                                                                                PAGE   8


           17B0  46              MOV     B,M
           17B1  03              INX     B
           17B2  2B              DCX     H
           17B3  71              MOV     M,C
           17B4  23              INX     H
           17B5  70              MOV     M,B
 170   4                  a$ptr$ptr = a$ptr$ptr + 1;
                                                 ; STATEMENT # 170
           17B6  2ADC2A          LHLD    APTRPTRP
           17B9  34              INR     M
 171   4                  if a$ptr$ptr = 64 then
                                                 ; STATEMENT # 171
           17BA  2ADC2A          LHLD    APTRPTRP
           17BD  7E              MOV     A,M
           17BE  FE40            CPI     40H
           17C0  C28218          JNZ     @8
 172   4                  do;
 173   5                      if links(FLINK) = 0 then
                                                 ; STATEMENT # 173
           17C3  2AC62A          LHLD    POINTERBASE
           17C6  23              INX     H
           17C7  23              INX     H
           17C8  3E00            MVI     A,0H
           17CA  CD402A          CALL    @P0103 
           17CD  B5              ORA     L
           17CE  C22618          JNZ     @9
 174   5                      do;
 175   6                          newptrblk = get$block(a$device);
                                                 ; STATEMENT # 175
           17D1  2ACC2A          LHLD    ADEVP
           17D4  4E              MOV     C,M
           17D5  CD4223          CALL    GETBLK
           17D8  22E02D          SHLD    NEWPTRBLK
 176   6                          links(FLINK) = newptrblk;   
                                                 ; STATEMENT # 176
           17DB  2AC62A          LHLD    POINTERBASE
           17DE  23              INX     H
           17DF  23              INX     H
           17E0  E5              PUSH    H       ; 1
           17E1  2AE02D          LHLD    NEWPTRBLK
           17E4  EB              XCHG
           17E5  E1              POP     H       ; 1
           17E6  73              MOV     M,E
           17E7  23              INX     H
           17E8  72              MOV     M,D
 177   6                          create = TRUE;
                                                 ; STATEMENT # 177
           17E9  21DF2D          LXI     H,CREATE
           17EC  36FF            MVI     M,0FFH
 178   6                          a$ptr$change = TRUE;
                                                 ; STATEMENT # 178
           17EE  2AE02A          LHLD    APTRCHANGEP
           17F1  36FF            MVI     M,0FFH
 179   6                          call clear$buf(temp := a$dbuf);
                                                 ; STATEMENT # 179
           17F3  2AD42A          LHLD    ADBUFP
           17F6  5E              MOV     E,M
PL/M-80 COMPILER                                                                                                PAGE   9


           17F7  23              INX     H
           17F8  56              MOV     D,M
           17F9  EB              XCHG
           17FA  22EB2D          SHLD    TEMP
           17FD  44              MOV     B,H
           17FE  4D              MOV     C,L
           17FF  CDE924          CALL    CLRBUF
 180   6                          newlinks(0) = a$ptr$blk;    /* save forward link */
                                                 ; STATEMENT # 180
           1802  2AE82A          LHLD    APTRBLKP
           1805  E5              PUSH    H       ; 1
           1806  2AEB2D          LHLD    TEMP
           1809  E3              XTHL            ; 1
           180A  4E              MOV     C,M
           180B  23              INX     H
           180C  46              MOV     B,M
           180D  E1              POP     H       ; 1
           180E  71              MOV     M,C
           180F  23              INX     H
           1810  70              MOV     M,B
 181   6                          call map$write(a$device);
                                                 ; STATEMENT # 181
           1811  2ACC2A          LHLD    ADEVP
           1814  4E              MOV     C,M
           1815  CDA922          CALL    MAPWRI
 182   6                          call abswrite(newptrblk, a$dbuf);
                                                 ; STATEMENT # 182
           1818  2AD42A          LHLD    ADBUFP
           181B  5E              MOV     E,M
           181C  23              INX     H
           181D  56              MOV     D,M
           181E  2AE02D          LHLD    NEWPTRBLK
           1821  44              MOV     B,H
           1822  4D              MOV     C,L
           1823  CDBD09          CALL    ABSWR
 183   6                      end;
                                                 ; STATEMENT # 183
                         @9:
        
 184   5                      call save$pointer$block;
                                                 ; STATEMENT # 184
           1826  CDFB1E          CALL    SAVEPOINTERBLOCK
 185   5                      if create then
                                                 ; STATEMENT # 185
           1829  3ADF2D          LDA     CREATE
           182C  1F              RAR
           182D  D25618          JNC     @10
 186   5                      do;
 187   6                          create = FALSE;
                                                 ; STATEMENT # 187
           1830  21DF2D          LXI     H,CREATE
           1833  3600            MVI     M,0H
 188   6                          call clear$buf(temp := a$pbuf);
                                                 ; STATEMENT # 188
           1835  2ADA2A          LHLD    APBUFP
           1838  5E              MOV     E,M
           1839  23              INX     H
PL/M-80 COMPILER                                                                                                PAGE  10


           183A  56              MOV     D,M
           183B  EB              XCHG
           183C  22EB2D          SHLD    TEMP
           183F  44              MOV     B,H
           1840  4D              MOV     C,L
           1841  CDE924          CALL    CLRBUF
 189   6                          newlinks(0) = a$ptr$blk;
                                                 ; STATEMENT # 189
           1844  2AE82A          LHLD    APTRBLKP
           1847  E5              PUSH    H       ; 1
           1848  2AEB2D          LHLD    TEMP
           184B  E3              XTHL            ; 1
           184C  4E              MOV     C,M
           184D  23              INX     H
           184E  46              MOV     B,M
           184F  E1              POP     H       ; 1
           1850  71              MOV     M,C
           1851  23              INX     H
           1852  70              MOV     M,B
 190   6                      end;
                                                 ; STATEMENT # 190
           1853  C37118          JMP     @11
                         @10:
                              else
 191   5                      do;
 192   6                          call absread(newptrblk := links(FLINK), a$pbuf);
                                                 ; STATEMENT # 192
           1856  2AC62A          LHLD    POINTERBASE
           1859  23              INX     H
           185A  23              INX     H
           185B  5E              MOV     E,M
           185C  23              INX     H
           185D  56              MOV     D,M
           185E  EB              XCHG
           185F  22E02D          SHLD    NEWPTRBLK
           1862  2ADA2A          LHLD    APBUFP
           1865  EB              XCHG
           1866  2B              DCX     H
           1867  4E              MOV     C,M
           1868  23              INX     H
           1869  46              MOV     B,M
           186A  EB              XCHG
           186B  5E              MOV     E,M
           186C  23              INX     H
           186D  56              MOV     D,M
           186E  CDA409          CALL    ABSRD
 193   6                      end;
                                                 ; STATEMENT # 193
                         @11:
 194   5                      a$ptr$blk = newptrblk;
                                                 ; STATEMENT # 194
           1871  2AE82A          LHLD    APTRBLKP
           1874  E5              PUSH    H       ; 1
           1875  2AE02D          LHLD    NEWPTRBLK
           1878  EB              XCHG
           1879  E1              POP     H       ; 1
           187A  73              MOV     M,E
PL/M-80 COMPILER                                                                                                PAGE  11


           187B  23              INX     H
           187C  72              MOV     M,D
 195   5                      a$ptr$ptr = 2;
                                                 ; STATEMENT # 195
           187D  2ADC2A          LHLD    APTRPTRP
           1880  3602            MVI     M,2H
 196   5                  end;
                                                 ; STATEMENT # 196
                         @8:
 197   4              end;
                                                 ; STATEMENT # 197
                         @7:
        
 198   3              adp$dif = 128 - a$data$ptr;
                                                 ; STATEMENT # 198
           1882  2AD62A          LHLD    ADATAPTRP
           1885  3E80            MVI     A,80H
           1887  96              SUB     M
           1888  32DC2D          STA     ADPDIF
 199   3              if a$blk$count <= a$blk$seqno AND READING then
                                                 ; STATEMENT # 199
           188B  2AE42A          LHLD    ABCNTP
           188E  E5              PUSH    H       ; 1
           188F  2AE62A          LHLD    ABLKSEQNOP
           1892  EB              XCHG
           1893  C1              POP     B       ; 1
           1894  CD282A          CALL    @P0098 
           1897  9F              SBB     A
           1898  2F              CMA
           1899  21EA2D          LXI     H,READING
           189C  A6              ANA     M
           189D  1F              RAR
           189E  D2BB18          JNC     @12
 200   3              do;
 201   4                  eof$dif = a$eof$data$ptr - a$data$ptr;
                                                 ; STATEMENT # 201
           18A1  2ADE2A          LHLD    AEOPP
           18A4  E5              PUSH    H       ; 1
           18A5  2AD62A          LHLD    ADATAPTRP
           18A8  C1              POP     B       ; 1
           18A9  0A              LDAX    B
           18AA  96              SUB     M
           18AB  32DB2D          STA     EOFDIF
 202   4                  if adp$dif > eof$dif then
                                                 ; STATEMENT # 202
           18AE  21DC2D          LXI     H,ADPDIF
           18B1  BE              CMP     M
           18B2  D2BB18          JNC     @13
 203   4                      adp$dif = eof$dif;
                                                 ; STATEMENT # 203
           18B5  3ADB2D          LDA     EOFDIF
           18B8  32DC2D          STA     ADPDIF
                         @13:
 204   4              end;
                                                 ; STATEMENT # 204
                         @12:
 205   3              countdiff = count - actual;
PL/M-80 COMPILER                                                                                                PAGE  12


                                                 ; STATEMENT # 205
           18BB  2AE82D          LHLD    ACTUALP
           18BE  11E62D          LXI     D,COUNT
           18C1  CD2A2A          CALL    @P0099 
           18C4  22D92D          SHLD    COUNTDIFF
 206   3              if adp$dif > count$diff then    /* check if more in buffer than needed */
                                                 ; STATEMENT # 206
           18C7  EB              XCHG
           18C8  3ADC2D          LDA     ADPDIF
           18CB  CD1E2A          CALL    @P0096 
           18CE  D2D918          JNC     @14
 207   3                  adp$dif = count$diff;
                                                 ; STATEMENT # 207
        
           18D1  2AD92D          LHLD    COUNTDIFF
           18D4  EB              XCHG
           18D5  21DC2D          LXI     H,ADPDIF
           18D8  73              MOV     M,E
                         @14:
        
 208   3              actual = actual + adp$dif;
                                                 ; STATEMENT # 208
           18D9  2AE82D          LHLD    ACTUALP
           18DC  3ADC2D          LDA     ADPDIF
           18DF  CD8629          CALL    @P0015 
           18E2  EB              XCHG
           18E3  2B              DCX     H
           18E4  73              MOV     M,E
           18E5  23              INX     H
           18E6  72              MOV     M,D
 209   3              non$sector$request = adp$dif <> 128;
                                                 ; STATEMENT # 209
           18E7  3ADC2D          LDA     ADPDIF
           18EA  D680            SUI     80H
           18EC  C6FF            ADI     255
           18EE  9F              SBB     A
           18EF  32ED2D          STA     NONSECTORREQUEST
 210   3              adp$dif = adp$dif + a$data$ptr;
                                                 ; STATEMENT # 210
           18F2  2AD62A          LHLD    ADATAPTRP
           18F5  3ADC2D          LDA     ADPDIF
           18F8  86              ADD     M
           18F9  32DC2D          STA     ADPDIF
 211   3              work$buf = buffer;
                                                 ; STATEMENT # 211
           18FC  2AE42D          LHLD    BUFFER
           18FF  22EE2D          SHLD    WORKBUF
 212   3              if non$sector$request then
                                                 ; STATEMENT # 212
           1902  3AED2D          LDA     NONSECTORREQUEST
           1905  1F              RAR
           1906  D21319          JNC     @15
 213   3                  work$buf = a$dbuf;
                                                 ; STATEMENT # 213
           1909  2AD42A          LHLD    ADBUFP
           190C  5E              MOV     E,M
           190D  23              INX     H
PL/M-80 COMPILER                                                                                                PAGE  13


           190E  56              MOV     D,M
           190F  EB              XCHG
           1910  22EE2D          SHLD    WORKBUF
                         @15:
 214   3              a$data$blk = links(a$ptr$ptr);
                                                 ; STATEMENT # 214
           1913  2ADC2A          LHLD    APTRPTRP
           1916  6E              MOV     L,M
           1917  2600            MVI     H,0
           1919  29              DAD     H
           191A  EB              XCHG
           191B  2AC62A          LHLD    POINTERBASE
           191E  19              DAD     D
           191F  E5              PUSH    H       ; 1
           1920  2AEC2A          LHLD    ADATABLKP
           1923  E3              XTHL            ; 1
           1924  4E              MOV     C,M
           1925  23              INX     H
           1926  46              MOV     B,M
           1927  E1              POP     H       ; 1
           1928  71              MOV     M,C
           1929  23              INX     H
           192A  70              MOV     M,B
 215   3              if a$data$blk = 0 then
                                                 ; STATEMENT # 215
           192B  2AEC2A          LHLD    ADATABLKP
           192E  3E00            MVI     A,0H
           1930  CD402A          CALL    @P0103 
           1933  B5              ORA     L
           1934  C27E19          JNZ     @16
 216   3              do;
 217   4                  if reading then
                                                 ; STATEMENT # 217
           1937  3AEA2D          LDA     READING
           193A  1F              RAR
           193B  D24919          JNC     @17
 218   4                      call clear$buf(work$buf);
                                                 ; STATEMENT # 218
           193E  2AEE2D          LHLD    WORKBUF
           1941  44              MOV     B,H
           1942  4D              MOV     C,L
           1943  CDE924          CALL    CLRBUF
           1946  C37B19          JMP     @18
                         @17:
                          else
 219   4                  do;
 220   5                      if non$sector$request then
                                                 ; STATEMENT # 220
           1949  3AED2D          LDA     NONSECTORREQUEST
           194C  1F              RAR
           194D  D25819          JNC     @19
 221   5                          call clear$buf(work$buf);
                                                 ; STATEMENT # 221
           1950  2AEE2D          LHLD    WORKBUF
           1953  44              MOV     B,H
           1954  4D              MOV     C,L
           1955  CDE924          CALL    CLRBUF
PL/M-80 COMPILER                                                                                                PAGE  14


                         @19:
 222   5                      a$ptr$change = TRUE;
                                                 ; STATEMENT # 222
           1958  2AE02A          LHLD    APTRCHANGEP
           195B  36FF            MVI     M,0FFH
 223   5                      links(a$ptr$ptr), a$data$blk =  get$block(a$device);
                                                 ; STATEMENT # 223
           195D  2ACC2A          LHLD    ADEVP
           1960  4E              MOV     C,M
           1961  CD4223          CALL    GETBLK
           1964  E5              PUSH    H       ; 1
           1965  2ADC2A          LHLD    APTRPTRP
           1968  6E              MOV     L,M
           1969  2600            MVI     H,0
           196B  29              DAD     H
           196C  EB              XCHG
           196D  2AC62A          LHLD    POINTERBASE
           1970  19              DAD     D
           1971  C1              POP     B       ; 1
           1972  71              MOV     M,C
           1973  23              INX     H
           1974  70              MOV     M,B
           1975  2AEC2A          LHLD    ADATABLKP
           1978  71              MOV     M,C
           1979  23              INX     H
           197A  70              MOV     M,B
 224   5                  end;
                                                 ; STATEMENT # 224
                         @18:
 225   4              end;
                                                 ; STATEMENT # 225
           197B  C3A619          JMP     @20
                         @16:
 226   3              else if a$dbuf$read then
                                                 ; STATEMENT # 226
           197E  2AEE2A          LHLD    ADBUFREADP
           1981  7E              MOV     A,M
           1982  1F              RAR
           1983  D28E19          JNC     @21
 227   3                  non$sector$request = TRUE;
                                                 ; STATEMENT # 227
           1986  21ED2D          LXI     H,NONSECTORREQUEST
           1989  36FF            MVI     M,0FFH
           198B  C3A619          JMP     @22
                         @21:
 228   3              else if non$sector$request OR reading then
                                                 ; STATEMENT # 228
           198E  3AEA2D          LDA     READING
           1991  21ED2D          LXI     H,NONSECTORREQUEST
           1994  B6              ORA     M
           1995  1F              RAR
           1996  D2A619          JNC     @23
 229   3                  call abs$read(a$data$blk, work$buf);
                                                 ; STATEMENT # 229
           1999  2AEC2A          LHLD    ADATABLKP
           199C  4E              MOV     C,M
           199D  23              INX     H
PL/M-80 COMPILER                                                                                                PAGE  15


           199E  46              MOV     B,M
           199F  2AEE2D          LHLD    WORKBUF
           19A2  EB              XCHG
           19A3  CDA409          CALL    ABSRD
                         @23:
                         @22:
                         @20:
        
 230   3              if non$sector$request then
                                                 ; STATEMENT # 230
           19A6  3AED2D          LDA     NONSECTORREQUEST
           19A9  1F              RAR
           19AA  D2F119          JNC     @24
 231   3              do;
 232   4                  a$dbuf$read = TRUE;
                                                 ; STATEMENT # 232
           19AD  2AEE2A          LHLD    ADBUFREADP
           19B0  36FF            MVI     M,0FFH
 233   4                  datapp = a$data$ptr$p;
                                                 ; STATEMENT # 233
           19B2  2AD62A          LHLD    ADATAPTRP
           19B5  22DD2D          SHLD    DATAPP
 234   4                  if reading then
                                                 ; STATEMENT # 234
           19B8  3AEA2D          LDA     READING
           19BB  1F              RAR
           19BC  D2D219          JNC     @25
 235   4                      call sysUsr(.buffer, buffer, datum$base);
                                                 ; STATEMENT # 235
           19BF  01E42D          LXI     B,BUFFER
           19C2  C5              PUSH    B       ; 1
           19C3  2AE42D          LHLD    BUFFER
           19C6  44              MOV     B,H
           19C7  4D              MOV     C,L
           19C8  2AC82A          LHLD    DATUMBASE
           19CB  EB              XCHG
           19CC  CD9826          CALL    SYSUSR
           19CF  C3E719          JMP     @26
                         @25:
                          else
 236   4                  do;
 237   5                      a$data$change = TRUE;
                                                 ; STATEMENT # 237
           19D2  2AE22A          LHLD    ADATACHANGEP
           19D5  36FF            MVI     M,0FFH
 238   5                      call usrSys(.buffer, buffer, datum$base);
                                                 ; STATEMENT # 238
           19D7  01E42D          LXI     B,BUFFER
           19DA  C5              PUSH    B       ; 1
           19DB  2AE42D          LHLD    BUFFER
           19DE  44              MOV     B,H
           19DF  4D              MOV     C,L
           19E0  2AC82A          LHLD    DATUMBASE
           19E3  EB              XCHG
           19E4  CD7D26          CALL    USRSYS
 239   5                  end;
                                                 ; STATEMENT # 239
PL/M-80 COMPILER                                                                                                PAGE  16


                         @26:
 240   4                  a$data$ptr = adp$dif;
                                                 ; STATEMENT # 240
           19E7  2AD62A          LHLD    ADATAPTRP
           19EA  3ADC2D          LDA     ADPDIF
           19ED  77              MOV     M,A
 241   4              end;
                                                 ; STATEMENT # 241
           19EE  C3141A          JMP     @27
                         @24:
                      else
 242   3              do;
 243   4                  if not reading then
                                                 ; STATEMENT # 243
           19F1  3AEA2D          LDA     READING
           19F4  1F              RAR
           19F5  DA051A          JC      @28
 244   4                      call abswrite(a$data$blk, work$buf);
                                                 ; STATEMENT # 244
           19F8  2AEC2A          LHLD    ADATABLKP
           19FB  4E              MOV     C,M
           19FC  23              INX     H
           19FD  46              MOV     B,M
           19FE  2AEE2D          LHLD    WORKBUF
           1A01  EB              XCHG
           1A02  CDBD09          CALL    ABSWR
                         @28:
 245   4                  a$data$ptr = 128;
                                                 ; STATEMENT # 245
           1A05  2AD62A          LHLD    ADATAPTRP
           1A08  3680            MVI     M,80H
 246   4                  buffer = buffer + 128;
                                                 ; STATEMENT # 246
           1A0A  118000          LXI     D,80H
           1A0D  2AE42D          LHLD    BUFFER
           1A10  19              DAD     D
           1A11  22E42D          SHLD    BUFFER
 247   4              end;
                                                 ; STATEMENT # 247
                         @27:
 248   3          end; /* of do while */
                                                 ; STATEMENT # 248
           1A14  C36017          JMP     @70
                         @71:
 249   2          call adjust$eof;
                                                 ; STATEMENT # 249
           1A17  CDB216          CALL    ADJUSTEOF
 250   2      end;
                                                 ; STATEMENT # 250
           1A1A  C9              RET
        
        
        
 251   1      non$disk$select: PROCEDURE;
                                                 ; STATEMENT # 251
                         ; PROC  NONDISKSELECT
                  /*
PL/M-80 COMPILER                                                                                                PAGE  17


                     set logical file assignments to use monitor routines
                     for doing byte at a time I/O devices
                  */
 252   2          call ioset(((iostat := iochk) AND iobyteMasks(a$device)) or iobyteFlags(a$device));
                                                 ; STATEMENT # 252
           1A1B  CD15F8          CALL    IOCHK
           1A1E  32E22D          STA     IOSTAT
           1A21  2ACC2A          LHLD    ADEVP
           1A24  4E              MOV     C,M
           1A25  0600            MVI     B,0
           1A27  212916          LXI     H,IOBYTEMASKS
           1A2A  09              DAD     B
           1A2B  A6              ANA     M
           1A2C  2ACC2A          LHLD    ADEVP
           1A2F  4E              MOV     C,M
           1A30  0600            MVI     B,0
           1A32  214616          LXI     H,IOBYTEFLAGS
           1A35  09              DAD     B
           1A36  B6              ORA     M
           1A37  4F              MOV     C,A
           1A38  CD18F8          CALL    IOSET
 253   2      end;
                                                 ; STATEMENT # 253
           1A3B  C9              RET
        
        
 254   1      read: PROCEDURE(aftn, buffer, count, actual$p) PUBLIC;
                                                 ; STATEMENT # 254
                         ; PROC  READ
           1A3C  21F62D          LXI     H,ACTUALP+1H
           1A3F  72              MOV     M,D
           1A40  2B              DCX     H
           1A41  73              MOV     M,E
           1A42  2B              DCX     H
           1A43  70              MOV     M,B
           1A44  2B              DCX     H
           1A45  71              MOV     M,C
           1A46  2B              DCX     H
           1A47  D1              POP     D       
           1A48  C1              POP     B       
           1A49  70              MOV     M,B
           1A4A  2B              DCX     H
           1A4B  71              MOV     M,C
           1A4C  2B              DCX     H
           1A4D  C1              POP     B       
           1A4E  71              MOV     M,C
           1A4F  D5              PUSH    D       
 255   2          DECLARE aftn BYTE, (buffer, count, actual$p) ADDRESS;
 256   2          DECLARE actual BASED actual$p ADDRESS;
 257   2          DECLARE bytes BASED buffer BYTE;
        
 258   2          actual = 0;
                                                 ; STATEMENT # 258
           1A50  2AF52D          LHLD    ACTUALP
           1A53  3E00            MVI     A,0H
           1A55  77              MOV     M,A
           1A56  23              INX     H
PL/M-80 COMPILER                                                                                                PAGE  18


           1A57  3600            MVI     M,0
 259   2          call aft$window(aftn);
                                                 ; STATEMENT # 259
           1A59  2AF02D          LHLD    AFTN
           1A5C  4D              MOV     C,L
           1A5D  CDA702          CALL    AWINDO
 260   2          if (a$access AND 1) = 0 then    /* not read */
                                                 ; STATEMENT # 260
           1A60  2ACE2A          LHLD    AACESP
           1A63  3E01            MVI     A,1H
           1A65  A6              ANA     M
           1A66  FE00            CPI     0H
           1A68  C2701A          JNZ     @29
 261   2              call warn(CANT$READ);
                                                 ; STATEMENT # 261
           1A6B  0E08            MVI     C,8H
           1A6D  CD510B          CALL    WARN
                         @29:
 262   2          if a$device = 26 then       /* BB */
                                                 ; STATEMENT # 262
           1A70  2ACC2A          LHLD    ADEVP
           1A73  7E              MOV     A,M
           1A74  FE1A            CPI     1AH
           1A76  C27A1A          JNZ     @30
 263   2              return;
                                                 ; STATEMENT # 263
           1A79  C9              RET
                         @30:
 264   2          call non$disk$select;
                                                 ; STATEMENT # 264
           1A7A  CD1B1A          CALL    NONDISKSELECT
 265   2          if a$device <= F9DEV then
                                                 ; STATEMENT # 265
           1A7D  2ACC2A          LHLD    ADEVP
           1A80  3E09            MVI     A,9H
           1A82  BE              CMP     M
           1A83  DA9D1A          JC      @31
 266   2          do;
 267   3              call rw(aftn, buffer, count, actual$p, TRUE);
                                                 ; STATEMENT # 267
           1A86  2AF02D          LHLD    AFTN
           1A89  E5              PUSH    H       ; 1
           1A8A  2AF12D          LHLD    BUFFER
           1A8D  E5              PUSH    H       ; 2
           1A8E  2AF32D          LHLD    COUNT
           1A91  E5              PUSH    H       ; 3
           1A92  2AF52D          LHLD    ACTUALP
           1A95  44              MOV     B,H
           1A96  4D              MOV     C,L
           1A97  1EFF            MVI     E,0FFH
           1A99  CD4917          CALL    RW
 268   3              return;
                                                 ; STATEMENT # 268
           1A9C  C9              RET
 269   3          end;
                                                 ; STATEMENT # 269
                         @31:
PL/M-80 COMPILER                                                                                                PAGE  19


        
 270   2          do while actual <> count;
                                                 ; STATEMENT # 270
                         @72:
           1A9D  2AF52D          LHLD    ACTUALP
           1AA0  11F32D          LXI     D,COUNT
           1AA3  CD2A2A          CALL    @P0099 
           1AA6  B5              ORA     L
           1AA7  CAE81A          JZ      @73
 271   3              if devClass(a$device) <> 0efh then
                                                 ; STATEMENT # 271
           1AAA  2ACC2A          LHLD    ADEVP
           1AAD  4E              MOV     C,M
           1AAE  0600            MVI     B,0
           1AB0  216316          LXI     H,DEVCLASS
           1AB3  09              DAD     B
           1AB4  7E              MOV     A,M
           1AB5  FEEF            CPI     0EFH
           1AB7  CAC41A          JZ      @32
 272   3                  bytes = ci;
                                                 ; STATEMENT # 272
           1ABA  CD03F8          CALL    CI
           1ABD  2AF12D          LHLD    BUFFER
           1AC0  77              MOV     M,A
           1AC1  C3D31A          JMP     @33
                         @32:
                      else
 273   3              do;
 274   4                  bytes = ri;
                                                 ; STATEMENT # 274
           1AC4  CD06F8          CALL    RI
           1AC7  2AF12D          LHLD    BUFFER
           1ACA  77              MOV     M,A
 275   4                  if CARRY then
                                                 ; STATEMENT # 275
           1ACB  9F              SBB     A
           1ACC  1F              RAR
           1ACD  D2D31A          JNC     @34
 276   4                      goto done;
                                                 ; STATEMENT # 276
           1AD0  C3E81A          JMP     DONE
                         @34:
 277   4              end;
                                                 ; STATEMENT # 277
                         @33:
 278   3              buffer = buffer + 1;
                                                 ; STATEMENT # 278
           1AD3  2AF12D          LHLD    BUFFER
           1AD6  23              INX     H
           1AD7  22F12D          SHLD    BUFFER
 279   3              actual = actual + 1;
                                                 ; STATEMENT # 279
           1ADA  2AF52D          LHLD    ACTUALP
           1ADD  4E              MOV     C,M
           1ADE  23              INX     H
           1ADF  46              MOV     B,M
           1AE0  03              INX     B
PL/M-80 COMPILER                                                                                                PAGE  20


           1AE1  2B              DCX     H
           1AE2  71              MOV     M,C
           1AE3  23              INX     H
           1AE4  70              MOV     M,B
 280   3          end;
                                                 ; STATEMENT # 280
           1AE5  C39D1A          JMP     @72
                         @73:
 281   2      done:
                                                 ; STATEMENT # 281
                         DONE:
           1AE8  2AE22D          LHLD    IOSTAT
           1AEB  4D              MOV     C,L
           1AEC  CD18F8          CALL    IOSET
                  call ioset(iostat);
 282   2      end;
                                                 ; STATEMENT # 282
           1AEF  C9              RET
        
        
        
 283   1      write: PROCEDURE(aftn, buffer, count) PUBLIC;
                                                 ; STATEMENT # 283
                         ; PROC  WRITE
           1AF0  21FB2D          LXI     H,COUNT+1H
           1AF3  72              MOV     M,D
           1AF4  2B              DCX     H
           1AF5  73              MOV     M,E
           1AF6  2B              DCX     H
           1AF7  70              MOV     M,B
           1AF8  2B              DCX     H
           1AF9  71              MOV     M,C
           1AFA  2B              DCX     H
           1AFB  D1              POP     D       
           1AFC  C1              POP     B       
           1AFD  71              MOV     M,C
           1AFE  D5              PUSH    D       
 284   2          DECLARE aftn byte, (buffer, count) ADDRESS;
 285   2          DECLARE bytes BASED buffer BYTE;
 286   2          DECLARE actual ADDRESS, i BYTE;
        
 287   2          call aft$window(aftn);
                                                 ; STATEMENT # 287
           1AFF  2AF72D          LHLD    AFTN
           1B02  4D              MOV     C,L
           1B03  CDA702          CALL    AWINDO
 288   2          if (a$access and 2) = 0 then
                                                 ; STATEMENT # 288
           1B06  2ACE2A          LHLD    AACESP
           1B09  3E02            MVI     A,2H
           1B0B  A6              ANA     M
           1B0C  FE00            CPI     0H
           1B0E  C2161B          JNZ     @35
 289   2              call warn(CANT$WRITE);
                                                 ; STATEMENT # 289
           1B11  0E06            MVI     C,6H
           1B13  CD510B          CALL    WARN
PL/M-80 COMPILER                                                                                                PAGE  21


                         @35:
 290   2          if a$device = 26 then   /* BB */
                                                 ; STATEMENT # 290
           1B16  2ACC2A          LHLD    ADEVP
           1B19  7E              MOV     A,M
           1B1A  FE1A            CPI     1AH
           1B1C  C2201B          JNZ     @36
 291   2              return;
                                                 ; STATEMENT # 291
           1B1F  C9              RET
                         @36:
 292   2          call non$disk$select;
                                                 ; STATEMENT # 292
        
           1B20  CD1B1A          CALL    NONDISKSELECT
 293   2          do while count <> 0;
                                                 ; STATEMENT # 293
                         @74:
           1B23  3E00            MVI     A,0H
           1B25  11FA2D          LXI     D,COUNT
           1B28  CD352A          CALL    @P0101 
           1B2B  B5              ORA     L
           1B2C  CAD51B          JZ      @75
 294   3              do case devClass(a$device);
                                                 ; STATEMENT # 294
           1B2F  2ACC2A          LHLD    ADEVP
           1B32  4E              MOV     C,M
           1B33  0600            MVI     B,0
           1B35  216316          LXI     H,DEVCLASS
           1B38  09              DAD     B
           1B39  4E              MOV     C,M
           1B3A  0600            MVI     B,0
           1B3C  21BC1B          LXI     H,@76
           1B3F  09              DAD     B
           1B40  09              DAD     B
           1B41  5E              MOV     E,M
           1B42  23              INX     H
           1B43  56              MOV     D,M
           1B44  EB              XCHG
           1B45  E9              PCHL
 295   4              do;     /* case 0 */
                                                 ; STATEMENT # 295
                         @38:
 296   5                  actual = 0;
                                                 ; STATEMENT # 296
           1B46  210000          LXI     H,0H
           1B49  22FC2D          SHLD    ACTUAL
 297   5                  call rw(aftn, buffer, count, .actual, FALSE);
                                                 ; STATEMENT # 297
           1B4C  2AF72D          LHLD    AFTN
           1B4F  E5              PUSH    H       ; 1
           1B50  2AF82D          LHLD    BUFFER
           1B53  E5              PUSH    H       ; 2
           1B54  2AFA2D          LHLD    COUNT
           1B57  E5              PUSH    H       ; 3
           1B58  1E00            MVI     E,0H
           1B5A  01FC2D          LXI     B,ACTUAL
PL/M-80 COMPILER                                                                                                PAGE  22


           1B5D  CD4917          CALL    RW
 298   5                  return;
                                                 ; STATEMENT # 298
           1B60  C9              RET
 299   5              end;
                                                 ; STATEMENT # 299
           1B61  C3C41B          JMP     @37
 300   4              do;     /* case 1 */
                                                 ; STATEMENT # 300
                         @39:
 301   5                  call CO(bytes);
                                                 ; STATEMENT # 301
           1B64  2AF82D          LHLD    BUFFER
           1B67  4E              MOV     C,M
           1B68  CD09F8          CALL    CO
 302   5                  if csts then
                                                 ; STATEMENT # 302
           1B6B  CD12F8          CALL    CSTS
           1B6E  1F              RAR
           1B6F  D2A51B          JNC     @40
 303   5                  do;
 304   6                      do i = 0 to 255;    /* delay a little */
                                                 ; STATEMENT # 304
           1B72  21FE2D          LXI     H,I
           1B75  3600            MVI     M,0H
                         @77:
           1B77  3EFF            MVI     A,0FFH
           1B79  21FE2D          LXI     H,I
           1B7C  BE              CMP     M
           1B7D  DA871B          JC      @78
 305   7                      end;
                                                 ; STATEMENT # 305
                         @79:
           1B80  21FE2D          LXI     H,I
           1B83  34              INR     M
           1B84  C2771B          JNZ     @77
                         @78:
 306   6                      if csts then
                                                 ; STATEMENT # 306
           1B87  CD12F8          CALL    CSTS
           1B8A  1F              RAR
           1B8B  D2A51B          JNC     @41
 307   6                          if (ci AND 7fh) = CONTROL$S then
                                                 ; STATEMENT # 307
           1B8E  CD03F8          CALL    CI
           1B91  E67F            ANI     7FH
           1B93  FE13            CPI     13H
           1B95  C2A51B          JNZ     @42
 308   6                              do while (ci AND 7fh) <> CONTROL$Q;
                                                 ; STATEMENT # 308
                         @80:
           1B98  CD03F8          CALL    CI
           1B9B  E67F            ANI     7FH
           1B9D  FE11            CPI     11H
           1B9F  CAA51B          JZ      @81
 309   7                              end;
                                                 ; STATEMENT # 309
PL/M-80 COMPILER                                                                                                PAGE  23


           1BA2  C3981B          JMP     @80
                         @81:
                         @42:
                         @41:
        
 310   6                  end;
                                                 ; STATEMENT # 310
                         @40:
 311   5              end;
                                                 ; STATEMENT # 311
           1BA5  C3C41B          JMP     @37
 312   4              call po(bytes);     /* case 2 */
                                                 ; STATEMENT # 312
                         @43:
           1BA8  2AF82D          LHLD    BUFFER
           1BAB  4E              MOV     C,M
           1BAC  CD0CF8          CALL    PO
           1BAF  C3C41B          JMP     @37
 313   4              call lo(bytes);     /* case 3 */
                                                 ; STATEMENT # 313
                         @44:
           1BB2  2AF82D          LHLD    BUFFER
           1BB5  4E              MOV     C,M
           1BB6  CD0FF8          CALL    LO
           1BB9  C3C41B          JMP     @37
 314   4              end;
                                                 ; STATEMENT # 314
                         @76:
           1BBC  461B            DW      @38
           1BBE  641B            DW      @39
           1BC0  A81B            DW      @43
           1BC2  B21B            DW      @44
                         @37:
        
 315   3              count = count - 1;
                                                 ; STATEMENT # 315
           1BC4  2AFA2D          LHLD    COUNT
           1BC7  2B              DCX     H
           1BC8  22FA2D          SHLD    COUNT
 316   3              buffer = buffer + 1;
                                                 ; STATEMENT # 316
           1BCB  2AF82D          LHLD    BUFFER
           1BCE  23              INX     H
           1BCF  22F82D          SHLD    BUFFER
 317   3          end;
                                                 ; STATEMENT # 317
           1BD2  C3231B          JMP     @74
                         @75:
 318   2          call ioset(iostat);
                                                 ; STATEMENT # 318
           1BD5  2AE22D          LHLD    IOSTAT
           1BD8  4D              MOV     C,L
           1BD9  CD18F8          CALL    IOSET
 319   2      end;
                                                 ; STATEMENT # 319
           1BDC  C9              RET
        
PL/M-80 COMPILER                                                                                                PAGE  24


        
        
 320   1      lined: PROCEDURE(aftn, buffer, count, actual$p) PUBLIC;
                                                 ; STATEMENT # 320
                         ; PROC  LINED
           1BDD  21052E          LXI     H,ACTUALP+1H
           1BE0  72              MOV     M,D
           1BE1  2B              DCX     H
           1BE2  73              MOV     M,E
           1BE3  2B              DCX     H
           1BE4  70              MOV     M,B
           1BE5  2B              DCX     H
           1BE6  71              MOV     M,C
           1BE7  2B              DCX     H
           1BE8  D1              POP     D       
           1BE9  C1              POP     B       
           1BEA  70              MOV     M,B
           1BEB  2B              DCX     H
           1BEC  71              MOV     M,C
           1BED  2B              DCX     H
           1BEE  C1              POP     B       
           1BEF  71              MOV     M,C
           1BF0  D5              PUSH    D       
 321   2          DECLARE aftn BYTE, (buffer, count, actual$p) ADDRESS;
 322   2          DECLARE actual BASED actual$p ADDRESS;
 323   2          DECLARE lbuf ADDRESS,
                      in$mode BYTE,
                      lit$mode BYTE,
                      lptr BYTE,
                      char BYTE,
                      i BYTE,     /* note read clobbers selector as well */
                      selector BYTE;
 324   2          DECLARE obuf BASED buffer (1) BYTE;
 325   2          DECLARE bytes BASED lbuf (128) BYTE;
 326   2          DECLARE addr BASED lbuf (64) ADDRESS;
        
        
 327   2          echo: PROCEDURE(char);      /* nested sub of lined */
                                                 ; STATEMENT # 327
                         ; PROC  ECHO
           1EAC  210E2E          LXI     H,CHAR
           1EAF  71              MOV     M,C
 328   3              DECLARE char BYTE;
 329   3              call write(a$edit, .char, 1);
                                                 ; STATEMENT # 329
           1EB0  2AD02A          LHLD    AEDITP
           1EB3  4E              MOV     C,M
           1EB4  C5              PUSH    B       ; 1
           1EB5  110100          LXI     D,1H
           1EB8  010E2E          LXI     B,CHAR
           1EBB  CDF01A          CALL    WRITE
 330   3              call aft$window(aftn);
                                                 ; STATEMENT # 330
           1EBE  2AFF2D          LHLD    AFTN
           1EC1  4D              MOV     C,L
           1EC2  CDA702          CALL    AWINDO
 331   3          end;
PL/M-80 COMPILER                                                                                                PAGE  25


                                                 ; STATEMENT # 331
           1EC5  C9              RET
        
 332   2          echoCRLF: PROCEDURE;
                                                 ; STATEMENT # 332
                         ; PROC  ECHOCRLF
 333   3              call echo(CR);
                                                 ; STATEMENT # 333
           1EC6  0E0D            MVI     C,0DH
           1EC8  CDAC1E          CALL    ECHO
 334   3              call echo(LF);
                                                 ; STATEMENT # 334
           1ECB  0E0A            MVI     C,0AH
           1ECD  CDAC1E          CALL    ECHO
 335   3          end;
                                                 ; STATEMENT # 335
           1ED0  C9              RET
        
 336   2          lineReset: PROCEDURE;       /* nested in lined */
                                                 ; STATEMENT # 336
                         ; PROC  LINERESET
 337   3              in$mode = FALSE;
                                                 ; STATEMENT # 337
           1ED1  21082E          LXI     H,INMODE
           1ED4  3600            MVI     M,0H
 338   3              lptr = 0;
                                                 ; STATEMENT # 338
           1ED6  210A2E          LXI     H,LPTR
           1ED9  3600            MVI     M,0H
 339   3          end;
                                                 ; STATEMENT # 339
           1EDB  C9              RET
        
        
 340   2          lit$mode = FALSE;
                                                 ; STATEMENT # 340
           1BF1  21092E          LXI     H,LITMODE
           1BF4  3600            MVI     M,0H
 341   2          lbuf = aft(aftn).lbuf;
                                                 ; STATEMENT # 341
           1BF6  111C00          LXI     D,1CH
           1BF9  2AFF2D          LHLD    AFTN
           1BFC  2600            MVI     H,0
           1BFE  CDC829          CALL    @P0034 
           1C01  01F02A          LXI     B,AFT
           1C04  09              DAD     B
           1C05  010400          LXI     B,LBUF
           1C08  09              DAD     B
           1C09  5E              MOV     E,M
           1C0A  23              INX     H
           1C0B  56              MOV     D,M
           1C0C  EB              XCHG
           1C0D  22062E          SHLD    LBUF
 342   2          lptr = bytes(126);
                                                 ; STATEMENT # 342
           1C10  017E00          LXI     B,7EH
           1C13  09              DAD     B
PL/M-80 COMPILER                                                                                                PAGE  26


           1C14  7E              MOV     A,M
           1C15  320A2E          STA     LPTR
 343   2          in$mode = bytes(127);
                                                 ; STATEMENT # 343
        
           1C18  2A062E          LHLD    LBUF
           1C1B  03              INX     B
           1C1C  09              DAD     B
           1C1D  7E              MOV     A,M
           1C1E  32082E          STA     INMODE
 344   2          do while in$mode;
                                                 ; STATEMENT # 344
                         @82:
           1C21  3A082E          LDA     INMODE
           1C24  1F              RAR
           1C25  D2111E          JNC     @83
 345   3              call read(aftn, .char, 1, .i);
                                                 ; STATEMENT # 345
           1C28  2AFF2D          LHLD    AFTN
           1C2B  E5              PUSH    H       ; 1
           1C2C  010B2E          LXI     B,CHAR
           1C2F  C5              PUSH    B       ; 2
           1C30  50              MOV     D,B
           1C31  59              MOV     E,C
           1C32  010100          LXI     B,1H
           1C35  13              INX     D
           1C36  CD3C1A          CALL    READ
 346   3              if i = 0 then
                                                 ; STATEMENT # 346
           1C39  3A0C2E          LDA     I
           1C3C  FE00            CPI     0H
           1C3E  C2531C          JNZ     @45
 347   3              do;
 348   4                  if aftn = AFT$CONSOLE then  /* 11 */
                                                 ; STATEMENT # 348
           1C41  3AFF2D          LDA     AFTN
           1C44  FE0B            CPI     0BH
           1C46  C24E1C          JNZ     @46
 349   4                      call abortx(CONSOLE$EOF);
                                                 ; STATEMENT # 349
           1C49  0E1D            MVI     C,1DH
           1C4B  CD4B0B          CALL    ABORTX
                         @46:
 350   4                  char = CONTROL$Z;
                                                 ; STATEMENT # 350
           1C4E  210B2E          LXI     H,CHAR
           1C51  361A            MVI     M,1AH
 351   4              end;
                                                 ; STATEMENT # 351
                         @45:
 352   3              bytes(125) = FALSE;
                                                 ; STATEMENT # 352
           1C53  017D00          LXI     B,7DH
           1C56  2A062E          LHLD    LBUF
           1C59  09              DAD     B
           1C5A  3600            MVI     M,0H
 353   3              char = char AND 7fh;
PL/M-80 COMPILER                                                                                                PAGE  27


                                                 ; STATEMENT # 353
           1C5C  3A0B2E          LDA     CHAR
           1C5F  E67F            ANI     7FH
           1C61  320B2E          STA     CHAR
 354   3              if char <> LF then
                                                 ; STATEMENT # 354
           1C64  FE0A            CPI     0AH
           1C66  CA7B1C          JZ      @47
 355   3                  call echo(bytes(lptr) := char);
                                                 ; STATEMENT # 355
           1C69  2A0A2E          LHLD    LPTR
           1C6C  2600            MVI     H,0
           1C6E  EB              XCHG
           1C6F  2A062E          LHLD    LBUF
           1C72  19              DAD     D
           1C73  3A0B2E          LDA     CHAR
           1C76  77              MOV     M,A
           1C77  4F              MOV     C,A
           1C78  CDAC1E          CALL    ECHO
                         @47:
        
 356   3              selector = 0;
                                                 ; STATEMENT # 356
           1C7B  210D2E          LXI     H,SELECTOR
           1C7E  3600            MVI     M,0H
 357   3              do i = 0 to 9;
                                                 ; STATEMENT # 357
           1C80  2B              DCX     H
           1C81  3600            MVI     M,0H
                         @84:
           1C83  3E09            MVI     A,9H
           1C85  210C2E          LXI     H,I
           1C88  BE              CMP     M
           1C89  DAA91C          JC      @85
 358   4                  if char = specialChars(i) then
                                                 ; STATEMENT # 358
           1C8C  2A0C2E          LHLD    I
           1C8F  2600            MVI     H,0
           1C91  018016          LXI     B,SPECIALCHARS
           1C94  09              DAD     B
           1C95  3A0B2E          LDA     CHAR
           1C98  BE              CMP     M
           1C99  C2A21C          JNZ     @48
 359   4                      selector = i;
                                                 ; STATEMENT # 359
           1C9C  3A0C2E          LDA     I
           1C9F  320D2E          STA     SELECTOR
                         @48:
 360   4              end;    
                                                 ; STATEMENT # 360
                         @86:
           1CA2  210C2E          LXI     H,I
           1CA5  34              INR     M
           1CA6  C2831C          JNZ     @84
                         @85:
 361   3              selector = selector and not lit$mode;
                                                 ; STATEMENT # 361
PL/M-80 COMPILER                                                                                                PAGE  28


           1CA9  3A092E          LDA     LITMODE
           1CAC  2F              CMA
           1CAD  210D2E          LXI     H,SELECTOR
           1CB0  A6              ANA     M
           1CB1  77              MOV     M,A
 362   3              lit$mode = FALSE;
                                                 ; STATEMENT # 362
           1CB2  21092E          LXI     H,LITMODE
           1CB5  3600            MVI     M,0H
 363   3              do case selector;
                                                 ; STATEMENT # 363
           1CB7  4F              MOV     C,A
           1CB8  0600            MVI     B,0
           1CBA  21EF1D          LXI     H,@87
           1CBD  09              DAD     B
           1CBE  09              DAD     B
           1CBF  5E              MOV     E,M
           1CC0  23              INX     H
           1CC1  56              MOV     D,M
           1CC2  EB              XCHG
           1CC3  E9              PCHL
 364   4                  lptr = lptr + 1;    /* case 0 - normal */
                                                 ; STATEMENT # 364
                         @50:
           1CC4  210A2E          LXI     H,LPTR
           1CC7  34              INR     M
           1CC8  C3031E          JMP     @49
 365   4                  do;         /* case 1, rubout */
                                                 ; STATEMENT # 365
                         @51:
 366   5                      if lptr <> 0 then
                                                 ; STATEMENT # 366
           1CCB  3A0A2E          LDA     LPTR
           1CCE  FE00            CPI     0H
           1CD0  CA201D          JZ      @52
 367   5                      do;
 368   6                          lptr = lptr - 1;
                                                 ; STATEMENT # 368
           1CD3  210A2E          LXI     H,LPTR
           1CD6  35              DCR     M
 369   6                          if aft(a$edit).device = 13 then
                                                 ; STATEMENT # 369
           1CD7  2AD02A          LHLD    AEDITP
           1CDA  6E              MOV     L,M
           1CDB  2600            MVI     H,0
           1CDD  111C00          LXI     D,1CH
           1CE0  CDC829          CALL    @P0034 
           1CE3  01F02A          LXI     B,AFT
           1CE6  09              DAD     B
           1CE7  010100          LXI     B,DEVICE
           1CEA  09              DAD     B
           1CEB  7E              MOV     A,M
           1CEC  FE0D            CPI     0DH
           1CEE  C20F1D          JNZ     @53
 370   6                          do;
 371   7                              call echo(BS);
                                                 ; STATEMENT # 371
PL/M-80 COMPILER                                                                                                PAGE  29


           1CF1  0E08            MVI     C,8H
           1CF3  CDAC1E          CALL    ECHO
 372   7                              bytes(lptr) = ' ';
                                                 ; STATEMENT # 372
           1CF6  2A0A2E          LHLD    LPTR
           1CF9  2600            MVI     H,0
           1CFB  EB              XCHG
           1CFC  2A062E          LHLD    LBUF
           1CFF  19              DAD     D
           1D00  3620            MVI     M,20H
 373   7                              call echo(' ');
                                                 ; STATEMENT # 373
           1D02  0E20            MVI     C,20H
           1D04  CDAC1E          CALL    ECHO
 374   7                              call echo(BS);
                                                 ; STATEMENT # 374
           1D07  0E08            MVI     C,8H
           1D09  CDAC1E          CALL    ECHO
 375   7                          end;
                                                 ; STATEMENT # 375
           1D0C  C31D1D          JMP     @54
                         @53:
                                  else
 376   6                              call echo(bytes(lptr));
                                                 ; STATEMENT # 376
           1D0F  2A0A2E          LHLD    LPTR
           1D12  2600            MVI     H,0
           1D14  EB              XCHG
           1D15  2A062E          LHLD    LBUF
           1D18  19              DAD     D
           1D19  4E              MOV     C,M
           1D1A  CDAC1E          CALL    ECHO
                         @54:
 377   6                      end;
                                                 ; STATEMENT # 377
           1D1D  C3251D          JMP     @55
                         @52:
                              else
 378   5                          call echo(BELL);
                                                 ; STATEMENT # 378
           1D20  0E07            MVI     C,7H
           1D22  CDAC1E          CALL    ECHO
                         @55:
 379   5                  end;
                                                 ; STATEMENT # 379
           1D25  C3031E          JMP     @49
 380   4                  do;         /* case 2 - control-Z */
                                                 ; STATEMENT # 380
                         @56:
 381   5                      actual = 0;
                                                 ; STATEMENT # 381
           1D28  2A042E          LHLD    ACTUALP
           1D2B  3E00            MVI     A,0H
           1D2D  77              MOV     M,A
           1D2E  23              INX     H
           1D2F  3600            MVI     M,0
 382   5                      bytes(125) = TRUE;
PL/M-80 COMPILER                                                                                                PAGE  30


                                                 ; STATEMENT # 382
           1D31  017D00          LXI     B,7DH
           1D34  2A062E          LHLD    LBUF
           1D37  09              DAD     B
           1D38  36FF            MVI     M,0FFH
 383   5                      addr(63) = 0ff00h;
                                                 ; STATEMENT # 383
           1D3A  2A062E          LHLD    LBUF
           1D3D  03              INX     B
           1D3E  09              DAD     B
           1D3F  0100FF          LXI     B,0FF00H
           1D42  71              MOV     M,C
           1D43  23              INX     H
           1D44  70              MOV     M,B
 384   5                      call echoCRLF;
                                                 ; STATEMENT # 384
           1D45  CDC61E          CALL    ECHOCRLF
 385   5                      return;
                                                 ; STATEMENT # 385
           1D48  C9              RET
 386   5                  end;
                                                 ; STATEMENT # 386
           1D49  C3031E          JMP     @49
 387   4                  do;         /* case 3 - control-R */
                                                 ; STATEMENT # 387
                         @57:
 388   5                      call echoCRLF;
                                                 ; STATEMENT # 388
           1D4C  CDC61E          CALL    ECHOCRLF
 389   5                      call write(a$edit, .bytes, lptr);
                                                 ; STATEMENT # 389
           1D4F  2AD02A          LHLD    AEDITP
           1D52  4E              MOV     C,M
           1D53  C5              PUSH    B       ; 1
           1D54  2A062E          LHLD    LBUF
           1D57  44              MOV     B,H
           1D58  4D              MOV     C,L
           1D59  2A0A2E          LHLD    LPTR
           1D5C  2600            MVI     H,0
           1D5E  EB              XCHG
           1D5F  CDF01A          CALL    WRITE
 390   5                  end;
                                                 ; STATEMENT # 390
           1D62  C3031E          JMP     @49
 391   4                  do;         /* case 4 - control-X */
                                                 ; STATEMENT # 391
                         @58:
 392   5                      lptr = 0;
                                                 ; STATEMENT # 392
           1D65  210A2E          LXI     H,LPTR
           1D68  3600            MVI     M,0H
 393   5                      call echo('#');
                                                 ; STATEMENT # 393
           1D6A  0E23            MVI     C,23H
           1D6C  CDAC1E          CALL    ECHO
 394   5                      call echoCRLF;
                                                 ; STATEMENT # 394
PL/M-80 COMPILER                                                                                                PAGE  31


           1D6F  CDC61E          CALL    ECHOCRLF
 395   5                  end;
                                                 ; STATEMENT # 395
           1D72  C3031E          JMP     @49
 396   4                  do;         /* case 5 - CR */
                                                 ; STATEMENT # 396
                         @59:
 397   5                      bytes(lptr := lptr + 1) = LF;
                                                 ; STATEMENT # 397
           1D75  3A0A2E          LDA     LPTR
           1D78  3C              INR     A
           1D79  320A2E          STA     LPTR
           1D7C  4F              MOV     C,A
           1D7D  0600            MVI     B,0
           1D7F  2A062E          LHLD    LBUF
           1D82  09              DAD     B
           1D83  360A            MVI     M,0AH
 398   5                      call echo(LF);
                                                 ; STATEMENT # 398
           1D85  0E0A            MVI     C,0AH
           1D87  CDAC1E          CALL    ECHO
 399   5                      call lineReset;
                                                 ; STATEMENT # 399
           1D8A  CDD11E          CALL    LINERESET
 400   5                  end;
                                                 ; STATEMENT # 400
           1D8D  C3031E          JMP     @49
 401   4                  do;         /* case 6 - LF */
                                                 ; STATEMENT # 401
                         @60:
 402   5                      if lptr <> 0 then
                                                 ; STATEMENT # 402
           1D90  3A0A2E          LDA     LPTR
           1D93  FE00            CPI     0H
           1D95  CAAD1D          JZ      @61
 403   5                      do;
 404   6                          call echo(bytes(lptr) := char);
                                                 ; STATEMENT # 404
           1D98  2A0A2E          LHLD    LPTR
           1D9B  2600            MVI     H,0
           1D9D  EB              XCHG
           1D9E  2A062E          LHLD    LBUF
           1DA1  19              DAD     D
           1DA2  3A0B2E          LDA     CHAR
           1DA5  77              MOV     M,A
           1DA6  4F              MOV     C,A
           1DA7  CDAC1E          CALL    ECHO
 405   6                          call lineReset;
                                                 ; STATEMENT # 405
           1DAA  CDD11E          CALL    LINERESET
 406   6                      end;
                                                 ; STATEMENT # 406
                         @61:
 407   5                  end;
                                                 ; STATEMENT # 407
           1DAD  C3031E          JMP     @49
 408   4                  do;         /* case 7 -  ESC */
PL/M-80 COMPILER                                                                                                PAGE  32


                                                 ; STATEMENT # 408
                         @62:
 409   5                      call echo(0);
                                                 ; STATEMENT # 409
           1DB0  0E00            MVI     C,0H
           1DB2  CDAC1E          CALL    ECHO
 410   5                      call echo('$');
                                                 ; STATEMENT # 410
           1DB5  0E24            MVI     C,24H
           1DB7  CDAC1E          CALL    ECHO
 411   5                      call lineReset;
                                                 ; STATEMENT # 411
           1DBA  CDD11E          CALL    LINERESET
 412   5                  end;
                                                 ; STATEMENT # 412
           1DBD  C3031E          JMP     @49
 413   4                  do;         /* case 8 - Control-E */
                                                 ; STATEMENT # 413
                         @63:
 414   5                      if aftn = AFT$CONSOLE then
                                                 ; STATEMENT # 414
           1DC0  3AFF2D          LDA     AFTN
           1DC3  FE0B            CPI     0BH
           1DC5  C2E41D          JNZ     @64
 415   5                      do;
 416   6                          i = aft(AFT$CONSOLE).device;
                                                 ; STATEMENT # 416
           1DC8  3A252C          LDA     AFT+135H
           1DCB  320C2E          STA     I
 417   6                          aft(AFT$CONSOLE).device = alt$cidev;
                                                 ; STATEMENT # 417
           1DCE  3A1D2D          LDA     ALTCIDEV
           1DD1  32252C          STA     AFT+135H
 418   6                          alt$cidev = i;
                                                 ; STATEMENT # 418
           1DD4  3A0C2E          LDA     I
           1DD7  321D2D          STA     ALTCIDEV
 419   6                          call echo('^');
                                                 ; STATEMENT # 419
           1DDA  0E5E            MVI     C,5EH
           1DDC  CDAC1E          CALL    ECHO
 420   6                          call echo('E');
                                                 ; STATEMENT # 420
           1DDF  0E45            MVI     C,45H
           1DE1  CDAC1E          CALL    ECHO
 421   6                      end;
                                                 ; STATEMENT # 421
                         @64:
 422   5                  end;
                                                 ; STATEMENT # 422
           1DE4  C3031E          JMP     @49
 423   4                  lit$mode = TRUE;    /* case 8 - control-P */
                                                 ; STATEMENT # 423
                         @65:
           1DE7  21092E          LXI     H,LITMODE
           1DEA  36FF            MVI     M,0FFH
           1DEC  C3031E          JMP     @49
PL/M-80 COMPILER                                                                                                PAGE  33


 424   4              end; /* of case */
                                                 ; STATEMENT # 424
                         @87:
           1DEF  C41C            DW      @50
           1DF1  CB1C            DW      @51
           1DF3  281D            DW      @56
           1DF5  4C1D            DW      @57
           1DF7  651D            DW      @58
           1DF9  751D            DW      @59
           1DFB  901D            DW      @60
           1DFD  B01D            DW      @62
           1DFF  C01D            DW      @63
           1E01  E71D            DW      @65
                         @49:
 425   3              if lptr = 122 then
                                                 ; STATEMENT # 425
           1E03  3A0A2E          LDA     LPTR
           1E06  FE7A            CPI     7AH
           1E08  C20E1E          JNZ     @66
 426   3                  call lineReset;
                                                 ; STATEMENT # 426
           1E0B  CDD11E          CALL    LINERESET
                         @66:
 427   3          end;
                                                 ; STATEMENT # 427
           1E0E  C3211C          JMP     @82
                         @83:
        
 428   2          actual = 0;
                                                 ; STATEMENT # 428
           1E11  2A042E          LHLD    ACTUALP
           1E14  3E00            MVI     A,0H
           1E16  77              MOV     M,A
           1E17  23              INX     H
           1E18  3600            MVI     M,0
 429   2          do while actual < count and not in$mode;
                                                 ; STATEMENT # 429
                         @88:
           1E1A  2A042E          LHLD    ACTUALP
           1E1D  EB              XCHG
           1E1E  01022E          LXI     B,COUNT
           1E21  CD282A          CALL    @P0098 
           1E24  9F              SBB     A
           1E25  F5              PUSH    PSW     ; 1
           1E26  3A082E          LDA     INMODE
           1E29  2F              CMA
           1E2A  C1              POP     B       ; 1
           1E2B  48              MOV     C,B
           1E2C  A1              ANA     C
           1E2D  1F              RAR
           1E2E  D2971E          JNC     @89
 430   3              if lptr < MAXLL then    /* 122 */
                                                 ; STATEMENT # 430
           1E31  3A0A2E          LDA     LPTR
           1E34  FE7A            CPI     7AH
           1E36  D28A1E          JNC     @67
 431   3              do;
PL/M-80 COMPILER                                                                                                PAGE  34


 432   4                  if (obuf(actual) := bytes(lptr)) = LF OR bytes(lptr) = ESC then
                                                 ; STATEMENT # 432
           1E39  2A0A2E          LHLD    LPTR
           1E3C  2600            MVI     H,0
           1E3E  EB              XCHG
           1E3F  2A062E          LHLD    LBUF
           1E42  19              DAD     D
           1E43  E5              PUSH    H       ; 1
           1E44  2A042E          LHLD    ACTUALP
           1E47  4E              MOV     C,M
           1E48  23              INX     H
           1E49  46              MOV     B,M
           1E4A  2A002E          LHLD    BUFFER
           1E4D  09              DAD     B
           1E4E  C1              POP     B       ; 1
           1E4F  0A              LDAX    B
           1E50  77              MOV     M,A
           1E51  D60A            SUI     0AH
           1E53  D601            SUI     1
           1E55  9F              SBB     A
           1E56  2A0A2E          LHLD    LPTR
           1E59  2600            MVI     H,0
           1E5B  EB              XCHG
           1E5C  2A062E          LHLD    LBUF
           1E5F  19              DAD     D
           1E60  F5              PUSH    PSW     ; 1
           1E61  7E              MOV     A,M
           1E62  D61B            SUI     1BH
           1E64  D601            SUI     1
           1E66  9F              SBB     A
           1E67  C1              POP     B       ; 1
           1E68  48              MOV     C,B
           1E69  B1              ORA     C
           1E6A  1F              RAR
           1E6B  D2781E          JNC     @68
 433   4                  do;
 434   5                      in$mode = TRUE;
                                                 ; STATEMENT # 434
           1E6E  21082E          LXI     H,INMODE
           1E71  36FF            MVI     M,0FFH
 435   5                      lptr = -1;
                                                 ; STATEMENT # 435
           1E73  210A2E          LXI     H,LPTR
           1E76  36FF            MVI     M,0FFH
 436   5                  end;
                                                 ; STATEMENT # 436
                         @68:
        
 437   4                  actual = actual + 1;
                                                 ; STATEMENT # 437
           1E78  2A042E          LHLD    ACTUALP
           1E7B  4E              MOV     C,M
           1E7C  23              INX     H
           1E7D  46              MOV     B,M
           1E7E  03              INX     B
           1E7F  2B              DCX     H
           1E80  71              MOV     M,C
PL/M-80 COMPILER                                                                                                PAGE  35


           1E81  23              INX     H
           1E82  70              MOV     M,B
 438   4                  lptr = lptr + 1;
                                                 ; STATEMENT # 438
           1E83  210A2E          LXI     H,LPTR
           1E86  34              INR     M
 439   4              end;
                                                 ; STATEMENT # 439
           1E87  C3941E          JMP     @69
                         @67:
                      else
 440   3              do;
 441   4                  in$mode = TRUE;
                                                 ; STATEMENT # 441
           1E8A  21082E          LXI     H,INMODE
           1E8D  36FF            MVI     M,0FFH
 442   4                  lptr = 0;
                                                 ; STATEMENT # 442
           1E8F  210A2E          LXI     H,LPTR
           1E92  3600            MVI     M,0H
 443   4              end;
                                                 ; STATEMENT # 443
                         @69:
 444   3          end;
                                                 ; STATEMENT # 444
           1E94  C31A1E          JMP     @88
                         @89:
 445   2          bytes(126) = lptr;
                                                 ; STATEMENT # 445
           1E97  017E00          LXI     B,7EH
           1E9A  2A062E          LHLD    LBUF
           1E9D  09              DAD     B
           1E9E  3A0A2E          LDA     LPTR
           1EA1  77              MOV     M,A
 446   2          bytes(127) = in$mode;
                                                 ; STATEMENT # 446
           1EA2  2A062E          LHLD    LBUF
           1EA5  03              INX     B
           1EA6  09              DAD     B
           1EA7  3A082E          LDA     INMODE
           1EAA  77              MOV     M,A
 447   2      end;
                                                 ; STATEMENT # 447
           1EAB  C9              RET
        
        
        
 448   1      end;
              eof



MODULE INFORMATION:

     CODE AREA SIZE     = 08B3H   2227D
     VARIABLE AREA SIZE = 0036H     54D
     MAXIMUM STACK SIZE = 0010H     16D
PL/M-80 COMPILER                                                                                                PAGE  36


     501 LINES READ
     0 PROGRAM ERRORS

END OF PL/M-80 COMPILATION
