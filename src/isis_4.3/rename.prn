PL/M-80 COMPILER                                                                                                PAGE   1


ISIS-II PL/M-80 V4.0 COMPILATION OF MODULE RENAME
OBJECT MODULE PLACED IN RENAME.OBJ
COMPILER INVOKED BY:  :F1:plm80 rename.plm PRINT(RENAME.LST) OBJECT(RENAME.OBJ) DEBUG OPTIMIZE CODE



   1          rename:
              do;
              $include(rename.ipx)
   2   1  =   declare Chk$pn$disk$file literally 'ckpndf';
   3   1  =   declare Chk$Write$Protect literally 'CkWriP';
   4   1  =   declare Write$Dir$Entry literally 'WDirEn';
   5   1  =   declare BOOLEAN literally 'BYTE';
   6   1  =   declare DIFFERENT$DISK literally '10';
   7   1  =   declare MULTIDEFINED literally '11';
   8   1  =   declare NO$SUCH$FILE literally '13';
   9   1  =   declare pn(1) byte external;
  10   1  =   declare pn2(1) byte external;
  11   1  =   chk$pn$disk$file: procedure(filename) external; declare filename address; end;
  14   1  =   ChkWriteProtect: procedure external; end;
  16   1  =   dlook: procedure(fn) BOOLEAN external; declare fn address; end;
  19   1  =   warn: procedure(errcode) external; declare errcode byte; end;
  22   1  =   WriteDirEntry: procedure external; end;
  24   1  =   xpath: procedure(p1, p2) external; declare p1 address, p2 address; end;
        
  27   1      rename: PROCEDURE(old$file, new$file) PUBLIC;
                                                 ; STATEMENT # 27
                         ; PROC  RENAME
           158D  21D32D          LXI     H,NEWFILE+1H
           1590  72              MOV     M,D
           1591  2B              DCX     H
           1592  73              MOV     M,E
           1593  2B              DCX     H
           1594  70              MOV     M,B
           1595  2B              DCX     H
           1596  71              MOV     M,C
  28   2          DECLARE (old$file, new$file) ADDRESS;
  29   2          DECLARE i BYTE;         /* no longer used but needed to align with isis.bin */
  30   2          DECLARE already$exists BOOLEAN;
                  
        
  31   2          call xpath(old$file, .pn2);
                                                 ; STATEMENT # 31
           1597  2AD02D          LHLD    OLDFILE
           159A  44              MOV     B,H
           159B  4D              MOV     C,L
           159C  11AA2D          LXI     D,PN2
           159F  CD2214          CALL    XPATH
  32   2          call chk$pn$disk$file(new$file);
                                                 ; STATEMENT # 32
           15A2  2AD22D          LHLD    NEWFILE
           15A5  44              MOV     B,H
           15A6  4D              MOV     C,L
           15A7  CD6615          CALL    CKPNDF
  33   2          if pn(0) <> pn2(0) then
                                                 ; STATEMENT # 33
           15AA  21AA2D          LXI     H,PN2
PL/M-80 COMPILER                                                                                                PAGE   2


           15AD  3A9E2D          LDA     PN
           15B0  BE              CMP     M
           15B1  CAB915          JZ      @1
  34   2              call warn(DIFFERENT$DISK);
                                                 ; STATEMENT # 34
           15B4  0E0A            MVI     C,0AH
           15B6  CD510B          CALL    WARN
                         @1:
  35   2          already$exists = dlook(.pn);
                                                 ; STATEMENT # 35
           15B9  019E2D          LXI     B,PN
           15BC  CDDE26          CALL    DLOOK
           15BF  32D52D          STA     ALREADYEXISTS
  36   2          if NOT dlook(.pn2) then
                                                 ; STATEMENT # 36
           15C2  01AA2D          LXI     B,PN2
           15C5  CDDE26          CALL    DLOOK
           15C8  1F              RAR
           15C9  DAD115          JC      @2
  37   2              call warn(NO$SUCH$FILE);
                                                 ; STATEMENT # 37
           15CC  0E0D            MVI     C,0DH
           15CE  CD510B          CALL    WARN
                         @2:
  38   2          call chk$write$protect;
                                                 ; STATEMENT # 38
           15D1  CD1F15          CALL    CKWRIP
  39   2          if already$exists then
                                                 ; STATEMENT # 39
           15D4  3AD52D          LDA     ALREADYEXISTS
           15D7  1F              RAR
           15D8  D2E015          JNC     @3
  40   2              call warn(MULTIDEFINED);
                                                 ; STATEMENT # 40
           15DB  0E0B            MVI     C,0BH
           15DD  CD510B          CALL    WARN
                         @3:
  41   2          call write$dir$entry;
                                                 ; STATEMENT # 41
           15E0  CD2F15          CALL    WDIREN
  42   2      end;
                                                 ; STATEMENT # 42
           15E3  C9              RET
  43   1      end;
              eof



MODULE INFORMATION:

     CODE AREA SIZE     = 0057H     87D
     VARIABLE AREA SIZE = 0006H      6D
     MAXIMUM STACK SIZE = 0002H      2D
     39 LINES READ
     0 PROGRAM ERRORS

END OF PL/M-80 COMPILATION
