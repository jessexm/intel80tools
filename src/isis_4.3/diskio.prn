:F1:asm80 diskio.asm print(diskio.lst) object(diskio.obj) DEBUG



ISIS-II 8080/8085 MACRO ASSEMBLER, V4.1         DISKIO   PAGE    1


  LOC  OBJ         LINE        SOURCE STATEMENT

                      1 
                      2         name diskio
                      3         CSEG
                      4         extrn   @P0103  ; library routine
                      5 
                      6 
                      7 ; ****************** some notes about this code ********************
                      8 ; most of the function diskio seems to have been originally been in PLM based on
                      9 ; the code sequences generated. However two of the ADDRESS variables have been
                     10 ; initialised to 0 in the final isis.bin file which indicates that this they
                     11 ; have been set as dw 0, statements in assembler as neither the parameter iopb
                     12 ; nor the realTK variable could legally be initialisd in PLM
                     13 ; There also appear to be a few of minor hand crafted code changes
                     14 ; those to ignoring r$byte and r$type could have been overcome by defining
                     15 ; different name entry points in the disk2.asm code
                     16 ; others like noting that the do loop variable is in the hl register at both
                     17 ; the initialisation and the increment so doesnot need to be loaded for the
                     18 ; loop test are not detected in plm80 4.0
                     19 
                     20 ; In this file I have left in the PLM code and the assembly generated from it
                     21 ; the PLM code is commented out and the original code is left in upper case
                     22 ; code that has been optimised out or changed has been commented out with a
                     23 ; leading ;-, and replacement code has been entered in lower case
                     24 
                     25 ; Note the include statements and unrequired declarations have been deleted
                     26 ; to keep the file reasonably clean
                     27 
                     28 ; DECLARE DCB$T LITERALLY 'STRUCTURE (iocw BYTE, ioins BYTE, nsec BYTE, tadr BYTE, sadr BYTE, bu
                        f ADDRESS)',
                     29 ;         TRUE        LITERALLY   '0ffh',
                     30 ;         FALSE       LITERALLY   '0',
                     31 ;         DISK$IO$ERROR   LITERALLY   '24',   /* Disk error */       
                     32 ;         DRIVE$NOT$READY LITERALLY   '30',   /* Drive not ready. */
                     33 ;         c$dk$sat ADDRESS EXTERNAL,
                     34         extrn   cdksat
                     35 ;         errdrv BYTE EXTERNAL;
                     36         extrn   errdrv
                     37 
                     38 ; DECLARE vec$0E ADDRESS EXTERNAL
                     39         extrn   vec0E
                     40 ; abortx: PROCEDURE(errcode) EXTERNAL; DECLARE errcode BYTE; END;
                     41         extrn   abortx
                     42 ; trap0B: PROCEDURE EXTERNAL; END;
                     43         extrn   trap0B
                     44 
                     45 ; dk$stat: PROCEDURE BYTE EXTERNAL; END;
                     46         extrn   dkstat
                     47 ; r$type: PROCEDURE BYTE EXTERNAL; END;
                     48         extrn   rtype
                     49 ; r$byte: PROCEDURE BYTE EXTERNAL; END;
                     50         extrn   rbyte
                     51 ; strt$io: PROCEDURE(iopb) EXTERNAL; DECLARE iopb ADDRESS; END;
                     52         extrn   strtio
                     53 


ISIS-II 8080/8085 MACRO ASSEMBLER, V4.1         DISKIO   PAGE    2


  LOC  OBJ         LINE        SOURCE STATEMENT

                     54 ; DECLARE  a$dev$p ADDRESS EXTERNAL,
                     55         extrn   adevp
                     56 ;          a$device BASED a$dev$p BYTE;
                     57 
                     58 ; DECLARE CMD$RECAL   LITERALLY   '3';
                     59 ; DECLARE CMD$READ    LITERALLY   '4';
                     60 ; DECLARE CMD$WRITE   LITERALLY   '6';
                     61 ; DECLARE DD$TYPE     LITERALLY   '1',
                     62 ;         SD$TYPE     LITERALLY   '2',
                     63 ;         ISD$TYPE    LITERALLY   '3',
                     64 ;         HD$TYPE     LITERALLY   '4';
                     65 
                     66 
                     67 ; DECLARE rcal$pb STRUCTURE(iocw BYTE, ioins BYTE, nsec BYTE, tadr BYTE, sadr BYTE)
                     68 ;                           INITIAL(80h, CMD$RECAL, 1, 0, 0);
  0794 80            69 rcalpb: db      80h, 3, 1, 0, 0
  0795 03              
  0796 01              
  0797 00              
  0798 00              
                     70 
                     71 ; DECLARE absdcb DCB$T INITIAL(80h, 0, 1, 0, 0, 0);
  0799 80            72 absdcb: db      80h, 0, 1, 0, 0
  079A 00              
  079B 01              
  079C 00              
  079D 00              
  079E 0000          73         dw      0
                     74 ; DECLARE dk$cf$tb(10) BYTE PUBLIC,
                     75         public  dkcftb
  000C               76 dkcftb: ds      10
                     77 ;         rdy$msk(10) BYTE PUBLIC,
                     78         public rdymsk
  0016               79 rdymsk: ds      10
                     80 ;         unit$mp(10) BYTE PUBLIC,
                     81         public unitmp
  0020               82 unitmp: ds      10
                     83 ;         dk$ct$tb(10) BYTE PUBLIC,  /* disk controller table */
                     84         public dkcttb
  002A               85 dkcttb: ds      10
                     86 ;         dkcont BYTE PUBLIC,
                     87         public  dkcont
  0034               88 dkcont: ds      1
                     89 ;         track BYTE PUBLIC,
                     90         public  track
  0035               91 track:  ds      1
                     92 ;         sector BYTE PUBLIC,
                     93         public  sector
  0036               94 sector: ds      1
                     95 ;         temp ADDRESS,
                     96 ;         (temp2, temp1) BYTE;
                     97 temp:
  0037               98 temp2:  ds      1
  0038               99 temp1:  ds      1
                    100 


ISIS-II 8080/8085 MACRO ASSEMBLER, V4.1         DISKIO   PAGE    3


  LOC  OBJ         LINE        SOURCE STATEMENT

                    101 ; DECLARE MAX$RETRIES LITERALLY   '10';
  0039              102 drive:  ds      1
  07CE 0000         103 iopb:   dw      0
  003C              104 i:      ds      1
  003D              105 diskHW: ds      1
  07D2 0000         106 realTk: dw      0       ; tell tail sign of assembly code
  0040              107 ival:   ds      1
  0041              108 sddrv:  ds      1
  0042              109 cmd:    ds      1
  0043              110 disk:   ds      1
  07D8 0000         111 block:  dw      0
  07DA 0000         112 buffer: dw      0
                    113 
                    114 ; diskio: PROCEDURE(drive, iopb) PUBLIC;
                    115         public  diskio
                    116 DISKIO:
  07DC 21CF07   C   117          LXI     H,IOPB+1H
  07DF 72           118          MOV     M,D
  07E0 2B           119          DCX     H
  07E1 73           120          MOV     M,E
  07E2 2B           121          DCX     H
  07E3 71           122          MOV     M,C
                    123 ;     DECLARE drive BYTE, iopb ADDRESS;
                    124 ;     DECLARE dcb BASED iopb DCB$T;
                    125 ;     DECLARE i BYTE,
                    126 ;             diskHW BYTE,
                    127 ;             realTk ADDRESS,
                    128 ;             ival BYTE,
                    129 ;             sd$drv BYTE;
                    130 ;
                    131 ;     track = dcb.tadr;
  07E4 010300       132          LXI     B,3H
  07E7 2ACE07   C   133          LHLD    IOPB
  07EA 09           134          DAD     B
  07EB 7E           135          MOV     A,M
  07EC 32C907   C   136          STA     TRACK
                    137 ;     sector = dcb.sadr;
                    138 ;-         LHLD    IOPB         ; hand optimisation
                    139 ;-         INX     B
                    140 ;-         DAD     B
  07EF 23           141         inx     h
  07F0 7E           142          MOV     A,M
  07F1 32CA07   C   143          STA     SECTOR
                    144 ;     ival = input(0fch);
  07F4 DBFC         145          IN      0FCH
  07F6 32D407   C   146          STA     IVAL
                    147 ;     output(0fch) = ival or 2;
  07F9 F602         148          ORI     2H
  07FB D3FC         149          OUT     0FCH
                    150 ;     dkcont = dk$ct$tb(drive);
  07FD 2ACD07   C   151          LHLD    DRIVE
  0800 2600         152          MVI     H,0
  0802 01BE07   C   153          LXI     B,DKCTTB
  0805 09           154          DAD     B
  0806 7E           155          MOV     A,M


ISIS-II 8080/8085 MACRO ASSEMBLER, V4.1         DISKIO   PAGE    4


  LOC  OBJ         LINE        SOURCE STATEMENT

  0807 32C807   C   156          STA     DKCONT
                    157 ;     sd$drv = FALSE;
  080A 21D507   C   158          LXI     H,SDDRV
  080D 3600         159          MVI     M,0H
                    160 ;     diskHW = dk$cf$tb(drive);
  080F 2ACD07   C   161          LHLD    DRIVE
  0812 2600         162          MVI     H,0
  0814 01A007   C   163          LXI     B,DKCFTB
  0817 09           164          DAD     B
  0818 7E           165          MOV     A,M
  0819 32D107   C   166          STA     DISKHW
                    167 ;     if diskHW = SD$TYPE AND (1 = 1 AND drive) then    /* SD disk (Not ISD) & odd numbered driv
                        e */
  081C D602         168          SUI     2H
  081E D601         169          SUI     1
  0820 9F           170          SBB     A
  0821 F5           171          PUSH    PSW 
  0822 3E01         172          MVI     A,1H   ; this code seems odd and presumably
  0824 D601         173          SUI     1H     ; was masked by LITERALLY defined names
  0826 D601         174          SUI     1
  0828 9F           175          SBB     A
  0829 21CD07   C   176          LXI     H,DRIVE
  082C A6           177          ANA     M
  082D C1           178          POP     B
  082E 48           179          MOV     C,B
  082F A1           180          ANA     C
  0830 1F           181          RAR
  0831 D24408   C   182          JNC     @1
                    183 ;     do;
                    184 ;         sd$drv = TRUE;
  0834 21D507   C   185          LXI     H,SDDRV
  0837 36FF         186          MVI     M,0FFH
                    187 ;         dcb.sadr = dcb.sadr OR 20h;     /* set selector flag */
  0839 010400       188          LXI     B,4H
  083C 2ACE07   C   189          LHLD    IOPB
  083F 09           190          DAD     B
  0840 3E20         191          MVI     A,20H
  0842 B6           192          ORA     M
  0843 77           193          MOV     M,A
                    194 ;     end;
                    195 @1:
                    196 ;     if diskHW = 4 then  /* hard disk */
  0844 3AD107   C   197          LDA     DISKHW
  0847 FE04         198          CPI     4H
  0849 C2BB08   C   199          JNZ     @2
                    200 ;     do;
                    201 ;         realTk = DOUBLE(dcb.tadr) * 2;
  084C 010300       202          LXI     B,3H
  084F 2ACE07   C   203          LHLD    IOPB
  0852 09           204          DAD     B
  0853 4E           205          MOV     C,M
  0854 0600         206          MVI     B,0
  0856 60           207          MOV     H,B
  0857 69           208          MOV     L,C
  0858 29           209          DAD     H


ISIS-II 8080/8085 MACRO ASSEMBLER, V4.1         DISKIO   PAGE    5


  LOC  OBJ         LINE        SOURCE STATEMENT

  0859 22D207   C   210          SHLD    REALTK
                    211 ;         if dcb.sadr > 72 then   /* then map to odd track number */
  085C 010400       212         lxi     b,4     ; PLM v4.0 optimised to an increment of BC
  085F 2ACE07   C   213          LHLD    IOPB
                    214 ;-         INX     B
  0862 09           215          DAD     B
  0863 3E48         216          MVI     A,48H
  0865 BE           217          CMP     M
  0866 D27B08   C   218          JNC     @3
                    219 ;         do;
                    220 ;             realTk = realTk + 1;
  0869 2AD207   C   221          LHLD    REALTK
  086C 23           222          INX     H
  086D 22D207   C   223          SHLD    REALTK
                    224 ;             dcb.sadr = dcb.sadr - 72;
  0870 010400       225          LXI     B,4H
  0873 2ACE07   C   226          LHLD    IOPB
  0876 09           227          DAD     B
  0877 7E           228          MOV     A,M
  0878 D648         229          SUI     48H
  087A 77           230          MOV     M,A
                    231 ;         end;
                    232 @3:
                    233 ;         if dcb.sadr < 37 then
                    234 ;-         LXI     B,4H         ; hand optimised as hl points to dcb.sadr on all paths
                    235 ;-         LHLD    IOPB
                    236 ;=         DAD     B
  087B 7E           237          MOV     A,M
  087C FE25         238          CPI     25H
  087E D28C08   C   239          JNC      @4
                    240 ;             dcb.ioins = dcb.ioins OR 8; /* select head */
  0881 2ACE07   C   241          LHLD    IOPB
  0884 23           242          INX     H
  0885 3E08         243          MVI     A,8H
  0887 B6           244          ORA     M
  0888 77           245          MOV     M,A
  0889 C39708   C   246          JMP     @5
                    247 @4:
                    248 ;         else
                    249 ;             dcb.sadr = dcb.sadr - 36;
  088C 010400       250          LXI     B,4H
  088F 2ACE07   C   251          LHLD    IOPB
  0892 09           252          DAD     B
  0893 7E           253          MOV     A,M
  0894 D624         254          SUI     24H
  0896 77           255          MOV     M,A
                    256 @5:
                    257 ;         if realTk > 255 then
  0897 3EFF         258          MVI     A,0FFH
  0899 21D207   C   259          LXI     H,REALTK
  089C CD402A   E   260          CALL    @P0103 
  089F D2AD08   C   261          JNC     @6
                    262 ;             dcb.sadr = dcb.sadr + 80h;  /* track extension bit */
  08A2 010400       263          LXI     B,4H
  08A5 2ACE07   C   264          LHLD    IOPB


ISIS-II 8080/8085 MACRO ASSEMBLER, V4.1         DISKIO   PAGE    6


  LOC  OBJ         LINE        SOURCE STATEMENT

  08A8 09           265          DAD     B
  08A9 3E80         266          MVI     A,80H
  08AB 86           267          ADD     M
  08AC 77           268          MOV     M,A
                    269 @6:
                    270 ;         dcb.tadr = realTk;  
  08AD 010300       271          LXI     B,3H
  08B0 2ACE07   C   272          LHLD    IOPB
  08B3 09           273          DAD     B
  08B4 E5           274          PUSH    H
  08B5 2AD207   C   275          LHLD    REALTK
  08B8 EB           276          XCHG
  08B9 E1           277          POP     H
  08BA 73           278          MOV     M,E
                    279 ;     end;
                    280 @2:
                    281 ;     dcb.ioins = dcb.ioins OR unit$mp(drive);
  08BB 2ACE07   C   282          LHLD    IOPB
  08BE 23           283          INX     H
  08BF E5           284          PUSH    H
  08C0 2ACD07   C   285          LHLD    DRIVE
  08C3 2600         286          MVI     H,0
  08C5 01B407   C   287          LXI     B,UNITMP
  08C8 09           288          DAD     B
  08C9 7E           289          MOV     A,M
  08CA E1           290          POP     H
  08CB B6           291          ORA     M
  08CC 77           292          MOV     M,A
                    293 ;     do i = 0 to MAX$RETRIES;    /* 0-10 */
  08CD 21D007   C   294          LXI     H,I
  08D0 3600         295          MVI     M,0H
                    296 @10:
  08D2 3E0A         297          MVI     A,0AH
                    298 ;-         LXI     H,I  ; hand optimised
  08D4 BE           299          CMP     M
  08D5 DA4D09   C   300          JC      @11
                    301 ;         do while (dk$stat AND 4) <> 0;
                    302 @12:
  08D8 CDBB27   E   303          CALL    DKSTAT
  08DB E604         304          ANI     4H
  08DD FE00         305          CPI     0H
  08DF CAEB08   C   306          JZ      @13
                    307 ;             temp1 = r$type; /* assignments removed in asm */
  08E2 CDDE27   E   308          CALL    RTYPE
                    309 ;-         STA     TEMP1        ; optimised (but non return version possible)
                    310 ;             temp1 = r$byte;
  08E5 CDFB27   E   311          CALL    RBYTE
                    312 ;-         STA     TEMP1        ; optimised (but non return version possible)
                    313 ;         end;
  08E8 C3D808   C   314          JMP     @12
                    315 @13:
                    316 ;         if (dk$stat AND rdy$msk(drive)) = 0 then
  08EB CDBB27   E   317          CALL    DKSTAT
  08EE 2ACD07   C   318          LHLD    DRIVE
  08F1 2600         319          MVI     H,0


ISIS-II 8080/8085 MACRO ASSEMBLER, V4.1         DISKIO   PAGE    7


  LOC  OBJ         LINE        SOURCE STATEMENT

  08F3 01AA07   C   320          LXI     B,RDYMSK
  08F6 09           321          DAD     B
  08F7 A6           322          ANA     M
  08F8 FE00         323          CPI     0H
  08FA C20209   C   324          JNZ     @7
                    325 ;             call abortx(DRIVE$NOT$READY);
  08FD 0E1E         326          MVI     C,1EH
  08FF CD4B0B   E   327          CALL    ABORTX
                    328 @7:
                    329 ;         call strt$io(iopb);
  0902 2ACE07   C   330          LHLD    IOPB
  0905 44           331          MOV     B,H
  0906 4D           332          MOV     C,L
  0907 CD1C28   E   333          CALL    STRTIO
                    334 ;         temp1 = r$type;
  090A CDDE27   E   335          CALL    RTYPE
  090D 32CC07   C   336          STA     TEMP1
                    337 ;         if (temp2 := r$byte) = 0 then
  0910 CDFB27   E   338          CALL    RBYTE
  0913 32CB07   C   339          STA     TEMP2
  0916 FE00         340          CPI     0H
  0918 C22109   C   341          JNZ     @8
                    342 ;         do;
                    343 ;             output(0fch) = ival;
  091B 3AD407   C   344          LDA     IVAL
  091E D3FC         345          OUT     0FCH
                    346 ;             return;
  0920 C9           347          RET
                    348 ;         end;
                    349 @8:
                    350 ;         if sd$drv then
  0921 3AD507   C   351          LDA     SDDRV
  0924 1F           352          RAR
  0925 D23009   C   353          JNC     @9
                    354 ;             rcal$pb.sadr = rcal$pb.sadr OR 20h;
  0928 3A9807   C   355          LDA     RCALPB+4H
  092B F620         356          ORI     20H
  092D 329807   C   357          STA     RCALPB+4H
                    358 @9:
                    359 ;         rcal$pb.ioins = rcal$pb.ioins OR unit$mp(drive);
  0930 2ACD07   C   360          LHLD    DRIVE
  0933 2600         361          MVI     H,0
  0935 01B407   C   362          LXI     B,UNITMP
  0938 09           363          DAD     B
  0939 3A9507   C   364          LDA     RCALPB+1H
  093C B6           365          ORA     M
  093D 329507   C   366          STA     RCALPB+1H
                    367 ;         call strt$io(.rcal$pb);
  0940 019407   C   368          LXI     B,RCALPB
  0943 CD1C28   E   369          CALL    STRTIO
                    370 ;     end;
                    371 @14:
  0946 21D007   C   372          LXI     H,I
  0949 34           373          INR     M
  094A C2D208   C   374          JNZ     @10


ISIS-II 8080/8085 MACRO ASSEMBLER, V4.1         DISKIO   PAGE    8


  LOC  OBJ         LINE        SOURCE STATEMENT

                    375 @11:
                    376 ;     errDrv = drive;
  094D 3ACD07   C   377          LDA     DRIVE
  0950 325E2D   E   378          STA     ERRDRV
                    379 ;     vec$0E, c$dk$sat, vec$0E = temp2;
  0953 2ACB07   C   380          LHLD    TEMP
  0956 220E00   E   381          SHLD    VEC0E
  0959 22322D   E   382          SHLD    CDKSAT
                    383 ;     output(0fch) = ival;
  095C 3AD407   C   384          LDA     IVAL
  095F D3FC         385          OUT     0FCH
                    386 ;     call trap0B;
  0961 CD0B00   E   387          CALL    TRAP0B
                    388 ;     output(0fch) = ival OR 2;
  0964 3AD407   C   389          LDA     IVAL
  0967 F602         390          ORI     2H
  0969 D3FC         391          OUT     0FCH
                    392 ;     call abortx(DISK$IO$ERROR);
  096B 0E18         393          MVI     C,18H
  096D CD4B0B   E   394          CALL    ABORTX
                    395 ; end;
  0970 C9           396          RET
                    397 
                    398 ; absio: PROCEDURE(cmd, disk, block$p, buffer)  PUBLIC;
                    399         public  absio
                    400 ABSIO:
  0971 21DB07   C   401          LXI     H,BUFFER+1H
  0974 72           402          MOV     M,D
  0975 2B           403          DCX     H
  0976 73           404          MOV     M,E
  0977 2B           405          DCX     H
  0978 70           406          MOV     M,B
  0979 2B           407          DCX     H
  097A 71           408          MOV     M,C
  097B 2B           409          DCX     H
  097C D1           410          POP     D       
  097D C1           411          POP     B       
  097E 71           412          MOV     M,C
  097F 2B           413          DCX     H
  0980 C1           414          POP     B       
  0981 71           415          MOV     M,C
  0982 D5           416          PUSH    D       
                    417 ;     DECLARE (cmd, disk) BYTE, (block$p, buffer) ADDRESS;
                    418 ;     DECLARE tsadr ADDRESS AT (.absdcb.tadr); /* to allow tadr & sadr write together */
  0008          C   419 tsadr   equ     absdcb+3
                    420 ;     DECLARE block BASED block$p;
                    421 ;     absdcb.ioins = cmd;
                    422 abscom:                         ; major optimisation to share code
  0983 3AD607   C   423          LDA     CMD
  0986 329A07   C   424          STA     ABSDCB+1H
                    425 ;     tsadr = block;
  0989 2AD807   C   426          LHLD    BLOCK
                    427 ;         SHLD    TSADR
  098C EB           428         xchg
  098D 219C07   C   429         lxi     h,tsadr


ISIS-II 8080/8085 MACRO ASSEMBLER, V4.1         DISKIO   PAGE    9


  LOC  OBJ         LINE        SOURCE STATEMENT

  0990 72           430         mov     m,d
  0991 23           431         inx     h
  0992 73           432         mov     m,e
                    433 ;     absdcb.buf = buffer;
  0993 2ADA07   C   434          LHLD    BUFFER
  0996 229E07   C   435          SHLD    ABSDCB+5H
                    436 ;     call diskio(disk, .absdcb);
  0999 2AD707   C   437          LHLD    DISK
  099C 4D           438          MOV     C,L
  099D 119907   C   439          LXI     D,ABSDCB
  09A0 CDDC07   C   440          CALL    DISKIO
                    441 ; end;
  09A3 C9           442          RET
                    443 ; abs$rd: PROCEDURE(block, buffer) PUBLIC;
                    444         public  absrd
                    445 ABSRD:
  09A4 3E04         446         mvi     a,4     ; CMD$READ
                    447 absrw:
  09A6 32D607   C   448         sta     cmd     ; store in cmd location for absio
  09A9 21DB07   C   449          LXI     H,BUFFER+1H    ; stores in parameters for absio
  09AC 72           450          MOV     M,D
  09AD 2B           451          DCX     H
  09AE 73           452          MOV     M,E
  09AF 2B           453          DCX     H
  09B0 70           454          MOV     M,B
  09B1 2B           455          DCX     H
  09B2 71           456          MOV     M,C
                    457 ;     DECLARE (block, buffer) ADDRESS;
                    458 ;     call absio(CMD$READ, a$device, block, buffer);
                    459 ;-         MVI     C,4H ; put in A reg as part of hand optimisation
                    460 ;-         PUSH    B    ; see ABSRD, ABDWR and storing at absrw
  09B3 2ACC2A   E   461          LHLD    ADEVP
  09B6 7E           462         mov     a,m     ; a$device
  09B7 32D707   C   463         sta     disk    ; store in the disk parameter for absio
  09BA C38309   C   464         jmp     abscom  ; jump to shared code
                    465 ;-         MOV     C,M
                    466 ;-         PUSH    B       ; 2
                    467 ;-         LHLD    BLOCK
                    468 ;-         MOV     B,H
                    469 ;-         MOV     C,L
                    470 ;-         LHLD    BUFFER
                    471 ;-         XCHG
                    472 ;-         CALL    ABSIO
                    473 ; end;
                    474 ;-         RET
                    475 ; abs$wr: PROCEDURE(block, buffer) PUBLIC;
                    476         public  abswr
                    477 ABSWR:
  09BD 3E06         478         mvi     a,6     ; CMD$WRITE
  09BF C3A609   C   479         jmp     absrw   ; share code with absrd
                    480 ;-         LXI     H,BUFFER+1H
                    481 ;-         MOV     M,D
                    482 ;-         DCX     H
                    483 ;-         MOV     M,E
                    484 ;-         DCX     H


ISIS-II 8080/8085 MACRO ASSEMBLER, V4.1         DISKIO   PAGE   10


  LOC  OBJ         LINE        SOURCE STATEMENT

                    485 ;-         MOV     M,B
                    486 ;-         DCX     H
                    487 ;-         MOV     M,C
                    488 ;     DECLARE (block, buffer) ADDRESS;
                    489 ;     call absio(CMD$WRITE, a$device, block, buffer);
                    490 ;-         MVI     C,6H
                    491 ;-         PUSH    B
                    492 ;-         LHLD    ADEVP
                    493 ;-         MOV     C,M
                    494 ;-         PUSH    B       ; 2
                    495 ;-         LHLD    BLOCK
                    496 ;-         MOV     B,H
                    497 ;-         MOV     C,L
                    498 ;-         LHLD    BUFFER
                    499 ;-         XCHG
                    500 ;-         CALL    ABSIO
                    501 ; end;
                    502 ;-         RET
                    503 ; end;
                    504 ; eof
                    505         end


PUBLIC SYMBOLS
ABSIO  C 01DD    ABSRD  C 0210    ABSWR  C 0229    DISKIO C 0048    DKCFTB C 000C    DKCONT C 0034    DKCTTB C 002A    
RDYMSK C 0016    SECTOR C 0036    TRACK  C 0035    UNITMP C 0020    

EXTERNAL SYMBOLS
@P0103 E 0000    ABORTX E 0000    ADEVP  E 0000    CDKSAT E 0000    DKSTAT E 0000    ERRDRV E 0000    RBYTE  E 0000    
RTYPE  E 0000    STRTIO E 0000    TRAP0B E 0000    VEC0E  E 0000    

USER SYMBOLS
@1     C 00B0    @10    C 013E    @11    C 01B9    @12    C 0144    @13    C 0157    @14    C 01B2    @2     C 0127    
@3     C 00E7    @4     C 00F8    @5     C 0103    @6     C 0119    @7     C 016E    @8     C 018D    @9     C 019C    
@P0103 E 0000    ABORTX E 0000    ABSCOM C 01EF    ABSDCB C 0005    ABSIO  C 01DD    ABSRD  C 0210    ABSRW  C 0212    
ABSWR  C 0229    ADEVP  E 0000    BLOCK  C 0044    BUFFER C 0046    CDKSAT E 0000    CMD    C 0042    DISK   C 0043    
DISKHW C 003D    DISKIO C 0048    DKCFTB C 000C    DKCONT C 0034    DKCTTB C 002A    DKSTAT E 0000    DRIVE  C 0039    
ERRDRV E 0000    I      C 003C    IOPB   C 003A    IVAL   C 0040    RBYTE  E 0000    RCALPB C 0000    RDYMSK C 0016    
REALTK C 003E    RTYPE  E 0000    SDDRV  C 0041    SECTOR C 0036    STRTIO E 0000    TEMP   C 0037    TEMP1  C 0038    
TEMP2  C 0037    TRACK  C 0035    TRAP0B E 0000    TSADR  C 0008    UNITMP C 0020    VEC0E  E 0000    

ASSEMBLY COMPLETE,   NO ERRORS
