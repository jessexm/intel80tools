seek:
do;
$include(seek.ipx)

save$data$blk: PROCEDURE PUBLIC;
	if a$data$change then
	do;
		call abswrite(a$data$blk, a$dbuf);
		a$data$change = FALSE;
	end;
end;

save$pointer$block: PROCEDURE PUBLIC;
	if a$ptr$change then
	do;
		call map$write(a$device);
		call abswrite(a$ptr$blk, a$pbuf);
		a$ptr$change = FALSE;
	end;
end;

rewind:	PROCEDURE PUBLIC;
	a$data$ptr = 128;
	a$ptr$ptr = 1;
	a$data$change = FALSE;
	a$dbuf$read = FALSE;
	a$ptr$change = FALSE;
	a$blk$seqno, a$data$blk = 0;
	call absread(a$ptr$blk := a$hdr$blk, a$pbuf);
end;

seek: PROCEDURE(aftn, mode, blockptr, byteptr) PUBLIC;
	DECLARE aftn BYTE, (mode, blockptr, byteptr) ADDRESS;
	DECLARE lowMode BYTE AT (.mode);
	DECLARE blk BASED blockptr ADDRESS, byt BASED byteptr ADDRESS;
	DECLARE plusMinus ADDRESS,
		orig$byte ADDRESS, lo$byte BYTE AT (.orig$byte),
		blockno ADDRESS, temp ADDRESS, forward BYTE;

	if mode > SEEK$EOF then
		call warn(BAD$SEEK$ARG);
	call aft$window(aftn);
	if a$device = BBDEV then
		return;

	if a$device > F9DEV then
		call warn(NON$DISK$SEEK);

	if a$access = WRITE$MODE then	/* 2 */
		call warn(SEEK$ON$WRITE);
	if lowMode = SEEK$RETURN then	/* 0 - SEEK$RETURN */
	do;
		byt = a$data$ptr;	
		if (blk := a$blk$seqno - 1) = 0FFFFh then
		do;
			blk, byt = 0;
		end;
		return;
	end;
	
	blockno = (blk AND 07fffh) + shr((orig$byte := byt), 7);
	lo$byte = lo$byte and 7fh;
	if lowMode = SEEK$EOF then
	do;
		lowMode = SEEK$ABS;
		lo$byte = a$eof$data$ptr;
		if (blockno := a$blk$count - 1) = 0FFFFh then
		do;
			blockno, lo$byte = 0;
		end;
	end;
	if lowMode = SEEK$ABS then
	do;
		if (blockno OR a$blk$seqno OR lo$byte) <> 0 then
		do;
			blockno = blockno + 1;
		end;
		else
			lo$byte = 128;
		lowMode = SEEK$BACKWARD;
		if blockno > a$blk$seqno then
		do;
			lowMode = SEEK$FORWARD;
			blockno = blockno - a$blk$seqno;
		end;
		else if blockno < a$blk$seqno then
			blockno = a$blk$seqno - blockno;
		else
		do;
			blockno = 0;
			if lo$byte > a$data$ptr then
				lowMode = SEEK$FORWARD;	/* seek within block */
		end;
	end;
	else
	do;
		if lowMode = SEEK$BACKWARD then
			lo$byte = -lo$byte;
		
		lo$byte = a$data$ptr + lo$byte;
		if lo$byte > 128 then
		do;
			blockno = blockno + 1;
			lo$byte = lo$byte - 128;
		end;
	end;
	a$data$ptr = lo$byte;
	if (forward := lowMode = SEEK$FORWARD) then
		call adjust$eof;

	do while blockno > 0;
		call save$data$blk;
		a$dbuf$read = FALSE;
		blockno = blockno - 1;
		if forward then
		do;
			plusMinus = 1;
			if a$ptr$ptr = 63 then
			do;
				if (temp := links(FLINK)) = 0 then
				do;
					call chk$eof;
					links(FLINK), temp = get$block(a$device);
					a$ptr$change = TRUE;
					call save$pointer$block;
					call clear$buf(a$pbuf);
					links(BLINK) = a$ptr$blk;
					call abswrite(temp, a$pbuf);
				end;
				else
				do;
					call save$pointer$block;
					call absread(temp, a$pbuf);
				end;
				a$ptr$ptr = 1;
				a$ptr$blk = temp;
			end;
		end;
		else if a$data$ptr = 128 then
		do;
			plusMinus = 0;
			a$data$ptr = 0;
		end;
		else
		do;
			plusMinus = 0FFFFH;	/* -1 */
			if a$ptr$ptr - 1 < 2 then 
				if links(BLINK) <> 0 then
				do;
					call save$pointer$block;
					a$ptr$ptr = 64;
					call absread((a$ptr$blk := links(BLINK)), a$pbuf);
				end;
				else
				do;
					a$ptr$ptr = 1;
					a$blk$seqno = 0;
					goto error;
			
				end;
		end;
		a$blk$seqno = a$blk$seqno + plusMinus;
		a$ptr$ptr = a$ptr$ptr + low(plusMinus);
		call adjust$eof;
	end;

error:
	if a$blk$seqno = 0 AND a$data$ptr <> 128 then
	do;
		a$data$ptr = 128;
		call warn(LONG$BACK$SEEK);
	end;
end;
end;
eof
