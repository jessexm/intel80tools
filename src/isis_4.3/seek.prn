PL/M-80 COMPILER                                                                                                PAGE   1


ISIS-II PL/M-80 V4.0 COMPILATION OF MODULE SEEK
OBJECT MODULE PLACED IN SEEK.OBJ
COMPILER INVOKED BY:  :F1:plm80 seek.plm PRINT(SEEK.LST) OBJECT(SEEK.OBJ) DEBUG OPTIMIZE CODE



   1          seek:
              do;
              $include(seek.ipx)
   2   1  =   declare a$access$p literally 'aAcesP';
   3   1  =   declare a$blk$count$p literally 'aBCntP';
   4   1  =   declare a$eof$data$ptr$p literally 'aEoPP';
   5   1  =   declare Aft$Window literally 'AWindo';
   6   1  =   declare a$hdr$blk$p literally 'aHBlkP';
   7   1  =   declare Clear$Buf literally 'ClrBuf';
   8   1  =   declare Get$Block literally 'GetBlk';
   9   1  =   declare Map$Write literally 'MapWri';
  10   1  =   declare absread literally 'abs$rd';
  11   1  =   declare abswrite literally 'abs$wr';
  12   1  =   declare BAD$SEEK$ARG literally '27';
  13   1  =   declare BBDEV literally '26';
  14   1  =   declare BLINK literally '0';
  15   1  =   declare F9DEV literally '9';
  16   1  =   declare FALSE literally '0';
  17   1  =   declare FLINK literally '1';
  18   1  =   declare LONG$BACK$SEEK literally '20';
  19   1  =   declare NON$DISK$SEEK literally '19';
  20   1  =   declare SEEK$ABS literally '2';
  21   1  =   declare SEEK$BACKWARD literally '1';
  22   1  =   declare SEEK$EOF literally '4';
  23   1  =   declare SEEK$FORWARD literally '3';
  24   1  =   declare SEEK$ON$WRITE literally '31';
  25   1  =   declare SEEK$RETURN literally '0';
  26   1  =   declare TRUE literally '0ffh';
  27   1  =   declare WRITE$MODE literally '2';
  28   1  =   declare a$access$p address external;
  29   1  =   declare a$blk$count$p address external;
  30   1  =   declare a$blk$seqno$p address external;
  31   1  =   declare a$data$blk$p address external;
  32   1  =   declare a$data$change$p address external;
  33   1  =   declare a$data$ptr$p address external;
  34   1  =   declare a$dbuf$p address external;
  35   1  =   declare a$dbuf$read$p address external;
  36   1  =   declare a$dev$p address external;
  37   1  =   declare a$eof$data$ptr$p address external;
  38   1  =   declare a$hdr$blk$p address external;
  39   1  =   declare a$pbuf$p address external;
  40   1  =   declare a$ptr$blk$p address external;
  41   1  =   declare a$ptr$change$p address external;
  42   1  =   declare a$ptr$ptr$p address external;
  43   1  =   declare pointer$base address external;
  44   1  =   abs$rd: procedure(block, buffer$ptr) external; declare block address, buffer$ptr address; end;
  47   1  =   abs$wr: procedure(block, buffer$ptr) external; declare block address, buffer$ptr address; end;
  50   1  =   adjust$eof: procedure external; end;
  52   1  =   Aft$Window: procedure(slot$number) external; declare slot$number byte; end;
  55   1  =   chk$eof: procedure external; end;
  57   1  =   ClearBuf: procedure(buf$address) external; declare buf$address address; end;
PL/M-80 COMPILER                                                                                                PAGE   2


  60   1  =   get$block: procedure(diskNum) address external; declare diskNum byte; end;
  63   1  =   MapWrite: procedure(diskNum) external; declare diskNum byte; end;
  66   1  =   warn: procedure(errcode) external; declare errcode byte; end;
  69   1  =   declare a$access based a$access$p  byte;
  70   1  =   declare a$blk$count based a$blk$count$p  address;
  71   1  =   declare a$blk$seqno based a$blk$seqno$p  address;
  72   1  =   declare a$data$blk based a$data$blk$p  address;
  73   1  =   declare a$data$change based a$data$change$p  byte;
  74   1  =   declare a$data$ptr based a$data$ptr$p  byte;
  75   1  =   declare a$dbuf based a$dbuf$p  address;
  76   1  =   declare a$dbuf$read based a$dbuf$read$p  byte;
  77   1  =   declare a$device based a$dev$p  byte;
  78   1  =   declare a$eof$data$ptr based a$eof$data$ptr$p  byte;
  79   1  =   declare a$hdr$blk based a$hdr$blk$p  address;
  80   1  =   declare a$pbuf based a$pbuf$p  address;
  81   1  =   declare a$ptr$blk based a$ptr$blk$p  address;
  82   1  =   declare a$ptr$change based a$ptr$change$p  byte;
  83   1  =   declare a$ptr$ptr based a$ptr$ptr$p  byte;
  84   1  =   declare links based pointer$base (64) address;
        
  85   1      save$data$blk: PROCEDURE PUBLIC;
                                                 ; STATEMENT # 85
                         ; PROC  SAVEDATABLK
  86   2          if a$data$change then
                                                 ; STATEMENT # 86
           1EDC  2AE22A          LHLD    ADATACHANGEP
           1EDF  7E              MOV     A,M
           1EE0  1F              RAR
           1EE1  D2FA1E          JNC     @1
  87   2          do;
  88   3              call abswrite(a$data$blk, a$dbuf);
                                                 ; STATEMENT # 88
           1EE4  2AEC2A          LHLD    ADATABLKP
           1EE7  E5              PUSH    H       ; 1
           1EE8  2AD42A          LHLD    ADBUFP
           1EEB  5E              MOV     E,M
           1EEC  23              INX     H
           1EED  56              MOV     D,M
           1EEE  E1              POP     H       ; 1
           1EEF  4E              MOV     C,M
           1EF0  23              INX     H
           1EF1  46              MOV     B,M
           1EF2  CDBD09          CALL    ABSWR
  89   3              a$data$change = FALSE;
                                                 ; STATEMENT # 89
           1EF5  2AE22A          LHLD    ADATACHANGEP
           1EF8  3600            MVI     M,0H
  90   3          end;
                                                 ; STATEMENT # 90
                         @1:
  91   2      end;
                                                 ; STATEMENT # 91
           1EFA  C9              RET
        
  92   1      save$pointer$block: PROCEDURE PUBLIC;
                                                 ; STATEMENT # 92
                         ; PROC  SAVEPOINTERBLOCK
PL/M-80 COMPILER                                                                                                PAGE   3


  93   2          if a$ptr$change then
                                                 ; STATEMENT # 93
           1EFB  2AE02A          LHLD    APTRCHANGEP
           1EFE  7E              MOV     A,M
           1EFF  1F              RAR
           1F00  D2201F          JNC     @2
  94   2          do;
  95   3              call map$write(a$device);
                                                 ; STATEMENT # 95
           1F03  2ACC2A          LHLD    ADEVP
           1F06  4E              MOV     C,M
           1F07  CDA922          CALL    MAPWRI
  96   3              call abswrite(a$ptr$blk, a$pbuf);
                                                 ; STATEMENT # 96
           1F0A  2AE82A          LHLD    APTRBLKP
           1F0D  E5              PUSH    H       ; 1
           1F0E  2ADA2A          LHLD    APBUFP
           1F11  5E              MOV     E,M
           1F12  23              INX     H
           1F13  56              MOV     D,M
           1F14  E1              POP     H       ; 1
           1F15  4E              MOV     C,M
           1F16  23              INX     H
           1F17  46              MOV     B,M
           1F18  CDBD09          CALL    ABSWR
  97   3              a$ptr$change = FALSE;
                                                 ; STATEMENT # 97
           1F1B  2AE02A          LHLD    APTRCHANGEP
           1F1E  3600            MVI     M,0H
  98   3          end;
                                                 ; STATEMENT # 98
                         @2:
  99   2      end;
                                                 ; STATEMENT # 99
           1F20  C9              RET
        
 100   1      rewind: PROCEDURE PUBLIC;
                                                 ; STATEMENT # 100
                         ; PROC  REWIND
 101   2          a$data$ptr = 128;
                                                 ; STATEMENT # 101
           1F21  2AD62A          LHLD    ADATAPTRP
           1F24  3680            MVI     M,80H
 102   2          a$ptr$ptr = 1;
                                                 ; STATEMENT # 102
           1F26  2ADC2A          LHLD    APTRPTRP
           1F29  3601            MVI     M,1H
 103   2          a$data$change = FALSE;
                                                 ; STATEMENT # 103
           1F2B  2AE22A          LHLD    ADATACHANGEP
           1F2E  3600            MVI     M,0H
 104   2          a$dbuf$read = FALSE;
                                                 ; STATEMENT # 104
           1F30  2AEE2A          LHLD    ADBUFREADP
           1F33  3600            MVI     M,0H
 105   2          a$ptr$change = FALSE;
                                                 ; STATEMENT # 105
PL/M-80 COMPILER                                                                                                PAGE   4


           1F35  2AE02A          LHLD    APTRCHANGEP
           1F38  3600            MVI     M,0H
 106   2          a$blk$seqno, a$data$blk = 0;
                                                 ; STATEMENT # 106
           1F3A  2AE62A          LHLD    ABLKSEQNOP
           1F3D  3E00            MVI     A,0H
           1F3F  77              MOV     M,A
           1F40  23              INX     H
           1F41  3600            MVI     M,0
           1F43  2AEC2A          LHLD    ADATABLKP
           1F46  77              MOV     M,A
           1F47  23              INX     H
           1F48  3600            MVI     M,0
 107   2          call absread(a$ptr$blk := a$hdr$blk, a$pbuf);
                                                 ; STATEMENT # 107
           1F4A  2AEA2A          LHLD    AHBLKP
           1F4D  E5              PUSH    H       ; 1
           1F4E  2AE82A          LHLD    APTRBLKP
           1F51  E3              XTHL            ; 1
           1F52  4E              MOV     C,M
           1F53  23              INX     H
           1F54  46              MOV     B,M
           1F55  D1              POP     D       ; 1
           1F56  EB              XCHG
           1F57  71              MOV     M,C
           1F58  23              INX     H
           1F59  70              MOV     M,B
           1F5A  2ADA2A          LHLD    APBUFP
           1F5D  5E              MOV     E,M
           1F5E  23              INX     H
           1F5F  56              MOV     D,M
           1F60  CDA409          CALL    ABSRD
 108   2      end;
                                                 ; STATEMENT # 108
           1F63  C9              RET
        
 109   1      seek: PROCEDURE(aftn, mode, blockptr, byteptr) PUBLIC;
                                                 ; STATEMENT # 109
                         ; PROC  SEEK
           1F64  21152E          LXI     H,BYTEPTR+1H
           1F67  72              MOV     M,D
           1F68  2B              DCX     H
           1F69  73              MOV     M,E
           1F6A  2B              DCX     H
           1F6B  70              MOV     M,B
           1F6C  2B              DCX     H
           1F6D  71              MOV     M,C
           1F6E  2B              DCX     H
           1F6F  D1              POP     D       
           1F70  C1              POP     B       
           1F71  70              MOV     M,B
           1F72  2B              DCX     H
           1F73  71              MOV     M,C
           1F74  2B              DCX     H
           1F75  C1              POP     B       
           1F76  71              MOV     M,C
           1F77  D5              PUSH    D       
PL/M-80 COMPILER                                                                                                PAGE   5


 110   2          DECLARE aftn BYTE, (mode, blockptr, byteptr) ADDRESS;
 111   2          DECLARE lowMode BYTE AT (.mode);
 112   2          DECLARE blk BASED blockptr ADDRESS, byt BASED byteptr ADDRESS;
 113   2          DECLARE plusMinus ADDRESS,
                      orig$byte ADDRESS, lo$byte BYTE AT (.orig$byte),
                      blockno ADDRESS, temp ADDRESS, forward BYTE;
        
 114   2          if mode > SEEK$EOF then
                                                 ; STATEMENT # 114
           1F78  3E04            MVI     A,4H
           1F7A  21102E          LXI     H,MODE
           1F7D  CD402A          CALL    @P0103 
           1F80  D2881F          JNC     @3
 115   2              call warn(BAD$SEEK$ARG);
                                                 ; STATEMENT # 115
           1F83  0E1B            MVI     C,1BH
           1F85  CD510B          CALL    WARN
                         @3:
 116   2          call aft$window(aftn);
                                                 ; STATEMENT # 116
           1F88  2A0F2E          LHLD    AFTN
           1F8B  4D              MOV     C,L
           1F8C  CDA702          CALL    AWINDO
 117   2          if a$device = BBDEV then
                                                 ; STATEMENT # 117
           1F8F  2ACC2A          LHLD    ADEVP
           1F92  7E              MOV     A,M
           1F93  FE1A            CPI     1AH
           1F95  C2991F          JNZ     @4
 118   2              return;
                                                 ; STATEMENT # 118
           1F98  C9              RET
                         @4:
        
 119   2          if a$device > F9DEV then
                                                 ; STATEMENT # 119
           1F99  2ACC2A          LHLD    ADEVP
           1F9C  3E09            MVI     A,9H
           1F9E  BE              CMP     M
           1F9F  D2A71F          JNC     @5
 120   2              call warn(NON$DISK$SEEK);
                                                 ; STATEMENT # 120
           1FA2  0E13            MVI     C,13H
           1FA4  CD510B          CALL    WARN
                         @5:
        
 121   2          if a$access = WRITE$MODE then   /* 2 */
                                                 ; STATEMENT # 121
           1FA7  2ACE2A          LHLD    AACESP
           1FAA  7E              MOV     A,M
           1FAB  FE02            CPI     2H
           1FAD  C2B51F          JNZ     @6
 122   2              call warn(SEEK$ON$WRITE);
                                                 ; STATEMENT # 122
           1FB0  0E1F            MVI     C,1FH
           1FB2  CD510B          CALL    WARN
                         @6:
PL/M-80 COMPILER                                                                                                PAGE   6


 123   2          if lowMode = SEEK$RETURN then   /* 0 - SEEK$RETURN */
                                                 ; STATEMENT # 123
           1FB5  3A102E          LDA     LOWMODE
           1FB8  FE00            CPI     0H
           1FBA  C2F21F          JNZ     @7
 124   2          do;
 125   3              byt = a$data$ptr;   
                                                 ; STATEMENT # 125
           1FBD  2AD62A          LHLD    ADATAPTRP
           1FC0  E5              PUSH    H       ; 1
           1FC1  2A142E          LHLD    BYTEPTR
           1FC4  C1              POP     B       ; 1
           1FC5  0A              LDAX    B
           1FC6  77              MOV     M,A
           1FC7  23              INX     H
           1FC8  3600            MVI     M,0
 126   3              if (blk := a$blk$seqno - 1) = 0FFFFh then
                                                 ; STATEMENT # 126
           1FCA  2AE62A          LHLD    ABLKSEQNOP
           1FCD  4E              MOV     C,M
           1FCE  23              INX     H
           1FCF  46              MOV     B,M
           1FD0  0B              DCX     B
           1FD1  2A122E          LHLD    BLOCKPTR
           1FD4  71              MOV     M,C
           1FD5  23              INX     H
           1FD6  70              MOV     M,B
           1FD7  11FFFF          LXI     D,0FFFFH
           1FDA  CD212A          CALL    @P0097 
           1FDD  B5              ORA     L
           1FDE  C2F11F          JNZ     @8
 127   3              do;
 128   4                  blk, byt = 0;
                                                 ; STATEMENT # 128
           1FE1  2A122E          LHLD    BLOCKPTR
           1FE4  3E00            MVI     A,0H
           1FE6  77              MOV     M,A
           1FE7  23              INX     H
           1FE8  3600            MVI     M,0
           1FEA  2A142E          LHLD    BYTEPTR
           1FED  77              MOV     M,A
           1FEE  23              INX     H
           1FEF  3600            MVI     M,0
 129   4              end;
                                                 ; STATEMENT # 129
                         @8:
 130   3              return;
                                                 ; STATEMENT # 130
           1FF1  C9              RET
 131   3          end;
                                                 ; STATEMENT # 131
                         @7:
                  
 132   2          blockno = (blk AND 07fffh) + shr((orig$byte := byt), 7);
                                                 ; STATEMENT # 132
           1FF2  2A122E          LHLD    BLOCKPTR
           1FF5  11FF7F          LXI     D,7FFFH
PL/M-80 COMPILER                                                                                                PAGE   7


           1FF8  CDA029          CALL    @P0027 
           1FFB  E5              PUSH    H       ; 1
           1FFC  2A142E          LHLD    BYTEPTR
           1FFF  5E              MOV     E,M
           2000  23              INX     H
           2001  56              MOV     D,M
           2002  EB              XCHG
           2003  22182E          SHLD    ORIGBYTE
           2006  0E07            MVI     C,7H
           2008  CD082A          CALL    @P0093 
           200B  C1              POP     B       ; 1
           200C  09              DAD     B
           200D  221A2E          SHLD    BLOCKNO
 133   2          lo$byte = lo$byte and 7fh;
                                                 ; STATEMENT # 133
           2010  3A182E          LDA     LOBYTE
           2013  E67F            ANI     7FH
           2015  32182E          STA     LOBYTE
 134   2          if lowMode = SEEK$EOF then
                                                 ; STATEMENT # 134
           2018  3A102E          LDA     LOWMODE
           201B  FE04            CPI     4H
           201D  C24C20          JNZ     @9
 135   2          do;
 136   3              lowMode = SEEK$ABS;
                                                 ; STATEMENT # 136
           2020  21102E          LXI     H,LOWMODE
           2023  3602            MVI     M,2H
 137   3              lo$byte = a$eof$data$ptr;
                                                 ; STATEMENT # 137
           2025  2ADE2A          LHLD    AEOPP
           2028  7E              MOV     A,M
           2029  32182E          STA     LOBYTE
 138   3              if (blockno := a$blk$count - 1) = 0FFFFh then
                                                 ; STATEMENT # 138
           202C  2AE42A          LHLD    ABCNTP
           202F  4E              MOV     C,M
           2030  23              INX     H
           2031  46              MOV     B,M
           2032  0B              DCX     B
           2033  60              MOV     H,B
           2034  69              MOV     L,C
           2035  221A2E          SHLD    BLOCKNO
           2038  11FFFF          LXI     D,0FFFFH
           203B  CD212A          CALL    @P0097 
           203E  B5              ORA     L
           203F  C24C20          JNZ     @10
 139   3              do;
 140   4                  blockno, lo$byte = 0;
                                                 ; STATEMENT # 140
           2042  210000          LXI     H,0H
           2045  221A2E          SHLD    BLOCKNO
           2048  7D              MOV     A,L
           2049  32182E          STA     LOBYTE
 141   4              end;
                                                 ; STATEMENT # 141
                         @10:
PL/M-80 COMPILER                                                                                                PAGE   8


 142   3          end;
                                                 ; STATEMENT # 142
                         @9:
 143   2          if lowMode = SEEK$ABS then
                                                 ; STATEMENT # 143
           204C  3A102E          LDA     LOWMODE
           204F  FE02            CPI     2H
           2051  C2D820          JNZ     @11
 144   2          do;
 145   3              if (blockno OR a$blk$seqno OR lo$byte) <> 0 then
                                                 ; STATEMENT # 145
           2054  2AE62A          LHLD    ABLKSEQNOP
           2057  111A2E          LXI     D,BLOCKNO
           205A  CDE829          CALL    @P0053 
           205D  3A182E          LDA     LOBYTE
           2060  CDDC29          CALL    @P0048 
           2063  3E00            MVI     A,0H
           2065  CD142A          CALL    @P0094 
           2068  B5              ORA     L
           2069  CA7620          JZ      @12
 146   3              do;
 147   4                  blockno = blockno + 1;
                                                 ; STATEMENT # 147
           206C  2A1A2E          LHLD    BLOCKNO
           206F  23              INX     H
           2070  221A2E          SHLD    BLOCKNO
 148   4              end;
                                                 ; STATEMENT # 148
           2073  C37B20          JMP     @13
                         @12:
                      else
 149   3                  lo$byte = 128;
                                                 ; STATEMENT # 149
           2076  21182E          LXI     H,LOBYTE
           2079  3680            MVI     M,80H
                         @13:
 150   3              lowMode = SEEK$BACKWARD;
                                                 ; STATEMENT # 150
           207B  21102E          LXI     H,LOWMODE
           207E  3601            MVI     M,1H
 151   3              if blockno > a$blk$seqno then
                                                 ; STATEMENT # 151
           2080  2AE62A          LHLD    ABLKSEQNOP
           2083  EB              XCHG
           2084  011A2E          LXI     B,BLOCKNO
           2087  CD282A          CALL    @P0098 
           208A  D2A320          JNC     @14
 152   3              do;
 153   4                  lowMode = SEEK$FORWARD;
                                                 ; STATEMENT # 153
           208D  21102E          LXI     H,LOWMODE
           2090  3603            MVI     M,3H
 154   4                  blockno = blockno - a$blk$seqno;
                                                 ; STATEMENT # 154
           2092  2AE62A          LHLD    ABLKSEQNOP
           2095  111A2E          LXI     D,BLOCKNO
           2098  CD2A2A          CALL    @P0099 
PL/M-80 COMPILER                                                                                                PAGE   9


           209B  EB              XCHG
           209C  2B              DCX     H
           209D  73              MOV     M,E
           209E  23              INX     H
           209F  72              MOV     M,D
 155   4              end;
                                                 ; STATEMENT # 155
           20A0  C3D520          JMP     @15
                         @14:
 156   3              else if blockno < a$blk$seqno then
                                                 ; STATEMENT # 156
           20A3  2AE62A          LHLD    ABLKSEQNOP
           20A6  111A2E          LXI     D,BLOCKNO
           20A9  CD2A2A          CALL    @P0099 
           20AC  D2BF20          JNC     @16
 157   3                  blockno = a$blk$seqno - blockno;
                                                 ; STATEMENT # 157
           20AF  2AE62A          LHLD    ABLKSEQNOP
           20B2  EB              XCHG
           20B3  011A2E          LXI     B,BLOCKNO
           20B6  CD282A          CALL    @P0098 
           20B9  221A2E          SHLD    BLOCKNO
           20BC  C3D520          JMP     @17
                         @16:
                      else
 158   3              do;
 159   4                  blockno = 0;
                                                 ; STATEMENT # 159
           20BF  210000          LXI     H,0H
           20C2  221A2E          SHLD    BLOCKNO
 160   4                  if lo$byte > a$data$ptr then
                                                 ; STATEMENT # 160
           20C5  2AD62A          LHLD    ADATAPTRP
           20C8  7E              MOV     A,M
           20C9  21182E          LXI     H,LOBYTE
           20CC  BE              CMP     M
           20CD  D2D520          JNC     @18
 161   4                      lowMode = SEEK$FORWARD; /* seek within block */
                                                 ; STATEMENT # 161
           20D0  21102E          LXI     H,LOWMODE
           20D3  3603            MVI     M,3H
                         @18:
 162   4              end;
                                                 ; STATEMENT # 162
                         @17:
                         @15:
 163   3          end;
                                                 ; STATEMENT # 163
           20D5  C30A21          JMP     @19
                         @11:
                  else
 164   2          do;
 165   3              if lowMode = SEEK$BACKWARD then
                                                 ; STATEMENT # 165
           20D8  3A102E          LDA     LOWMODE
           20DB  FE01            CPI     1H
           20DD  C2E820          JNZ     @20
PL/M-80 COMPILER                                                                                                PAGE  10


 166   3                  lo$byte = -lo$byte;
                                                 ; STATEMENT # 166
           20E0  3A182E          LDA     LOBYTE
           20E3  2F              CMA
           20E4  3C              INR     A
           20E5  32182E          STA     LOBYTE
                         @20:
                      
 167   3              lo$byte = a$data$ptr + lo$byte;
                                                 ; STATEMENT # 167
           20E8  2AD62A          LHLD    ADATAPTRP
           20EB  3A182E          LDA     LOBYTE
           20EE  86              ADD     M
           20EF  32182E          STA     LOBYTE
 168   3              if lo$byte > 128 then
                                                 ; STATEMENT # 168
           20F2  3E80            MVI     A,80H
           20F4  21182E          LXI     H,LOBYTE
           20F7  BE              CMP     M
           20F8  D20A21          JNC     @21
 169   3              do;
 170   4                  blockno = blockno + 1;
                                                 ; STATEMENT # 170
           20FB  2A1A2E          LHLD    BLOCKNO
           20FE  23              INX     H
           20FF  221A2E          SHLD    BLOCKNO
 171   4                  lo$byte = lo$byte - 128;
                                                 ; STATEMENT # 171
           2102  3A182E          LDA     LOBYTE
           2105  D680            SUI     80H
           2107  32182E          STA     LOBYTE
 172   4              end;
                                                 ; STATEMENT # 172
                         @21:
 173   3          end;
                                                 ; STATEMENT # 173
                         @19:
 174   2          a$data$ptr = lo$byte;
                                                 ; STATEMENT # 174
           210A  2AD62A          LHLD    ADATAPTRP
           210D  3A182E          LDA     LOBYTE
           2110  77              MOV     M,A
 175   2          if (forward := lowMode = SEEK$FORWARD) then
                                                 ; STATEMENT # 175
           2111  3A102E          LDA     LOWMODE
           2114  D603            SUI     3H
           2116  D601            SUI     1
           2118  9F              SBB     A
           2119  321E2E          STA     FORWARD
           211C  1F              RAR
           211D  D22321          JNC     @22
 176   2              call adjust$eof;
                                                 ; STATEMENT # 176
           2120  CDB216          CALL    ADJUSTEOF
                         @22:
        
 177   2          do while blockno > 0;
PL/M-80 COMPILER                                                                                                PAGE  11


                                                 ; STATEMENT # 177
                         @34:
           2123  3E00            MVI     A,0H
           2125  211A2E          LXI     H,BLOCKNO
           2128  CD402A          CALL    @P0103 
           212B  D25F22          JNC     @35
 178   3              call save$data$blk;
                                                 ; STATEMENT # 178
           212E  CDDC1E          CALL    SAVEDATABLK
 179   3              a$dbuf$read = FALSE;
                                                 ; STATEMENT # 179
           2131  2AEE2A          LHLD    ADBUFREADP
           2134  3600            MVI     M,0H
 180   3              blockno = blockno - 1;
                                                 ; STATEMENT # 180
           2136  2A1A2E          LHLD    BLOCKNO
           2139  2B              DCX     H
           213A  221A2E          SHLD    BLOCKNO
 181   3              if forward then
                                                 ; STATEMENT # 181
           213D  3A1E2E          LDA     FORWARD
           2140  1F              RAR
           2141  D2D721          JNC     @23
 182   3              do;
 183   4                  plusMinus = 1;
                                                 ; STATEMENT # 183
           2144  210100          LXI     H,1H
           2147  22162E          SHLD    PLUSMINUS
 184   4                  if a$ptr$ptr = 63 then
                                                 ; STATEMENT # 184
           214A  2ADC2A          LHLD    APTRPTRP
           214D  7E              MOV     A,M
           214E  FE3F            CPI     3FH
           2150  C2D421          JNZ     @24
 185   4                  do;
 186   5                      if (temp := links(FLINK)) = 0 then
                                                 ; STATEMENT # 186
           2153  2AC62A          LHLD    POINTERBASE
           2156  23              INX     H
           2157  23              INX     H
           2158  5E              MOV     E,M
           2159  23              INX     H
           215A  56              MOV     D,M
           215B  EB              XCHG
           215C  221C2E          SHLD    TEMP
           215F  3E00            MVI     A,0H
           2161  CD142A          CALL    @P0094 
           2164  B5              ORA     L
           2165  C2B221          JNZ     @25
 187   5                      do;
 188   6                          call chk$eof;
                                                 ; STATEMENT # 188
           2168  CD8A16          CALL    CHKEOF
 189   6                          links(FLINK), temp = get$block(a$device);
                                                 ; STATEMENT # 189
           216B  2ACC2A          LHLD    ADEVP
           216E  4E              MOV     C,M
PL/M-80 COMPILER                                                                                                PAGE  12


           216F  CD4223          CALL    GETBLK
           2172  E5              PUSH    H       ; 1
           2173  2AC62A          LHLD    POINTERBASE
           2176  23              INX     H
           2177  23              INX     H
           2178  C1              POP     B       ; 1
           2179  71              MOV     M,C
           217A  23              INX     H
           217B  70              MOV     M,B
           217C  60              MOV     H,B
           217D  69              MOV     L,C
           217E  221C2E          SHLD    TEMP
 190   6                          a$ptr$change = TRUE;
                                                 ; STATEMENT # 190
           2181  2AE02A          LHLD    APTRCHANGEP
           2184  36FF            MVI     M,0FFH
 191   6                          call save$pointer$block;
                                                 ; STATEMENT # 191
           2186  CDFB1E          CALL    SAVEPOINTERBLOCK
 192   6                          call clear$buf(a$pbuf);
                                                 ; STATEMENT # 192
           2189  2ADA2A          LHLD    APBUFP
           218C  4E              MOV     C,M
           218D  23              INX     H
           218E  46              MOV     B,M
           218F  CDE924          CALL    CLRBUF
 193   6                          links(BLINK) = a$ptr$blk;
                                                 ; STATEMENT # 193
           2192  2AE82A          LHLD    APTRBLKP
           2195  E5              PUSH    H       ; 1
           2196  2AC62A          LHLD    POINTERBASE
           2199  E3              XTHL            ; 1
           219A  4E              MOV     C,M
           219B  23              INX     H
           219C  46              MOV     B,M
           219D  E1              POP     H       ; 1
           219E  71              MOV     M,C
           219F  23              INX     H
           21A0  70              MOV     M,B
 194   6                          call abswrite(temp, a$pbuf);
                                                 ; STATEMENT # 194
           21A1  2ADA2A          LHLD    APBUFP
           21A4  5E              MOV     E,M
           21A5  23              INX     H
           21A6  56              MOV     D,M
           21A7  2A1C2E          LHLD    TEMP
           21AA  44              MOV     B,H
           21AB  4D              MOV     C,L
           21AC  CDBD09          CALL    ABSWR
 195   6                      end;
                                                 ; STATEMENT # 195
           21AF  C3C321          JMP     @26
                         @25:
                              else
 196   5                      do;
 197   6                          call save$pointer$block;
                                                 ; STATEMENT # 197
PL/M-80 COMPILER                                                                                                PAGE  13


           21B2  CDFB1E          CALL    SAVEPOINTERBLOCK
 198   6                          call absread(temp, a$pbuf);
                                                 ; STATEMENT # 198
           21B5  2ADA2A          LHLD    APBUFP
           21B8  5E              MOV     E,M
           21B9  23              INX     H
           21BA  56              MOV     D,M
           21BB  2A1C2E          LHLD    TEMP
           21BE  44              MOV     B,H
           21BF  4D              MOV     C,L
           21C0  CDA409          CALL    ABSRD
 199   6                      end;
                                                 ; STATEMENT # 199
                         @26:
 200   5                      a$ptr$ptr = 1;
                                                 ; STATEMENT # 200
           21C3  2ADC2A          LHLD    APTRPTRP
           21C6  3601            MVI     M,1H
 201   5                      a$ptr$blk = temp;
                                                 ; STATEMENT # 201
           21C8  2AE82A          LHLD    APTRBLKP
           21CB  E5              PUSH    H       ; 1
           21CC  2A1C2E          LHLD    TEMP
           21CF  EB              XCHG
           21D0  E1              POP     H       ; 1
           21D1  73              MOV     M,E
           21D2  23              INX     H
           21D3  72              MOV     M,D
 202   5                  end;
                                                 ; STATEMENT # 202
                         @24:
 203   4              end;
                                                 ; STATEMENT # 203
           21D4  C33F22          JMP     @27
                         @23:
 204   3              else if a$data$ptr = 128 then
                                                 ; STATEMENT # 204
           21D7  2AD62A          LHLD    ADATAPTRP
           21DA  7E              MOV     A,M
           21DB  FE80            CPI     80H
           21DD  C2EE21          JNZ     @28
 205   3              do;
 206   4                  plusMinus = 0;
                                                 ; STATEMENT # 206
           21E0  210000          LXI     H,0H
           21E3  22162E          SHLD    PLUSMINUS
 207   4                  a$data$ptr = 0;
                                                 ; STATEMENT # 207
           21E6  2AD62A          LHLD    ADATAPTRP
           21E9  3600            MVI     M,0H
 208   4              end;
                                                 ; STATEMENT # 208
           21EB  C33F22          JMP     @29
                         @28:
                      else
 209   3              do;
 210   4                  plusMinus = 0FFFFH; /* -1 */
PL/M-80 COMPILER                                                                                                PAGE  14


                                                 ; STATEMENT # 210
           21EE  21FFFF          LXI     H,0FFFFH
           21F1  22162E          SHLD    PLUSMINUS
 211   4                  if a$ptr$ptr - 1 < 2 then 
                                                 ; STATEMENT # 211
           21F4  2ADC2A          LHLD    APTRPTRP
           21F7  7E              MOV     A,M
           21F8  3D              DCR     A
           21F9  FE02            CPI     2H
           21FB  D23F22          JNC     @30
 212   4                      if links(BLINK) <> 0 then
                                                 ; STATEMENT # 212
           21FE  2AC62A          LHLD    POINTERBASE
           2201  3E00            MVI     A,0H
           2203  CD402A          CALL    @P0103 
           2206  B5              ORA     L
           2207  CA2E22          JZ      @31
 213   4                      do;
 214   5                          call save$pointer$block;
                                                 ; STATEMENT # 214
           220A  CDFB1E          CALL    SAVEPOINTERBLOCK
 215   5                          a$ptr$ptr = 64;
                                                 ; STATEMENT # 215
           220D  2ADC2A          LHLD    APTRPTRP
           2210  3640            MVI     M,40H
 216   5                          call absread((a$ptr$blk := links(BLINK)), a$pbuf);
                                                 ; STATEMENT # 216
           2212  2AC62A          LHLD    POINTERBASE
           2215  E5              PUSH    H       ; 1
           2216  2AE82A          LHLD    APTRBLKP
           2219  E3              XTHL            ; 1
           221A  4E              MOV     C,M
           221B  23              INX     H
           221C  46              MOV     B,M
           221D  D1              POP     D       ; 1
           221E  EB              XCHG
           221F  71              MOV     M,C
           2220  23              INX     H
           2221  70              MOV     M,B
           2222  2ADA2A          LHLD    APBUFP
           2225  5E              MOV     E,M
           2226  23              INX     H
           2227  56              MOV     D,M
           2228  CDA409          CALL    ABSRD
 217   5                      end;
                                                 ; STATEMENT # 217
           222B  C33F22          JMP     @32
                         @31:
                              else
 218   4                      do;
 219   5                          a$ptr$ptr = 1;
                                                 ; STATEMENT # 219
           222E  2ADC2A          LHLD    APTRPTRP
           2231  3601            MVI     M,1H
 220   5                          a$blk$seqno = 0;
                                                 ; STATEMENT # 220
           2233  2AE62A          LHLD    ABLKSEQNOP
PL/M-80 COMPILER                                                                                                PAGE  15


           2236  3E00            MVI     A,0H
           2238  77              MOV     M,A
           2239  23              INX     H
           223A  3600            MVI     M,0
 221   5                          goto error;
                                                 ; STATEMENT # 221
           223C  C35F22          JMP     ERROR
                          
 222   5                      end;
                                                 ; STATEMENT # 222
                         @32:
                         @30:
 223   4              end;
                                                 ; STATEMENT # 223
                         @29:
                         @27:
 224   3              a$blk$seqno = a$blk$seqno + plusMinus;
                                                 ; STATEMENT # 224
           223F  2AE62A          LHLD    ABLKSEQNOP
           2242  11162E          LXI     D,PLUSMINUS
           2245  E5              PUSH    H       ; 1
           2246  CD7A29          CALL    @P0012 
           2249  EB              XCHG
           224A  E1              POP     H       ; 1
           224B  73              MOV     M,E
           224C  23              INX     H
           224D  72              MOV     M,D
 225   3              a$ptr$ptr = a$ptr$ptr + low(plusMinus);
                                                 ; STATEMENT # 225
           224E  2ADC2A          LHLD    APTRPTRP
           2251  E5              PUSH    H       ; 1
           2252  2A162E          LHLD    PLUSMINUS
           2255  7D              MOV     A,L
           2256  E1              POP     H       ; 1
           2257  86              ADD     M
           2258  77              MOV     M,A
 226   3              call adjust$eof;
                                                 ; STATEMENT # 226
           2259  CDB216          CALL    ADJUSTEOF
 227   3          end;
                                                 ; STATEMENT # 227
           225C  C32321          JMP     @34
                         @35:
        
 228   2      error:
                                                 ; STATEMENT # 228
                         ERROR:
           225F  2AE62A          LHLD    ABLKSEQNOP
           2262  3E00            MVI     A,0H
           2264  CD402A          CALL    @P0103 
           2267  B5              ORA     L
           2268  D601            SUI     1
           226A  9F              SBB     A
           226B  2AD62A          LHLD    ADATAPTRP
           226E  F5              PUSH    PSW     ; 1
           226F  7E              MOV     A,M
           2270  D680            SUI     80H
PL/M-80 COMPILER                                                                                                PAGE  16


           2272  C6FF            ADI     255
           2274  9F              SBB     A
           2275  C1              POP     B       ; 1
           2276  48              MOV     C,B
           2277  A1              ANA     C
           2278  1F              RAR
           2279  D28622          JNC     @33
                  if a$blk$seqno = 0 AND a$data$ptr <> 128 then
 229   2          do;
 230   3              a$data$ptr = 128;
                                                 ; STATEMENT # 230
           227C  2AD62A          LHLD    ADATAPTRP
           227F  3680            MVI     M,80H
 231   3              call warn(LONG$BACK$SEEK);
                                                 ; STATEMENT # 231
           2281  0E14            MVI     C,14H
           2283  CD510B          CALL    WARN
 232   3          end;
                                                 ; STATEMENT # 232
                         @33:
 233   2      end;
                                                 ; STATEMENT # 233
           2286  C9              RET
 234   1      end;
              eof



MODULE INFORMATION:

     CODE AREA SIZE     = 03ABH    939D
     VARIABLE AREA SIZE = 0010H     16D
     MAXIMUM STACK SIZE = 0004H      4D
     242 LINES READ
     0 PROGRAM ERRORS

END OF PL/M-80 COMPILATION
