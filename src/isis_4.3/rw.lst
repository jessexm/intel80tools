PL/M-80 COMPILER                                                                                                PAGE   1


ISIS-II PL/M-80 V4.0 COMPILATION OF MODULE RW
OBJECT MODULE PLACED IN RW.OBJ
COMPILER INVOKED BY:  :F1:plm80 rw.plm PRINT(RW.LST) OBJECT(RW.OBJ) DEBUG OPTIMIZE CODE



   1          rw:
              do;
        
              $include(rw.ipx)
   2   1  =   declare a$access$p literally 'aAcesP';
   3   1  =   declare a$blk$count$p literally 'aBCntP';
   4   1  =   declare a$eof$data$ptr$p literally 'aEoPP';
   5   1  =   declare Aft$Window literally 'AWindo';
   6   1  =   declare Clear$Buf literally 'ClrBuf';
   7   1  =   declare Get$Block literally 'GetBlk';
   8   1  =   declare Map$Write literally 'MapWri';
   9   1  =   declare absread literally 'abs$rd';
  10   1  =   declare abswrite literally 'abs$wr';
  11   1  =   declare AFT$CONSOLE literally '11';
  12   1  =   declare AFT$T literally 'structure(AFT$T1, AFT$T2, AFT$T3, AFT$T4)';
  13   1  =   declare AFT$T1 literally 'empty BYTE, device BYTE, access BYTE, edit BYTE, lbuf ADDRESS';
  14   1  =   declare AFT$T2 literally 'dbuf ADDRESS, pbuf ADDRESS, data$ptr BYTE, i$no ADDRESS, ptr$ptr BYTE';
  15   1  =   declare AFT$T3 literally 'eofcnt BYTE, ptr$change BYTE, data$change BYTE, blk ADDRESS, blk$seq ADDRESS';
  16   1  =   declare AFT$T4 literally 'ptr$blk ADDRESS, hdr$blk ADDRESS, data$blk$count ADDRESS, dbuf$read BYTE';
  17   1  =   declare BELL literally '7';
  18   1  =   declare BS literally '8';
  19   1  =   declare CANT$READ literally '8';
  20   1  =   declare CANT$WRITE literally '6';
  21   1  =   declare CONSOLE$EOF literally '29';
  22   1  =   declare CONTROL$E literally '5';
  23   1  =   declare CONTROL$P literally '10h';
  24   1  =   declare CONTROL$Q literally '11h';
  25   1  =   declare CONTROL$R literally '12h';
  26   1  =   declare CONTROL$S literally '13h';
  27   1  =   declare CONTROL$X literally '18h';
  28   1  =   declare CONTROL$Z literally '1ah';
  29   1  =   declare CR literally '0dh';
  30   1  =   declare DELKEY literally '7fh';
  31   1  =   declare ESC literally '1bh';
  32   1  =   declare F9DEV literally '9';
  33   1  =   declare FALSE literally '0';
  34   1  =   declare FLINK literally '1';
  35   1  =   declare LF literally '0ah';
  36   1  =   declare SEEK$PAST$EOF literally '35';
  37   1  =   declare TRUE literally '0ffh';
  38   1  =   declare a$access$p address external;
  39   1  =   declare a$blk$count$p address external;
  40   1  =   declare a$blk$seqno$p address external;
  41   1  =   declare a$data$blk$p address external;
  42   1  =   declare a$data$change$p address external;
  43   1  =   declare a$data$ptr$p address external;
  44   1  =   declare a$dbuf$p address external;
  45   1  =   declare a$dbuf$read$p address external;
  46   1  =   declare a$dev$p address external;
  47   1  =   declare a$edit$p address external;
  48   1  =   declare a$eof$data$ptr$p address external;
PL/M-80 COMPILER                                                                                                PAGE   2


  49   1  =   declare aft(18) AFT$T external;
  50   1  =   declare alt$cidev byte external;
  51   1  =   declare a$pbuf$p address external;
  52   1  =   declare a$ptr$blk$p address external;
  53   1  =   declare a$ptr$change$p address external;
  54   1  =   declare a$ptr$ptr$p address external;
  55   1  =   declare datum$base address external;
  56   1  =   declare pointer$base address external;
  57   1  =   abortx: procedure(errcode) external; declare errcode byte; end;
  60   1  =   abs$rd: procedure(block, buffer$ptr) external; declare block address, buffer$ptr address; end;
  63   1  =   abs$wr: procedure(block, buffer$ptr) external; declare block address, buffer$ptr address; end;
  66   1  =   Aft$Window: procedure(slot$number) external; declare slot$number byte; end;
  69   1  =   CI: procedure byte external; end;
  71   1  =   ClearBuf: procedure(buf$address) external; declare buf$address address; end;
  74   1  =   CO: procedure(val) external; declare val byte; end;
  77   1  =   CSTS: procedure byte external; end;
  79   1  =   get$block: procedure(diskNum) address external; declare diskNum byte; end;
  82   1  =   IOCHK: procedure byte external; end;
  84   1  =   IOSET: procedure(val) external; declare val byte; end;
  87   1  =   LO: procedure(val) external; declare val byte; end;
  90   1  =   MapWrite: procedure(diskNum) external; declare diskNum byte; end;
  93   1  =   PO: procedure(val) external; declare val byte; end;
  96   1  =   RI: procedure byte external; end;
  98   1  =   save$data$blk: procedure external; end;
 100   1  =   save$pointer$block: procedure external; end;
 102   1  =   sysUsr: procedure(buffer$p, buffer, datum$base) external;
 103   2  =             declare buffer$p address, buffer address, datum$base address; end;
 105   1  =   usrSys: procedure(buffer$p, buffer, datum$base) external;
 106   2  =             declare buffer$p address, buffer address, datum$base address; end;
 108   1  =   warn: procedure(errcode) external; declare errcode byte; end;
 111   1  =   declare a$access based a$access$p  byte;
 112   1  =   declare a$blk$count based a$blk$count$p  address;
 113   1  =   declare a$blk$seqno based a$blk$seqno$p  address;
 114   1  =   declare a$data$blk based a$data$blk$p  address;
 115   1  =   declare a$data$change based a$data$change$p  byte;
 116   1  =   declare a$data$ptr based a$data$ptr$p  byte;
 117   1  =   declare a$dbuf based a$dbuf$p  address;
 118   1  =   declare a$dbuf$read based a$dbuf$read$p  byte;
 119   1  =   declare a$device based a$dev$p  byte;
 120   1  =   declare a$edit based a$edit$p  byte;
 121   1  =   declare a$eof$data$ptr based a$eof$data$ptr$p  byte;
 122   1  =   declare a$pbuf based a$pbuf$p  address;
 123   1  =   declare a$ptr$blk based a$ptr$blk$p  address;
 124   1  =   declare a$ptr$change based a$ptr$change$p  byte;
 125   1  =   declare a$ptr$ptr based a$ptr$ptr$p  byte;
 126   1  =   declare links based pointer$base (64) address;
        
 127   1      DECLARE ACCESS$READ LITERALLY   '1',
                  ACCESS$WRITE    LITERALLY   '2';
        
 128   1      DECLARE MAXLL       LITERALLY   '122';  /* maximum line length */
        
 129   1      DECLARE iobyteMasks(*) BYTE DATA(0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh,
                               0FCh, 0FCh, 0FCh, 0FCh, 0FCh, 0FCh, 0F3h, 0F3h, 0F3h, 0F3h,
                               0CFh, 0CFh, 0CFh, 0CFh, 3Fh, 3Fh, 0FFh, 0FFh, 0FFh);
 130   1      DECLARE iobyteFlags(*) BYTE DATA(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                               0, 0, 1, 1, 3, 3, 0, 4, 8, 0Ch,
PL/M-80 COMPILER                                                                                                PAGE   3


                               0, 10h, 20h, 30h, 80h, 0C0h, 0, 0, 0);
 131   1      DECLARE devClass(*) BYTE DATA(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                0FFh, 1, 0FFh, 1, 0FFh, 1, 0EFh, 0EFh, 0EFh, 0EFh,
                                2, 2, 2, 2, 3, 3, 4, 0FFh, 0FFh);
 132   1      DECLARE specialChars(*) byte DATA(0, DELKEY, CONTROL$Z, CONTROL$R, CONTROL$X, CR, LF, ESC, CONTROL$E, CONT
           -   ROL$P);
        
        
 133   1      DECLARE count$diff ADDRESS,
                  eof$dif BYTE,
                  adp$dif BYTE PUBLIC,
                  datapp  ADDRESS PUBLIC, /* interface to usrSys & sysUsr asm routines */
                  create BYTE INITIAL(0),
                  newptrblk ADDRESS,
                  iostat BYTE;
                  
        
 134   1      chk$eof: PROCEDURE PUBLIC;
                                                 ; STATEMENT # 134
                         ; PROC  CHKEOF
 135   2          if a$access = ACCESS$READ then  /* 1 */
                                                 ; STATEMENT # 135
           0061  2A0000          LHLD    AACESP
           0064  7E              MOV     A,M
           0065  FE01            CPI     1H
           0067  C28800          JNZ     @1
 136   2          do;
 137   3              a$blk$seqno = a$blk$count;
                                                 ; STATEMENT # 137
           006A  2A0000          LHLD    ABCNTP
           006D  E5              PUSH    H       ; 1
           006E  2A0000          LHLD    ABLKSEQNOP
           0071  E3              XTHL            ; 1
           0072  4E              MOV     C,M
           0073  23              INX     H
           0074  46              MOV     B,M
           0075  E1              POP     H       ; 1
           0076  71              MOV     M,C
           0077  23              INX     H
           0078  70              MOV     M,B
 138   3              a$data$ptr = a$eof$data$ptr;
                                                 ; STATEMENT # 138
           0079  2A0000          LHLD    AEOPP
           007C  E5              PUSH    H       ; 1
           007D  2A0000          LHLD    ADATAPTRP
           0080  C1              POP     B       ; 1
           0081  0A              LDAX    B
           0082  77              MOV     M,A
 139   3              call WARN(SEEK$PAST$EOF);
                                                 ; STATEMENT # 139
           0083  0E23            MVI     C,23H
           0085  CD0000          CALL    WARN
        
 140   3          end;
                                                 ; STATEMENT # 140
                         @1:
 141   2      end;
PL/M-80 COMPILER                                                                                                PAGE   4


                                                 ; STATEMENT # 141
           0088  C9              RET
        
 142   1      adjust$eof: PROCEDURE PUBLIC;
                                                 ; STATEMENT # 142
                         ; PROC  ADJUSTEOF
 143   2          if a$blk$seqno <> 0 AND a$data$ptr = 0 then
                                                 ; STATEMENT # 143
           0089  2A0000          LHLD    ABLKSEQNOP
           008C  3E00            MVI     A,0H
           008E  CD0000          CALL    @P0103 
           0091  B5              ORA     L
           0092  C6FF            ADI     255
           0094  9F              SBB     A
           0095  2A0000          LHLD    ADATAPTRP
           0098  F5              PUSH    PSW     ; 1
           0099  7E              MOV     A,M
           009A  D600            SUI     0H
           009C  D601            SUI     1
           009E  9F              SBB     A
           009F  C1              POP     B       ; 1
           00A0  48              MOV     C,B
           00A1  A1              ANA     C
           00A2  1F              RAR
           00A3  D2D400          JNC     @2
 144   2          do;
 145   3              if not ((a$eof$data$ptr < 128 AND a$blk$seqno - 1 = a$blk$count) OR a$blk$count < a$blk$seqno - 1)
           -    then
                                                 ; STATEMENT # 145
           00A6  2A0000          LHLD    AEOPP
           00A9  7E              MOV     A,M
           00AA  D680            SUI     80H
           00AC  9F              SBB     A
           00AD  2A0000          LHLD    ABLKSEQNOP
           00B0  4E              MOV     C,M
           00B1  23              INX     H
           00B2  46              MOV     B,M
           00B3  0B              DCX     B
           00B4  2A0000          LHLD    ABCNTP
           00B7  EB              XCHG
           00B8  F5              PUSH    PSW     ; 1
           00B9  CD0000          CALL    @P0100 
           00BC  B5              ORA     L
           00BD  D601            SUI     1
           00BF  9F              SBB     A
           00C0  E1              POP     H       ; 1
           00C1  6C              MOV     L,H
           00C2  A5              ANA     L
           00C3  1B              DCX     D
           00C4  F5              PUSH    PSW     ; 1
           00C5  CD0000          CALL    @P0100 
           00C8  9F              SBB     A
           00C9  C1              POP     B       ; 1
           00CA  48              MOV     C,B
           00CB  B1              ORA     C
           00CC  1F              RAR
           00CD  DAD100          JC      @3
PL/M-80 COMPILER                                                                                                PAGE   5


 146   3                  return;
                                                 ; STATEMENT # 146
           00D0  C9              RET
                         @3:
 147   3          end;
                                                 ; STATEMENT # 147
           00D1  C30301          JMP     @4
                         @2:
                  else
 148   2          do;
 149   3              if not ((a$eof$data$ptr < a$data$ptr AND a$blk$seqno = a$blk$count) OR a$blk$seqno > a$blk$count) 
           -   then
                                                 ; STATEMENT # 149
           00D4  2A0000          LHLD    AEOPP
           00D7  E5              PUSH    H       ; 1
           00D8  2A0000          LHLD    ADATAPTRP
           00DB  C1              POP     B       ; 1
           00DC  0A              LDAX    B
           00DD  96              SUB     M
           00DE  9F              SBB     A
           00DF  2A0000          LHLD    ABLKSEQNOP
           00E2  E5              PUSH    H       ; 1
           00E3  2A0000          LHLD    ABCNTP
           00E6  D1              POP     D       ; 1
           00E7  F5              PUSH    PSW     ; 1
           00E8  E5              PUSH    H       ; 2
           00E9  CD0000          CALL    @P0099 
           00EC  B5              ORA     L
           00ED  D601            SUI     1
           00EF  9F              SBB     A
           00F0  E1              POP     H       ; 2
           00F1  C1              POP     B       ; 1
           00F2  48              MOV     C,B
           00F3  A1              ANA     C
           00F4  EB              XCHG
           00F5  2B              DCX     H
           00F6  F5              PUSH    PSW     ; 1
           00F7  CD0000          CALL    @P0099 
           00FA  9F              SBB     A
           00FB  C1              POP     B       ; 1
           00FC  48              MOV     C,B
           00FD  B1              ORA     C
           00FE  1F              RAR
           00FF  DA0301          JC      @5
 150   3                  return;
                                                 ; STATEMENT # 150
           0102  C9              RET
                         @5:
 151   3          end;
                                                 ; STATEMENT # 151
                         @4:
 152   2          call chk$eof;
                                                 ; STATEMENT # 152
           0103  CD6100          CALL    CHKEOF
 153   2          a$blk$count = a$blk$seqno;
                                                 ; STATEMENT # 153
           0106  2A0000          LHLD    ABLKSEQNOP
PL/M-80 COMPILER                                                                                                PAGE   6


           0109  E5              PUSH    H       ; 1
           010A  2A0000          LHLD    ABCNTP
           010D  E3              XTHL            ; 1
           010E  4E              MOV     C,M
           010F  23              INX     H
           0110  46              MOV     B,M
           0111  E1              POP     H       ; 1
           0112  71              MOV     M,C
           0113  23              INX     H
           0114  70              MOV     M,B
 154   2          a$eof$data$ptr = a$data$ptr;
                                                 ; STATEMENT # 154
           0115  2A0000          LHLD    ADATAPTRP
           0118  E5              PUSH    H       ; 1
           0119  2A0000          LHLD    AEOPP
           011C  C1              POP     B       ; 1
           011D  0A              LDAX    B
           011E  77              MOV     M,A
 155   2      end;
                                                 ; STATEMENT # 155
           011F  C9              RET
        
        
        
 156   1      rw: PROCEDURE(aftn, buffer, count, actual$p, reading);
                                                 ; STATEMENT # 156
                         ; PROC  RW
           0120  211100          LXI     H,READING
           0123  73              MOV     M,E
           0124  2B              DCX     H
           0125  70              MOV     M,B
           0126  2B              DCX     H
           0127  71              MOV     M,C
           0128  2B              DCX     H
           0129  D1              POP     D       
           012A  C1              POP     B       
           012B  70              MOV     M,B
           012C  2B              DCX     H
           012D  71              MOV     M,C
           012E  2B              DCX     H
           012F  C1              POP     B       
           0130  70              MOV     M,B
           0131  2B              DCX     H
           0132  71              MOV     M,C
           0133  2B              DCX     H
           0134  C1              POP     B       
           0135  71              MOV     M,C
           0136  D5              PUSH    D       
 157   2          DECLARE aftn BYTE, (buffer, count, actual$p) ADDRESS, reading BYTE;
 158   2          DECLARE actual BASED actual$p ADDRESS;
 159   2          DECLARE temp ADDRESS, non$sector$request BYTE, work$buf ADDRESS;
 160   2          DECLARE newlinks BASED temp (64) ADDRESS;
        
 161   2          do while count > actual;
                                                 ; STATEMENT # 161
                         @70:
           0137  2A0F00          LHLD    ACTUALP
PL/M-80 COMPILER                                                                                                PAGE   7


           013A  EB              XCHG
           013B  010D00          LXI     B,COUNT
           013E  CD0000          CALL    @P0098 
           0141  D2EE03          JNC     @71
 162   3              if a$blk$count <= a$blk$seqno AND reading AND a$data$ptr = a$eof$data$ptr then
                                                 ; STATEMENT # 162
           0144  2A0000          LHLD    ABCNTP
           0147  E5              PUSH    H       ; 1
           0148  2A0000          LHLD    ABLKSEQNOP
           014B  EB              XCHG
           014C  C1              POP     B       ; 1
           014D  CD0000          CALL    @P0098 
           0150  9F              SBB     A
           0151  2F              CMA
           0152  211100          LXI     H,READING
           0155  A6              ANA     M
           0156  2A0000          LHLD    ADATAPTRP
           0159  E5              PUSH    H       ; 1
           015A  2A0000          LHLD    AEOPP
           015D  C1              POP     B       ; 1
           015E  F5              PUSH    PSW     ; 1
           015F  0A              LDAX    B
           0160  96              SUB     M
           0161  D601            SUI     1
           0163  9F              SBB     A
           0164  C1              POP     B       ; 1
           0165  48              MOV     C,B
           0166  A1              ANA     C
           0167  1F              RAR
           0168  D26C01          JNC     @6
 163   3                  return;
                                                 ; STATEMENT # 163
           016B  C9              RET
                         @6:
 164   3              if a$data$ptr = 128 then
                                                 ; STATEMENT # 164
           016C  2A0000          LHLD    ADATAPTRP
           016F  7E              MOV     A,M
           0170  FE80            CPI     80H
           0172  C25902          JNZ     @7
 165   3              do;
 166   4                  call save$data$blk;
                                                 ; STATEMENT # 166
           0175  CD0000          CALL    SAVEDATABLK
 167   4                  a$data$ptr = 0;
                                                 ; STATEMENT # 167
           0178  2A0000          LHLD    ADATAPTRP
           017B  3600            MVI     M,0H
 168   4                  a$dbuf$read = FALSE;
                                                 ; STATEMENT # 168
           017D  2A0000          LHLD    ADBUFREADP
           0180  3600            MVI     M,0H
 169   4                  a$blk$seqno = a$blk$seqno + 1;
                                                 ; STATEMENT # 169
           0182  2A0000          LHLD    ABLKSEQNOP
           0185  4E              MOV     C,M
           0186  23              INX     H
PL/M-80 COMPILER                                                                                                PAGE   8


           0187  46              MOV     B,M
           0188  03              INX     B
           0189  2B              DCX     H
           018A  71              MOV     M,C
           018B  23              INX     H
           018C  70              MOV     M,B
 170   4                  a$ptr$ptr = a$ptr$ptr + 1;
                                                 ; STATEMENT # 170
           018D  2A0000          LHLD    APTRPTRP
           0190  34              INR     M
 171   4                  if a$ptr$ptr = 64 then
                                                 ; STATEMENT # 171
           0191  2A0000          LHLD    APTRPTRP
           0194  7E              MOV     A,M
           0195  FE40            CPI     40H
           0197  C25902          JNZ     @8
 172   4                  do;
 173   5                      if links(FLINK) = 0 then
                                                 ; STATEMENT # 173
           019A  2A0000          LHLD    POINTERBASE
           019D  23              INX     H
           019E  23              INX     H
           019F  3E00            MVI     A,0H
           01A1  CD0000          CALL    @P0103 
           01A4  B5              ORA     L
           01A5  C2FD01          JNZ     @9
 174   5                      do;
 175   6                          newptrblk = get$block(a$device);
                                                 ; STATEMENT # 175
           01A8  2A0000          LHLD    ADEVP
           01AB  4E              MOV     C,M
           01AC  CD0000          CALL    GETBLK
           01AF  220700          SHLD    NEWPTRBLK
 176   6                          links(FLINK) = newptrblk;   
                                                 ; STATEMENT # 176
           01B2  2A0000          LHLD    POINTERBASE
           01B5  23              INX     H
           01B6  23              INX     H
           01B7  E5              PUSH    H       ; 1
           01B8  2A0700          LHLD    NEWPTRBLK
           01BB  EB              XCHG
           01BC  E1              POP     H       ; 1
           01BD  73              MOV     M,E
           01BE  23              INX     H
           01BF  72              MOV     M,D
 177   6                          create = TRUE;
                                                 ; STATEMENT # 177
           01C0  210600          LXI     H,CREATE
           01C3  36FF            MVI     M,0FFH
 178   6                          a$ptr$change = TRUE;
                                                 ; STATEMENT # 178
           01C5  2A0000          LHLD    APTRCHANGEP
           01C8  36FF            MVI     M,0FFH
 179   6                          call clear$buf(temp := a$dbuf);
                                                 ; STATEMENT # 179
           01CA  2A0000          LHLD    ADBUFP
           01CD  5E              MOV     E,M
PL/M-80 COMPILER                                                                                                PAGE   9


           01CE  23              INX     H
           01CF  56              MOV     D,M
           01D0  EB              XCHG
           01D1  221200          SHLD    TEMP
           01D4  44              MOV     B,H
           01D5  4D              MOV     C,L
           01D6  CD0000          CALL    CLRBUF
 180   6                          newlinks(0) = a$ptr$blk;    /* save forward link */
                                                 ; STATEMENT # 180
           01D9  2A0000          LHLD    APTRBLKP
           01DC  E5              PUSH    H       ; 1
           01DD  2A1200          LHLD    TEMP
           01E0  E3              XTHL            ; 1
           01E1  4E              MOV     C,M
           01E2  23              INX     H
           01E3  46              MOV     B,M
           01E4  E1              POP     H       ; 1
           01E5  71              MOV     M,C
           01E6  23              INX     H
           01E7  70              MOV     M,B
 181   6                          call map$write(a$device);
                                                 ; STATEMENT # 181
           01E8  2A0000          LHLD    ADEVP
           01EB  4E              MOV     C,M
           01EC  CD0000          CALL    MAPWRI
 182   6                          call abswrite(newptrblk, a$dbuf);
                                                 ; STATEMENT # 182
           01EF  2A0000          LHLD    ADBUFP
           01F2  5E              MOV     E,M
           01F3  23              INX     H
           01F4  56              MOV     D,M
           01F5  2A0700          LHLD    NEWPTRBLK
           01F8  44              MOV     B,H
           01F9  4D              MOV     C,L
           01FA  CD0000          CALL    ABSWR
 183   6                      end;
                                                 ; STATEMENT # 183
                         @9:
        
 184   5                      call save$pointer$block;
                                                 ; STATEMENT # 184
           01FD  CD0000          CALL    SAVEPOINTERBLOCK
 185   5                      if create then
                                                 ; STATEMENT # 185
           0200  3A0600          LDA     CREATE
           0203  1F              RAR
           0204  D22D02          JNC     @10
 186   5                      do;
 187   6                          create = FALSE;
                                                 ; STATEMENT # 187
           0207  210600          LXI     H,CREATE
           020A  3600            MVI     M,0H
 188   6                          call clear$buf(temp := a$pbuf);
                                                 ; STATEMENT # 188
           020C  2A0000          LHLD    APBUFP
           020F  5E              MOV     E,M
           0210  23              INX     H
PL/M-80 COMPILER                                                                                                PAGE  10


           0211  56              MOV     D,M
           0212  EB              XCHG
           0213  221200          SHLD    TEMP
           0216  44              MOV     B,H
           0217  4D              MOV     C,L
           0218  CD0000          CALL    CLRBUF
 189   6                          newlinks(0) = a$ptr$blk;
                                                 ; STATEMENT # 189
           021B  2A0000          LHLD    APTRBLKP
           021E  E5              PUSH    H       ; 1
           021F  2A1200          LHLD    TEMP
           0222  E3              XTHL            ; 1
           0223  4E              MOV     C,M
           0224  23              INX     H
           0225  46              MOV     B,M
           0226  E1              POP     H       ; 1
           0227  71              MOV     M,C
           0228  23              INX     H
           0229  70              MOV     M,B
 190   6                      end;
                                                 ; STATEMENT # 190
           022A  C34802          JMP     @11
                         @10:
                              else
 191   5                      do;
 192   6                          call absread(newptrblk := links(FLINK), a$pbuf);
                                                 ; STATEMENT # 192
           022D  2A0000          LHLD    POINTERBASE
           0230  23              INX     H
           0231  23              INX     H
           0232  5E              MOV     E,M
           0233  23              INX     H
           0234  56              MOV     D,M
           0235  EB              XCHG
           0236  220700          SHLD    NEWPTRBLK
           0239  2A0000          LHLD    APBUFP
           023C  EB              XCHG
           023D  2B              DCX     H
           023E  4E              MOV     C,M
           023F  23              INX     H
           0240  46              MOV     B,M
           0241  EB              XCHG
           0242  5E              MOV     E,M
           0243  23              INX     H
           0244  56              MOV     D,M
           0245  CD0000          CALL    ABSRD
 193   6                      end;
                                                 ; STATEMENT # 193
                         @11:
 194   5                      a$ptr$blk = newptrblk;
                                                 ; STATEMENT # 194
           0248  2A0000          LHLD    APTRBLKP
           024B  E5              PUSH    H       ; 1
           024C  2A0700          LHLD    NEWPTRBLK
           024F  EB              XCHG
           0250  E1              POP     H       ; 1
           0251  73              MOV     M,E
PL/M-80 COMPILER                                                                                                PAGE  11


           0252  23              INX     H
           0253  72              MOV     M,D
 195   5                      a$ptr$ptr = 2;
                                                 ; STATEMENT # 195
           0254  2A0000          LHLD    APTRPTRP
           0257  3602            MVI     M,2H
 196   5                  end;
                                                 ; STATEMENT # 196
                         @8:
 197   4              end;
                                                 ; STATEMENT # 197
                         @7:
        
 198   3              adp$dif = 128 - a$data$ptr;
                                                 ; STATEMENT # 198
           0259  2A0000          LHLD    ADATAPTRP
           025C  3E80            MVI     A,80H
           025E  96              SUB     M
           025F  320300          STA     ADPDIF
 199   3              if a$blk$count <= a$blk$seqno AND READING then
                                                 ; STATEMENT # 199
           0262  2A0000          LHLD    ABCNTP
           0265  E5              PUSH    H       ; 1
           0266  2A0000          LHLD    ABLKSEQNOP
           0269  EB              XCHG
           026A  C1              POP     B       ; 1
           026B  CD0000          CALL    @P0098 
           026E  9F              SBB     A
           026F  2F              CMA
           0270  211100          LXI     H,READING
           0273  A6              ANA     M
           0274  1F              RAR
           0275  D29202          JNC     @12
 200   3              do;
 201   4                  eof$dif = a$eof$data$ptr - a$data$ptr;
                                                 ; STATEMENT # 201
           0278  2A0000          LHLD    AEOPP
           027B  E5              PUSH    H       ; 1
           027C  2A0000          LHLD    ADATAPTRP
           027F  C1              POP     B       ; 1
           0280  0A              LDAX    B
           0281  96              SUB     M
           0282  320200          STA     EOFDIF
 202   4                  if adp$dif > eof$dif then
                                                 ; STATEMENT # 202
           0285  210300          LXI     H,ADPDIF
           0288  BE              CMP     M
           0289  D29202          JNC     @13
 203   4                      adp$dif = eof$dif;
                                                 ; STATEMENT # 203
           028C  3A0200          LDA     EOFDIF
           028F  320300          STA     ADPDIF
                         @13:
 204   4              end;
                                                 ; STATEMENT # 204
                         @12:
 205   3              countdiff = count - actual;
PL/M-80 COMPILER                                                                                                PAGE  12


                                                 ; STATEMENT # 205
           0292  2A0F00          LHLD    ACTUALP
           0295  110D00          LXI     D,COUNT
           0298  CD0000          CALL    @P0099 
           029B  220000          SHLD    COUNTDIFF
 206   3              if adp$dif > count$diff then    /* check if more in buffer than needed */
                                                 ; STATEMENT # 206
           029E  EB              XCHG
           029F  3A0300          LDA     ADPDIF
           02A2  CD0000          CALL    @P0096 
           02A5  D2B002          JNC     @14
 207   3                  adp$dif = count$diff;
                                                 ; STATEMENT # 207
        
           02A8  2A0000          LHLD    COUNTDIFF
           02AB  EB              XCHG
           02AC  210300          LXI     H,ADPDIF
           02AF  73              MOV     M,E
                         @14:
        
 208   3              actual = actual + adp$dif;
                                                 ; STATEMENT # 208
           02B0  2A0F00          LHLD    ACTUALP
           02B3  3A0300          LDA     ADPDIF
           02B6  CD0000          CALL    @P0015 
           02B9  EB              XCHG
           02BA  2B              DCX     H
           02BB  73              MOV     M,E
           02BC  23              INX     H
           02BD  72              MOV     M,D
 209   3              non$sector$request = adp$dif <> 128;
                                                 ; STATEMENT # 209
           02BE  3A0300          LDA     ADPDIF
           02C1  D680            SUI     80H
           02C3  C6FF            ADI     255
           02C5  9F              SBB     A
           02C6  321400          STA     NONSECTORREQUEST
 210   3              adp$dif = adp$dif + a$data$ptr;
                                                 ; STATEMENT # 210
           02C9  2A0000          LHLD    ADATAPTRP
           02CC  3A0300          LDA     ADPDIF
           02CF  86              ADD     M
           02D0  320300          STA     ADPDIF
 211   3              work$buf = buffer;
                                                 ; STATEMENT # 211
           02D3  2A0B00          LHLD    BUFFER
           02D6  221500          SHLD    WORKBUF
 212   3              if non$sector$request then
                                                 ; STATEMENT # 212
           02D9  3A1400          LDA     NONSECTORREQUEST
           02DC  1F              RAR
           02DD  D2EA02          JNC     @15
 213   3                  work$buf = a$dbuf;
                                                 ; STATEMENT # 213
           02E0  2A0000          LHLD    ADBUFP
           02E3  5E              MOV     E,M
           02E4  23              INX     H
PL/M-80 COMPILER                                                                                                PAGE  13


           02E5  56              MOV     D,M
           02E6  EB              XCHG
           02E7  221500          SHLD    WORKBUF
                         @15:
 214   3              a$data$blk = links(a$ptr$ptr);
                                                 ; STATEMENT # 214
           02EA  2A0000          LHLD    APTRPTRP
           02ED  6E              MOV     L,M
           02EE  2600            MVI     H,0
           02F0  29              DAD     H
           02F1  EB              XCHG
           02F2  2A0000          LHLD    POINTERBASE
           02F5  19              DAD     D
           02F6  E5              PUSH    H       ; 1
           02F7  2A0000          LHLD    ADATABLKP
           02FA  E3              XTHL            ; 1
           02FB  4E              MOV     C,M
           02FC  23              INX     H
           02FD  46              MOV     B,M
           02FE  E1              POP     H       ; 1
           02FF  71              MOV     M,C
           0300  23              INX     H
           0301  70              MOV     M,B
 215   3              if a$data$blk = 0 then
                                                 ; STATEMENT # 215
           0302  2A0000          LHLD    ADATABLKP
           0305  3E00            MVI     A,0H
           0307  CD0000          CALL    @P0103 
           030A  B5              ORA     L
           030B  C25503          JNZ     @16
 216   3              do;
 217   4                  if reading then
                                                 ; STATEMENT # 217
           030E  3A1100          LDA     READING
           0311  1F              RAR
           0312  D22003          JNC     @17
 218   4                      call clear$buf(work$buf);
                                                 ; STATEMENT # 218
           0315  2A1500          LHLD    WORKBUF
           0318  44              MOV     B,H
           0319  4D              MOV     C,L
           031A  CD0000          CALL    CLRBUF
           031D  C35203          JMP     @18
                         @17:
                          else
 219   4                  do;
 220   5                      if non$sector$request then
                                                 ; STATEMENT # 220
           0320  3A1400          LDA     NONSECTORREQUEST
           0323  1F              RAR
           0324  D22F03          JNC     @19
 221   5                          call clear$buf(work$buf);
                                                 ; STATEMENT # 221
           0327  2A1500          LHLD    WORKBUF
           032A  44              MOV     B,H
           032B  4D              MOV     C,L
           032C  CD0000          CALL    CLRBUF
PL/M-80 COMPILER                                                                                                PAGE  14


                         @19:
 222   5                      a$ptr$change = TRUE;
                                                 ; STATEMENT # 222
           032F  2A0000          LHLD    APTRCHANGEP
           0332  36FF            MVI     M,0FFH
 223   5                      links(a$ptr$ptr), a$data$blk =  get$block(a$device);
                                                 ; STATEMENT # 223
           0334  2A0000          LHLD    ADEVP
           0337  4E              MOV     C,M
           0338  CD0000          CALL    GETBLK
           033B  E5              PUSH    H       ; 1
           033C  2A0000          LHLD    APTRPTRP
           033F  6E              MOV     L,M
           0340  2600            MVI     H,0
           0342  29              DAD     H
           0343  EB              XCHG
           0344  2A0000          LHLD    POINTERBASE
           0347  19              DAD     D
           0348  C1              POP     B       ; 1
           0349  71              MOV     M,C
           034A  23              INX     H
           034B  70              MOV     M,B
           034C  2A0000          LHLD    ADATABLKP
           034F  71              MOV     M,C
           0350  23              INX     H
           0351  70              MOV     M,B
 224   5                  end;
                                                 ; STATEMENT # 224
                         @18:
 225   4              end;
                                                 ; STATEMENT # 225
           0352  C37D03          JMP     @20
                         @16:
 226   3              else if a$dbuf$read then
                                                 ; STATEMENT # 226
           0355  2A0000          LHLD    ADBUFREADP
           0358  7E              MOV     A,M
           0359  1F              RAR
           035A  D26503          JNC     @21
 227   3                  non$sector$request = TRUE;
                                                 ; STATEMENT # 227
           035D  211400          LXI     H,NONSECTORREQUEST
           0360  36FF            MVI     M,0FFH
           0362  C37D03          JMP     @22
                         @21:
 228   3              else if non$sector$request OR reading then
                                                 ; STATEMENT # 228
           0365  3A1100          LDA     READING
           0368  211400          LXI     H,NONSECTORREQUEST
           036B  B6              ORA     M
           036C  1F              RAR
           036D  D27D03          JNC     @23
 229   3                  call abs$read(a$data$blk, work$buf);
                                                 ; STATEMENT # 229
           0370  2A0000          LHLD    ADATABLKP
           0373  4E              MOV     C,M
           0374  23              INX     H
PL/M-80 COMPILER                                                                                                PAGE  15


           0375  46              MOV     B,M
           0376  2A1500          LHLD    WORKBUF
           0379  EB              XCHG
           037A  CD0000          CALL    ABSRD
                         @23:
                         @22:
                         @20:
        
 230   3              if non$sector$request then
                                                 ; STATEMENT # 230
           037D  3A1400          LDA     NONSECTORREQUEST
           0380  1F              RAR
           0381  D2C803          JNC     @24
 231   3              do;
 232   4                  a$dbuf$read = TRUE;
                                                 ; STATEMENT # 232
           0384  2A0000          LHLD    ADBUFREADP
           0387  36FF            MVI     M,0FFH
 233   4                  datapp = a$data$ptr$p;
                                                 ; STATEMENT # 233
           0389  2A0000          LHLD    ADATAPTRP
           038C  220400          SHLD    DATAPP
 234   4                  if reading then
                                                 ; STATEMENT # 234
           038F  3A1100          LDA     READING
           0392  1F              RAR
           0393  D2A903          JNC     @25
 235   4                      call sysUsr(.buffer, buffer, datum$base);
                                                 ; STATEMENT # 235
           0396  010B00          LXI     B,BUFFER
           0399  C5              PUSH    B       ; 1
           039A  2A0B00          LHLD    BUFFER
           039D  44              MOV     B,H
           039E  4D              MOV     C,L
           039F  2A0000          LHLD    DATUMBASE
           03A2  EB              XCHG
           03A3  CD0000          CALL    SYSUSR
           03A6  C3BE03          JMP     @26
                         @25:
                          else
 236   4                  do;
 237   5                      a$data$change = TRUE;
                                                 ; STATEMENT # 237
           03A9  2A0000          LHLD    ADATACHANGEP
           03AC  36FF            MVI     M,0FFH
 238   5                      call usrSys(.buffer, buffer, datum$base);
                                                 ; STATEMENT # 238
           03AE  010B00          LXI     B,BUFFER
           03B1  C5              PUSH    B       ; 1
           03B2  2A0B00          LHLD    BUFFER
           03B5  44              MOV     B,H
           03B6  4D              MOV     C,L
           03B7  2A0000          LHLD    DATUMBASE
           03BA  EB              XCHG
           03BB  CD0000          CALL    USRSYS
 239   5                  end;
                                                 ; STATEMENT # 239
PL/M-80 COMPILER                                                                                                PAGE  16


                         @26:
 240   4                  a$data$ptr = adp$dif;
                                                 ; STATEMENT # 240
           03BE  2A0000          LHLD    ADATAPTRP
           03C1  3A0300          LDA     ADPDIF
           03C4  77              MOV     M,A
 241   4              end;
                                                 ; STATEMENT # 241
           03C5  C3EB03          JMP     @27
                         @24:
                      else
 242   3              do;
 243   4                  if not reading then
                                                 ; STATEMENT # 243
           03C8  3A1100          LDA     READING
           03CB  1F              RAR
           03CC  DADC03          JC      @28
 244   4                      call abswrite(a$data$blk, work$buf);
                                                 ; STATEMENT # 244
           03CF  2A0000          LHLD    ADATABLKP
           03D2  4E              MOV     C,M
           03D3  23              INX     H
           03D4  46              MOV     B,M
           03D5  2A1500          LHLD    WORKBUF
           03D8  EB              XCHG
           03D9  CD0000          CALL    ABSWR
                         @28:
 245   4                  a$data$ptr = 128;
                                                 ; STATEMENT # 245
           03DC  2A0000          LHLD    ADATAPTRP
           03DF  3680            MVI     M,80H
 246   4                  buffer = buffer + 128;
                                                 ; STATEMENT # 246
           03E1  118000          LXI     D,80H
           03E4  2A0B00          LHLD    BUFFER
           03E7  19              DAD     D
           03E8  220B00          SHLD    BUFFER
 247   4              end;
                                                 ; STATEMENT # 247
                         @27:
 248   3          end; /* of do while */
                                                 ; STATEMENT # 248
           03EB  C33701          JMP     @70
                         @71:
 249   2          call adjust$eof;
                                                 ; STATEMENT # 249
           03EE  CD8900          CALL    ADJUSTEOF
 250   2      end;
                                                 ; STATEMENT # 250
           03F1  C9              RET
        
        
        
 251   1      non$disk$select: PROCEDURE;
                                                 ; STATEMENT # 251
                         ; PROC  NONDISKSELECT
                  /*
PL/M-80 COMPILER                                                                                                PAGE  17


                     set logical file assignments to use monitor routines
                     for doing byte at a time I/O devices
                  */
 252   2          call ioset(((iostat := iochk) AND iobyteMasks(a$device)) or iobyteFlags(a$device));
                                                 ; STATEMENT # 252
           03F2  CD0000          CALL    IOCHK
           03F5  320900          STA     IOSTAT
           03F8  2A0000          LHLD    ADEVP
           03FB  4E              MOV     C,M
           03FC  0600            MVI     B,0
           03FE  210000          LXI     H,IOBYTEMASKS
           0401  09              DAD     B
           0402  A6              ANA     M
           0403  2A0000          LHLD    ADEVP
           0406  4E              MOV     C,M
           0407  0600            MVI     B,0
           0409  211D00          LXI     H,IOBYTEFLAGS
           040C  09              DAD     B
           040D  B6              ORA     M
           040E  4F              MOV     C,A
           040F  CD0000          CALL    IOSET
 253   2      end;
                                                 ; STATEMENT # 253
           0412  C9              RET
        
        
 254   1      read: PROCEDURE(aftn, buffer, count, actual$p) PUBLIC;
                                                 ; STATEMENT # 254
                         ; PROC  READ
           0413  211D00          LXI     H,ACTUALP+1H
           0416  72              MOV     M,D
           0417  2B              DCX     H
           0418  73              MOV     M,E
           0419  2B              DCX     H
           041A  70              MOV     M,B
           041B  2B              DCX     H
           041C  71              MOV     M,C
           041D  2B              DCX     H
           041E  D1              POP     D       
           041F  C1              POP     B       
           0420  70              MOV     M,B
           0421  2B              DCX     H
           0422  71              MOV     M,C
           0423  2B              DCX     H
           0424  C1              POP     B       
           0425  71              MOV     M,C
           0426  D5              PUSH    D       
 255   2          DECLARE aftn BYTE, (buffer, count, actual$p) ADDRESS;
 256   2          DECLARE actual BASED actual$p ADDRESS;
 257   2          DECLARE bytes BASED buffer BYTE;
        
 258   2          actual = 0;
                                                 ; STATEMENT # 258
           0427  2A1C00          LHLD    ACTUALP
           042A  3E00            MVI     A,0H
           042C  77              MOV     M,A
           042D  23              INX     H
PL/M-80 COMPILER                                                                                                PAGE  18


           042E  3600            MVI     M,0
 259   2          call aft$window(aftn);
                                                 ; STATEMENT # 259
           0430  2A1700          LHLD    AFTN
           0433  4D              MOV     C,L
           0434  CD0000          CALL    AWINDO
 260   2          if (a$access AND 1) = 0 then    /* not read */
                                                 ; STATEMENT # 260
           0437  2A0000          LHLD    AACESP
           043A  3E01            MVI     A,1H
           043C  A6              ANA     M
           043D  FE00            CPI     0H
           043F  C24704          JNZ     @29
 261   2              call warn(CANT$READ);
                                                 ; STATEMENT # 261
           0442  0E08            MVI     C,8H
           0444  CD0000          CALL    WARN
                         @29:
 262   2          if a$device = 26 then       /* BB */
                                                 ; STATEMENT # 262
           0447  2A0000          LHLD    ADEVP
           044A  7E              MOV     A,M
           044B  FE1A            CPI     1AH
           044D  C25104          JNZ     @30
 263   2              return;
                                                 ; STATEMENT # 263
           0450  C9              RET
                         @30:
 264   2          call non$disk$select;
                                                 ; STATEMENT # 264
           0451  CDF203          CALL    NONDISKSELECT
 265   2          if a$device <= F9DEV then
                                                 ; STATEMENT # 265
           0454  2A0000          LHLD    ADEVP
           0457  3E09            MVI     A,9H
           0459  BE              CMP     M
           045A  DA7404          JC      @31
 266   2          do;
 267   3              call rw(aftn, buffer, count, actual$p, TRUE);
                                                 ; STATEMENT # 267
           045D  2A1700          LHLD    AFTN
           0460  E5              PUSH    H       ; 1
           0461  2A1800          LHLD    BUFFER
           0464  E5              PUSH    H       ; 2
           0465  2A1A00          LHLD    COUNT
           0468  E5              PUSH    H       ; 3
           0469  2A1C00          LHLD    ACTUALP
           046C  44              MOV     B,H
           046D  4D              MOV     C,L
           046E  1EFF            MVI     E,0FFH
           0470  CD2001          CALL    RW
 268   3              return;
                                                 ; STATEMENT # 268
           0473  C9              RET
 269   3          end;
                                                 ; STATEMENT # 269
                         @31:
PL/M-80 COMPILER                                                                                                PAGE  19


        
 270   2          do while actual <> count;
                                                 ; STATEMENT # 270
                         @72:
           0474  2A1C00          LHLD    ACTUALP
           0477  111A00          LXI     D,COUNT
           047A  CD0000          CALL    @P0099 
           047D  B5              ORA     L
           047E  CABF04          JZ      @73
 271   3              if devClass(a$device) <> 0efh then
                                                 ; STATEMENT # 271
           0481  2A0000          LHLD    ADEVP
           0484  4E              MOV     C,M
           0485  0600            MVI     B,0
           0487  213A00          LXI     H,DEVCLASS
           048A  09              DAD     B
           048B  7E              MOV     A,M
           048C  FEEF            CPI     0EFH
           048E  CA9B04          JZ      @32
 272   3                  bytes = ci;
                                                 ; STATEMENT # 272
           0491  CD0000          CALL    CI
           0494  2A1800          LHLD    BUFFER
           0497  77              MOV     M,A
           0498  C3AA04          JMP     @33
                         @32:
                      else
 273   3              do;
 274   4                  bytes = ri;
                                                 ; STATEMENT # 274
           049B  CD0000          CALL    RI
           049E  2A1800          LHLD    BUFFER
           04A1  77              MOV     M,A
 275   4                  if CARRY then
                                                 ; STATEMENT # 275
           04A2  9F              SBB     A
           04A3  1F              RAR
           04A4  D2AA04          JNC     @34
 276   4                      goto done;
                                                 ; STATEMENT # 276
           04A7  C3BF04          JMP     DONE
                         @34:
 277   4              end;
                                                 ; STATEMENT # 277
                         @33:
 278   3              buffer = buffer + 1;
                                                 ; STATEMENT # 278
           04AA  2A1800          LHLD    BUFFER
           04AD  23              INX     H
           04AE  221800          SHLD    BUFFER
 279   3              actual = actual + 1;
                                                 ; STATEMENT # 279
           04B1  2A1C00          LHLD    ACTUALP
           04B4  4E              MOV     C,M
           04B5  23              INX     H
           04B6  46              MOV     B,M
           04B7  03              INX     B
PL/M-80 COMPILER                                                                                                PAGE  20


           04B8  2B              DCX     H
           04B9  71              MOV     M,C
           04BA  23              INX     H
           04BB  70              MOV     M,B
 280   3          end;
                                                 ; STATEMENT # 280
           04BC  C37404          JMP     @72
                         @73:
 281   2      done:
                                                 ; STATEMENT # 281
                         DONE:
           04BF  2A0900          LHLD    IOSTAT
           04C2  4D              MOV     C,L
           04C3  CD0000          CALL    IOSET
                  call ioset(iostat);
 282   2      end;
                                                 ; STATEMENT # 282
           04C6  C9              RET
        
        
        
 283   1      write: PROCEDURE(aftn, buffer, count) PUBLIC;
                                                 ; STATEMENT # 283
                         ; PROC  WRITE
           04C7  212200          LXI     H,COUNT+1H
           04CA  72              MOV     M,D
           04CB  2B              DCX     H
           04CC  73              MOV     M,E
           04CD  2B              DCX     H
           04CE  70              MOV     M,B
           04CF  2B              DCX     H
           04D0  71              MOV     M,C
           04D1  2B              DCX     H
           04D2  D1              POP     D       
           04D3  C1              POP     B       
           04D4  71              MOV     M,C
           04D5  D5              PUSH    D       
 284   2          DECLARE aftn byte, (buffer, count) ADDRESS;
 285   2          DECLARE bytes BASED buffer BYTE;
 286   2          DECLARE actual ADDRESS, i BYTE;
        
 287   2          call aft$window(aftn);
                                                 ; STATEMENT # 287
           04D6  2A1E00          LHLD    AFTN
           04D9  4D              MOV     C,L
           04DA  CD0000          CALL    AWINDO
 288   2          if (a$access and 2) = 0 then
                                                 ; STATEMENT # 288
           04DD  2A0000          LHLD    AACESP
           04E0  3E02            MVI     A,2H
           04E2  A6              ANA     M
           04E3  FE00            CPI     0H
           04E5  C2ED04          JNZ     @35
 289   2              call warn(CANT$WRITE);
                                                 ; STATEMENT # 289
           04E8  0E06            MVI     C,6H
           04EA  CD0000          CALL    WARN
PL/M-80 COMPILER                                                                                                PAGE  21


                         @35:
 290   2          if a$device = 26 then   /* BB */
                                                 ; STATEMENT # 290
           04ED  2A0000          LHLD    ADEVP
           04F0  7E              MOV     A,M
           04F1  FE1A            CPI     1AH
           04F3  C2F704          JNZ     @36
 291   2              return;
                                                 ; STATEMENT # 291
           04F6  C9              RET
                         @36:
 292   2          call non$disk$select;
                                                 ; STATEMENT # 292
        
           04F7  CDF203          CALL    NONDISKSELECT
 293   2          do while count <> 0;
                                                 ; STATEMENT # 293
                         @74:
           04FA  3E00            MVI     A,0H
           04FC  112100          LXI     D,COUNT
           04FF  CD0000          CALL    @P0101 
           0502  B5              ORA     L
           0503  CAAC05          JZ      @75
 294   3              do case devClass(a$device);
                                                 ; STATEMENT # 294
           0506  2A0000          LHLD    ADEVP
           0509  4E              MOV     C,M
           050A  0600            MVI     B,0
           050C  213A00          LXI     H,DEVCLASS
           050F  09              DAD     B
           0510  4E              MOV     C,M
           0511  0600            MVI     B,0
           0513  219305          LXI     H,@76
           0516  09              DAD     B
           0517  09              DAD     B
           0518  5E              MOV     E,M
           0519  23              INX     H
           051A  56              MOV     D,M
           051B  EB              XCHG
           051C  E9              PCHL
 295   4              do;     /* case 0 */
                                                 ; STATEMENT # 295
                         @38:
 296   5                  actual = 0;
                                                 ; STATEMENT # 296
           051D  210000          LXI     H,0H
           0520  222300          SHLD    ACTUAL
 297   5                  call rw(aftn, buffer, count, .actual, FALSE);
                                                 ; STATEMENT # 297
           0523  2A1E00          LHLD    AFTN
           0526  E5              PUSH    H       ; 1
           0527  2A1F00          LHLD    BUFFER
           052A  E5              PUSH    H       ; 2
           052B  2A2100          LHLD    COUNT
           052E  E5              PUSH    H       ; 3
           052F  1E00            MVI     E,0H
           0531  012300          LXI     B,ACTUAL
PL/M-80 COMPILER                                                                                                PAGE  22


           0534  CD2001          CALL    RW
 298   5                  return;
                                                 ; STATEMENT # 298
           0537  C9              RET
 299   5              end;
                                                 ; STATEMENT # 299
           0538  C39B05          JMP     @37
 300   4              do;     /* case 1 */
                                                 ; STATEMENT # 300
                         @39:
 301   5                  call CO(bytes);
                                                 ; STATEMENT # 301
           053B  2A1F00          LHLD    BUFFER
           053E  4E              MOV     C,M
           053F  CD0000          CALL    CO
 302   5                  if csts then
                                                 ; STATEMENT # 302
           0542  CD0000          CALL    CSTS
           0545  1F              RAR
           0546  D27C05          JNC     @40
 303   5                  do;
 304   6                      do i = 0 to 255;    /* delay a little */
                                                 ; STATEMENT # 304
           0549  212500          LXI     H,I
           054C  3600            MVI     M,0H
                         @77:
           054E  3EFF            MVI     A,0FFH
           0550  212500          LXI     H,I
           0553  BE              CMP     M
           0554  DA5E05          JC      @78
 305   7                      end;
                                                 ; STATEMENT # 305
                         @79:
           0557  212500          LXI     H,I
           055A  34              INR     M
           055B  C24E05          JNZ     @77
                         @78:
 306   6                      if csts then
                                                 ; STATEMENT # 306
           055E  CD0000          CALL    CSTS
           0561  1F              RAR
           0562  D27C05          JNC     @41
 307   6                          if (ci AND 7fh) = CONTROL$S then
                                                 ; STATEMENT # 307
           0565  CD0000          CALL    CI
           0568  E67F            ANI     7FH
           056A  FE13            CPI     13H
           056C  C27C05          JNZ     @42
 308   6                              do while (ci AND 7fh) <> CONTROL$Q;
                                                 ; STATEMENT # 308
                         @80:
           056F  CD0000          CALL    CI
           0572  E67F            ANI     7FH
           0574  FE11            CPI     11H
           0576  CA7C05          JZ      @81
 309   7                              end;
                                                 ; STATEMENT # 309
PL/M-80 COMPILER                                                                                                PAGE  23


           0579  C36F05          JMP     @80
                         @81:
                         @42:
                         @41:
        
 310   6                  end;
                                                 ; STATEMENT # 310
                         @40:
 311   5              end;
                                                 ; STATEMENT # 311
           057C  C39B05          JMP     @37
 312   4              call po(bytes);     /* case 2 */
                                                 ; STATEMENT # 312
                         @43:
           057F  2A1F00          LHLD    BUFFER
           0582  4E              MOV     C,M
           0583  CD0000          CALL    PO
           0586  C39B05          JMP     @37
 313   4              call lo(bytes);     /* case 3 */
                                                 ; STATEMENT # 313
                         @44:
           0589  2A1F00          LHLD    BUFFER
           058C  4E              MOV     C,M
           058D  CD0000          CALL    LO
           0590  C39B05          JMP     @37
 314   4              end;
                                                 ; STATEMENT # 314
                         @76:
           0593  1D05            DW      @38
           0595  3B05            DW      @39
           0597  7F05            DW      @43
           0599  8905            DW      @44
                         @37:
        
 315   3              count = count - 1;
                                                 ; STATEMENT # 315
           059B  2A2100          LHLD    COUNT
           059E  2B              DCX     H
           059F  222100          SHLD    COUNT
 316   3              buffer = buffer + 1;
                                                 ; STATEMENT # 316
           05A2  2A1F00          LHLD    BUFFER
           05A5  23              INX     H
           05A6  221F00          SHLD    BUFFER
 317   3          end;
                                                 ; STATEMENT # 317
           05A9  C3FA04          JMP     @74
                         @75:
 318   2          call ioset(iostat);
                                                 ; STATEMENT # 318
           05AC  2A0900          LHLD    IOSTAT
           05AF  4D              MOV     C,L
           05B0  CD0000          CALL    IOSET
 319   2      end;
                                                 ; STATEMENT # 319
           05B3  C9              RET
        
PL/M-80 COMPILER                                                                                                PAGE  24


        
        
 320   1      lined: PROCEDURE(aftn, buffer, count, actual$p) PUBLIC;
                                                 ; STATEMENT # 320
                         ; PROC  LINED
           05B4  212C00          LXI     H,ACTUALP+1H
           05B7  72              MOV     M,D
           05B8  2B              DCX     H
           05B9  73              MOV     M,E
           05BA  2B              DCX     H
           05BB  70              MOV     M,B
           05BC  2B              DCX     H
           05BD  71              MOV     M,C
           05BE  2B              DCX     H
           05BF  D1              POP     D       
           05C0  C1              POP     B       
           05C1  70              MOV     M,B
           05C2  2B              DCX     H
           05C3  71              MOV     M,C
           05C4  2B              DCX     H
           05C5  C1              POP     B       
           05C6  71              MOV     M,C
           05C7  D5              PUSH    D       
 321   2          DECLARE aftn BYTE, (buffer, count, actual$p) ADDRESS;
 322   2          DECLARE actual BASED actual$p ADDRESS;
 323   2          DECLARE lbuf ADDRESS,
                      in$mode BYTE,
                      lit$mode BYTE,
                      lptr BYTE,
                      char BYTE,
                      i BYTE,     /* note read clobbers selector as well */
                      selector BYTE;
 324   2          DECLARE obuf BASED buffer (1) BYTE;
 325   2          DECLARE bytes BASED lbuf (128) BYTE;
 326   2          DECLARE addr BASED lbuf (64) ADDRESS;
        
        
 327   2          echo: PROCEDURE(char);      /* nested sub of lined */
                                                 ; STATEMENT # 327
                         ; PROC  ECHO
           0883  213500          LXI     H,CHAR
           0886  71              MOV     M,C
 328   3              DECLARE char BYTE;
 329   3              call write(a$edit, .char, 1);
                                                 ; STATEMENT # 329
           0887  2A0000          LHLD    AEDITP
           088A  4E              MOV     C,M
           088B  C5              PUSH    B       ; 1
           088C  110100          LXI     D,1H
           088F  013500          LXI     B,CHAR
           0892  CDC704          CALL    WRITE
 330   3              call aft$window(aftn);
                                                 ; STATEMENT # 330
           0895  2A2600          LHLD    AFTN
           0898  4D              MOV     C,L
           0899  CD0000          CALL    AWINDO
 331   3          end;
PL/M-80 COMPILER                                                                                                PAGE  25


                                                 ; STATEMENT # 331
           089C  C9              RET
        
 332   2          echoCRLF: PROCEDURE;
                                                 ; STATEMENT # 332
                         ; PROC  ECHOCRLF
 333   3              call echo(CR);
                                                 ; STATEMENT # 333
           089D  0E0D            MVI     C,0DH
           089F  CD8308          CALL    ECHO
 334   3              call echo(LF);
                                                 ; STATEMENT # 334
           08A2  0E0A            MVI     C,0AH
           08A4  CD8308          CALL    ECHO
 335   3          end;
                                                 ; STATEMENT # 335
           08A7  C9              RET
        
 336   2          lineReset: PROCEDURE;       /* nested in lined */
                                                 ; STATEMENT # 336
                         ; PROC  LINERESET
 337   3              in$mode = FALSE;
                                                 ; STATEMENT # 337
           08A8  212F00          LXI     H,INMODE
           08AB  3600            MVI     M,0H
 338   3              lptr = 0;
                                                 ; STATEMENT # 338
           08AD  213100          LXI     H,LPTR
           08B0  3600            MVI     M,0H
 339   3          end;
                                                 ; STATEMENT # 339
           08B2  C9              RET
        
        
 340   2          lit$mode = FALSE;
                                                 ; STATEMENT # 340
           05C8  213000          LXI     H,LITMODE
           05CB  3600            MVI     M,0H
 341   2          lbuf = aft(aftn).lbuf;
                                                 ; STATEMENT # 341
           05CD  111C00          LXI     D,1CH
           05D0  2A2600          LHLD    AFTN
           05D3  2600            MVI     H,0
           05D5  CD0000          CALL    @P0034 
           05D8  010000          LXI     B,AFT
           05DB  09              DAD     B
           05DC  010400          LXI     B,LBUF
           05DF  09              DAD     B
           05E0  5E              MOV     E,M
           05E1  23              INX     H
           05E2  56              MOV     D,M
           05E3  EB              XCHG
           05E4  222D00          SHLD    LBUF
 342   2          lptr = bytes(126);
                                                 ; STATEMENT # 342
           05E7  017E00          LXI     B,7EH
           05EA  09              DAD     B
PL/M-80 COMPILER                                                                                                PAGE  26


           05EB  7E              MOV     A,M
           05EC  323100          STA     LPTR
 343   2          in$mode = bytes(127);
                                                 ; STATEMENT # 343
        
           05EF  2A2D00          LHLD    LBUF
           05F2  03              INX     B
           05F3  09              DAD     B
           05F4  7E              MOV     A,M
           05F5  322F00          STA     INMODE
 344   2          do while in$mode;
                                                 ; STATEMENT # 344
                         @82:
           05F8  3A2F00          LDA     INMODE
           05FB  1F              RAR
           05FC  D2E807          JNC     @83
 345   3              call read(aftn, .char, 1, .i);
                                                 ; STATEMENT # 345
           05FF  2A2600          LHLD    AFTN
           0602  E5              PUSH    H       ; 1
           0603  013200          LXI     B,CHAR
           0606  C5              PUSH    B       ; 2
           0607  50              MOV     D,B
           0608  59              MOV     E,C
           0609  010100          LXI     B,1H
           060C  13              INX     D
           060D  CD1304          CALL    READ
 346   3              if i = 0 then
                                                 ; STATEMENT # 346
           0610  3A3300          LDA     I
           0613  FE00            CPI     0H
           0615  C22A06          JNZ     @45
 347   3              do;
 348   4                  if aftn = AFT$CONSOLE then  /* 11 */
                                                 ; STATEMENT # 348
           0618  3A2600          LDA     AFTN
           061B  FE0B            CPI     0BH
           061D  C22506          JNZ     @46
 349   4                      call abortx(CONSOLE$EOF);
                                                 ; STATEMENT # 349
           0620  0E1D            MVI     C,1DH
           0622  CD0000          CALL    ABORTX
                         @46:
 350   4                  char = CONTROL$Z;
                                                 ; STATEMENT # 350
           0625  213200          LXI     H,CHAR
           0628  361A            MVI     M,1AH
 351   4              end;
                                                 ; STATEMENT # 351
                         @45:
 352   3              bytes(125) = FALSE;
                                                 ; STATEMENT # 352
           062A  017D00          LXI     B,7DH
           062D  2A2D00          LHLD    LBUF
           0630  09              DAD     B
           0631  3600            MVI     M,0H
 353   3              char = char AND 7fh;
PL/M-80 COMPILER                                                                                                PAGE  27


                                                 ; STATEMENT # 353
           0633  3A3200          LDA     CHAR
           0636  E67F            ANI     7FH
           0638  323200          STA     CHAR
 354   3              if char <> LF then
                                                 ; STATEMENT # 354
           063B  FE0A            CPI     0AH
           063D  CA5206          JZ      @47
 355   3                  call echo(bytes(lptr) := char);
                                                 ; STATEMENT # 355
           0640  2A3100          LHLD    LPTR
           0643  2600            MVI     H,0
           0645  EB              XCHG
           0646  2A2D00          LHLD    LBUF
           0649  19              DAD     D
           064A  3A3200          LDA     CHAR
           064D  77              MOV     M,A
           064E  4F              MOV     C,A
           064F  CD8308          CALL    ECHO
                         @47:
        
 356   3              selector = 0;
                                                 ; STATEMENT # 356
           0652  213400          LXI     H,SELECTOR
           0655  3600            MVI     M,0H
 357   3              do i = 0 to 9;
                                                 ; STATEMENT # 357
           0657  2B              DCX     H
           0658  3600            MVI     M,0H
                         @84:
           065A  3E09            MVI     A,9H
           065C  213300          LXI     H,I
           065F  BE              CMP     M
           0660  DA8006          JC      @85
 358   4                  if char = specialChars(i) then
                                                 ; STATEMENT # 358
           0663  2A3300          LHLD    I
           0666  2600            MVI     H,0
           0668  015700          LXI     B,SPECIALCHARS
           066B  09              DAD     B
           066C  3A3200          LDA     CHAR
           066F  BE              CMP     M
           0670  C27906          JNZ     @48
 359   4                      selector = i;
                                                 ; STATEMENT # 359
           0673  3A3300          LDA     I
           0676  323400          STA     SELECTOR
                         @48:
 360   4              end;    
                                                 ; STATEMENT # 360
                         @86:
           0679  213300          LXI     H,I
           067C  34              INR     M
           067D  C25A06          JNZ     @84
                         @85:
 361   3              selector = selector and not lit$mode;
                                                 ; STATEMENT # 361
PL/M-80 COMPILER                                                                                                PAGE  28


           0680  3A3000          LDA     LITMODE
           0683  2F              CMA
           0684  213400          LXI     H,SELECTOR
           0687  A6              ANA     M
           0688  77              MOV     M,A
 362   3              lit$mode = FALSE;
                                                 ; STATEMENT # 362
           0689  213000          LXI     H,LITMODE
           068C  3600            MVI     M,0H
 363   3              do case selector;
                                                 ; STATEMENT # 363
           068E  4F              MOV     C,A
           068F  0600            MVI     B,0
           0691  21C607          LXI     H,@87
           0694  09              DAD     B
           0695  09              DAD     B
           0696  5E              MOV     E,M
           0697  23              INX     H
           0698  56              MOV     D,M
           0699  EB              XCHG
           069A  E9              PCHL
 364   4                  lptr = lptr + 1;    /* case 0 - normal */
                                                 ; STATEMENT # 364
                         @50:
           069B  213100          LXI     H,LPTR
           069E  34              INR     M
           069F  C3DA07          JMP     @49
 365   4                  do;         /* case 1, rubout */
                                                 ; STATEMENT # 365
                         @51:
 366   5                      if lptr <> 0 then
                                                 ; STATEMENT # 366
           06A2  3A3100          LDA     LPTR
           06A5  FE00            CPI     0H
           06A7  CAF706          JZ      @52
 367   5                      do;
 368   6                          lptr = lptr - 1;
                                                 ; STATEMENT # 368
           06AA  213100          LXI     H,LPTR
           06AD  35              DCR     M
 369   6                          if aft(a$edit).device = 13 then
                                                 ; STATEMENT # 369
           06AE  2A0000          LHLD    AEDITP
           06B1  6E              MOV     L,M
           06B2  2600            MVI     H,0
           06B4  111C00          LXI     D,1CH
           06B7  CD0000          CALL    @P0034 
           06BA  010000          LXI     B,AFT
           06BD  09              DAD     B
           06BE  010100          LXI     B,DEVICE
           06C1  09              DAD     B
           06C2  7E              MOV     A,M
           06C3  FE0D            CPI     0DH
           06C5  C2E606          JNZ     @53
 370   6                          do;
 371   7                              call echo(BS);
                                                 ; STATEMENT # 371
PL/M-80 COMPILER                                                                                                PAGE  29


           06C8  0E08            MVI     C,8H
           06CA  CD8308          CALL    ECHO
 372   7                              bytes(lptr) = ' ';
                                                 ; STATEMENT # 372
           06CD  2A3100          LHLD    LPTR
           06D0  2600            MVI     H,0
           06D2  EB              XCHG
           06D3  2A2D00          LHLD    LBUF
           06D6  19              DAD     D
           06D7  3620            MVI     M,20H
 373   7                              call echo(' ');
                                                 ; STATEMENT # 373
           06D9  0E20            MVI     C,20H
           06DB  CD8308          CALL    ECHO
 374   7                              call echo(BS);
                                                 ; STATEMENT # 374
           06DE  0E08            MVI     C,8H
           06E0  CD8308          CALL    ECHO
 375   7                          end;
                                                 ; STATEMENT # 375
           06E3  C3F406          JMP     @54
                         @53:
                                  else
 376   6                              call echo(bytes(lptr));
                                                 ; STATEMENT # 376
           06E6  2A3100          LHLD    LPTR
           06E9  2600            MVI     H,0
           06EB  EB              XCHG
           06EC  2A2D00          LHLD    LBUF
           06EF  19              DAD     D
           06F0  4E              MOV     C,M
           06F1  CD8308          CALL    ECHO
                         @54:
 377   6                      end;
                                                 ; STATEMENT # 377
           06F4  C3FC06          JMP     @55
                         @52:
                              else
 378   5                          call echo(BELL);
                                                 ; STATEMENT # 378
           06F7  0E07            MVI     C,7H
           06F9  CD8308          CALL    ECHO
                         @55:
 379   5                  end;
                                                 ; STATEMENT # 379
           06FC  C3DA07          JMP     @49
 380   4                  do;         /* case 2 - control-Z */
                                                 ; STATEMENT # 380
                         @56:
 381   5                      actual = 0;
                                                 ; STATEMENT # 381
           06FF  2A2B00          LHLD    ACTUALP
           0702  3E00            MVI     A,0H
           0704  77              MOV     M,A
           0705  23              INX     H
           0706  3600            MVI     M,0
 382   5                      bytes(125) = TRUE;
PL/M-80 COMPILER                                                                                                PAGE  30


                                                 ; STATEMENT # 382
           0708  017D00          LXI     B,7DH
           070B  2A2D00          LHLD    LBUF
           070E  09              DAD     B
           070F  36FF            MVI     M,0FFH
 383   5                      addr(63) = 0ff00h;
                                                 ; STATEMENT # 383
           0711  2A2D00          LHLD    LBUF
           0714  03              INX     B
           0715  09              DAD     B
           0716  0100FF          LXI     B,0FF00H
           0719  71              MOV     M,C
           071A  23              INX     H
           071B  70              MOV     M,B
 384   5                      call echoCRLF;
                                                 ; STATEMENT # 384
           071C  CD9D08          CALL    ECHOCRLF
 385   5                      return;
                                                 ; STATEMENT # 385
           071F  C9              RET
 386   5                  end;
                                                 ; STATEMENT # 386
           0720  C3DA07          JMP     @49
 387   4                  do;         /* case 3 - control-R */
                                                 ; STATEMENT # 387
                         @57:
 388   5                      call echoCRLF;
                                                 ; STATEMENT # 388
           0723  CD9D08          CALL    ECHOCRLF
 389   5                      call write(a$edit, .bytes, lptr);
                                                 ; STATEMENT # 389
           0726  2A0000          LHLD    AEDITP
           0729  4E              MOV     C,M
           072A  C5              PUSH    B       ; 1
           072B  2A2D00          LHLD    LBUF
           072E  44              MOV     B,H
           072F  4D              MOV     C,L
           0730  2A3100          LHLD    LPTR
           0733  2600            MVI     H,0
           0735  EB              XCHG
           0736  CDC704          CALL    WRITE
 390   5                  end;
                                                 ; STATEMENT # 390
           0739  C3DA07          JMP     @49
 391   4                  do;         /* case 4 - control-X */
                                                 ; STATEMENT # 391
                         @58:
 392   5                      lptr = 0;
                                                 ; STATEMENT # 392
           073C  213100          LXI     H,LPTR
           073F  3600            MVI     M,0H
 393   5                      call echo('#');
                                                 ; STATEMENT # 393
           0741  0E23            MVI     C,23H
           0743  CD8308          CALL    ECHO
 394   5                      call echoCRLF;
                                                 ; STATEMENT # 394
PL/M-80 COMPILER                                                                                                PAGE  31


           0746  CD9D08          CALL    ECHOCRLF
 395   5                  end;
                                                 ; STATEMENT # 395
           0749  C3DA07          JMP     @49
 396   4                  do;         /* case 5 - CR */
                                                 ; STATEMENT # 396
                         @59:
 397   5                      bytes(lptr := lptr + 1) = LF;
                                                 ; STATEMENT # 397
           074C  3A3100          LDA     LPTR
           074F  3C              INR     A
           0750  323100          STA     LPTR
           0753  4F              MOV     C,A
           0754  0600            MVI     B,0
           0756  2A2D00          LHLD    LBUF
           0759  09              DAD     B
           075A  360A            MVI     M,0AH
 398   5                      call echo(LF);
                                                 ; STATEMENT # 398
           075C  0E0A            MVI     C,0AH
           075E  CD8308          CALL    ECHO
 399   5                      call lineReset;
                                                 ; STATEMENT # 399
           0761  CDA808          CALL    LINERESET
 400   5                  end;
                                                 ; STATEMENT # 400
           0764  C3DA07          JMP     @49
 401   4                  do;         /* case 6 - LF */
                                                 ; STATEMENT # 401
                         @60:
 402   5                      if lptr <> 0 then
                                                 ; STATEMENT # 402
           0767  3A3100          LDA     LPTR
           076A  FE00            CPI     0H
           076C  CA8407          JZ      @61
 403   5                      do;
 404   6                          call echo(bytes(lptr) := char);
                                                 ; STATEMENT # 404
           076F  2A3100          LHLD    LPTR
           0772  2600            MVI     H,0
           0774  EB              XCHG
           0775  2A2D00          LHLD    LBUF
           0778  19              DAD     D
           0779  3A3200          LDA     CHAR
           077C  77              MOV     M,A
           077D  4F              MOV     C,A
           077E  CD8308          CALL    ECHO
 405   6                          call lineReset;
                                                 ; STATEMENT # 405
           0781  CDA808          CALL    LINERESET
 406   6                      end;
                                                 ; STATEMENT # 406
                         @61:
 407   5                  end;
                                                 ; STATEMENT # 407
           0784  C3DA07          JMP     @49
 408   4                  do;         /* case 7 -  ESC */
PL/M-80 COMPILER                                                                                                PAGE  32


                                                 ; STATEMENT # 408
                         @62:
 409   5                      call echo(0);
                                                 ; STATEMENT # 409
           0787  0E00            MVI     C,0H
           0789  CD8308          CALL    ECHO
 410   5                      call echo('$');
                                                 ; STATEMENT # 410
           078C  0E24            MVI     C,24H
           078E  CD8308          CALL    ECHO
 411   5                      call lineReset;
                                                 ; STATEMENT # 411
           0791  CDA808          CALL    LINERESET
 412   5                  end;
                                                 ; STATEMENT # 412
           0794  C3DA07          JMP     @49
 413   4                  do;         /* case 8 - Control-E */
                                                 ; STATEMENT # 413
                         @63:
 414   5                      if aftn = AFT$CONSOLE then
                                                 ; STATEMENT # 414
           0797  3A2600          LDA     AFTN
           079A  FE0B            CPI     0BH
           079C  C2BB07          JNZ     @64
 415   5                      do;
 416   6                          i = aft(AFT$CONSOLE).device;
                                                 ; STATEMENT # 416
           079F  3A3501          LDA     AFT+135H
           07A2  323300          STA     I
 417   6                          aft(AFT$CONSOLE).device = alt$cidev;
                                                 ; STATEMENT # 417
           07A5  3A0000          LDA     ALTCIDEV
           07A8  323501          STA     AFT+135H
 418   6                          alt$cidev = i;
                                                 ; STATEMENT # 418
           07AB  3A3300          LDA     I
           07AE  320000          STA     ALTCIDEV
 419   6                          call echo('^');
                                                 ; STATEMENT # 419
           07B1  0E5E            MVI     C,5EH
           07B3  CD8308          CALL    ECHO
 420   6                          call echo('E');
                                                 ; STATEMENT # 420
           07B6  0E45            MVI     C,45H
           07B8  CD8308          CALL    ECHO
 421   6                      end;
                                                 ; STATEMENT # 421
                         @64:
 422   5                  end;
                                                 ; STATEMENT # 422
           07BB  C3DA07          JMP     @49
 423   4                  lit$mode = TRUE;    /* case 8 - control-P */
                                                 ; STATEMENT # 423
                         @65:
           07BE  213000          LXI     H,LITMODE
           07C1  36FF            MVI     M,0FFH
           07C3  C3DA07          JMP     @49
PL/M-80 COMPILER                                                                                                PAGE  33


 424   4              end; /* of case */
                                                 ; STATEMENT # 424
                         @87:
           07C6  9B06            DW      @50
           07C8  A206            DW      @51
           07CA  FF06            DW      @56
           07CC  2307            DW      @57
           07CE  3C07            DW      @58
           07D0  4C07            DW      @59
           07D2  6707            DW      @60
           07D4  8707            DW      @62
           07D6  9707            DW      @63
           07D8  BE07            DW      @65
                         @49:
 425   3              if lptr = 122 then
                                                 ; STATEMENT # 425
           07DA  3A3100          LDA     LPTR
           07DD  FE7A            CPI     7AH
           07DF  C2E507          JNZ     @66
 426   3                  call lineReset;
                                                 ; STATEMENT # 426
           07E2  CDA808          CALL    LINERESET
                         @66:
 427   3          end;
                                                 ; STATEMENT # 427
           07E5  C3F805          JMP     @82
                         @83:
        
 428   2          actual = 0;
                                                 ; STATEMENT # 428
           07E8  2A2B00          LHLD    ACTUALP
           07EB  3E00            MVI     A,0H
           07ED  77              MOV     M,A
           07EE  23              INX     H
           07EF  3600            MVI     M,0
 429   2          do while actual < count and not in$mode;
                                                 ; STATEMENT # 429
                         @88:
           07F1  2A2B00          LHLD    ACTUALP
           07F4  EB              XCHG
           07F5  012900          LXI     B,COUNT
           07F8  CD0000          CALL    @P0098 
           07FB  9F              SBB     A
           07FC  F5              PUSH    PSW     ; 1
           07FD  3A2F00          LDA     INMODE
           0800  2F              CMA
           0801  C1              POP     B       ; 1
           0802  48              MOV     C,B
           0803  A1              ANA     C
           0804  1F              RAR
           0805  D26E08          JNC     @89
 430   3              if lptr < MAXLL then    /* 122 */
                                                 ; STATEMENT # 430
           0808  3A3100          LDA     LPTR
           080B  FE7A            CPI     7AH
           080D  D26108          JNC     @67
 431   3              do;
PL/M-80 COMPILER                                                                                                PAGE  34


 432   4                  if (obuf(actual) := bytes(lptr)) = LF OR bytes(lptr) = ESC then
                                                 ; STATEMENT # 432
           0810  2A3100          LHLD    LPTR
           0813  2600            MVI     H,0
           0815  EB              XCHG
           0816  2A2D00          LHLD    LBUF
           0819  19              DAD     D
           081A  E5              PUSH    H       ; 1
           081B  2A2B00          LHLD    ACTUALP
           081E  4E              MOV     C,M
           081F  23              INX     H
           0820  46              MOV     B,M
           0821  2A2700          LHLD    BUFFER
           0824  09              DAD     B
           0825  C1              POP     B       ; 1
           0826  0A              LDAX    B
           0827  77              MOV     M,A
           0828  D60A            SUI     0AH
           082A  D601            SUI     1
           082C  9F              SBB     A
           082D  2A3100          LHLD    LPTR
           0830  2600            MVI     H,0
           0832  EB              XCHG
           0833  2A2D00          LHLD    LBUF
           0836  19              DAD     D
           0837  F5              PUSH    PSW     ; 1
           0838  7E              MOV     A,M
           0839  D61B            SUI     1BH
           083B  D601            SUI     1
           083D  9F              SBB     A
           083E  C1              POP     B       ; 1
           083F  48              MOV     C,B
           0840  B1              ORA     C
           0841  1F              RAR
           0842  D24F08          JNC     @68
 433   4                  do;
 434   5                      in$mode = TRUE;
                                                 ; STATEMENT # 434
           0845  212F00          LXI     H,INMODE
           0848  36FF            MVI     M,0FFH
 435   5                      lptr = -1;
                                                 ; STATEMENT # 435
           084A  213100          LXI     H,LPTR
           084D  36FF            MVI     M,0FFH
 436   5                  end;
                                                 ; STATEMENT # 436
                         @68:
        
 437   4                  actual = actual + 1;
                                                 ; STATEMENT # 437
           084F  2A2B00          LHLD    ACTUALP
           0852  4E              MOV     C,M
           0853  23              INX     H
           0854  46              MOV     B,M
           0855  03              INX     B
           0856  2B              DCX     H
           0857  71              MOV     M,C
PL/M-80 COMPILER                                                                                                PAGE  35


           0858  23              INX     H
           0859  70              MOV     M,B
 438   4                  lptr = lptr + 1;
                                                 ; STATEMENT # 438
           085A  213100          LXI     H,LPTR
           085D  34              INR     M
 439   4              end;
                                                 ; STATEMENT # 439
           085E  C36B08          JMP     @69
                         @67:
                      else
 440   3              do;
 441   4                  in$mode = TRUE;
                                                 ; STATEMENT # 441
           0861  212F00          LXI     H,INMODE
           0864  36FF            MVI     M,0FFH
 442   4                  lptr = 0;
                                                 ; STATEMENT # 442
           0866  213100          LXI     H,LPTR
           0869  3600            MVI     M,0H
 443   4              end;
                                                 ; STATEMENT # 443
                         @69:
 444   3          end;
                                                 ; STATEMENT # 444
           086B  C3F107          JMP     @88
                         @89:
 445   2          bytes(126) = lptr;
                                                 ; STATEMENT # 445
           086E  017E00          LXI     B,7EH
           0871  2A2D00          LHLD    LBUF
           0874  09              DAD     B
           0875  3A3100          LDA     LPTR
           0878  77              MOV     M,A
 446   2          bytes(127) = in$mode;
                                                 ; STATEMENT # 446
           0879  2A2D00          LHLD    LBUF
           087C  03              INX     B
           087D  09              DAD     B
           087E  3A2F00          LDA     INMODE
           0881  77              MOV     M,A
 447   2      end;
                                                 ; STATEMENT # 447
           0882  C9              RET
        
        
        
 448   1      end;
              eof



MODULE INFORMATION:

     CODE AREA SIZE     = 08B3H   2227D
     VARIABLE AREA SIZE = 0036H     54D
     MAXIMUM STACK SIZE = 0010H     16D
PL/M-80 COMPILER                                                                                                PAGE  36


     501 LINES READ
     0 PROGRAM ERRORS

END OF PL/M-80 COMPILATION
