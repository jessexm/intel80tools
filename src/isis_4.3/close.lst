PL/M-80 COMPILER                                                                                                PAGE   1


ISIS-II PL/M-80 V4.0 COMPILATION OF MODULE CLOSE
OBJECT MODULE PLACED IN CLOSE.OBJ
COMPILER INVOKED BY:  :F1:plm80 close.plm PRINT(CLOSE.LST) OBJECT(CLOSE.OBJ) DEBUG OPTIMIZE CODE



   1          close:
              do;
              $include(close.ipx)
   2   1  =   declare a$access$p literally 'aAcesP';
   3   1  =   declare a$blk$count$p literally 'aBCntP';
   4   1  =   declare a$empty$p literally 'aEmtyP';
   5   1  =   declare a$eof$data$ptr$p literally 'aEoPP';
   6   1  =   declare Aft$Window literally 'AWindo';
   7   1  =   declare Map$Write literally 'MapWri';
   8   1  =   declare AFT$T literally 'structure(AFT$T1, AFT$T2, AFT$T3, AFT$T4)';
   9   1  =   declare AFT$T1 literally 'empty BYTE, device BYTE, access BYTE, edit BYTE, lbuf ADDRESS';
  10   1  =   declare AFT$T2 literally 'dbuf ADDRESS, pbuf ADDRESS, data$ptr BYTE, i$no ADDRESS, ptr$ptr BYTE';
  11   1  =   declare AFT$T3 literally 'eofcnt BYTE, ptr$change BYTE, data$change BYTE, blk ADDRESS, blk$seq ADDRESS';
  12   1  =   declare AFT$T4 literally 'ptr$blk ADDRESS, hdr$blk ADDRESS, data$blk$count ADDRESS, dbuf$read BYTE';
  13   1  =   declare BOOLEAN literally 'BYTE';
  14   1  =   declare DIRECT$T literally 'structure(DIRECT$T1, DIRECT$T2)';
  15   1  =   declare DIRECT$T1 literally 'empty BOOLEAN, file(6) BYTE, ext(3) BYTE, attrib BYTE';
  16   1  =   declare DIRECT$T2 literally 'eof$count BYTE, blk ADDRESS, hdr$blk ADDRESS';
  17   1  =   declare SEEK$ABS literally '2';
  18   1  =   declare TRUE literally '0ffh';
  19   1  =   declare a$access$p address external;
  20   1  =   declare a$blk$count$p address external;
  21   1  =   declare a$data$ptr$p address external;
  22   1  =   declare a$dbuf$p address external;
  23   1  =   declare a$dev$p address external;
  24   1  =   declare a$edit$p address external;
  25   1  =   declare a$empty$p address external;
  26   1  =   declare a$eof$data$ptr$p address external;
  27   1  =   declare aft(18) AFT$T external;
  28   1  =   declare a$i$no$p address external;
  29   1  =   declare a$lbuf$p address external;
  30   1  =   declare a$pbuf$p address external;
  31   1  =   declare direct DIRECT$T external;
  32   1  =   adjust$eof: procedure external; end;
  34   1  =   Aft$Window: procedure(slot$number) external; declare slot$number byte; end;
  37   1  =   attrib: procedure(file$ptr, swid, value) external;
  38   2  =             declare file$ptr address, swid address, value BOOLEAN; end;
  40   1  =   dir$close: procedure(aftn) external; declare aftn byte; end;
  43   1  =   MapWrite: procedure(diskNum) external; declare diskNum byte; end;
  46   1  =   read: procedure(aftn, buffer, count, actual$p) external;
  47   2  =           declare aftn byte, buffer address, count address, actual$p address; end;
  49   1  =   return$buf: procedure(buf$address) external; declare buf$address address; end;
  52   1  =   rewind: procedure external; end;
  54   1  =   save$data$blk: procedure external; end;
  56   1  =   save$pointer$block: procedure external; end;
  58   1  =   seek: procedure(aftn, mode, blockptr, byteptr) external;
  59   2  =           declare aftn byte, mode address, blockptr address, byteptr address; end;
  61   1  =   write: procedure(aftn, buffer, count) external; declare aftn byte, buffer address, count address; end;
  64   1  =   declare a$access based a$access$p  byte;
  65   1  =   declare a$blk$count based a$blk$count$p  address;
  66   1  =   declare a$data$ptr based a$data$ptr$p  byte;
PL/M-80 COMPILER                                                                                                PAGE   2


  67   1  =   declare a$dbuf based a$dbuf$p  address;
  68   1  =   declare a$device based a$dev$p  byte;
  69   1  =   declare a$edit based a$edit$p  byte;
  70   1  =   declare a$empty based a$empty$p  byte;
  71   1  =   declare a$eof$data$ptr based a$eof$data$ptr$p  byte;
  72   1  =   declare a$i$no based a$i$no$p  address;
  73   1  =   declare a$lbuf based a$lbuf$p  address;
  74   1  =   declare a$pbuf based a$pbuf$p  address;
        
        
        
  75   1      DECLARE caseMap(*) BYTE DATA (0,0,0,0,0,0,0,0,0,0,  /* F0-F9 */
                                1,2,1,2,1,2,1,1,1,1,  /* TI, TO, VI, VO, I1, O1, TR, HR, T1, T2 */
                                3,3,3,3,4,4,1,1,1);   /* TP, HP, P1, P2, LP, L1, BB, CI, CO */
        
  76   1      DECLARE t$blk   ADDRESS,
                  t$eof   BYTE,
                  zero    ADDRESS INITIAL(0),
                  bytes   ADDRESS INITIAL(0);
        
  77   1      close: PROCEDURE(aftn) PUBLIC;
                                                 ; STATEMENT # 77
                         ; PROC  CLOSE
           001E  210700          LXI     H,AFTN
           0021  71              MOV     M,C
  78   2          DECLARE aftn BYTE;
  79   2          DECLARE i ADDRESS;
        
  80   2          call aft$window(aftn);
                                                 ; STATEMENT # 80
           0022  2A0700          LHLD    AFTN
           0025  4D              MOV     C,L
           0026  CD0000          CALL    AWINDO
  81   2          if a$empty then
                                                 ; STATEMENT # 81
           0029  2A0000          LHLD    AEMTYP
           002C  7E              MOV     A,M
           002D  1F              RAR
           002E  D23200          JNC     @1
  82   2              return;
                                                 ; STATEMENT # 82
           0031  C9              RET
                         @1:
  83   2          if a$edit <> 0 then
                                                 ; STATEMENT # 83
           0032  2A0000          LHLD    AEDITP
           0035  7E              MOV     A,M
           0036  FE00            CPI     0H
           0038  CA4400          JZ      @2
  84   2              call return$buf(a$lbuf);
                                                 ; STATEMENT # 84
           003B  2A0000          LHLD    ALBUFP
           003E  4E              MOV     C,M
           003F  23              INX     H
           0040  46              MOV     B,M
           0041  CD0000          CALL    RETURNBUF
                         @2:
PL/M-80 COMPILER                                                                                                PAGE   3


  85   2          do case caseMap(a$device);
                                                 ; STATEMENT # 85
           0044  2A0000          LHLD    ADEVP
           0047  4E              MOV     C,M
           0048  0600            MVI     B,0
           004A  210000          LXI     H,CASEMAP
           004D  09              DAD     B
           004E  4E              MOV     C,M
           004F  0600            MVI     B,0
           0051  216E01          LXI     H,@10
           0054  09              DAD     B
           0055  09              DAD     B
           0056  5E              MOV     E,M
           0057  23              INX     H
           0058  56              MOV     D,M
           0059  EB              XCHG
           005A  E9              PCHL
  86   3              do; /* 0 - disk */
                                                 ; STATEMENT # 86
                         @4:
  87   4                  call save$data$blk;
                                                 ; STATEMENT # 87
           005B  CD0000          CALL    SAVEDATABLK
  88   4                  call save$pointer$block;
                                                 ; STATEMENT # 88
           005E  CD0000          CALL    SAVEPOINTERBLOCK
  89   4                  call return$buf(a$pbuf);
                                                 ; STATEMENT # 89
           0061  2A0000          LHLD    APBUFP
           0064  4E              MOV     C,M
           0065  23              INX     H
           0066  46              MOV     B,M
           0067  CD0000          CALL    RETURNBUF
  90   4                  call return$buf(a$dbuf);
                                                 ; STATEMENT # 90
           006A  2A0000          LHLD    ADBUFP
           006D  4E              MOV     C,M
           006E  23              INX     H
           006F  46              MOV     B,M
           0070  CD0000          CALL    RETURNBUF
  91   4                  if a$access >= 2 then
                                                 ; STATEMENT # 91
           0073  2A0000          LHLD    AACESP
           0076  7E              MOV     A,M
           0077  FE02            CPI     2H
           0079  DA3401          JC      @5
  92   4                  do;
  93   5                      call adjust$eof;
                                                 ; STATEMENT # 93
           007C  CD0000          CALL    ADJUSTEOF
  94   5                      t$eof = a$eof$data$ptr;
                                                 ; STATEMENT # 94
           007F  2A0000          LHLD    AEOPP
           0082  7E              MOV     A,M
           0083  320200          STA     TEOF
  95   5                      t$blk = a$blk$count;
                                                 ; STATEMENT # 95
PL/M-80 COMPILER                                                                                                PAGE   4


           0086  2A0000          LHLD    ABCNTP
           0089  5E              MOV     E,M
           008A  23              INX     H
           008B  56              MOV     D,M
           008C  EB              XCHG
           008D  220000          SHLD    TBLK
  96   5                      bytes = a$i$no * 16;
                                                 ; STATEMENT # 96
           0090  2A0000          LHLD    AINOP
           0093  5E              MOV     E,M
           0094  23              INX     H
           0095  56              MOV     D,M
           0096  EB              XCHG
           0097  29              DAD     H
           0098  29              DAD     H
           0099  29              DAD     H
           009A  29              DAD     H
           009B  220500          SHLD    BYTES
  97   5                      call map$write(a$device);
                                                 ; STATEMENT # 97
           009E  2A0000          LHLD    ADEVP
           00A1  4E              MOV     C,M
           00A2  CD0000          CALL    MAPWRI
  98   5                      aft(a$device).dbuf = a$dbuf;        /* let device use returned buffers */
                                                 ; STATEMENT # 98
           00A5  2A0000          LHLD    ADBUFP
           00A8  E5              PUSH    H       ; 1
           00A9  2A0000          LHLD    ADEVP
           00AC  6E              MOV     L,M
           00AD  2600            MVI     H,0
           00AF  111C00          LXI     D,1CH
           00B2  CD0000          CALL    @P0034 
           00B5  010000          LXI     B,AFT
           00B8  09              DAD     B
           00B9  010600          LXI     B,DBUF
           00BC  09              DAD     B
           00BD  E3              XTHL            ; 1
           00BE  4E              MOV     C,M
           00BF  23              INX     H
           00C0  46              MOV     B,M
           00C1  E1              POP     H       ; 1
           00C2  71              MOV     M,C
           00C3  23              INX     H
           00C4  70              MOV     M,B
  99   5                      aft(a$device).pbuf = a$pbuf;
                                                 ; STATEMENT # 99
           00C5  2A0000          LHLD    APBUFP
           00C8  E5              PUSH    H       ; 1
           00C9  2A0000          LHLD    ADEVP
           00CC  6E              MOV     L,M
           00CD  2600            MVI     H,0
           00CF  111C00          LXI     D,1CH
           00D2  CD0000          CALL    @P0034 
           00D5  010000          LXI     B,AFT
           00D8  09              DAD     B
           00D9  010800          LXI     B,PBUF
           00DC  09              DAD     B
PL/M-80 COMPILER                                                                                                PAGE   5


           00DD  E3              XTHL            ; 1
           00DE  4E              MOV     C,M
           00DF  23              INX     H
           00E0  46              MOV     B,M
           00E1  E1              POP     H       ; 1
           00E2  71              MOV     M,C
           00E3  23              INX     H
           00E4  70              MOV     M,B
 100   5                      call aft$window(a$device);
                                                 ; STATEMENT # 100
           00E5  2A0000          LHLD    ADEVP
           00E8  4E              MOV     C,M
           00E9  CD0000          CALL    AWINDO
 101   5                      call rewind;        /* get to dir header */
                                                 ; STATEMENT # 101
           00EC  CD0000          CALL    REWIND
 102   5                      call seek(a$device, SEEK$ABS, .zero, .bytes);   /* seek to file entry */
                                                 ; STATEMENT # 102
           00EF  2A0000          LHLD    ADEVP
           00F2  4E              MOV     C,M
           00F3  C5              PUSH    B       ; 1
           00F4  010200          LXI     B,2H
           00F7  C5              PUSH    B       ; 2
           00F8  110500          LXI     D,BYTES
           00FB  010300          LXI     B,ZERO
           00FE  CD0000          CALL    SEEK
 103   5                      call read(a$device, .direct, 16, .i);       /* read the dir entry */
                                                 ; STATEMENT # 103
           0101  2A0000          LHLD    ADEVP
           0104  4E              MOV     C,M
           0105  C5              PUSH    B       ; 1
           0106  010000          LXI     B,DIRECT
           0109  C5              PUSH    B       ; 2
           010A  110800          LXI     D,I
           010D  011000          LXI     B,10H
           0110  CD0000          CALL    READ
 104   5                      direct.eof$count = t$eof;
                                                 ; STATEMENT # 104
           0113  3A0200          LDA     TEOF
           0116  320B00          STA     DIRECT+0BH
 105   5                      direct.blk = t$blk;
                                                 ; STATEMENT # 105
           0119  2A0000          LHLD    TBLK
           011C  220C00          SHLD    DIRECT+0CH
 106   5                      a$data$ptr = a$data$ptr - DOUBLE(16);
                                                 ; STATEMENT # 106
           011F  2A0000          LHLD    ADATAPTRP
           0122  7E              MOV     A,M
           0123  E5              PUSH    H       ; 1
           0124  211000          LXI     H,10H
           0127  CD0000          CALL    @P0094 
           012A  EB              XCHG
           012B  E1              POP     H       ; 1
           012C  73              MOV     M,E
 107   5                      call dir$close(a$device);
                                                 ; STATEMENT # 107
           012D  2A0000          LHLD    ADEVP
PL/M-80 COMPILER                                                                                                PAGE   6


           0130  4E              MOV     C,M
           0131  CD0000          CALL    DIRCLOSE
 108   5                  end;
                                                 ; STATEMENT # 108
                         @5:
 109   4              end;
                                                 ; STATEMENT # 109
           0134  C37801          JMP     @3
 110   3              ;   /* 1 */
                                                 ; STATEMENT # 110
                         @6:
           0137  C37801          JMP     @3
 111   3              ;   /* 2 */
                                                 ; STATEMENT # 111
                         @7:
           013A  C37801          JMP     @3
 112   3              do i = 0 to 119;    /* 3 output 120 nulls */
                                                 ; STATEMENT # 112
                         @8:
           013D  210000          LXI     H,0H
           0140  220800          SHLD    I
                         @11:
           0143  3E77            MVI     A,77H
           0145  210800          LXI     H,I
           0148  CD0000          CALL    @P0103 
           014B  DA6801          JC      @12
 113   4                  call write(aftn, .(0), 1);
                                                 ; STATEMENT # 113
           014E  2A0700          LHLD    AFTN
           0151  E5              PUSH    H       ; 1
           0152  110100          LXI     D,1H
           0155  011D00          LXI     B,$-138H
           0158  CD0000          CALL    WRITE
 114   4              end;
                                                 ; STATEMENT # 114
           015B  110100          LXI     D,1H
           015E  2A0800          LHLD    I
           0161  19              DAD     D
           0162  220800          SHLD    I
           0165  D24301          JNC     @11
                         @12:
           0168  C37801          JMP     @3
 115   3              ;   /* 4 */
                                                 ; STATEMENT # 115
                         @9:
           016B  C37801          JMP     @3
 116   3          end;
                                                 ; STATEMENT # 116
                         @10:
           016E  5B00            DW      @4
           0170  3701            DW      @6
           0172  3A01            DW      @7
           0174  3D01            DW      @8
           0176  6B01            DW      @9
                         @3:
 117   2          aft(aftn).empty = TRUE;
                                                 ; STATEMENT # 117
PL/M-80 COMPILER                                                                                                PAGE   7


           0178  111C00          LXI     D,1CH
           017B  2A0700          LHLD    AFTN
           017E  2600            MVI     H,0
           0180  CD0000          CALL    @P0034 
           0183  010000          LXI     B,AFT
           0186  09              DAD     B
           0187  36FF            MVI     M,0FFH
 118   2      end;    
                                                 ; STATEMENT # 118
           0189  C9              RET
 119   1      end;
              eof



MODULE INFORMATION:

     CODE AREA SIZE     = 018AH    394D
     VARIABLE AREA SIZE = 000AH     10D
     MAXIMUM STACK SIZE = 0006H      6D
     116 LINES READ
     0 PROGRAM ERRORS

END OF PL/M-80 COMPILATION
