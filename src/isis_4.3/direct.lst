PL/M-80 COMPILER                                                                                                PAGE   1


ISIS-II PL/M-80 V4.0 COMPILATION OF MODULE DIRECT
OBJECT MODULE PLACED IN DIRECT.OBJ
COMPILER INVOKED BY:  :F1:plm80 direct.plm PRINT(DIRECT.LST) OBJECT(DIRECT.OBJ) DEBUG OPTIMIZE CODE



   1          direct:
              do;
        
              /*
                  ABSTRACT
                      All knowledge about the format and location of a diskette
                      directory is contained by this module
        
                  Module organisation
                      The module contains a data adara, which normally contains
                      the information from a single entry in a diskette directory
                      and the procedures dir$close and dlook
        
                  Invariants
                      On every diskette, the directory file is partitioned into
                      'entries' containing 16 bytes of data each.
                      The various byte- and address-variables within an entry are
                      given descriptive names (see the structure 'direct' below).
                      at all times, teh following must be true:
        
                      1.  direct.empty = false => the entry contains meaningful data
                      2.  (direct.empty = true(0ffh)) => the directory slot is empty.
                      3.  (direct.empty = true(07fh)) => the directory slot and all
                      further directory slots are empty;
              */
        
              $include(direct.ipx)
   2   1  =   declare Aft$Window literally 'AWindo';
   3   1  =   declare direct$i$no literally 'dirINo';
   4   1  =   declare abswrite literally 'abs$wr';
   5   1  =   declare BOOLEAN literally 'BYTE';
   6   1  =   declare FALSE literally '0';
   7   1  =   declare SEEK$ABS literally '2';
   8   1  =   declare TRUE literally '0ffh';
   9   1  =   declare a$data$blk$p address external;
  10   1  =   declare a$dbuf$p address external;
  11   1  =   declare a$dev$p address external;
  12   1  =   declare a$pbuf$p address external;
  13   1  =   declare datum$base address external;
  14   1  =   declare pointer$base address external;
  15   1  =   abs$wr: procedure(block, buffer$ptr) external; declare block address, buffer$ptr address; end;
  18   1  =   Aft$Window: procedure(slot$number) external; declare slot$number byte; end;
  21   1  =   get$buf: procedure address external; end;
  23   1  =   read: procedure(aftn, buffer, count, actual$p) external;
  24   2  =           declare aftn byte, buffer address, count address, actual$p address; end;
  26   1  =   return$buf: procedure(buf$address) external; declare buf$address address; end;
  29   1  =   rewind: procedure external; end;
  31   1  =   seek: procedure(aftn, mode, blockptr, byteptr) external;
  32   2  =           declare aftn byte, mode address, blockptr address, byteptr address; end;
  34   1  =   write: procedure(aftn, buffer, count) external; declare aftn byte, buffer address, count address; end;
  37   1  =   declare a$data$blk based a$data$blk$p  address;
PL/M-80 COMPILER                                                                                                PAGE   2


  38   1  =   declare a$dbuf based a$dbuf$p  address;
  39   1  =   declare a$device based a$dev$p  byte;
  40   1  =   declare a$pbuf based a$pbuf$p  address;
        
              /* interface to assembler support code */
  41   1      DECLARE fndFre  BYTE PUBLIC;    /* logical flag used to indicate if a
                                 free dir slot has been allocated */
  42   1      DECLARE inoPtr  ADDRESS PUBLIC; /* is setup to point to direct$i$no */
  43   1      DECLARE dirPtr ADDRESS PUBLIC;  /* is setup to point to the direct */
        
  44   1      DECLARE dnum ADDRESS EXTERNAL;
  45   1      fndDir: PROCEDURE(fname, datum) BYTE EXTERNAL;
  46   2          DECLARE fname ADDRESS, datum ADDRESS;
  47   2      END;
        
              /* end of asm interface */
        
        
        
        
  48   1      DECLARE direct structure (
                  empty       BOOLEAN,    /* flag to indicate whether directory entry is used */
                  file(6)     BYTE,   /* file name */
                  ext(3)      BYTE,   /* extension */
                  attrib      BYTE,   /* file attributes */
                  eof$count   BYTE,   /* character count, last data block */
                  blk   ADDRESS,  /* number of block in file */
                  hdr$blk     ADDRESS)    /* address of first pointer block */
                  PUBLIC;
        
  49   1      DECLARE direct$i$no ADDRESS PUBLIC; /* directory entry pointer */
        
        
        
  50   1      dir$close: PROCEDURE(aftn) PUBLIC;
                                                 ; STATEMENT # 50
                         ; PROC  DIRCLOSE
           0002  211700          LXI     H,AFTN
           0005  71              MOV     M,C
  51   2          DECLARE aftn BYTE;
        
                  /*
                      This procedure assumes that aftwindow has been called
                      correctly setting up the appropriate directory slot
                      and that teh dbuffer and pbuffer have correct data
                      but need not be returned to the pool
                  */
        
  52   2          call write(aftn, .direct, size(direct));
                                                 ; STATEMENT # 52
           0006  2A1700          LHLD    AFTN
           0009  E5              PUSH    H       ; 1
           000A  111000          LXI     D,10H
           000D  010500          LXI     B,DIRECT
           0010  CD0000          CALL    WRITE
  53   2          call abswrite(a$data$blk, a$dbuf);  /* both based vars */
                                                 ; STATEMENT # 53
PL/M-80 COMPILER                                                                                                PAGE   3


           0013  2A0000          LHLD    ADATABLKP
           0016  E5              PUSH    H       ; 1
           0017  2A0000          LHLD    ADBUFP
           001A  5E              MOV     E,M
           001B  23              INX     H
           001C  56              MOV     D,M
           001D  E1              POP     H       ; 1
           001E  4E              MOV     C,M
           001F  23              INX     H
           0020  46              MOV     B,M
           0021  CD0000          CALL    ABSWR
  54   2      end;
                                                 ; STATEMENT # 54
           0024  C9              RET
        
        
  55   1      dlook: PROCEDURE(fn) BOOLEAN PUBLIC;
                                                 ; STATEMENT # 55
                         ; PROC  DLOOK
           0025  211900          LXI     H,FN+1H
           0028  70              MOV     M,B
           0029  2B              DCX     H
           002A  71              MOV     M,C
  56   2          DECLARE fn ADDRESS;
  57   2          DECLARE blockno ADDRESS DATA(0);
  58   2          DECLARE rcount BYTE;
                  /* The location at (rcount + 1) is modified by the procedure read,
                     hence byteno must always follow the declaration of rcount
                  */
  59   2          DECLARE byteno ADDRESS;
  60   2          DECLARE array based fn(12) BYTE;
  61   2          DECLARE (i, aftn) BYTE;
  62   2          DECLARE return$value BOOLEAN;
        
                  /*
                    This procedure is used to lookup a file name in a
                    disk directory. The device number of the disk
                    is contained in fn(0), the six characters of the
                    file name are in fn(1) through fn(6), and the
                    three characters of the file extension are in
                    fn(7) through fn(9)
        
                    The procedure returns 'TRUE' if the file is found,
                    with direct$i$no pointing to the entry of the file in the
                    directory
        
                    otherwise, the procedure returns 'FALSE', and direct$i$no points
                    at a blank slot in the directory. The directory marker is
                    adjusted so taht it points at the beginning of the entry
                    pointed to by direct$i$no.
        
                    If the directory is full, direct$i$no = 0ffffh
                  */
  63   2          call aft$window(aftn := a$device);
                                                 ; STATEMENT # 63
           002B  2A0000          LHLD    ADEVP
           002E  7E              MOV     A,M
PL/M-80 COMPILER                                                                                                PAGE   4


           002F  321E00          STA     AFTN
           0032  4F              MOV     C,A
           0033  CD0000          CALL    AWINDO
  64   2          pointer$base, a$pbuf = get$buf;
                                                 ; STATEMENT # 64
           0036  CD0000          CALL    GETBUF
           0039  220000          SHLD    POINTERBASE
           003C  E5              PUSH    H       ; 1
           003D  2A0000          LHLD    APBUFP
           0040  C1              POP     B       ; 1
           0041  71              MOV     M,C
           0042  23              INX     H
           0043  70              MOV     M,B
  65   2          datum$base, a$dbuf = get$buf;
                                                 ; STATEMENT # 65
           0044  CD0000          CALL    GETBUF
           0047  220000          SHLD    DATUMBASE
           004A  E5              PUSH    H       ; 1
           004B  2A0000          LHLD    ADBUFP
           004E  C1              POP     B       ; 1
           004F  71              MOV     M,C
           0050  23              INX     H
           0051  70              MOV     M,B
  66   2          call rewind;
                                                 ; STATEMENT # 66
           0052  CD0000          CALL    REWIND
  67   2          direct$i$no = 0ffffh;
                                                 ; STATEMENT # 67
           0055  21FFFF          LXI     H,0FFFFH
           0058  221500          SHLD    DIRINO
  68   2          dirPtr = .direct;
                                                 ; STATEMENT # 68
           005B  210500          LXI     H,DIRECT
           005E  220300          SHLD    DIRPTR
  69   2          inoPtr = .direct$i$no;
                                                 ; STATEMENT # 69
           0061  211500          LXI     H,DIRINO
           0064  220100          SHLD    INOPTR
  70   2          rcount = 1;
                                                 ; STATEMENT # 70
           0067  211A00          LXI     H,RCOUNT
           006A  3601            MVI     M,1H
  71   2          fndFre = FALSE;
                                                 ; STATEMENT # 71
           006C  210000          LXI     H,FNDFRE
           006F  3600            MVI     M,0H
  72   2          dnum, return$value = 0;
                                                 ; STATEMENT # 72
        
           0071  210000          LXI     H,0H
           0074  220000          SHLD    DNUM
           0077  7D              MOV     A,L
           0078  321F00          STA     RETURNVALUE
  73   2          do while rcount <> 0;
                                                 ; STATEMENT # 73
                         @4:
           007B  3A1A00          LDA     RCOUNT
PL/M-80 COMPILER                                                                                                PAGE   5


           007E  FE00            CPI     0H
           0080  CAC400          JZ      @5
  74   3              call read(aftn, a$dbuf, 128, .rcount);
                                                 ; STATEMENT # 74
           0083  2A1E00          LHLD    AFTN
           0086  E5              PUSH    H       ; 1
           0087  2A0000          LHLD    ADBUFP
           008A  4E              MOV     C,M
           008B  23              INX     H
           008C  46              MOV     B,M
           008D  C5              PUSH    B       ; 2
           008E  111A00          LXI     D,RCOUNT
           0091  018000          LXI     B,80H
           0094  CD0000          CALL    READ
  75   3              if (i := fndDir(fn + 1, datum$base)) = 07fh then /* no more entries */
                                                 ; STATEMENT # 75
           0097  2A1800          LHLD    FN
           009A  23              INX     H
           009B  44              MOV     B,H
           009C  4D              MOV     C,L
           009D  2A0000          LHLD    DATUMBASE
           00A0  EB              XCHG
           00A1  CD0000          CALL    FNDDIR
           00A4  321D00          STA     I
           00A7  FE7F            CPI     7FH
           00A9  C2AF00          JNZ     @1
  76   3                  goto done;  /* break */
                                                 ; STATEMENT # 76
           00AC  C3C400          JMP     DONE
                         @1:
  77   3              if i = 0ffh then    /* found */
                                                 ; STATEMENT # 77
           00AF  3A1D00          LDA     I
           00B2  FEFF            CPI     0FFH
           00B4  C2C100          JNZ     @2
  78   3              do;
  79   4                  return$value = TRUE;
                                                 ; STATEMENT # 79
           00B7  211F00          LXI     H,RETURNVALUE
           00BA  36FF            MVI     M,0FFH
  80   4                  rcount = 0;
                                                 ; STATEMENT # 80
           00BC  211A00          LXI     H,RCOUNT
           00BF  3600            MVI     M,0H
  81   4              end;
                                                 ; STATEMENT # 81
                         @2:
  82   3          end;
                                                 ; STATEMENT # 82
           00C1  C37B00          JMP     @4
                         @5:
  83   2      done:
                                                 ; STATEMENT # 83
                         DONE:
           00C4  01FFFF          LXI     B,0FFFFH
           00C7  111500          LXI     D,DIRINO
           00CA  CD0000          CALL    @P0100 
PL/M-80 COMPILER                                                                                                PAGE   6


           00CD  B5              ORA     L
           00CE  CAEC00          JZ      @3
                  if direct$i$No <> 0ffffh then
  84   2          do;
  85   3              byteno = direct$i$no * size(direct);
                                                 ; STATEMENT # 85
           00D1  2A1500          LHLD    DIRINO
           00D4  29              DAD     H
           00D5  29              DAD     H
           00D6  29              DAD     H
           00D7  29              DAD     H
           00D8  221B00          SHLD    BYTENO
  86   3              call seek(aftn, SEEK$ABS, .blockno, .byteno);
                                                 ; STATEMENT # 86
           00DB  2A1E00          LHLD    AFTN
           00DE  E5              PUSH    H       ; 1
           00DF  010200          LXI     B,2H
           00E2  C5              PUSH    B       ; 2
           00E3  111B00          LXI     D,BYTENO
           00E6  010000          LXI     B,BLOCKNO
           00E9  CD0000          CALL    SEEK
  87   3          end;
                                                 ; STATEMENT # 87
                         @3:
  88   2          call return$buf(a$dbuf);
                                                 ; STATEMENT # 88
           00EC  2A0000          LHLD    ADBUFP
           00EF  4E              MOV     C,M
           00F0  23              INX     H
           00F1  46              MOV     B,M
           00F2  CD0000          CALL    RETURNBUF
  89   2          call return$buf(a$pbuf);
                                                 ; STATEMENT # 89
           00F5  2A0000          LHLD    APBUFP
           00F8  4E              MOV     C,M
           00F9  23              INX     H
           00FA  46              MOV     B,M
           00FB  CD0000          CALL    RETURNBUF
  90   2          return return$value;
                                                 ; STATEMENT # 90
           00FE  3A1F00          LDA     RETURNVALUE
           0101  C9              RET
  91   2      end;
                                                 ; STATEMENT # 91
  92   1      end;
              eof



MODULE INFORMATION:

     CODE AREA SIZE     = 0102H    258D
     VARIABLE AREA SIZE = 0020H     32D
     MAXIMUM STACK SIZE = 0006H      6D
     164 LINES READ
     0 PROGRAM ERRORS
PL/M-80 COMPILER                                                                                                PAGE   7


END OF PL/M-80 COMPILATION
