PL/M-80 COMPILER                                                                                                PAGE   1


ISIS-II PL/M-80 V4.0 COMPILATION OF MODULE ALLOC
OBJECT MODULE PLACED IN ALLOC.OBJ
COMPILER INVOKED BY:  :F1:plm80 alloc.plm PRINT(ALLOC.LST) OBJECT(ALLOC.OBJ) DEBUG OPTIMIZE CODE



   1          alloc:
              do;
              $include(alloc.ipx)
   2   1  =   declare Get$Block literally 'GetBlk';
   3   1  =   declare Map$Write literally 'MapWri';
   4   1  =   declare CMD$READ literally '4';
   5   1  =   declare CMD$WRITE literally '6';
   6   1  =   declare DCB$T literally 'structure(iocw BYTE, ioins BYTE, nsec BYTE, tadr BYTE, sadr BYTE, buf ADDRESS)';
   7   1  =   declare DISK$FULL literally '7';
   8   1  =   declare FALSE literally '0';
   9   1  =   declare TRUE literally '0ffh';
  10   1  =   abortx: procedure(errcode) external; declare errcode byte; end;
  13   1  =   diskio: procedure(drive, iopb) external; declare drive byte, iopb address; end;
        
  16   1      DECLARE tracksTable(10) BYTE PUBLIC,    /* initialised by boot routines */
                  sectorsTable(10) BYTE PUBLIC,
                  bitmapBuffer(128) BYTE,
                  current$bitmap BYTE PUBLIC INITIAL(0ffh),
                  map$change BYTE INITIAL(FALSE),
                  baseTrackSector ADDRESS,
                  baseSector BYTE AT (.baseTrackSector),
                  baseTrack BYTE AT (.baseTrackSector + 1),
                  bitmapIndex ADDRESS,
                  lowBitMapIndex BYTE AT (.bitmapIndex),
                  map$dcb DCB$T INITIAL(80h, 4, 1, 2, 2, .bitmapBuffer),
                  current$part BYTE INITIAL(0ffh),
                  base$part BYTE INITIAL(0),
                  next$part BYTE INITIAL(0),
                  bitmapByte$p ADDRESS INITIAL(0),
                  (lowBitmapByte$p, highBitmapByte$p) BYTE AT (.bitmapByte$p),
                  bitmapByte BASED bitmapByte$p BYTE,
                  bitmapBit BYTE,
                  command BYTE,
                  disk BYTE,
                  tracksPerDisk BYTE,
                  sectorsPerTrack BYTE;
        
        
  17   1      mapio:  PROCEDURE;
                                                 ; STATEMENT # 17
                         ; PROC  MAPIO
  18   2          map$change = FALSE;
                                                 ; STATEMENT # 18
           0000  219500          LXI     H,MAPCHANGE
           0003  3600            MVI     M,0H
  19   2          map$dcb.ioins = command;    /* set up command */
                                                 ; STATEMENT # 19
           0005  3AA700          LDA     COMMAND
           0008  329B00          STA     MAPDCB+1H
  20   2          map$dcb.tadr = 2;       /* set up partition */
                                                 ; STATEMENT # 20
PL/M-80 COMPILER                                                                                                PAGE   2


           000B  219D00          LXI     H,MAPDCB+3H
           000E  3602            MVI     M,2H
  21   2          map$dcb.sadr = current$part + 2;
                                                 ; STATEMENT # 21
           0010  3AA100          LDA     CURRENTPART
           0013  3C              INR     A
           0014  3C              INR     A
           0015  23              INX     H
           0016  77              MOV     M,A
  22   2          call diskio(disk, .map$dcb);
                                                 ; STATEMENT # 22
           0017  2AA800          LHLD    DISK
           001A  4D              MOV     C,L
           001B  119A00          LXI     D,MAPDCB
           001E  CD0000          CALL    DISKIO
  23   2      end;
                                                 ; STATEMENT # 23
           0021  C9              RET
        
        
  24   1      map$write: PROCEDURE(diskNum) PUBLIC;
                                                 ; STATEMENT # 24
                         ; PROC  MAPWRI
           0022  21AB00          LXI     H,DISKNUM
           0025  71              MOV     M,C
  25   2          DECLARE diskNum BYTE;
        
  26   2          disk = diskNum;
                                                 ; STATEMENT # 26
           0026  3AAB00          LDA     DISKNUM
           0029  32A800          STA     DISK
  27   2          if  disk = current$bitmap AND map$change then
                                                 ; STATEMENT # 27
           002C  219400          LXI     H,CURRENTBITMAP
           002F  96              SUB     M
           0030  D601            SUI     1
           0032  9F              SBB     A
           0033  23              INX     H
           0034  A6              ANA     M
           0035  1F              RAR
           0036  D24100          JNC     @1
  28   2          do;
  29   3              command = CMD$WRITE;    
                                                 ; STATEMENT # 29
           0039  21A700          LXI     H,COMMAND
           003C  3606            MVI     M,6H
  30   3              call mapio;
                                                 ; STATEMENT # 30
           003E  CD0000          CALL    MAPIO
  31   3          end;
                                                 ; STATEMENT # 31
                         @1:
  32   2      end;
                                                 ; STATEMENT # 32
           0041  C9              RET
        
                      
PL/M-80 COMPILER                                                                                                PAGE   3


        
  33   1      map$read: PROCEDURE PUBLIC;
                                                 ; STATEMENT # 33
                         ; PROC  MAPREAD
  34   2          DECLARE temp BYTE;
        
  35   2          temp = disk <> current$bitmap;
                                                 ; STATEMENT # 35
           0042  219400          LXI     H,CURRENTBITMAP
           0045  3AA800          LDA     DISK
           0048  96              SUB     M
           0049  C6FF            ADI     255
           004B  9F              SBB     A
           004C  32AC00          STA     TEMP
  36   2          if current$part <> next$part or temp then
                                                 ; STATEMENT # 36
           004F  21A300          LXI     H,NEXTPART
           0052  3AA100          LDA     CURRENTPART
           0055  96              SUB     M
           0056  C6FF            ADI     255
           0058  9F              SBB     A
           0059  21AC00          LXI     H,TEMP
           005C  B6              ORA     M
           005D  1F              RAR
           005E  D29F00          JNC     @2
  37   2          do;
  38   3              if temp then
                                                 ; STATEMENT # 38
           0061  3AAC00          LDA     TEMP
           0064  1F              RAR
           0065  D27900          JNC     @3
  39   3              do;
  40   4                  base$part = 0;
                                                 ; STATEMENT # 40
           0068  21A200          LXI     H,BASEPART
           006B  3600            MVI     M,0H
  41   4                  bitmapIndex = 0;
                                                 ; STATEMENT # 41
           006D  210000          LXI     H,0H
           0070  229800          SHLD    BITMAPINDEX
  42   4                  baseTrackSector = 1;
                                                 ; STATEMENT # 42
           0073  210100          LXI     H,1H
           0076  229600          SHLD    BASETRACKSECTOR
  43   4              end;
                                                 ; STATEMENT # 43
                         @3:
  44   3              temp = disk;
                                                 ; STATEMENT # 44
           0079  3AA800          LDA     DISK
           007C  32AC00          STA     TEMP
  45   3              call map$write(current$bitmap);
                                                 ; STATEMENT # 45
           007F  2A9400          LHLD    CURRENTBITMAP
           0082  4D              MOV     C,L
           0083  CD2200          CALL    MAPWRI
  46   3              disk = temp;
PL/M-80 COMPILER                                                                                                PAGE   4


                                                 ; STATEMENT # 46
           0086  3AAC00          LDA     TEMP
           0089  32A800          STA     DISK
  47   3              command = CMD$READ;
                                                 ; STATEMENT # 47
           008C  21A700          LXI     H,COMMAND
           008F  3604            MVI     M,4H
  48   3              current$part = next$part;
                                                 ; STATEMENT # 48
           0091  3AA300          LDA     NEXTPART
           0094  32A100          STA     CURRENTPART
  49   3              current$bitmap = disk;
                                                 ; STATEMENT # 49
           0097  23              INX     H
           0098  7E              MOV     A,M
           0099  329400          STA     CURRENTBITMAP
  50   3              call mapio;
                                                 ; STATEMENT # 50
           009C  CD0000          CALL    MAPIO
  51   3          end;
                                                 ; STATEMENT # 51
                         @2:
  52   2      end;
                                                 ; STATEMENT # 52
           009F  C9              RET
        
        
  53   1      set$num$sect$trk: PROCEDURE;
                                                 ; STATEMENT # 53
                         ; PROC  SETNUMSECTTRK
  54   2          sectorsPerTrack = sectorsTable(disk);
                                                 ; STATEMENT # 54
           00A0  2AA800          LHLD    DISK
           00A3  2600            MVI     H,0
           00A5  010A00          LXI     B,SECTORSTABLE
           00A8  09              DAD     B
           00A9  7E              MOV     A,M
           00AA  32AA00          STA     SECTORSPERTRACK
  55   2          tracksPerDisk = tracksTable(disk);
                                                 ; STATEMENT # 55
           00AD  2AA800          LHLD    DISK
           00B0  2600            MVI     H,0
           00B2  010000          LXI     B,TRACKSTABLE
           00B5  09              DAD     B
           00B6  7E              MOV     A,M
           00B7  32A900          STA     TRACKSPERDISK
  56   2      end;
                                                 ; STATEMENT # 56
           00BA  C9              RET
        
        
        
  57   1      get$block: PROCEDURE(diskNum) ADDRESS PUBLIC;
                                                 ; STATEMENT # 57
                         ; PROC  GETBLK
           00BB  21AD00          LXI     H,DISKNUM
           00BE  71              MOV     M,C
PL/M-80 COMPILER                                                                                                PAGE   5


  58   2          DECLARE diskNum BYTE;
  59   2          DECLARE trackSector ADDRESS,
                      sector BYTE AT (.trackSector),
                      track BYTE AT (.trackSector + 1);
        
  60   2          disk = diskNum;
                                                 ; STATEMENT # 60
           00BF  3AAD00          LDA     DISKNUM
           00C2  32A800          STA     DISK
  61   2          call set$num$sect$trk;
                                                 ; STATEMENT # 61
           00C5  CDA000          CALL    SETNUMSECTTRK
  62   2          next$part = base$part;
                                                 ; STATEMENT # 62
           00C8  3AA200          LDA     BASEPART
           00CB  32A300          STA     NEXTPART
  63   2          if disk <> current$bitmap then
                                                 ; STATEMENT # 63
           00CE  219400          LXI     H,CURRENTBITMAP
           00D1  3AA800          LDA     DISK
           00D4  BE              CMP     M
           00D5  CADD00          JZ      @4
  64   2              next$part = 0;
                                                 ; STATEMENT # 64
           00D8  21A300          LXI     H,NEXTPART
           00DB  3600            MVI     M,0H
                         @4:
  65   2          call map$read;
                                                 ; STATEMENT # 65
           00DD  CD4200          CALL    MAPREAD
  66   2          bitmapBit = ror(1, lowBitmapIndex and 7);
                                                 ; STATEMENT # 66
           00E0  3A9800          LDA     LOWBITMAPINDEX
           00E3  E607            ANI     7H
           00E5  4F              MOV     C,A
           00E6  3E01            MVI     A,1H
           00E8  CD0000          CALL    @P0072 
           00EB  32A600          STA     BITMAPBIT
  67   2          do track = baseTrack TO tracksPerDisk;
                                                 ; STATEMENT # 67
           00EE  3A9700          LDA     BASETRACK
           00F1  32AF00          STA     TRACK
                         @12:
           00F4  3AA900          LDA     TRACKSPERDISK
           00F7  21AF00          LXI     H,TRACK
           00FA  BE              CMP     M
           00FB  DAC201          JC      @13
  68   3              do sector = baseSector TO sectorsPerTrack;
                                                 ; STATEMENT # 68
           00FE  3A9600          LDA     BASESECTOR
           0101  32AE00          STA     SECTOR
                         @14:
           0104  3AAA00          LDA     SECTORSPERTRACK
           0107  21AE00          LXI     H,SECTOR
           010A  BE              CMP     M
           010B  DAB601          JC      @15
  69   4                  bitmapByte$p = .bitmapBuffer(SHR(bitmapIndex, 3));
PL/M-80 COMPILER                                                                                                PAGE   6


                                                 ; STATEMENT # 69
           010E  0E03            MVI     C,3H
           0110  219800          LXI     H,BITMAPINDEX
           0113  CD0000          CALL    @P0091 
           0116  011400          LXI     B,BITMAPBUFFER
           0119  09              DAD     B
           011A  22A400          SHLD    BITMAPBYTEP
  70   4                  if bitmapByte = 0ffh  AND bitmapBit then    /* no free entry */
                                                 ; STATEMENT # 70
           011D  7E              MOV     A,M
           011E  D6FF            SUI     0FFH
           0120  D601            SUI     1
           0122  9F              SBB     A
           0123  21A600          LXI     H,BITMAPBIT
           0126  A6              ANA     M
           0127  1F              RAR
           0128  D26201          JNC     @5
  71   4                  do;
  72   5                      bitmapIndex = bitmapIndex + 8;
                                                 ; STATEMENT # 72
           012B  110800          LXI     D,8H
           012E  2A9800          LHLD    BITMAPINDEX
           0131  19              DAD     D
           0132  229800          SHLD    BITMAPINDEX
  73   5                      sector = sector + 7;            /* the do loop adds 1 */
                                                 ; STATEMENT # 73
           0135  3AAE00          LDA     SECTOR
           0138  C607            ADI     7H
           013A  32AE00          STA     SECTOR
  74   5                      if sector > sectorsPerTrack then
                                                 ; STATEMENT # 74
           013D  3AAA00          LDA     SECTORSPERTRACK
           0140  21AE00          LXI     H,SECTOR
           0143  BE              CMP     M
           0144  D25F01          JNC     @6
  75   5                      do;
  76   6                          sector = sector - sectorsPerTrack;
                                                 ; STATEMENT # 76
           0147  21AA00          LXI     H,SECTORSPERTRACK
           014A  3AAE00          LDA     SECTOR
           014D  96              SUB     M
           014E  32AE00          STA     SECTOR
  77   6                          track = track + 1;
                                                 ; STATEMENT # 77
           0151  21AF00          LXI     H,TRACK
           0154  34              INR     M
  78   6                          if track > tracksPerDisk then   
                                                 ; STATEMENT # 78
           0155  3AA900          LDA     TRACKSPERDISK
           0158  BE              CMP     M
           0159  D25F01          JNC     @7
  79   6                              goto full;
                                                 ; STATEMENT # 79
           015C  C3C201          JMP     FULL
                         @7:
  80   6                      end;
                                                 ; STATEMENT # 80
PL/M-80 COMPILER                                                                                                PAGE   7


                         @6:
  81   5                  end;
                                                 ; STATEMENT # 81
           015F  C39301          JMP     @8
                         @5:
                          else
  82   4                  do;
  83   5                      if ((bitmapBit := ROR(bitmapBit, 1)) AND bitmapByte) = 0 then   /* found a slot */
                                                 ; STATEMENT # 83
           0162  3AA600          LDA     BITMAPBIT
           0165  0F              RRC
           0166  32A600          STA     BITMAPBIT
           0169  2AA400          LHLD    BITMAPBYTEP
           016C  A6              ANA     M
           016D  FE00            CPI     0H
           016F  C28C01          JNZ     @9
  84   5                      do;
  85   6                          map$change = TRUE;
                                                 ; STATEMENT # 85
           0172  219500          LXI     H,MAPCHANGE
           0175  36FF            MVI     M,0FFH
  86   6                          bitmapByte = bitmapByte OR bitmapBit;
                                                 ; STATEMENT # 86
           0177  2AA400          LHLD    BITMAPBYTEP
           017A  3AA600          LDA     BITMAPBIT
           017D  B6              ORA     M
           017E  77              MOV     M,A
  87   6                          base$part = current$part;
                                                 ; STATEMENT # 87
           017F  3AA100          LDA     CURRENTPART
           0182  32A200          STA     BASEPART
  88   6                          return (baseTrackSector := trackSector);
                                                 ; STATEMENT # 88
           0185  2AAE00          LHLD    TRACKSECTOR
           0188  229600          SHLD    BASETRACKSECTOR
           018B  C9              RET
  89   6                      end;
                                                 ; STATEMENT # 89
                         @9:
  90   5                      bitmapIndex = bitmapIndex + 1;
                                                 ; STATEMENT # 90
           018C  2A9800          LHLD    BITMAPINDEX
           018F  23              INX     H
           0190  229800          SHLD    BITMAPINDEX
  91   5                  end;
                                                 ; STATEMENT # 91
                         @8:
  92   4                  if bitmapIndex > 03ffh then
                                                 ; STATEMENT # 92
           0193  11FF03          LXI     D,3FFH
           0196  219800          LXI     H,BITMAPINDEX
           0199  CD0000          CALL    @P0104 
           019C  D2AF01          JNC     @10
  93   4                  do;
  94   5                      next$part = current$part + 1;
                                                 ; STATEMENT # 94
           019F  3AA100          LDA     CURRENTPART
PL/M-80 COMPILER                                                                                                PAGE   8


           01A2  3C              INR     A
           01A3  32A300          STA     NEXTPART
  95   5                      call map$read;
                                                 ; STATEMENT # 95
           01A6  CD4200          CALL    MAPREAD
  96   5                      bitmapIndex = 0;
                                                 ; STATEMENT # 96
           01A9  210000          LXI     H,0H
           01AC  229800          SHLD    BITMAPINDEX
  97   5                  end;
                                                 ; STATEMENT # 97
                         @10:
  98   4              end;
                                                 ; STATEMENT # 98
                         @16:
           01AF  21AE00          LXI     H,SECTOR
           01B2  34              INR     M
           01B3  C20401          JNZ     @14
                         @15:
  99   3              baseSector = 1; 
                                                 ; STATEMENT # 99
           01B6  219600          LXI     H,BASESECTOR
           01B9  3601            MVI     M,1H
 100   3          end;
                                                 ; STATEMENT # 100
                         @17:
           01BB  21AF00          LXI     H,TRACK
           01BE  34              INR     M
           01BF  C2F400          JNZ     @12
                         @13:
 101   2      full:
                                                 ; STATEMENT # 101
                         FULL:
           01C2  0E07            MVI     C,7H
           01C4  CD0000          CALL    ABORTX
                  call abortx(DISK$FULL);
 102   2      end;
                                                 ; STATEMENT # 102
           01C7  C9              RET
        
        
 103   1      free$block: PROCEDURE(diskNum, trackSector) PUBLIC;
                                                 ; STATEMENT # 103
                         ; PROC  FREEBLOCK
           01C8  21B200          LXI     H,TRACKSECTOR+1H
           01CB  72              MOV     M,D
           01CC  2B              DCX     H
           01CD  73              MOV     M,E
           01CE  2B              DCX     H
           01CF  71              MOV     M,C
 104   2          DECLARE disknum BYTE, trackSector ADDRESS;
 105   2          DECLARE (sector, track) BYTE AT (.trackSector);
 106   2          DECLARE temp BYTE;
        
 107   2          disk = disknum;
                                                 ; STATEMENT # 107
           01D0  3AB000          LDA     DISKNUM
PL/M-80 COMPILER                                                                                                PAGE   9


           01D3  32A800          STA     DISK
 108   2          call set$num$sect$trk;
                                                 ; STATEMENT # 108
           01D6  CDA000          CALL    SETNUMSECTTRK
 109   2          bitmapByte$p = track * sectorsPerTrack + sector - 1;
                                                 ; STATEMENT # 109
           01D9  2AAA00          LHLD    SECTORSPERTRACK
           01DC  2600            MVI     H,0
           01DE  EB              XCHG
           01DF  2AB200          LHLD    TRACK
           01E2  2600            MVI     H,0
           01E4  CD0000          CALL    @P0034 
           01E7  E5              PUSH    H       ; 1
           01E8  2AB100          LHLD    SECTOR
           01EB  2600            MVI     H,0
           01ED  C1              POP     B       ; 1
           01EE  09              DAD     B
           01EF  2B              DCX     H
           01F0  22A400          SHLD    BITMAPBYTEP
 110   2          next$part = shr(highBitmapByte$p, 2);
                                                 ; STATEMENT # 110
           01F3  3AA500          LDA     HIGHBITMAPBYTEP
           01F6  E6FE            ANI     254
           01F8  1F              RAR
           01F9  1F              RAR
           01FA  32A300          STA     NEXTPART
 111   2          if bitmapByte$p < bitmapIndex + shl(double(base$part),10) then
                                                 ; STATEMENT # 111
           01FD  2AA200          LHLD    BASEPART
           0200  2600            MVI     H,0
           0202  0E0A            MVI     C,0AH
           0204  CD0000          CALL    @P0088 
           0207  EB              XCHG
           0208  2A9800          LHLD    BITMAPINDEX
           020B  19              DAD     D
           020C  11A400          LXI     D,BITMAPBYTEP
           020F  CD0000          CALL    @P0102 
           0212  D22D02          JNC     @11
 112   2          do;
 113   3              base$part = next$part;
                                                 ; STATEMENT # 113
           0215  3AA300          LDA     NEXTPART
           0218  32A200          STA     BASEPART
 114   3              bitmapIndex = bitmapByte$p AND 03ffh;
                                                 ; STATEMENT # 114
           021B  11FF03          LXI     D,3FFH
           021E  21A400          LXI     H,BITMAPBYTEP
           0221  CD0000          CALL    @P0027 
           0224  229800          SHLD    BITMAPINDEX
 115   3              baseTrackSector = trackSector;
                                                 ; STATEMENT # 115
           0227  2AB100          LHLD    TRACKSECTOR
           022A  229600          SHLD    BASETRACKSECTOR
 116   3          end;
                                                 ; STATEMENT # 116
                         @11:
 117   2          call map$read;
PL/M-80 COMPILER                                                                                                PAGE  10


                                                 ; STATEMENT # 117
           022D  CD4200          CALL    MAPREAD
 118   2          temp = lowBitmapByte$p;
                                                 ; STATEMENT # 118
           0230  3AA400          LDA     LOWBITMAPBYTEP
           0233  32B300          STA     TEMP
 119   2          bitmapByte$p = .bitmapBuffer(shr(bitmapByte$p and 03ffh, 3));
                                                 ; STATEMENT # 119
           0236  11FF03          LXI     D,3FFH
           0239  21A400          LXI     H,BITMAPBYTEP
           023C  CD0000          CALL    @P0027 
           023F  0E03            MVI     C,3H
           0241  CD0000          CALL    @P0093 
           0244  011400          LXI     B,BITMAPBUFFER
           0247  09              DAD     B
           0248  EB              XCHG
           0249  2B              DCX     H
           024A  73              MOV     M,E
           024B  23              INX     H
           024C  72              MOV     M,D
 120   2          bitmapByte = bitmapByte AND not ROR(80h, temp and 7);
                                                 ; STATEMENT # 120
           024D  3AB300          LDA     TEMP
           0250  E607            ANI     7H
           0252  4F              MOV     C,A
           0253  3E80            MVI     A,80H
           0255  CD0000          CALL    @P0072 
           0258  2F              CMA
           0259  EB              XCHG
           025A  A6              ANA     M
           025B  77              MOV     M,A
 121   2          map$change = TRUE;
                                                 ; STATEMENT # 121
           025C  219500          LXI     H,MAPCHANGE
           025F  36FF            MVI     M,0FFH
 122   2      end;
                                                 ; STATEMENT # 122
           0261  C9              RET
 123   1      end;
              eof



MODULE INFORMATION:

     CODE AREA SIZE     = 0262H    610D
     VARIABLE AREA SIZE = 00B4H    180D
     MAXIMUM STACK SIZE = 0008H      8D
     166 LINES READ
     0 PROGRAM ERRORS

END OF PL/M-80 COMPILATION
