PL/M-80 COMPILER                                                                                                PAGE   1


ISIS-II PL/M-80 V4.0 COMPILATION OF MODULE LOAD
OBJECT MODULE PLACED IN LOAD.OBJ
COMPILER INVOKED BY:  :F1:plm80 load.plm PRINT(LOAD.LST) OBJECT(LOAD.OBJ) DEBUG OPTIMIZE CODE



   1          load:
              do;
              $include(load.ipx)
   2   1  =   declare debug$Toggle literally 'dTogle';
   3   1  =   declare AFT$BOTTOM literally '10';
   4   1  =   declare BAD$LOAD$FORMAT literally '16';
   5   1  =   declare BAD$RETSW literally '34';
   6   1  =   declare FALSE literally '0';
   7   1  =   declare ISIS$OVERWRITE literally '15';
   8   1  =   declare SEEK$FORWARD literally '3';
   9   1  =   declare TRUE literally '0ffh';
  10   1  =   declare buffer$table(1) byte external;
  11   1  =   declare debugToggle byte external;
  12   1  =   declare usrSP address external;
  13   1  =   abortx: procedure(errcode) external; declare errcode byte; end;
  16   1  =   close: procedure(aftn) external; declare aftn byte; end;
  19   1  =   jmpto: procedure(entry, stack) external; declare entry address, stack address; end;
  22   1  =   memck: procedure address external; end;
  24   1  =   open: procedure(pathname, access$mode, lined$aft) byte external;
  25   2  =           declare pathname address, access$mode address, lined$aft address; end;
  27   1  =   pack$aft$buf: procedure address external; end;
  29   1  =   read: procedure(aftn, buffer, count, actual$p) external;
  30   2  =           declare aftn byte, buffer address, count address, actual$p address; end;
  32   1  =   seek: procedure(aftn, mode, blockptr, byteptr) external;
  33   2  =           declare aftn byte, mode address, blockptr address, byteptr address; end;
  35   1  =   trap: procedure external; end;
  37   1  =   warn: procedure(errcode) external; declare errcode byte; end;
        
  40   1      DECLARE R$MODHDR    LITERALLY   '2',
                  R$MODEND    LITERALLY   '4',
                  R$CONTENT   LITERALLY   '6',
                  R$LINENO    LITERALLY   '8',
                  R$EOF       LITERALLY   '0EH',
                  R$ANCESTOR  LITERALLY   '10H',
                  R$LOCALS    LITERALLY   '12H',
                  R$PUBLICS   LITERALLY   '16H',
                  R$EXTNAMES  LITERALLY   '18H',
                  R$EXTREF    LITERALLY   '20H',
                  R$RELOC     LITERALLY   '22H',
                  R$INTERSEG  LITERALLY   '24H',
                  R$LIBLOCS   LITERALLY   '26H',
                  R$LIBNAMES  LITERALLY   '28H',
                  R$LIBDICT   LITERALLY   '2AH',
                  R$LIBHDR    LITERALLY   '2CH',
                  R$COMDEF    LITERALLY   '2EH';
        
  41   1      load: PROCEDURE(pathname, bias, retsw, entry$p) PUBLIC;
                                                 ; STATEMENT # 41
                         ; PROC  LOAD
           0BB8  21852D          LXI     H,ENTRYP+1H
           0BBB  72              MOV     M,D
PL/M-80 COMPILER                                                                                                PAGE   2


           0BBC  2B              DCX     H
           0BBD  73              MOV     M,E
           0BBE  2B              DCX     H
           0BBF  70              MOV     M,B
           0BC0  2B              DCX     H
           0BC1  71              MOV     M,C
           0BC2  2B              DCX     H
           0BC3  D1              POP     D       
           0BC4  C1              POP     B       
           0BC5  70              MOV     M,B
           0BC6  2B              DCX     H
           0BC7  71              MOV     M,C
           0BC8  2B              DCX     H
           0BC9  C1              POP     B       
           0BCA  70              MOV     M,B
           0BCB  2B              DCX     H
           0BCC  71              MOV     M,C
           0BCD  D5              PUSH    D       
  42   2          DECLARE (pathname, bias, retsw, entry$p) ADDRESS;
  43   2          DECLARE entry BASED entry$p ADDRESS;
  44   2          DECLARE (aftn, i, retsw$b) BYTE;
  45   2          DECLARE record STRUCTURE(type BYTE, length ADDRESS);
  46   2          DECLARE modend STRUCTURE(modtype BYTE, segid BYTE, load$addr ADDRESS);
  47   2          DECLARE content STRUCTURE(segid BYTE, load$addr ADDRESS) AT (.modend);
  48   2          DECLARE checksum BYTE AT (.modend); 
  49   2          DECLARE actual ADDRESS, pad ADDRESS;
  50   2          DECLARE blockno ADDRESS, user$bottom ADDRESS, buffer$top ADDRESS;
        
  51   2          bounds$test: PROCEDURE(addr, len);
                                                 ; STATEMENT # 51
                         ; PROC  BOUNDSTEST
           0DFB  219D2D          LXI     H,LEN+1H
           0DFE  72              MOV     M,D
           0DFF  2B              DCX     H
           0E00  73              MOV     M,E
           0E01  2B              DCX     H
           0E02  70              MOV     M,B
           0E03  2B              DCX     H
           0E04  71              MOV     M,C
  52   3              DECLARE (addr, len) ADDRESS;
  53   3              if addr >= 18h AND addr <= 3fh AND addr + len <= 40h then
                                                 ; STATEMENT # 53
           0E05  3E18            MVI     A,18H
           0E07  119A2D          LXI     D,ADDR
           0E0A  CD352A          CALL    @P0101 
           0E0D  9F              SBB     A
           0E0E  2F              CMA
           0E0F  EB              XCHG
           0E10  F5              PUSH    PSW     ; 1
           0E11  3E3F            MVI     A,3FH
           0E13  2B              DCX     H
           0E14  CD402A          CALL    @P0103 
           0E17  9F              SBB     A
           0E18  2F              CMA
           0E19  C1              POP     B       ; 1
           0E1A  48              MOV     C,B
           0E1B  A1              ANA     C
PL/M-80 COMPILER                                                                                                PAGE   3


           0E1C  2A9C2D          LHLD    LEN
           0E1F  1B              DCX     D
           0E20  F5              PUSH    PSW     ; 1
           0E21  CD8A29          CALL    @P0017 
           0E24  3E40            MVI     A,40H
           0E26  CD142A          CALL    @P0094 
           0E29  9F              SBB     A
           0E2A  2F              CMA
           0E2B  C1              POP     B       ; 1
           0E2C  48              MOV     C,B
           0E2D  A1              ANA     C
           0E2E  1F              RAR
           0E2F  D2330E          JNC     @1
  54   3                  return;
                                                 ; STATEMENT # 54
           0E32  C9              RET
                         @1:
  55   3              if user$bottom > addr then
                                                 ; STATEMENT # 55
           0E33  119A2D          LXI     D,ADDR
           0E36  01962D          LXI     B,USERBOTTOM
           0E39  CD282A          CALL    @P0098 
           0E3C  D2450E          JNC     @2
  56   3                  user$bottom = addr; /* first address will update this if applicable */
                                                 ; STATEMENT # 56
           0E3F  2A9A2D          LHLD    ADDR
           0E42  22962D          SHLD    USERBOTTOM
                         @2:
  57   3              if buffer$top > addr OR addr + len  < addr then
                                                 ; STATEMENT # 57
           0E45  119A2D          LXI     D,ADDR
           0E48  01982D          LXI     B,BUFFERTOP
           0E4B  CD282A          CALL    @P0098 
           0E4E  9F              SBB     A
           0E4F  2A9C2D          LHLD    LEN
           0E52  1B              DCX     D
           0E53  F5              PUSH    PSW     ; 1
           0E54  CD8A29          CALL    @P0017 
           0E57  EB              XCHG
           0E58  2B              DCX     H
           0E59  CD432A          CALL    @P0104 
           0E5C  9F              SBB     A
           0E5D  C1              POP     B       ; 1
           0E5E  48              MOV     C,B
           0E5F  B1              ORA     C
           0E60  1F              RAR
           0E61  D2690E          JNC     @3
  58   3                  call abortx(ISIS$OVERWRITE);
                                                 ; STATEMENT # 58
           0E64  0E0F            MVI     C,0FH
           0E66  CD4B0B          CALL    ABORTX
                         @3:
  59   3          end;
                                                 ; STATEMENT # 59
           0E69  C9              RET
        
  60   2          blockno = 0;
PL/M-80 COMPILER                                                                                                PAGE   4


                                                 ; STATEMENT # 60
           0BCE  210000          LXI     H,0H
           0BD1  22942D          SHLD    BLOCKNO
  61   2          user$bottom = 0ffffh;
                                                 ; STATEMENT # 61
           0BD4  2B              DCX     H
           0BD5  22962D          SHLD    USERBOTTOM
  62   2          if retsw > 2 then
                                                 ; STATEMENT # 62
           0BD8  3E02            MVI     A,2H
           0BDA  21822D          LXI     H,RETSW
           0BDD  CD402A          CALL    @P0103 
           0BE0  D2E80B          JNC     @4
  63   2              call warn(BAD$RETSW);
                                                 ; STATEMENT # 63
           0BE3  0E22            MVI     C,22H
           0BE5  CD510B          CALL    WARN
                         @4:
        
  64   2          aftn = AFT$BOTTOM +  open(pathname, 1, 0);  /* open$read */
                                                 ; STATEMENT # 64
           0BE8  2A7E2D          LHLD    PATHNAME
           0BEB  E5              PUSH    H       ; 1
           0BEC  110000          LXI     D,0H
           0BEF  010100          LXI     B,1H
           0BF2  CD7D0E          CALL    OPEN
           0BF5  C60A            ADI     0AH
           0BF7  32862D          STA     AFTN
  65   2          if (retsw$b := retsw) <> 0 then
                                                 ; STATEMENT # 65
           0BFA  2A822D          LHLD    RETSW
           0BFD  EB              XCHG
           0BFE  21882D          LXI     H,RETSWB
           0C01  73              MOV     M,E
           0C02  3E00            MVI     A,0H
           0C04  CD1E2A          CALL    @P0096 
           0C07  B5              ORA     L
           0C08  CA110C          JZ      @5
  66   2              user$bottom = memck;
                                                 ; STATEMENT # 66
           0C0B  CD7229          CALL    MEMCK
           0C0E  22962D          SHLD    USERBOTTOM
                         @5:
  67   2          buffer$top = pack$aft$buf;
                                                 ; STATEMENT # 67
           0C11  CD7025          CALL    PACKAFTBUF
           0C14  22982D          SHLD    BUFFERTOP
  68   2          do while TRUE;
                                                 ; STATEMENT # 68
                         @21:
  69   3              call read(aftn, .record, 3, .actual);   /* read record type and length */
                                                 ; STATEMENT # 69
           0C17  2A862D          LHLD    AFTN
           0C1A  E5              PUSH    H       ; 1
           0C1B  01892D          LXI     B,RECORD
           0C1E  C5              PUSH    B       ; 2
           0C1F  11902D          LXI     D,ACTUAL
PL/M-80 COMPILER                                                                                                PAGE   5


           0C22  010300          LXI     B,3H
           0C25  CD3C1A          CALL    READ
  70   3              if actual < 3 OR record.type >= R$RELOC OR record.type then /* short, relocate or odd type */
                                                 ; STATEMENT # 70
           0C28  3E03            MVI     A,3H
           0C2A  11902D          LXI     D,ACTUAL
           0C2D  CD352A          CALL    @P0101 
           0C30  9F              SBB     A
           0C31  F5              PUSH    PSW     ; 1
           0C32  3A892D          LDA     RECORD
           0C35  D622            SUI     22H
           0C37  9F              SBB     A
           0C38  2F              CMA
           0C39  C1              POP     B       ; 1
           0C3A  48              MOV     C,B
           0C3B  B1              ORA     C
           0C3C  21892D          LXI     H,RECORD
           0C3F  B6              ORA     M
           0C40  1F              RAR
           0C41  D2490C          JNC     @6
  71   3                  call abortx(BAD$LOAD$FORMAT);
                                                 ; STATEMENT # 71
           0C44  0E10            MVI     C,10H
           0C46  CD4B0B          CALL    ABORTX
                         @6:
  72   3              if record.type > R$CONTENT then
                                                 ; STATEMENT # 72
           0C49  3E06            MVI     A,6H
           0C4B  21892D          LXI     H,RECORD
           0C4E  BE              CMP     M
           0C4F  D2660C          JNC     @7
  73   3                  call seek(aftn, SEEK$FORWARD, .blockno, .record.length);    /* skip record */
                                                 ; STATEMENT # 73
           0C52  2A862D          LHLD    AFTN
           0C55  E5              PUSH    H       ; 1
           0C56  010300          LXI     B,3H
           0C59  C5              PUSH    B       ; 2
           0C5A  118A2D          LXI     D,RECORD+1H
           0C5D  01942D          LXI     B,BLOCKNO
           0C60  CD641F          CALL    SEEK
           0C63  C3F70D          JMP     @8
                         @7:
                      else
  74   3              do;
  75   4                  do case shr(record.type,1);
                                                 ; STATEMENT # 75
           0C66  3A892D          LDA     RECORD
           0C69  B7              ORA     A
           0C6A  1F              RAR
           0C6B  4F              MOV     C,A
           0C6C  0600            MVI     B,0
           0C6E  21EF0D          LXI     H,@23
           0C71  09              DAD     B
           0C72  09              DAD     B
           0C73  5E              MOV     E,M
           0C74  23              INX     H
           0C75  56              MOV     D,M
PL/M-80 COMPILER                                                                                                PAGE   6


           0C76  EB              XCHG
           0C77  E9              PCHL
  76   5                  call abortx(BAD$LOAD$FORMAT);   /* case 0 */
                                                 ; STATEMENT # 76
                         @10:
           0C78  0E10            MVI     C,10H
           0C7A  CD4B0B          CALL    ABORTX
           0C7D  C3F70D          JMP     @9
  77   5                  call seek(aftn, SEEK$FORWARD, .blockno, .record.length);    /* case 1 - R$MODHDR skip */
                                                 ; STATEMENT # 77
                         @11:
           0C80  2A862D          LHLD    AFTN
           0C83  E5              PUSH    H       ; 1
           0C84  010300          LXI     B,3H
           0C87  C5              PUSH    B       ; 2
           0C88  118A2D          LXI     D,RECORD+1H
           0C8B  01942D          LXI     B,BLOCKNO
           0C8E  CD641F          CALL    SEEK
           0C91  C3F70D          JMP     @9
  78   5                  do; /* case 2 - R$MODEND */
                                                 ; STATEMENT # 78
                         @12:
  79   6                      call read(aftn, .modend, size(modend), .actual);
                                                 ; STATEMENT # 79
           0C94  2A862D          LHLD    AFTN
           0C97  E5              PUSH    H       ; 1
           0C98  018C2D          LXI     B,MODEND
           0C9B  C5              PUSH    B       ; 2
           0C9C  11902D          LXI     D,ACTUAL
           0C9F  010400          LXI     B,4H
           0CA2  CD3C1A          CALL    READ
  80   6                      modend.load$addr = modend.load$addr + bias;
                                                 ; STATEMENT # 80
           0CA5  2A802D          LHLD    BIAS
           0CA8  EB              XCHG
           0CA9  2A8E2D          LHLD    MODEND+2H
           0CAC  19              DAD     D
           0CAD  228E2D          SHLD    MODEND+2H
  81   6                      if modend.modtype = 1 then      /* system */
                                                 ; STATEMENT # 81
           0CB0  3A8C2D          LDA     MODEND
           0CB3  FE01            CPI     1H
           0CB5  C2C60C          JNZ     @13
  82   6                          call bounds$test(modend.load$addr, 0);
                                                 ; STATEMENT # 82
           0CB8  2A8E2D          LHLD    MODEND+2H
           0CBB  44              MOV     B,H
           0CBC  4D              MOV     C,L
           0CBD  110000          LXI     D,0H
           0CC0  CDFB0D          CALL    BOUNDSTEST
           0CC3  C3CC0C          JMP     @14
                         @13:
                              else
  83   6                          modend.load$addr = 0;
                                                 ; STATEMENT # 83
           0CC6  210000          LXI     H,0H
           0CC9  228E2D          SHLD    MODEND+2H
PL/M-80 COMPILER                                                                                                PAGE   7


                         @14:
  84   6                      call close(aftn);
                                                 ; STATEMENT # 84
           0CCC  2A862D          LHLD    AFTN
           0CCF  4D              MOV     C,L
           0CD0  CDF903          CALL    CLOSE
  85   6                      user$bottom = user$bottom AND 0ff80h;
                                                 ; STATEMENT # 85
           0CD3  1180FF          LXI     D,0FF80H
           0CD6  21962D          LXI     H,USERBOTTOM
           0CD9  CDA029          CALL    @P0027 
           0CDC  EB              XCHG
           0CDD  2B              DCX     H
           0CDE  73              MOV     M,E
           0CDF  23              INX     H
           0CE0  72              MOV     M,D
  86   6                      do i = 0 to 18;
                                                 ; STATEMENT # 86
           0CE1  21872D          LXI     H,I
           0CE4  3600            MVI     M,0H
                         @24:
           0CE6  3E12            MVI     A,12H
           0CE8  21872D          LXI     H,I
           0CEB  BE              CMP     M
           0CEC  DA260D          JC      @25
  87   7                          buffer$table(i) = buffer$table(i) AND 0FEh; /* assume available or in use */
                                                 ; STATEMENT # 87
           0CEF  2A872D          LHLD    I
           0CF2  2600            MVI     H,0
           0CF4  01D32E          LXI     B,BUFFERTABLE
           0CF7  09              DAD     B
           0CF8  3EFE            MVI     A,0FEH
           0CFA  A6              ANA     M
           0CFB  77              MOV     M,A
  88   7                          if user$bottom <= .MEMORY(shl(DOUBLE(i), 7)) then
                                                 ; STATEMENT # 88
           0CFC  2A872D          LHLD    I
           0CFF  2600            MVI     H,0
           0D01  0E07            MVI     C,7H
           0D03  CDFE29          CALL    @P0088 
           0D06  010030          LXI     B,MEMORY
           0D09  09              DAD     B
           0D0A  EB              XCHG
           0D0B  21962D          LXI     H,USERBOTTOM
           0D0E  CD432A          CALL    @P0104 
           0D11  DA1F0D          JC      @15
  89   7                              buffer$table(i) = 1;    /* not available */
                                                 ; STATEMENT # 89
           0D14  2A872D          LHLD    I
           0D17  2600            MVI     H,0
           0D19  01D32E          LXI     B,BUFFERTABLE
           0D1C  09              DAD     B
           0D1D  3601            MVI     M,1H
                         @15:
  90   7                      end;
                                                 ; STATEMENT # 90
                         @26:
PL/M-80 COMPILER                                                                                                PAGE   8


           0D1F  21872D          LXI     H,I
           0D22  34              INR     M
           0D23  C2E60C          JNZ     @24
                         @25:
  91   6                      if retsw$b = 0 then
                                                 ; STATEMENT # 91
           0D26  3A882D          LDA     RETSWB
           0D29  FE00            CPI     0H
           0D2B  C23B0D          JNZ     @16
  92   6                      do;
  93   7                          entry = modend.load$addr;
                                                 ; STATEMENT # 93
           0D2E  2A842D          LHLD    ENTRYP
           0D31  E5              PUSH    H       ; 1
           0D32  2A8E2D          LHLD    MODEND+2H
           0D35  EB              XCHG
           0D36  E1              POP     H       ; 1
           0D37  73              MOV     M,E
           0D38  23              INX     H
           0D39  72              MOV     M,D
  94   7                          return;
                                                 ; STATEMENT # 94
           0D3A  C9              RET
  95   7                      end;
                                                 ; STATEMENT # 95
                         @16:
  96   6                      if retsw$b = 1 then
                                                 ; STATEMENT # 96
           0D3B  3A882D          LDA     RETSWB
           0D3E  FE01            CPI     1H
           0D40  C2560D          JNZ     @17
  97   6                      do;
  98   7                          debug$toggle = FALSE;
                                                 ; STATEMENT # 98
           0D43  21302D          LXI     H,DTOGLE
           0D46  3600            MVI     M,0H
  99   7                          call jmpto(modend.load$addr, usrSP + 2);    /* wastes the return address */
                                                 ; STATEMENT # 99
           0D48  2A4400          LHLD    USRSP
           0D4B  23              INX     H
           0D4C  23              INX     H
           0D4D  EB              XCHG
           0D4E  2A8E2D          LHLD    MODEND+2H
           0D51  44              MOV     B,H
           0D52  4D              MOV     C,L
           0D53  CD8000          CALL    JMPTO
 100   7                      end;
                                                 ; STATEMENT # 100
                         @17:
 101   6                      STACKPTR = memck;   
                                                 ; STATEMENT # 101
           0D56  CD7229          CALL    MEMCK
           0D59  F9              SPHL
 102   6                      entry$p = STACKPTR;
                                                 ; STATEMENT # 102
           0D5A  210000          LXI     H,0     ; 0
           0D5D  39              DAD     SP
PL/M-80 COMPILER                                                                                                PAGE   9


           0D5E  22842D          SHLD    ENTRYP
 103   6                      entry = modend.load$addr;
                                                 ; STATEMENT # 103
           0D61  E5              PUSH    H       ; 1
           0D62  2A8E2D          LHLD    MODEND+2H
           0D65  EB              XCHG
           0D66  E1              POP     H       ; 1
           0D67  73              MOV     M,E
           0D68  23              INX     H
           0D69  72              MOV     M,D
 104   6                      debug$toggle = TRUE;
                                                 ; STATEMENT # 104
           0D6A  21302D          LXI     H,DTOGLE
           0D6D  36FF            MVI     M,0FFH
 105   6                      call trap;
                                                 ; STATEMENT # 105
           0D6F  CDFD28          CALL    TRAP
 106   6                  end;
                                                 ; STATEMENT # 106
           0D72  C3F70D          JMP     @9
 107   5                  do; /* case 3 - R$CONTENT */
                                                 ; STATEMENT # 107
                         @18:
 108   6                      call read(aftn, .content, 3, .actual);
                                                 ; STATEMENT # 108
           0D75  2A862D          LHLD    AFTN
           0D78  E5              PUSH    H       ; 1
           0D79  018C2D          LXI     B,CONTENT
           0D7C  C5              PUSH    B       ; 2
           0D7D  11902D          LXI     D,ACTUAL
           0D80  010300          LXI     B,3H
           0D83  CD3C1A          CALL    READ
 109   6                      if content.segId <> 0 then
                                                 ; STATEMENT # 109
           0D86  3A8C2D          LDA     CONTENT
           0D89  FE00            CPI     0H
           0D8B  CA930D          JZ      @19
 110   6                          call abortx(BAD$LOAD$FORMAT);
                                                 ; STATEMENT # 110
           0D8E  0E10            MVI     C,10H
           0D90  CD4B0B          CALL    ABORTX
                         @19:
 111   6                      record.length = record.length - 4;      /* don't include header and crc */
                                                 ; STATEMENT # 111
           0D93  3E04            MVI     A,4H
           0D95  118A2D          LXI     D,RECORD+1H
           0D98  CD352A          CALL    @P0101 
           0D9B  EB              XCHG
           0D9C  2B              DCX     H
           0D9D  73              MOV     M,E
           0D9E  23              INX     H
           0D9F  72              MOV     M,D
 112   6                      content.load$addr = content.load$addr + bias;
                                                 ; STATEMENT # 112
           0DA0  2A802D          LHLD    BIAS
           0DA3  EB              XCHG
           0DA4  2A8D2D          LHLD    CONTENT+1H
PL/M-80 COMPILER                                                                                                PAGE  10


           0DA7  19              DAD     D
           0DA8  228D2D          SHLD    CONTENT+1H
 113   6                      call bounds$test(content.load$addr, record.length);
                                                 ; STATEMENT # 113
           0DAB  2A8D2D          LHLD    CONTENT+1H
           0DAE  44              MOV     B,H
           0DAF  4D              MOV     C,L
           0DB0  2A8A2D          LHLD    RECORD+1H
           0DB3  EB              XCHG
           0DB4  CDFB0D          CALL    BOUNDSTEST
 114   6                      call read(aftn, content.load$addr, record.length, .actual);
                                                 ; STATEMENT # 114
           0DB7  2A862D          LHLD    AFTN
           0DBA  E5              PUSH    H       ; 1
           0DBB  2A8D2D          LHLD    CONTENT+1H
           0DBE  E5              PUSH    H       ; 2
           0DBF  2A8A2D          LHLD    RECORD+1H
           0DC2  44              MOV     B,H
           0DC3  4D              MOV     C,L
           0DC4  11902D          LXI     D,ACTUAL
           0DC7  CD3C1A          CALL    READ
 115   6                      if actual < record.length then
                                                 ; STATEMENT # 115
           0DCA  018A2D          LXI     B,RECORD+1H
           0DCD  11902D          LXI     D,ACTUAL
           0DD0  CD282A          CALL    @P0098 
           0DD3  D2DB0D          JNC     @20
 116   6                          call abortx(BAD$LOAD$FORMAT);
                                                 ; STATEMENT # 116
           0DD6  0E10            MVI     C,10H
           0DD8  CD4B0B          CALL    ABORTX
                         @20:
 117   6                      call read(aftn, .checksum, 1, .actual);
                                                 ; STATEMENT # 117
           0DDB  2A862D          LHLD    AFTN
           0DDE  E5              PUSH    H       ; 1
           0DDF  018C2D          LXI     B,CHECKSUM
           0DE2  C5              PUSH    B       ; 2
           0DE3  11902D          LXI     D,ACTUAL
           0DE6  010100          LXI     B,1H
           0DE9  CD3C1A          CALL    READ
 118   6                  end;
                                                 ; STATEMENT # 118
           0DEC  C3F70D          JMP     @9
 119   5                  end;    /* of case */
                                                 ; STATEMENT # 119
                         @23:
           0DEF  780C            DW      @10
           0DF1  800C            DW      @11
           0DF3  940C            DW      @12
           0DF5  750D            DW      @18
                         @9:
 120   4              end;    /* of else */
                                                 ; STATEMENT # 120
                         @8:
 121   3          end;
                                                 ; STATEMENT # 121
PL/M-80 COMPILER                                                                                                PAGE  11


           0DF7  C3170C          JMP     @21
                         @22:
 122   2      end;
                                                 ; STATEMENT # 122
           0DFA  C9              RET
 123   1      end;
              eof



MODULE INFORMATION:

     CODE AREA SIZE     = 02B2H    690D
     VARIABLE AREA SIZE = 0020H     32D
     MAXIMUM STACK SIZE = 0006H      6D
     135 LINES READ
     0 PROGRAM ERRORS

END OF PL/M-80 COMPILATION
