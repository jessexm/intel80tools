PL/M-80 COMPILER                                                                                                PAGE   1


ISIS-II PL/M-80 V4.0 COMPILATION OF MODULE BUFFER
OBJECT MODULE PLACED IN BUFFER.OBJ
COMPILER INVOKED BY:  :F1:plm80 buffer.plm PRINT(BUFFER.LST) OBJECT(BUFFER.OBJ) DEBUG OPTIMIZE CODE



   1          buffer:
              DO;
        
              /*
                  ABSTRACT
                      This module contains routines for obtaining, clearing
                      releasing and packing buffers of 128 bytes each.
        
                  MODULE ORGANISATION
                      This module contains an llocation table ('buffer$table') and
                      4 subroutines
                      Buffers are allocted in RAM, starting at ".MEMORY" and
                      working upwards (to the user's program origin point).
                      'buffer$table' contains 19 entries, allowing maximum buffer
                      usage for 6 open files (all lined input files, 3 buffers each),
                      plus 1 buffer for the console.
        
                  INVARIANTS
                      Each entry in 'buffer$table' is initialised to '0'; legal
                      values are 0, 1 and 2 with the following meanings
                      0 - corresponding buffer is available, but not allocated.
                      1 - corresponding buffer is not available, because it is
                          in the current user RAM area
                      2 - corresponding buffer is in use.
        
                      Entries change when buffes are obtained or released (via
                      get$buf and return$buf), or when then user's program origin
                      point is changed (by making a call to the 'load' subroutine).
              */
        
              $include(buffer.ipx)
   2   1  =   declare Clear$Buf literally 'ClrBuf';
   3   1  =   declare AFT$BOTTOM literally '10';
   4   1  =   declare AFT$LAST literally '17';
   5   1  =   declare AFT$T literally 'structure(AFT$T1, AFT$T2, AFT$T3, AFT$T4)';
   6   1  =   declare AFT$T1 literally 'empty BYTE, device BYTE, access BYTE, edit BYTE, lbuf ADDRESS';
   7   1  =   declare AFT$T2 literally 'dbuf ADDRESS, pbuf ADDRESS, data$ptr BYTE, i$no ADDRESS, ptr$ptr BYTE';
   8   1  =   declare AFT$T3 literally 'eofcnt BYTE, ptr$change BYTE, data$change BYTE, blk ADDRESS, blk$seq ADDRESS';
   9   1  =   declare AFT$T4 literally 'ptr$blk ADDRESS, hdr$blk ADDRESS, data$blk$count ADDRESS, dbuf$read BYTE';
  10   1  =   declare NO$FREE$BUFFER literally '1';
  11   1  =   declare aft(18) AFT$T external;
  12   1  =   abortx: procedure(errcode) external; declare errcode byte; end;
        
  15   1      DECLARE buffer$table(19) BYTE PUBLIC INITIAL(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
  16   1      DECLARE i BYTE;
        
  17   1      clear$buf: PROCEDURE(buf$address) PUBLIC;
                                                 ; STATEMENT # 17
                         ; PROC  CLRBUF
           0000  211500          LXI     H,BUFADDRESS+1H
           0003  70              MOV     M,B
PL/M-80 COMPILER                                                                                                PAGE   2


           0004  2B              DCX     H
           0005  71              MOV     M,C
  18   2          DECLARE buf$address ADDRESS;
  19   2          DECLARE buffer BASED buf$address (128) BYTE;
        
  20   2          do i = 0 to 127;
                                                 ; STATEMENT # 20
           0006  211300          LXI     H,I
           0009  3600            MVI     M,0H
                         @6:
           000B  3E7F            MVI     A,7FH
           000D  211300          LXI     H,I
           0010  BE              CMP     M
           0011  DA2700          JC      @7
  21   3              buffer(i) = 0;
                                                 ; STATEMENT # 21
           0014  2A1300          LHLD    I
           0017  2600            MVI     H,0
           0019  EB              XCHG
           001A  2A1400          LHLD    BUFADDRESS
           001D  19              DAD     D
           001E  3600            MVI     M,0H
  22   3          end;
                                                 ; STATEMENT # 22
                         @8:
           0020  211300          LXI     H,I
           0023  34              INR     M
           0024  C20B00          JNZ     @6
                         @7:
  23   2      end;
                                                 ; STATEMENT # 23
           0027  C9              RET
        
  24   1      return$buf: PROCEDURE(buf$address) PUBLIC;
                                                 ; STATEMENT # 24
                         ; PROC  RETURNBUF
           0028  211700          LXI     H,BUFADDRESS+1H
           002B  70              MOV     M,B
           002C  2B              DCX     H
           002D  71              MOV     M,C
  25   2          DECLARE buf$address ADDRESS;
        
  26   2          buffer$table(shr(buf$address - .MEMORY, 7)) = 0;
                                                 ; STATEMENT # 26
           002E  010000          LXI     B,MEMORY
           0031  111600          LXI     D,BUFADDRESS
           0034  CD0000          CALL    @P0100 
           0037  0E07            MVI     C,7H
           0039  CD0000          CALL    @P0093 
           003C  010000          LXI     B,BUFFERTABLE
           003F  09              DAD     B
           0040  3600            MVI     M,0H
  27   2      end;
                                                 ; STATEMENT # 27
           0042  C9              RET
        
        
PL/M-80 COMPILER                                                                                                PAGE   3


        
        
  28   1      get$buf: PROCEDURE ADDRESS PUBLIC;
                                                 ; STATEMENT # 28
                         ; PROC  GETBUF
  29   2          do i = 0 to last(buffer$table);
                                                 ; STATEMENT # 29
           0043  211300          LXI     H,I
           0046  3600            MVI     M,0H
                         @9:
           0048  3E12            MVI     A,12H
           004A  211300          LXI     H,I
           004D  BE              CMP     M
           004E  DA8100          JC      @10
  30   3              if buffer$table(i) = 0 then
                                                 ; STATEMENT # 30
           0051  2A1300          LHLD    I
           0054  2600            MVI     H,0
           0056  010000          LXI     B,BUFFERTABLE
           0059  09              DAD     B
           005A  7E              MOV     A,M
           005B  FE00            CPI     0H
           005D  C27A00          JNZ     @1
  31   3              do;
  32   4                  buffer$table(i) = 2;
                                                 ; STATEMENT # 32
           0060  2A1300          LHLD    I
           0063  2600            MVI     H,0
           0065  010000          LXI     B,BUFFERTABLE
           0068  09              DAD     B
           0069  3602            MVI     M,2H
  33   4                  return .MEMORY + shl(DOUBLE(i), 7);
                                                 ; STATEMENT # 33
           006B  2A1300          LHLD    I
           006E  2600            MVI     H,0
           0070  0E07            MVI     C,7H
           0072  CD0000          CALL    @P0088 
           0075  010000          LXI     B,MEMORY
           0078  09              DAD     B
           0079  C9              RET
  34   4              end;
                                                 ; STATEMENT # 34
                         @1:
  35   3          end;
                                                 ; STATEMENT # 35
                         @11:
           007A  211300          LXI     H,I
           007D  34              INR     M
           007E  C24800          JNZ     @9
                         @10:
  36   2          call abortx(NO$FREE$BUFFER);    /* 1 */
                                                 ; STATEMENT # 36
           0081  0E01            MVI     C,1H
           0083  CD0000          CALL    ABORTX
  37   2      end;
                                                 ; STATEMENT # 37
           0086  C9              RET
PL/M-80 COMPILER                                                                                                PAGE   4


        
              /*
                  ABSTRACT
                      This routine reassigns buffer space and moves buffer
                      contents as necessary, to ensure that there is no unused
                      buffer space below the area occupied by the highest buffer
                      in use.
        
        
                  RETURNS
                      The address of the first (lowest) byte in the first
                      (lowest) unallocated buffer. THis information is the "top of
                      buffer area" described in the mds-dos operator's manual.
        
                  DESCRIPTION
                      For every AFT entry which is a currently assigned
                      buffer address, the buffer is returned (using 'return$buf')
                      and is replace by a new buffer (using 'get$buf'). If the new
                      buffer is a different one than the one returned, then the
                      data from the old is moved into the new.
              */
        
        
        
  38   1      pack$aft$buf: PROCEDURE ADDRESS PUBLIC;
                                                 ; STATEMENT # 38
                         ; PROC  PACKAFTBUF
  39   2          DECLARE (i, j, index) BYTE;
  40   2          DECLARE buffer$top ADDRESS;
  41   2          DECLARE bptr ADDRESS, bufadr BASED bptr ADDRESS;
  42   2          DECLARE new$badr ADDRESS, new$datum BASED new$badr(128) BYTE,
                      old$badr ADDRESS, old$datum BASED old$badr(128) BYTE;
        
  43   2          buffer$top = .MEMORY;
                                                 ; STATEMENT # 43
           0087  210000          LXI     H,MEMORY
           008A  221B00          SHLD    BUFFERTOP
  44   2          do i = AFT$BOTTOM to AFT$LAST;
                                                 ; STATEMENT # 44
           008D  211800          LXI     H,I
           0090  360A            MVI     M,0AH
                         @12:
           0092  3E11            MVI     A,11H
           0094  211800          LXI     H,I
           0097  BE              CMP     M
           0098  DA8C01          JC      @13
  45   3              if not aft(i).empty then
                                                 ; STATEMENT # 45
           009B  111C00          LXI     D,1CH
           009E  2A1800          LHLD    I
           00A1  2600            MVI     H,0
           00A3  CD0000          CALL    @P0034 
           00A6  010000          LXI     B,AFT
           00A9  09              DAD     B
           00AA  7E              MOV     A,M
           00AB  1F              RAR
           00AC  DA8501          JC      @2
PL/M-80 COMPILER                                                                                                PAGE   5


  46   3              do index = 0 to 4 BY 2;
                                                 ; STATEMENT # 46
           00AF  211A00          LXI     H,INDEX
           00B2  3600            MVI     M,0H
                         @14:
           00B4  3E04            MVI     A,4H
           00B6  211A00          LXI     H,INDEX
           00B9  BE              CMP     M
           00BA  DA8501          JC      @15
           00BD  C3CE00          JMP     @16
                         @17:
           00C0  3A1A00          LDA     INDEX
           00C3  C602            ADI     2H
           00C5  321A00          STA     INDEX
           00C8  D2B400          JNC     @14
           00CB  C38501          JMP     @15
                         @16:
  47   4                  bptr = .aft(i).pbuf - index;
                                                 ; STATEMENT # 47
           00CE  111C00          LXI     D,1CH
           00D1  2A1800          LHLD    I
           00D4  2600            MVI     H,0
           00D6  CD0000          CALL    @P0034 
           00D9  010000          LXI     B,AFT
           00DC  09              DAD     B
           00DD  010800          LXI     B,PBUF
           00E0  09              DAD     B
           00E1  EB              XCHG
           00E2  3A1A00          LDA     INDEX
           00E5  CD0000          CALL    @P0096 
           00E8  221D00          SHLD    BPTR
  48   4                  j = shr(bufadr - .MEMORY, 7);
                                                 ; STATEMENT # 48
           00EB  EB              XCHG
           00EC  010000          LXI     B,MEMORY
           00EF  CD0000          CALL    @P0100 
           00F2  0E07            MVI     C,7H
           00F4  CD0000          CALL    @P0093 
           00F7  EB              XCHG
           00F8  211900          LXI     H,J
           00FB  73              MOV     M,E
  49   4                  if j <= last(buffer$table) and buffer$table(j) = 2 then
                                                 ; STATEMENT # 49
           00FC  3E12            MVI     A,12H
           00FE  93              SUB     E
           00FF  9F              SBB     A
           0100  2F              CMA
           0101  1600            MVI     D,0
           0103  210000          LXI     H,BUFFERTABLE
           0106  19              DAD     D
           0107  F5              PUSH    PSW     ; 1
           0108  7E              MOV     A,M
           0109  D602            SUI     2H
           010B  D601            SUI     1
           010D  9F              SBB     A
           010E  C1              POP     B       ; 1
           010F  48              MOV     C,B
PL/M-80 COMPILER                                                                                                PAGE   6


           0110  A1              ANA     C
           0111  1F              RAR
           0112  D28201          JNC     @3
  50   4                  do;
  51   5                      old$badr = bufadr;
                                                 ; STATEMENT # 51
           0115  2A1D00          LHLD    BPTR
           0118  5E              MOV     E,M
           0119  23              INX     H
           011A  56              MOV     D,M
           011B  EB              XCHG
           011C  222100          SHLD    OLDBADR
  52   5                      call return$buf(old$badr);
                                                 ; STATEMENT # 52
           011F  2A2100          LHLD    OLDBADR
           0122  44              MOV     B,H
           0123  4D              MOV     C,L
           0124  CD2800          CALL    RETURNBUF
  53   5                      if buffer$top < (new$badr := getbuf) then
                                                 ; STATEMENT # 53
           0127  CD4300          CALL    GETBUF
           012A  221F00          SHLD    NEWBADR
           012D  111B00          LXI     D,BUFFERTOP
           0130  CD0000          CALL    @P0102 
           0133  D23C01          JNC     @4
  54   5                          buffer$top = new$badr;
                                                 ; STATEMENT # 54
           0136  2A1F00          LHLD    NEWBADR
           0139  221B00          SHLD    BUFFERTOP
                         @4:
  55   5                      if new$badr <> old$badr then
                                                 ; STATEMENT # 55
           013C  012100          LXI     B,OLDBADR
           013F  111F00          LXI     D,NEWBADR
           0142  CD0000          CALL    @P0098 
           0145  B5              ORA     L
           0146  CA8201          JZ      @5
  56   5                      do;
  57   6                          do j = 0 to 127;
                                                 ; STATEMENT # 57
           0149  211900          LXI     H,J
           014C  3600            MVI     M,0H
                         @18:
           014E  3E7F            MVI     A,7FH
           0150  211900          LXI     H,J
           0153  BE              CMP     M
           0154  DA7601          JC      @19
  58   7                              new$datum(j) = old$datum(j);
                                                 ; STATEMENT # 58
           0157  2A1900          LHLD    J
           015A  2600            MVI     H,0
           015C  EB              XCHG
           015D  2A2100          LHLD    OLDBADR
           0160  19              DAD     D
           0161  E5              PUSH    H       ; 1
           0162  2A1900          LHLD    J
           0165  2600            MVI     H,0
PL/M-80 COMPILER                                                                                                PAGE   7


           0167  EB              XCHG
           0168  2A1F00          LHLD    NEWBADR
           016B  19              DAD     D
           016C  C1              POP     B       ; 1
           016D  0A              LDAX    B
           016E  77              MOV     M,A
  59   7                          end;
                                                 ; STATEMENT # 59
                         @20:
           016F  211900          LXI     H,J
           0172  34              INR     M
           0173  C24E01          JNZ     @18
                         @19:
  60   6                          bufadr = new$badr;
                                                 ; STATEMENT # 60
           0176  2A1D00          LHLD    BPTR
           0179  E5              PUSH    H       ; 1
           017A  2A1F00          LHLD    NEWBADR
           017D  EB              XCHG
           017E  E1              POP     H       ; 1
           017F  73              MOV     M,E
           0180  23              INX     H
           0181  72              MOV     M,D
  61   6                      end;
                                                 ; STATEMENT # 61
                         @5:
  62   5                  end;
                                                 ; STATEMENT # 62
                         @3:
  63   4              end;    /* of loop to handle each buffer p, d, l */
                                                 ; STATEMENT # 63
           0182  C3C000          JMP     @17
                         @15:
                         @2:
  64   3          end;    /* of look to traverse aft */
                                                 ; STATEMENT # 64
                         @21:
           0185  211800          LXI     H,I
           0188  34              INR     M
           0189  C29200          JNZ     @12
                         @13:
  65   2          return buffer$top + 128;
                                                 ; STATEMENT # 65
           018C  118000          LXI     D,80H
           018F  2A1B00          LHLD    BUFFERTOP
           0192  19              DAD     D
           0193  C9              RET
  66   2      end;
                                                 ; STATEMENT # 66
  67   1      end;
              eof



MODULE INFORMATION:

     CODE AREA SIZE     = 0194H    404D
PL/M-80 COMPILER                                                                                                PAGE   8


     VARIABLE AREA SIZE = 0023H     35D
     MAXIMUM STACK SIZE = 0004H      4D
     131 LINES READ
     0 PROGRAM ERRORS

END OF PL/M-80 COMPILATION
