PL/M-80 COMPILER                                                                                                PAGE   1


ISIS-II PL/M-80 V4.0 COMPILATION OF MODULE LOAD
OBJECT MODULE PLACED IN LOAD.OBJ
COMPILER INVOKED BY:  :F1:plm80 load.plm PRINT(LOAD.LST) OBJECT(LOAD.OBJ) DEBUG OPTIMIZE CODE



   1          load:
              do;
              $include(load.ipx)
   2   1  =   declare debug$Toggle literally 'dTogle';
   3   1  =   declare AFT$BOTTOM literally '10';
   4   1  =   declare BAD$LOAD$FORMAT literally '16';
   5   1  =   declare BAD$RETSW literally '34';
   6   1  =   declare FALSE literally '0';
   7   1  =   declare ISIS$OVERWRITE literally '15';
   8   1  =   declare SEEK$FORWARD literally '3';
   9   1  =   declare TRUE literally '0ffh';
  10   1  =   declare buffer$table(1) byte external;
  11   1  =   declare debugToggle byte external;
  12   1  =   declare usrSP address external;
  13   1  =   abortx: procedure(errcode) external; declare errcode byte; end;
  16   1  =   close: procedure(aftn) external; declare aftn byte; end;
  19   1  =   jmpto: procedure(entry, stack) external; declare entry address, stack address; end;
  22   1  =   memck: procedure address external; end;
  24   1  =   open: procedure(pathname, access$mode, lined$aft) byte external;
  25   2  =           declare pathname address, access$mode address, lined$aft address; end;
  27   1  =   pack$aft$buf: procedure address external; end;
  29   1  =   read: procedure(aftn, buffer, count, actual$p) external;
  30   2  =           declare aftn byte, buffer address, count address, actual$p address; end;
  32   1  =   seek: procedure(aftn, mode, blockptr, byteptr) external;
  33   2  =           declare aftn byte, mode address, blockptr address, byteptr address; end;
  35   1  =   trap: procedure external; end;
  37   1  =   warn: procedure(errcode) external; declare errcode byte; end;
        
  40   1      DECLARE R$MODHDR    LITERALLY   '2',
                  R$MODEND    LITERALLY   '4',
                  R$CONTENT   LITERALLY   '6',
                  R$LINENO    LITERALLY   '8',
                  R$EOF       LITERALLY   '0EH',
                  R$ANCESTOR  LITERALLY   '10H',
                  R$LOCALS    LITERALLY   '12H',
                  R$PUBLICS   LITERALLY   '16H',
                  R$EXTNAMES  LITERALLY   '18H',
                  R$EXTREF    LITERALLY   '20H',
                  R$RELOC     LITERALLY   '22H',
                  R$INTERSEG  LITERALLY   '24H',
                  R$LIBLOCS   LITERALLY   '26H',
                  R$LIBNAMES  LITERALLY   '28H',
                  R$LIBDICT   LITERALLY   '2AH',
                  R$LIBHDR    LITERALLY   '2CH',
                  R$COMDEF    LITERALLY   '2EH';
        
  41   1      load: PROCEDURE(pathname, bias, retsw, entry$p) PUBLIC;
                                                 ; STATEMENT # 41
                         ; PROC  LOAD
           0000  210700          LXI     H,ENTRYP+1H
           0003  72              MOV     M,D
PL/M-80 COMPILER                                                                                                PAGE   2


           0004  2B              DCX     H
           0005  73              MOV     M,E
           0006  2B              DCX     H
           0007  70              MOV     M,B
           0008  2B              DCX     H
           0009  71              MOV     M,C
           000A  2B              DCX     H
           000B  D1              POP     D       
           000C  C1              POP     B       
           000D  70              MOV     M,B
           000E  2B              DCX     H
           000F  71              MOV     M,C
           0010  2B              DCX     H
           0011  C1              POP     B       
           0012  70              MOV     M,B
           0013  2B              DCX     H
           0014  71              MOV     M,C
           0015  D5              PUSH    D       
  42   2          DECLARE (pathname, bias, retsw, entry$p) ADDRESS;
  43   2          DECLARE entry BASED entry$p ADDRESS;
  44   2          DECLARE (aftn, i, retsw$b) BYTE;
  45   2          DECLARE record STRUCTURE(type BYTE, length ADDRESS);
  46   2          DECLARE modend STRUCTURE(modtype BYTE, segid BYTE, load$addr ADDRESS);
  47   2          DECLARE content STRUCTURE(segid BYTE, load$addr ADDRESS) AT (.modend);
  48   2          DECLARE checksum BYTE AT (.modend); 
  49   2          DECLARE actual ADDRESS, pad ADDRESS;
  50   2          DECLARE blockno ADDRESS, user$bottom ADDRESS, buffer$top ADDRESS;
        
  51   2          bounds$test: PROCEDURE(addr, len);
                                                 ; STATEMENT # 51
                         ; PROC  BOUNDSTEST
           0243  211F00          LXI     H,LEN+1H
           0246  72              MOV     M,D
           0247  2B              DCX     H
           0248  73              MOV     M,E
           0249  2B              DCX     H
           024A  70              MOV     M,B
           024B  2B              DCX     H
           024C  71              MOV     M,C
  52   3              DECLARE (addr, len) ADDRESS;
  53   3              if addr >= 18h AND addr <= 3fh AND addr + len <= 40h then
                                                 ; STATEMENT # 53
           024D  3E18            MVI     A,18H
           024F  111C00          LXI     D,ADDR
           0252  CD0000          CALL    @P0101 
           0255  9F              SBB     A
           0256  2F              CMA
           0257  EB              XCHG
           0258  F5              PUSH    PSW     ; 1
           0259  3E3F            MVI     A,3FH
           025B  2B              DCX     H
           025C  CD0000          CALL    @P0103 
           025F  9F              SBB     A
           0260  2F              CMA
           0261  C1              POP     B       ; 1
           0262  48              MOV     C,B
           0263  A1              ANA     C
PL/M-80 COMPILER                                                                                                PAGE   3


           0264  2A1E00          LHLD    LEN
           0267  1B              DCX     D
           0268  F5              PUSH    PSW     ; 1
           0269  CD0000          CALL    @P0017 
           026C  3E40            MVI     A,40H
           026E  CD0000          CALL    @P0094 
           0271  9F              SBB     A
           0272  2F              CMA
           0273  C1              POP     B       ; 1
           0274  48              MOV     C,B
           0275  A1              ANA     C
           0276  1F              RAR
           0277  D27B02          JNC     @1
  54   3                  return;
                                                 ; STATEMENT # 54
           027A  C9              RET
                         @1:
  55   3              if user$bottom > addr then
                                                 ; STATEMENT # 55
           027B  111C00          LXI     D,ADDR
           027E  011800          LXI     B,USERBOTTOM
           0281  CD0000          CALL    @P0098 
           0284  D28D02          JNC     @2
  56   3                  user$bottom = addr; /* first address will update this if applicable */
                                                 ; STATEMENT # 56
           0287  2A1C00          LHLD    ADDR
           028A  221800          SHLD    USERBOTTOM
                         @2:
  57   3              if buffer$top > addr OR addr + len  < addr then
                                                 ; STATEMENT # 57
           028D  111C00          LXI     D,ADDR
           0290  011A00          LXI     B,BUFFERTOP
           0293  CD0000          CALL    @P0098 
           0296  9F              SBB     A
           0297  2A1E00          LHLD    LEN
           029A  1B              DCX     D
           029B  F5              PUSH    PSW     ; 1
           029C  CD0000          CALL    @P0017 
           029F  EB              XCHG
           02A0  2B              DCX     H
           02A1  CD0000          CALL    @P0104 
           02A4  9F              SBB     A
           02A5  C1              POP     B       ; 1
           02A6  48              MOV     C,B
           02A7  B1              ORA     C
           02A8  1F              RAR
           02A9  D2B102          JNC     @3
  58   3                  call abortx(ISIS$OVERWRITE);
                                                 ; STATEMENT # 58
           02AC  0E0F            MVI     C,0FH
           02AE  CD0000          CALL    ABORTX
                         @3:
  59   3          end;
                                                 ; STATEMENT # 59
           02B1  C9              RET
        
  60   2          blockno = 0;
PL/M-80 COMPILER                                                                                                PAGE   4


                                                 ; STATEMENT # 60
           0016  210000          LXI     H,0H
           0019  221600          SHLD    BLOCKNO
  61   2          user$bottom = 0ffffh;
                                                 ; STATEMENT # 61
           001C  2B              DCX     H
           001D  221800          SHLD    USERBOTTOM
  62   2          if retsw > 2 then
                                                 ; STATEMENT # 62
           0020  3E02            MVI     A,2H
           0022  210400          LXI     H,RETSW
           0025  CD0000          CALL    @P0103 
           0028  D23000          JNC     @4
  63   2              call warn(BAD$RETSW);
                                                 ; STATEMENT # 63
           002B  0E22            MVI     C,22H
           002D  CD0000          CALL    WARN
                         @4:
        
  64   2          aftn = AFT$BOTTOM +  open(pathname, 1, 0);  /* open$read */
                                                 ; STATEMENT # 64
           0030  2A0000          LHLD    PATHNAME
           0033  E5              PUSH    H       ; 1
           0034  110000          LXI     D,0H
           0037  010100          LXI     B,1H
           003A  CD0000          CALL    OPEN
           003D  C60A            ADI     0AH
           003F  320800          STA     AFTN
  65   2          if (retsw$b := retsw) <> 0 then
                                                 ; STATEMENT # 65
           0042  2A0400          LHLD    RETSW
           0045  EB              XCHG
           0046  210A00          LXI     H,RETSWB
           0049  73              MOV     M,E
           004A  3E00            MVI     A,0H
           004C  CD0000          CALL    @P0096 
           004F  B5              ORA     L
           0050  CA5900          JZ      @5
  66   2              user$bottom = memck;
                                                 ; STATEMENT # 66
           0053  CD0000          CALL    MEMCK
           0056  221800          SHLD    USERBOTTOM
                         @5:
  67   2          buffer$top = pack$aft$buf;
                                                 ; STATEMENT # 67
           0059  CD0000          CALL    PACKAFTBUF
           005C  221A00          SHLD    BUFFERTOP
  68   2          do while TRUE;
                                                 ; STATEMENT # 68
                         @21:
  69   3              call read(aftn, .record, 3, .actual);   /* read record type and length */
                                                 ; STATEMENT # 69
           005F  2A0800          LHLD    AFTN
           0062  E5              PUSH    H       ; 1
           0063  010B00          LXI     B,RECORD
           0066  C5              PUSH    B       ; 2
           0067  111200          LXI     D,ACTUAL
PL/M-80 COMPILER                                                                                                PAGE   5


           006A  010300          LXI     B,3H
           006D  CD0000          CALL    READ
  70   3              if actual < 3 OR record.type >= R$RELOC OR record.type then /* short, relocate or odd type */
                                                 ; STATEMENT # 70
           0070  3E03            MVI     A,3H
           0072  111200          LXI     D,ACTUAL
           0075  CD0000          CALL    @P0101 
           0078  9F              SBB     A
           0079  F5              PUSH    PSW     ; 1
           007A  3A0B00          LDA     RECORD
           007D  D622            SUI     22H
           007F  9F              SBB     A
           0080  2F              CMA
           0081  C1              POP     B       ; 1
           0082  48              MOV     C,B
           0083  B1              ORA     C
           0084  210B00          LXI     H,RECORD
           0087  B6              ORA     M
           0088  1F              RAR
           0089  D29100          JNC     @6
  71   3                  call abortx(BAD$LOAD$FORMAT);
                                                 ; STATEMENT # 71
           008C  0E10            MVI     C,10H
           008E  CD0000          CALL    ABORTX
                         @6:
  72   3              if record.type > R$CONTENT then
                                                 ; STATEMENT # 72
           0091  3E06            MVI     A,6H
           0093  210B00          LXI     H,RECORD
           0096  BE              CMP     M
           0097  D2AE00          JNC     @7
  73   3                  call seek(aftn, SEEK$FORWARD, .blockno, .record.length);    /* skip record */
                                                 ; STATEMENT # 73
           009A  2A0800          LHLD    AFTN
           009D  E5              PUSH    H       ; 1
           009E  010300          LXI     B,3H
           00A1  C5              PUSH    B       ; 2
           00A2  110C00          LXI     D,RECORD+1H
           00A5  011600          LXI     B,BLOCKNO
           00A8  CD0000          CALL    SEEK
           00AB  C33F02          JMP     @8
                         @7:
                      else
  74   3              do;
  75   4                  do case shr(record.type,1);
                                                 ; STATEMENT # 75
           00AE  3A0B00          LDA     RECORD
           00B1  B7              ORA     A
           00B2  1F              RAR
           00B3  4F              MOV     C,A
           00B4  0600            MVI     B,0
           00B6  213702          LXI     H,@23
           00B9  09              DAD     B
           00BA  09              DAD     B
           00BB  5E              MOV     E,M
           00BC  23              INX     H
           00BD  56              MOV     D,M
PL/M-80 COMPILER                                                                                                PAGE   6


           00BE  EB              XCHG
           00BF  E9              PCHL
  76   5                  call abortx(BAD$LOAD$FORMAT);   /* case 0 */
                                                 ; STATEMENT # 76
                         @10:
           00C0  0E10            MVI     C,10H
           00C2  CD0000          CALL    ABORTX
           00C5  C33F02          JMP     @9
  77   5                  call seek(aftn, SEEK$FORWARD, .blockno, .record.length);    /* case 1 - R$MODHDR skip */
                                                 ; STATEMENT # 77
                         @11:
           00C8  2A0800          LHLD    AFTN
           00CB  E5              PUSH    H       ; 1
           00CC  010300          LXI     B,3H
           00CF  C5              PUSH    B       ; 2
           00D0  110C00          LXI     D,RECORD+1H
           00D3  011600          LXI     B,BLOCKNO
           00D6  CD0000          CALL    SEEK
           00D9  C33F02          JMP     @9
  78   5                  do; /* case 2 - R$MODEND */
                                                 ; STATEMENT # 78
                         @12:
  79   6                      call read(aftn, .modend, size(modend), .actual);
                                                 ; STATEMENT # 79
           00DC  2A0800          LHLD    AFTN
           00DF  E5              PUSH    H       ; 1
           00E0  010E00          LXI     B,MODEND
           00E3  C5              PUSH    B       ; 2
           00E4  111200          LXI     D,ACTUAL
           00E7  010400          LXI     B,4H
           00EA  CD0000          CALL    READ
  80   6                      modend.load$addr = modend.load$addr + bias;
                                                 ; STATEMENT # 80
           00ED  2A0200          LHLD    BIAS
           00F0  EB              XCHG
           00F1  2A1000          LHLD    MODEND+2H
           00F4  19              DAD     D
           00F5  221000          SHLD    MODEND+2H
  81   6                      if modend.modtype = 1 then      /* system */
                                                 ; STATEMENT # 81
           00F8  3A0E00          LDA     MODEND
           00FB  FE01            CPI     1H
           00FD  C20E01          JNZ     @13
  82   6                          call bounds$test(modend.load$addr, 0);
                                                 ; STATEMENT # 82
           0100  2A1000          LHLD    MODEND+2H
           0103  44              MOV     B,H
           0104  4D              MOV     C,L
           0105  110000          LXI     D,0H
           0108  CD4302          CALL    BOUNDSTEST
           010B  C31401          JMP     @14
                         @13:
                              else
  83   6                          modend.load$addr = 0;
                                                 ; STATEMENT # 83
           010E  210000          LXI     H,0H
           0111  221000          SHLD    MODEND+2H
PL/M-80 COMPILER                                                                                                PAGE   7


                         @14:
  84   6                      call close(aftn);
                                                 ; STATEMENT # 84
           0114  2A0800          LHLD    AFTN
           0117  4D              MOV     C,L
           0118  CD0000          CALL    CLOSE
  85   6                      user$bottom = user$bottom AND 0ff80h;
                                                 ; STATEMENT # 85
           011B  1180FF          LXI     D,0FF80H
           011E  211800          LXI     H,USERBOTTOM
           0121  CD0000          CALL    @P0027 
           0124  EB              XCHG
           0125  2B              DCX     H
           0126  73              MOV     M,E
           0127  23              INX     H
           0128  72              MOV     M,D
  86   6                      do i = 0 to 18;
                                                 ; STATEMENT # 86
           0129  210900          LXI     H,I
           012C  3600            MVI     M,0H
                         @24:
           012E  3E12            MVI     A,12H
           0130  210900          LXI     H,I
           0133  BE              CMP     M
           0134  DA6E01          JC      @25
  87   7                          buffer$table(i) = buffer$table(i) AND 0FEh; /* assume available or in use */
                                                 ; STATEMENT # 87
           0137  2A0900          LHLD    I
           013A  2600            MVI     H,0
           013C  010000          LXI     B,BUFFERTABLE
           013F  09              DAD     B
           0140  3EFE            MVI     A,0FEH
           0142  A6              ANA     M
           0143  77              MOV     M,A
  88   7                          if user$bottom <= .MEMORY(shl(DOUBLE(i), 7)) then
                                                 ; STATEMENT # 88
           0144  2A0900          LHLD    I
           0147  2600            MVI     H,0
           0149  0E07            MVI     C,7H
           014B  CD0000          CALL    @P0088 
           014E  010000          LXI     B,MEMORY
           0151  09              DAD     B
           0152  EB              XCHG
           0153  211800          LXI     H,USERBOTTOM
           0156  CD0000          CALL    @P0104 
           0159  DA6701          JC      @15
  89   7                              buffer$table(i) = 1;    /* not available */
                                                 ; STATEMENT # 89
           015C  2A0900          LHLD    I
           015F  2600            MVI     H,0
           0161  010000          LXI     B,BUFFERTABLE
           0164  09              DAD     B
           0165  3601            MVI     M,1H
                         @15:
  90   7                      end;
                                                 ; STATEMENT # 90
                         @26:
PL/M-80 COMPILER                                                                                                PAGE   8


           0167  210900          LXI     H,I
           016A  34              INR     M
           016B  C22E01          JNZ     @24
                         @25:
  91   6                      if retsw$b = 0 then
                                                 ; STATEMENT # 91
           016E  3A0A00          LDA     RETSWB
           0171  FE00            CPI     0H
           0173  C28301          JNZ     @16
  92   6                      do;
  93   7                          entry = modend.load$addr;
                                                 ; STATEMENT # 93
           0176  2A0600          LHLD    ENTRYP
           0179  E5              PUSH    H       ; 1
           017A  2A1000          LHLD    MODEND+2H
           017D  EB              XCHG
           017E  E1              POP     H       ; 1
           017F  73              MOV     M,E
           0180  23              INX     H
           0181  72              MOV     M,D
  94   7                          return;
                                                 ; STATEMENT # 94
           0182  C9              RET
  95   7                      end;
                                                 ; STATEMENT # 95
                         @16:
  96   6                      if retsw$b = 1 then
                                                 ; STATEMENT # 96
           0183  3A0A00          LDA     RETSWB
           0186  FE01            CPI     1H
           0188  C29E01          JNZ     @17
  97   6                      do;
  98   7                          debug$toggle = FALSE;
                                                 ; STATEMENT # 98
           018B  210000          LXI     H,DTOGLE
           018E  3600            MVI     M,0H
  99   7                          call jmpto(modend.load$addr, usrSP + 2);    /* wastes the return address */
                                                 ; STATEMENT # 99
           0190  2A0000          LHLD    USRSP
           0193  23              INX     H
           0194  23              INX     H
           0195  EB              XCHG
           0196  2A1000          LHLD    MODEND+2H
           0199  44              MOV     B,H
           019A  4D              MOV     C,L
           019B  CD0000          CALL    JMPTO
 100   7                      end;
                                                 ; STATEMENT # 100
                         @17:
 101   6                      STACKPTR = memck;   
                                                 ; STATEMENT # 101
           019E  CD0000          CALL    MEMCK
           01A1  F9              SPHL
 102   6                      entry$p = STACKPTR;
                                                 ; STATEMENT # 102
           01A2  210000          LXI     H,0     ; 0
           01A5  39              DAD     SP
PL/M-80 COMPILER                                                                                                PAGE   9


           01A6  220600          SHLD    ENTRYP
 103   6                      entry = modend.load$addr;
                                                 ; STATEMENT # 103
           01A9  E5              PUSH    H       ; 1
           01AA  2A1000          LHLD    MODEND+2H
           01AD  EB              XCHG
           01AE  E1              POP     H       ; 1
           01AF  73              MOV     M,E
           01B0  23              INX     H
           01B1  72              MOV     M,D
 104   6                      debug$toggle = TRUE;
                                                 ; STATEMENT # 104
           01B2  210000          LXI     H,DTOGLE
           01B5  36FF            MVI     M,0FFH
 105   6                      call trap;
                                                 ; STATEMENT # 105
           01B7  CD0000          CALL    TRAP
 106   6                  end;
                                                 ; STATEMENT # 106
           01BA  C33F02          JMP     @9
 107   5                  do; /* case 3 - R$CONTENT */
                                                 ; STATEMENT # 107
                         @18:
 108   6                      call read(aftn, .content, 3, .actual);
                                                 ; STATEMENT # 108
           01BD  2A0800          LHLD    AFTN
           01C0  E5              PUSH    H       ; 1
           01C1  010E00          LXI     B,CONTENT
           01C4  C5              PUSH    B       ; 2
           01C5  111200          LXI     D,ACTUAL
           01C8  010300          LXI     B,3H
           01CB  CD0000          CALL    READ
 109   6                      if content.segId <> 0 then
                                                 ; STATEMENT # 109
           01CE  3A0E00          LDA     CONTENT
           01D1  FE00            CPI     0H
           01D3  CADB01          JZ      @19
 110   6                          call abortx(BAD$LOAD$FORMAT);
                                                 ; STATEMENT # 110
           01D6  0E10            MVI     C,10H
           01D8  CD0000          CALL    ABORTX
                         @19:
 111   6                      record.length = record.length - 4;      /* don't include header and crc */
                                                 ; STATEMENT # 111
           01DB  3E04            MVI     A,4H
           01DD  110C00          LXI     D,RECORD+1H
           01E0  CD0000          CALL    @P0101 
           01E3  EB              XCHG
           01E4  2B              DCX     H
           01E5  73              MOV     M,E
           01E6  23              INX     H
           01E7  72              MOV     M,D
 112   6                      content.load$addr = content.load$addr + bias;
                                                 ; STATEMENT # 112
           01E8  2A0200          LHLD    BIAS
           01EB  EB              XCHG
           01EC  2A0F00          LHLD    CONTENT+1H
PL/M-80 COMPILER                                                                                                PAGE  10


           01EF  19              DAD     D
           01F0  220F00          SHLD    CONTENT+1H
 113   6                      call bounds$test(content.load$addr, record.length);
                                                 ; STATEMENT # 113
           01F3  2A0F00          LHLD    CONTENT+1H
           01F6  44              MOV     B,H
           01F7  4D              MOV     C,L
           01F8  2A0C00          LHLD    RECORD+1H
           01FB  EB              XCHG
           01FC  CD4302          CALL    BOUNDSTEST
 114   6                      call read(aftn, content.load$addr, record.length, .actual);
                                                 ; STATEMENT # 114
           01FF  2A0800          LHLD    AFTN
           0202  E5              PUSH    H       ; 1
           0203  2A0F00          LHLD    CONTENT+1H
           0206  E5              PUSH    H       ; 2
           0207  2A0C00          LHLD    RECORD+1H
           020A  44              MOV     B,H
           020B  4D              MOV     C,L
           020C  111200          LXI     D,ACTUAL
           020F  CD0000          CALL    READ
 115   6                      if actual < record.length then
                                                 ; STATEMENT # 115
           0212  010C00          LXI     B,RECORD+1H
           0215  111200          LXI     D,ACTUAL
           0218  CD0000          CALL    @P0098 
           021B  D22302          JNC     @20
 116   6                          call abortx(BAD$LOAD$FORMAT);
                                                 ; STATEMENT # 116
           021E  0E10            MVI     C,10H
           0220  CD0000          CALL    ABORTX
                         @20:
 117   6                      call read(aftn, .checksum, 1, .actual);
                                                 ; STATEMENT # 117
           0223  2A0800          LHLD    AFTN
           0226  E5              PUSH    H       ; 1
           0227  010E00          LXI     B,CHECKSUM
           022A  C5              PUSH    B       ; 2
           022B  111200          LXI     D,ACTUAL
           022E  010100          LXI     B,1H
           0231  CD0000          CALL    READ
 118   6                  end;
                                                 ; STATEMENT # 118
           0234  C33F02          JMP     @9
 119   5                  end;    /* of case */
                                                 ; STATEMENT # 119
                         @23:
           0237  C000            DW      @10
           0239  C800            DW      @11
           023B  DC00            DW      @12
           023D  BD01            DW      @18
                         @9:
 120   4              end;    /* of else */
                                                 ; STATEMENT # 120
                         @8:
 121   3          end;
                                                 ; STATEMENT # 121
PL/M-80 COMPILER                                                                                                PAGE  11


           023F  C35F00          JMP     @21
                         @22:
 122   2      end;
                                                 ; STATEMENT # 122
           0242  C9              RET
 123   1      end;
              eof



MODULE INFORMATION:

     CODE AREA SIZE     = 02B2H    690D
     VARIABLE AREA SIZE = 0020H     32D
     MAXIMUM STACK SIZE = 0006H      6D
     135 LINES READ
     0 PROGRAM ERRORS

END OF PL/M-80 COMPILATION
