delete:
DO;
$include(delete.ipx)

dlook$pn: PROCEDURE PUBLIC;
    if not dlook(.pn) then
	call warn(NO$SUCH$FILE);
end;

DECLARE i BYTE;		/* shared temp counter */

del: PROCEDURE(disknum) PUBLIC;
    DECLARE disknum BYTE;
    DECLARE blockno ADDRESS DATA (0);
    DECLARE byteno ADDRESS DATA(16 /* size(DIRECT) */);
    DECLARE temp ADDRESS;
    DECLARE buf based TEMP (64) ADDRESS;

    /* internal delete routing
	disknum = F0DEV .. F9DEV
	direct must contain the directory entry for an existing file or disk.
	aft slot for the appropriate directory must have buffers;
	and these buffers must be setup for directory reading and
	writing. These buffers will be clobbered
    */


     direct.empty = TRUE;
     call dir$close(disknum);
     call seek(disknum, 1, .blockno, .byteno);	/* save location of directory entry */
     temp = a$dbuf;	/* temp -> a buffer we not exists based a$dbuf$p */
     do while direct.hdr$blk <> 0;
	call free$block(disknum, direct.hdr$blk);
	call absio(CMD$READ, disknum, direct.hdr$blk, temp);
	direct.hdr$blk = buf(FLINK);
	do i = 2 to 63;
	    if buf(i) <> 0 then
		call free$block(disknum, buf(i));
	end;
     end;
     call absio(CMD$READ, disknum, a$data$blk, a$dbuf);	/* last 2 based vars */
     call map$write(disknum);
end;


delete: PROCEDURE(pathname) PUBLIC;
	DECLARE pathname ADDRESS;

	call chk$pn$disk$file(pathname);
	call dlook$pn;
	call chk$write$protect;
	do i = AFT$BOTTOM to AFT$LAST;
	    call aft$window(i);
	    if (not a$empty) and (a$device = pn(0)) and (a$i$no = direct$i$no) then
		call warn(CANT$DELETE);	
	end;
	call del(pn(0));
end;
end;
eof
