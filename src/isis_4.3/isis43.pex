# plm aliases for asm functions and data
@global$severity	'gblSev' 
@Console		'consol'
@userStatus$p	'uStatP'
@Chk$pn$disk$file 'ckpndf'
@Dlook$pn	'dlokpn'
@debug$Toggle	'dTogle'
@a$access$p	'aAcesP'
@a$blk$count$p	'aBCntP'
@a$empty$p	'aEmtyP'
@a$eof$data$ptr$p	'aEoPP'
@a$hdr$blk$p	'aHBlkP'
@Aft$Window	'AWindo'
@Chk$Write$Protect	'CkWriP'
@Clear$Buf	'ClrBuf'
@Get$Aft$Slot	'GASlot'
@Map$Write	'MapWri'
@Write$Dir$Entry	'WDirEn'
@direct$i$no	'dirINo'
@Get$Block	'GetBlk'

# common control characters
CONTROL$E	'5'
BELL		'7'
BS		'8'
CR		'0dh'
LF		'0ah'
CONTROL$P	'10h'
CONTROL$Q	'11h'
CONTROL$R	'12h'
CONTROL$S	'13h'
CONTROL$X	'18h'
CONTROL$Z	'1ah'
ESC		'1bh'
DELKEY		'7fh'

# boolean literals
BOOLEAN		'BYTE'
TRUE		'0ffh'
FALSE		'0'

# console literals
AFTN$CONSOL$IN	'11'
AFTN$CONSOL$OUT	'10'
READ$MODE	'1'
WRITE$MODE	'2'

# seek options
SEEK$RETURN	'0'
SEEK$BACKWARD	'1'
SEEK$ABS	'2'
SEEK$FORWARD	'3'
SEEK$EOF	'4'

# common types
DCB$T		'structure(iocw BYTE, ioins BYTE, nsec BYTE, tadr BYTE, sadr BYTE, buf ADDRESS)'

# error codes
OK	'0'	/* No error detected. */
NO$FREE$BUFFER	'1'	/* Insufficient space in buffer area for a required buffer. */
BAD$AFT$NO	'2'	/* AFTN does not specify an open file. */
AFT$FULL	'3'	/* Attempt to open more than 6 files simultaneously. */
BAD$PATH	'4'	/* Illegal pathname specification. */
BAD$DEVICE	'5'	/* Illegal or unrecognized device specification */
CANT$WRITE	'6'	/* Attempt to write to a file open for input. */
DISK$FULL	'7'	/* Operation aborted: insufficient disk space. */
CANT$READ	'8'	/* Attempt to read from a file open for output. */
DIRECTORY$FULL	'9'	/* No more room in disk directory. */
DIFFERENT$DISK	'10'	/* Pathnames do not specify the same disk. */
MULTIDEFINED	'11'	/* Cannot rename file; name already in use. */
ALREADY$OPEN	'12'	/* Attempt to open a file already open. */
NO$SUCH$FILE	'13'	/* No such file. */
WRITE$PROTECT	'14'	/* Attempt to open for writing or to delete or rename a write-protected file. */
ISIS$OVERWRITE	'15'	/* Attempt to load into ISIS-II area or buffer area. */	
BAD$LOAD$FORMAT	'16'	/* Illegal format record. */	
NON$DISK$FILE	'17'	/* Attempt to rename/delete a non-disk file. */	
BAD$COMMAND	'18'	/* Unrecognized system call. */	
NON$DISK$SEEK	'19'	/* Attempt to seek on a non-disk file. */	
LONG$BACK$SEEK	'20'	/* Attempt to seek backward past beginning of a file */	
CANT$RESCAN	'21'	/* Attempt to rescan a non-lined file. */	
BAD$ACCESS	'22'	/* Illegal ACCESS parameter to OPEN or access mode impossible for file specified. */	
NULL$FILENAME	'23'	/* No filename specified for a disk file. */		
DISK$IO$ERROR	'24'	/* Disk error (see below). */		
BAD$ECHO	'25'	/* Incorrect specification of echo file to OPEN */	
BAD$ATTRIB	'26'	/* Incorrect SWID argument in ATTRIB system call */		
BAD$SEEK$ARG	'27'	/* Incorrect MODE argument in SEEK system call. */		
NULL$EXTENSION	'28'	/* Null file extension. */
CONSOLE$EOF	'29'	/* End of file on console input. */
DRIVE$NOT$READY	'30'	/* Drive not ready. */
SEEK$ON$WRITE	'31'	/* Attempted seek on write-only (output) file. */
CANT$DELETE	'32'	/* Can't delete an open file. */
BAD$PARAMETER	'33'	/* Illegal system call parameter. */
BAD$RETSW	'34'	/* Bad RETSW argument to LOAD. */
SEEK$PAST$EOF	'35'	/* Attempt to extend a file opened for input by seeking past end-of-file */

WARNING		'0'
MESSAGE		'1'
ABORT		'2'
CMSK		'0fch'

# attributes
INVISIBLE$ATTRIBUTE	'1'
SYSTEM$ATTRIBUTE	'2'
WRITEP$ATTRIBUTE	'4'
FORMAT$ATTRIBUTE	'80h'

$file(aft.plm)
AFT$BOTTOM	'10'
AFT$CONSOLE	'11'
AFT$PROTECT	'12'
AFT$LAST	'17'
CI$AFT		'1'
CO$AFT		'0'
F0DEV		'0'
F1DEV		'1'
F2DEV		'2'
F3DEV		'3'
F4DEV		'4'
F5DEV		'5'
F6DEV		'6'
F7DEV		'7'
F8DEV		'8'
F9DEV		'9'
CIDEV		'27'
CODEV		'28'
BBDEV		'26'
AFT$T1		'empty BYTE, device BYTE, access BYTE, edit BYTE, lbuf ADDRESS'
AFT$T2		'dbuf ADDRESS, pbuf ADDRESS, data$ptr BYTE, i$no ADDRESS, ptr$ptr BYTE'
AFT$T3		'eofcnt BYTE, ptr$change BYTE, data$change BYTE, blk ADDRESS, blk$seq ADDRESS'
AFT$T4		'ptr$blk ADDRESS, hdr$blk ADDRESS, data$blk$count ADDRESS, dbuf$read BYTE'
AFT$T		'structure(AFT$T1, AFT$T2, AFT$T3, AFT$T4)'
a$access$p      A
a$blk$count$p   A
a$blk$seqno$p   A
a$data$blk$p    A
a$data$change$p A
a$data$ptr$p    A
a$dbuf$p        A
a$dbuf$read$p   A
a$dev$p         A
a$edit$p        A
a$empty$p       A
a$eof$data$ptr$p A
aft             "AFT$T"(18)
a$hdr$blk$p	A
a$i$no$p        A
a$lbuf$p        A
a$pbuf$p        A
a$ptr$blk$p     A
a$ptr$change$p  A
a$ptr$ptr$p     A
datum$base      A
pointer$base    A
Aft$Window      P(B slot$number)
Get$Aft$Slot    PB
a$empty		B..a$empty$p
a$device	B..a$dev$p
a$access	B..a$access$p
a$edit		B..a$edit$p
a$dbuf          A..a$dbuf$p
a$lbuf		A..a$lbuf$p
a$pbuf          A..a$pbuf$p
a$data$ptr	B..a$data$ptr$p
a$i$no		A..a$i$no$p
a$ptr$ptr	B..a$ptr$ptr$p
a$eof$data$ptr	B..a$eof$data$ptr$p
a$ptr$change	B..a$ptr$change$p
a$data$change	B..a$data$change$p
a$blk$count	A..a$blk$count$p
a$blk$seqno	A..a$blk$seqno$p
a$ptr$blk	A..a$ptr$blk$p
a$hdr$blk	A..a$hdr$blk$p
a$data$blk	A..a$data$blk$p
a$dbuf$read	B..a$dbuf$read$p

BLINK		'0'
FLINK		'1'
links		A(64)..pointer$base

$file(alloc.plm)
current$bitmap  B
sectorsTable    BS
tracksTable     BS
free$block      P(B diskNum,A trackSector)
get$block       P(B diskNum)A
map$read        P
MapWrite        P(B diskNum)
bitmapByte      B..bitmapByte$p

$file(attrib.plm)
attrib          P(A file$ptr,A swid,"BOOLEAN" value)

$file(buffer.plm)
buffer$table    BS
ClearBuf       P(A buf$address)
get$buf         PA
pack$aft$buf    PA
return$buf      P(A buf$address)

$file(close.plm)
close           P(B aftn)

$file(consol.plm)
alt$cidev       B
cold$cidev      B
cur$consol$in   BS
cur$consol$out  BS
Console         P(A infile,A outfile)
Whocon          P(B aftn,A bufferloc)

$file(delete.plm)
del             P(B disknum)
delete          P(A pathname)
dlook$pn        P

$file(direct.plm)
DIRECT$T1	'empty BOOLEAN, file(6) BYTE, ext(3) BYTE, attrib BYTE'
DIRECT$T2	'eof$count BYTE, blk ADDRESS, hdr$blk ADDRESS'
DIRECT$T	'structure(DIRECT$T1, DIRECT$T2)'
direct          "DIRECT$T"
direct$i$no     A
dirPtr          A
#dnum            A
fndFre          B
inoPtr          A
dir$close        P(B aftn)
dlook           P(A fn)"BOOLEAN"
#fndDir          P(A fname,A datum)B

$file(disk2.asm)
dk$stat		PB
r$type		PB
r$byte		PB
strt$io		P(A iopb)

$file(diskio.asm)
absread		'abs$rd'
abswrite	'abs$wr'
CMD$RECAL	'3'
CMD$READ	'4'
CMD$WRITE	'6'
absio		P(B command,B disk,A block,A buffer$ptr)
abs$rd		P(A block, A buffer$ptr)
abs$wr		P(A block, A buffer$ptr)
dk$cf$tb	B(10)
rdy$msk		B(10)
unit$mp		B(10)
dk$ct$tb	B(10)
dkcont		B
track		B
sector		B
diskio		P(B drive, A iopb)


$file(error.asm)
c$dk$sat        A
debugToggle     B
errdrv          B
global$severity	B
abortx          P(B errcode)
err             P(B severity,B error$type)
warn            P(B errcode)

$file(exit.plm)
# rename of plm to asm 6 char name
close$all	'clsall'
cli             BS
clsall          P(B aft$start)
exit            P

$file(fndrir.asm)
fnDir		P(A fname,A datum)B
dnum		A

$file(loc62.asm)
userStatus$p	A
isis            P(B command,A parameter$block)
userStatus      A..userStatus$p

$file(load.plm)
R$CONTENT       '6'
R$RELOC         '22H'
load            P(A pathname,A bias,A retsw,A entry$p)

$file(loc62.asm)
isis$E		B
usrSP		A
usrStk		B
vec0E		A
CI		PB
CO		P(B val)
CSTS		PB
IOCHK		PB
IOSET		P(B val)
isis40		P(B command,A parameter$block)
jmpto		P(A entry,A stack)
LO		P(B val)
PO		P(B val)
reboot		P
RI		PB
trap0B		P

$file(memck.asm)
memck		PA

$file(open.plm)
open            P(A pathname,A access$mode,A lined$aft)B

$file(path.plm)
pn              BS
pn2             BS
chk$pn$disk$file P(A filename)
ChkWriteProtect	P
path            P(A pathname,A pn$p)B
unpath          P(A pathname$p,A pn$p)
WriteDirEntry	P
xpath           P(A p1,A p2)

$file(rename.plm)
rename          P(A old$file,A new$file)

$file(rescan.plm)
rescan          P(B aftn)

$file(rw1.asm)
usrSys		P(A buffer$p,A buffer,A datum$base)
sysUsr		P(A buffer$p,A buffer,A datum$base)

$file(rw.plm)
ACCESS$READ     '1'
MAXLL           '122'
adp$dif         B
datapp          A
adjust$eof      P
chk$eof         P
lined           P(B aftn,A buffer,A count,A actual$p)
read            P(B aftn,A buffer,A count,A actual$p)
write           P(B aftn,A buffer,A count)

$file(seek.plm)
rewind          P
save$data$blk   P
save$pointer$block P
seek            P(B aftn,A mode,A blockptr,A byteptr)

$file(trap.asm)
trap		P
