PL/M-80 COMPILER                                                                                                PAGE   1


ISIS-II PL/M-80 V4.0 COMPILATION OF MODULE CLOSE
OBJECT MODULE PLACED IN CLOSE.OBJ
COMPILER INVOKED BY:  :F1:plm80 close.plm PRINT(CLOSE.LST) OBJECT(CLOSE.OBJ) DEBUG OPTIMIZE CODE



   1          close:
              do;
              $include(close.ipx)
   2   1  =   declare a$access$p literally 'aAcesP';
   3   1  =   declare a$blk$count$p literally 'aBCntP';
   4   1  =   declare a$empty$p literally 'aEmtyP';
   5   1  =   declare a$eof$data$ptr$p literally 'aEoPP';
   6   1  =   declare Aft$Window literally 'AWindo';
   7   1  =   declare Map$Write literally 'MapWri';
   8   1  =   declare AFT$T literally 'structure(AFT$T1, AFT$T2, AFT$T3, AFT$T4)';
   9   1  =   declare AFT$T1 literally 'empty BYTE, device BYTE, access BYTE, edit BYTE, lbuf ADDRESS';
  10   1  =   declare AFT$T2 literally 'dbuf ADDRESS, pbuf ADDRESS, data$ptr BYTE, i$no ADDRESS, ptr$ptr BYTE';
  11   1  =   declare AFT$T3 literally 'eofcnt BYTE, ptr$change BYTE, data$change BYTE, blk ADDRESS, blk$seq ADDRESS';
  12   1  =   declare AFT$T4 literally 'ptr$blk ADDRESS, hdr$blk ADDRESS, data$blk$count ADDRESS, dbuf$read BYTE';
  13   1  =   declare BOOLEAN literally 'BYTE';
  14   1  =   declare DIRECT$T literally 'structure(DIRECT$T1, DIRECT$T2)';
  15   1  =   declare DIRECT$T1 literally 'empty BOOLEAN, file(6) BYTE, ext(3) BYTE, attrib BYTE';
  16   1  =   declare DIRECT$T2 literally 'eof$count BYTE, blk ADDRESS, hdr$blk ADDRESS';
  17   1  =   declare SEEK$ABS literally '2';
  18   1  =   declare TRUE literally '0ffh';
  19   1  =   declare a$access$p address external;
  20   1  =   declare a$blk$count$p address external;
  21   1  =   declare a$data$ptr$p address external;
  22   1  =   declare a$dbuf$p address external;
  23   1  =   declare a$dev$p address external;
  24   1  =   declare a$edit$p address external;
  25   1  =   declare a$empty$p address external;
  26   1  =   declare a$eof$data$ptr$p address external;
  27   1  =   declare aft(18) AFT$T external;
  28   1  =   declare a$i$no$p address external;
  29   1  =   declare a$lbuf$p address external;
  30   1  =   declare a$pbuf$p address external;
  31   1  =   declare direct DIRECT$T external;
  32   1  =   adjust$eof: procedure external; end;
  34   1  =   Aft$Window: procedure(slot$number) external; declare slot$number byte; end;
  37   1  =   attrib: procedure(file$ptr, swid, value) external;
  38   2  =             declare file$ptr address, swid address, value BOOLEAN; end;
  40   1  =   dir$close: procedure(aftn) external; declare aftn byte; end;
  43   1  =   MapWrite: procedure(diskNum) external; declare diskNum byte; end;
  46   1  =   read: procedure(aftn, buffer, count, actual$p) external;
  47   2  =           declare aftn byte, buffer address, count address, actual$p address; end;
  49   1  =   return$buf: procedure(buf$address) external; declare buf$address address; end;
  52   1  =   rewind: procedure external; end;
  54   1  =   save$data$blk: procedure external; end;
  56   1  =   save$pointer$block: procedure external; end;
  58   1  =   seek: procedure(aftn, mode, blockptr, byteptr) external;
  59   2  =           declare aftn byte, mode address, blockptr address, byteptr address; end;
  61   1  =   write: procedure(aftn, buffer, count) external; declare aftn byte, buffer address, count address; end;
  64   1  =   declare a$access based a$access$p  byte;
  65   1  =   declare a$blk$count based a$blk$count$p  address;
  66   1  =   declare a$data$ptr based a$data$ptr$p  byte;
PL/M-80 COMPILER                                                                                                PAGE   2


  67   1  =   declare a$dbuf based a$dbuf$p  address;
  68   1  =   declare a$device based a$dev$p  byte;
  69   1  =   declare a$edit based a$edit$p  byte;
  70   1  =   declare a$empty based a$empty$p  byte;
  71   1  =   declare a$eof$data$ptr based a$eof$data$ptr$p  byte;
  72   1  =   declare a$i$no based a$i$no$p  address;
  73   1  =   declare a$lbuf based a$lbuf$p  address;
  74   1  =   declare a$pbuf based a$pbuf$p  address;
        
        
        
  75   1      DECLARE caseMap(*) BYTE DATA (0,0,0,0,0,0,0,0,0,0,  /* F0-F9 */
                                1,2,1,2,1,2,1,1,1,1,  /* TI, TO, VI, VO, I1, O1, TR, HR, T1, T2 */
                                3,3,3,3,4,4,1,1,1);   /* TP, HP, P1, P2, LP, L1, BB, CI, CO */
        
  76   1      DECLARE t$blk   ADDRESS,
                  t$eof   BYTE,
                  zero    ADDRESS INITIAL(0),
                  bytes   ADDRESS INITIAL(0);
        
  77   1      close: PROCEDURE(aftn) PUBLIC;
                                                 ; STATEMENT # 77
                         ; PROC  CLOSE
           03F9  21F62C          LXI     H,AFTN
           03FC  71              MOV     M,C
  78   2          DECLARE aftn BYTE;
  79   2          DECLARE i ADDRESS;
        
  80   2          call aft$window(aftn);
                                                 ; STATEMENT # 80
           03FD  2AF62C          LHLD    AFTN
           0400  4D              MOV     C,L
           0401  CDA702          CALL    AWINDO
  81   2          if a$empty then
                                                 ; STATEMENT # 81
           0404  2ACA2A          LHLD    AEMTYP
           0407  7E              MOV     A,M
           0408  1F              RAR
           0409  D20D04          JNC     @1
  82   2              return;
                                                 ; STATEMENT # 82
           040C  C9              RET
                         @1:
  83   2          if a$edit <> 0 then
                                                 ; STATEMENT # 83
           040D  2AD02A          LHLD    AEDITP
           0410  7E              MOV     A,M
           0411  FE00            CPI     0H
           0413  CA1F04          JZ      @2
  84   2              call return$buf(a$lbuf);
                                                 ; STATEMENT # 84
           0416  2AD22A          LHLD    ALBUFP
           0419  4E              MOV     C,M
           041A  23              INX     H
           041B  46              MOV     B,M
           041C  CD1125          CALL    RETURNBUF
                         @2:
PL/M-80 COMPILER                                                                                                PAGE   3


  85   2          do case caseMap(a$device);
                                                 ; STATEMENT # 85
           041F  2ACC2A          LHLD    ADEVP
           0422  4E              MOV     C,M
           0423  0600            MVI     B,0
           0425  21DB03          LXI     H,CASEMAP
           0428  09              DAD     B
           0429  4E              MOV     C,M
           042A  0600            MVI     B,0
           042C  214905          LXI     H,@10
           042F  09              DAD     B
           0430  09              DAD     B
           0431  5E              MOV     E,M
           0432  23              INX     H
           0433  56              MOV     D,M
           0434  EB              XCHG
           0435  E9              PCHL
  86   3              do; /* 0 - disk */
                                                 ; STATEMENT # 86
                         @4:
  87   4                  call save$data$blk;
                                                 ; STATEMENT # 87
           0436  CDDC1E          CALL    SAVEDATABLK
  88   4                  call save$pointer$block;
                                                 ; STATEMENT # 88
           0439  CDFB1E          CALL    SAVEPOINTERBLOCK
  89   4                  call return$buf(a$pbuf);
                                                 ; STATEMENT # 89
           043C  2ADA2A          LHLD    APBUFP
           043F  4E              MOV     C,M
           0440  23              INX     H
           0441  46              MOV     B,M
           0442  CD1125          CALL    RETURNBUF
  90   4                  call return$buf(a$dbuf);
                                                 ; STATEMENT # 90
           0445  2AD42A          LHLD    ADBUFP
           0448  4E              MOV     C,M
           0449  23              INX     H
           044A  46              MOV     B,M
           044B  CD1125          CALL    RETURNBUF
  91   4                  if a$access >= 2 then
                                                 ; STATEMENT # 91
           044E  2ACE2A          LHLD    AACESP
           0451  7E              MOV     A,M
           0452  FE02            CPI     2H
           0454  DA0F05          JC      @5
  92   4                  do;
  93   5                      call adjust$eof;
                                                 ; STATEMENT # 93
           0457  CDB216          CALL    ADJUSTEOF
  94   5                      t$eof = a$eof$data$ptr;
                                                 ; STATEMENT # 94
           045A  2ADE2A          LHLD    AEOPP
           045D  7E              MOV     A,M
           045E  32F12C          STA     TEOF
  95   5                      t$blk = a$blk$count;
                                                 ; STATEMENT # 95
PL/M-80 COMPILER                                                                                                PAGE   4


           0461  2AE42A          LHLD    ABCNTP
           0464  5E              MOV     E,M
           0465  23              INX     H
           0466  56              MOV     D,M
           0467  EB              XCHG
           0468  22EF2C          SHLD    TBLK
  96   5                      bytes = a$i$no * 16;
                                                 ; STATEMENT # 96
           046B  2AD82A          LHLD    AINOP
           046E  5E              MOV     E,M
           046F  23              INX     H
           0470  56              MOV     D,M
           0471  EB              XCHG
           0472  29              DAD     H
           0473  29              DAD     H
           0474  29              DAD     H
           0475  29              DAD     H
           0476  22F42C          SHLD    BYTES
  97   5                      call map$write(a$device);
                                                 ; STATEMENT # 97
           0479  2ACC2A          LHLD    ADEVP
           047C  4E              MOV     C,M
           047D  CDA922          CALL    MAPWRI
  98   5                      aft(a$device).dbuf = a$dbuf;        /* let device use returned buffers */
                                                 ; STATEMENT # 98
           0480  2AD42A          LHLD    ADBUFP
           0483  E5              PUSH    H       ; 1
           0484  2ACC2A          LHLD    ADEVP
           0487  6E              MOV     L,M
           0488  2600            MVI     H,0
           048A  111C00          LXI     D,1CH
           048D  CDC829          CALL    @P0034 
           0490  01F02A          LXI     B,AFT
           0493  09              DAD     B
           0494  010600          LXI     B,DBUF
           0497  09              DAD     B
           0498  E3              XTHL            ; 1
           0499  4E              MOV     C,M
           049A  23              INX     H
           049B  46              MOV     B,M
           049C  E1              POP     H       ; 1
           049D  71              MOV     M,C
           049E  23              INX     H
           049F  70              MOV     M,B
  99   5                      aft(a$device).pbuf = a$pbuf;
                                                 ; STATEMENT # 99
           04A0  2ADA2A          LHLD    APBUFP
           04A3  E5              PUSH    H       ; 1
           04A4  2ACC2A          LHLD    ADEVP
           04A7  6E              MOV     L,M
           04A8  2600            MVI     H,0
           04AA  111C00          LXI     D,1CH
           04AD  CDC829          CALL    @P0034 
           04B0  01F02A          LXI     B,AFT
           04B3  09              DAD     B
           04B4  010800          LXI     B,PBUF
           04B7  09              DAD     B
PL/M-80 COMPILER                                                                                                PAGE   5


           04B8  E3              XTHL            ; 1
           04B9  4E              MOV     C,M
           04BA  23              INX     H
           04BB  46              MOV     B,M
           04BC  E1              POP     H       ; 1
           04BD  71              MOV     M,C
           04BE  23              INX     H
           04BF  70              MOV     M,B
 100   5                      call aft$window(a$device);
                                                 ; STATEMENT # 100
           04C0  2ACC2A          LHLD    ADEVP
           04C3  4E              MOV     C,M
           04C4  CDA702          CALL    AWINDO
 101   5                      call rewind;        /* get to dir header */
                                                 ; STATEMENT # 101
           04C7  CD211F          CALL    REWIND
 102   5                      call seek(a$device, SEEK$ABS, .zero, .bytes);   /* seek to file entry */
                                                 ; STATEMENT # 102
           04CA  2ACC2A          LHLD    ADEVP
           04CD  4E              MOV     C,M
           04CE  C5              PUSH    B       ; 1
           04CF  010200          LXI     B,2H
           04D2  C5              PUSH    B       ; 2
           04D3  11F42C          LXI     D,BYTES
           04D6  01F22C          LXI     B,ZERO
           04D9  CD641F          CALL    SEEK
 103   5                      call read(a$device, .direct, 16, .i);       /* read the dir entry */
                                                 ; STATEMENT # 103
           04DC  2ACC2A          LHLD    ADEVP
           04DF  4E              MOV     C,M
           04E0  C5              PUSH    B       ; 1
           04E1  01FB2E          LXI     B,DIRECT
           04E4  C5              PUSH    B       ; 2
           04E5  11F72C          LXI     D,I
           04E8  011000          LXI     B,10H
           04EB  CD3C1A          CALL    READ
 104   5                      direct.eof$count = t$eof;
                                                 ; STATEMENT # 104
           04EE  3AF12C          LDA     TEOF
           04F1  32062F          STA     DIRECT+0BH
 105   5                      direct.blk = t$blk;
                                                 ; STATEMENT # 105
           04F4  2AEF2C          LHLD    TBLK
           04F7  22072F          SHLD    DIRECT+0CH
 106   5                      a$data$ptr = a$data$ptr - DOUBLE(16);
                                                 ; STATEMENT # 106
           04FA  2AD62A          LHLD    ADATAPTRP
           04FD  7E              MOV     A,M
           04FE  E5              PUSH    H       ; 1
           04FF  211000          LXI     H,10H
           0502  CD142A          CALL    @P0094 
           0505  EB              XCHG
           0506  E1              POP     H       ; 1
           0507  73              MOV     M,E
 107   5                      call dir$close(a$device);
                                                 ; STATEMENT # 107
           0508  2ACC2A          LHLD    ADEVP
PL/M-80 COMPILER                                                                                                PAGE   6


           050B  4E              MOV     C,M
           050C  CDBB26          CALL    DIRCLOSE
 108   5                  end;
                                                 ; STATEMENT # 108
                         @5:
 109   4              end;
                                                 ; STATEMENT # 109
           050F  C35305          JMP     @3
 110   3              ;   /* 1 */
                                                 ; STATEMENT # 110
                         @6:
           0512  C35305          JMP     @3
 111   3              ;   /* 2 */
                                                 ; STATEMENT # 111
                         @7:
           0515  C35305          JMP     @3
 112   3              do i = 0 to 119;    /* 3 output 120 nulls */
                                                 ; STATEMENT # 112
                         @8:
           0518  210000          LXI     H,0H
           051B  22F72C          SHLD    I
                         @11:
           051E  3E77            MVI     A,77H
           0520  21F72C          LXI     H,I
           0523  CD402A          CALL    @P0103 
           0526  DA4305          JC      @12
 113   4                  call write(aftn, .(0), 1);
                                                 ; STATEMENT # 113
           0529  2AF62C          LHLD    AFTN
           052C  E5              PUSH    H       ; 1
           052D  110100          LXI     D,1H
           0530  01F803          LXI     B,$-138H
           0533  CDF01A          CALL    WRITE
 114   4              end;
                                                 ; STATEMENT # 114
           0536  110100          LXI     D,1H
           0539  2AF72C          LHLD    I
           053C  19              DAD     D
           053D  22F72C          SHLD    I
           0540  D21E05          JNC     @11
                         @12:
           0543  C35305          JMP     @3
 115   3              ;   /* 4 */
                                                 ; STATEMENT # 115
                         @9:
           0546  C35305          JMP     @3
 116   3          end;
                                                 ; STATEMENT # 116
                         @10:
           0549  3604            DW      @4
           054B  1205            DW      @6
           054D  1505            DW      @7
           054F  1805            DW      @8
           0551  4605            DW      @9
                         @3:
 117   2          aft(aftn).empty = TRUE;
                                                 ; STATEMENT # 117
PL/M-80 COMPILER                                                                                                PAGE   7


           0553  111C00          LXI     D,1CH
           0556  2AF62C          LHLD    AFTN
           0559  2600            MVI     H,0
           055B  CDC829          CALL    @P0034 
           055E  01F02A          LXI     B,AFT
           0561  09              DAD     B
           0562  36FF            MVI     M,0FFH
 118   2      end;    
                                                 ; STATEMENT # 118
           0564  C9              RET
 119   1      end;
              eof



MODULE INFORMATION:

     CODE AREA SIZE     = 018AH    394D
     VARIABLE AREA SIZE = 000AH     10D
     MAXIMUM STACK SIZE = 0006H      6D
     116 LINES READ
     0 PROGRAM ERRORS

END OF PL/M-80 COMPILATION
