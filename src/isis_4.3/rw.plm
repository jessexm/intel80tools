rw:
do;

$include(rw.ipx)

DECLARE ACCESS$READ	LITERALLY	'1',
	ACCESS$WRITE	LITERALLY	'2';

DECLARE	MAXLL		LITERALLY	'122';	/* maximum line length */

DECLARE iobyteMasks(*) BYTE DATA(0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh,
				 0FCh, 0FCh, 0FCh, 0FCh, 0FCh, 0FCh, 0F3h, 0F3h, 0F3h, 0F3h,
				 0CFh, 0CFh, 0CFh, 0CFh, 3Fh, 3Fh, 0FFh, 0FFh, 0FFh);
DECLARE iobyteFlags(*) BYTE DATA(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				 0, 0, 1, 1, 3, 3, 0, 4, 8, 0Ch,
				 0, 10h, 20h, 30h, 80h, 0C0h, 0, 0, 0);
DECLARE devClass(*) BYTE DATA(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			      0FFh, 1, 0FFh, 1, 0FFh, 1, 0EFh, 0EFh, 0EFh, 0EFh,
			      2, 2, 2, 2, 3, 3, 4, 0FFh, 0FFh);
DECLARE specialChars(*) byte DATA(0, DELKEY, CONTROL$Z, CONTROL$R, CONTROL$X, CR, LF, ESC, CONTROL$E, CONTROL$P);


DECLARE	count$diff ADDRESS,
	eof$dif BYTE,
	adp$dif BYTE PUBLIC,
	datapp	ADDRESS PUBLIC, /* interface to usrSys & sysUsr asm routines */
	create BYTE INITIAL(0),
	newptrblk ADDRESS,
	iostat BYTE;
	

chk$eof: PROCEDURE PUBLIC;
	if a$access = ACCESS$READ then	/* 1 */
	do;
		a$blk$seqno = a$blk$count;
		a$data$ptr = a$eof$data$ptr;
		call WARN(SEEK$PAST$EOF);

	end;
end;

adjust$eof: PROCEDURE PUBLIC;
	if a$blk$seqno <> 0 AND a$data$ptr = 0 then
	do;
		if not ((a$eof$data$ptr < 128 AND a$blk$seqno - 1 = a$blk$count) OR a$blk$count < a$blk$seqno - 1) then
			return;
	end;
	else
	do;
		if not ((a$eof$data$ptr < a$data$ptr AND a$blk$seqno = a$blk$count) OR a$blk$seqno > a$blk$count) then
			return;
	end;
	call chk$eof;
	a$blk$count = a$blk$seqno;
	a$eof$data$ptr = a$data$ptr;
end;



rw: PROCEDURE(aftn, buffer, count, actual$p, reading);
	DECLARE aftn BYTE, (buffer, count, actual$p) ADDRESS, reading BYTE;
	DECLARE actual BASED actual$p ADDRESS;
	DECLARE temp ADDRESS, non$sector$request BYTE, work$buf ADDRESS;
	DECLARE newlinks BASED temp (64) ADDRESS;

	do while count > actual;
		if a$blk$count <= a$blk$seqno AND reading AND a$data$ptr = a$eof$data$ptr then
			return;
		if a$data$ptr = 128 then
		do;
			call save$data$blk;
			a$data$ptr = 0;
			a$dbuf$read = FALSE;
			a$blk$seqno = a$blk$seqno + 1;
			a$ptr$ptr = a$ptr$ptr + 1;
			if a$ptr$ptr = 64 then
			do;
				if links(FLINK) = 0 then
				do;
					newptrblk = get$block(a$device);
					links(FLINK) = newptrblk;	
					create = TRUE;
					a$ptr$change = TRUE;
					call clear$buf(temp := a$dbuf);
					newlinks(0) = a$ptr$blk;	/* save forward link */
					call map$write(a$device);
					call abswrite(newptrblk, a$dbuf);
				end;

				call save$pointer$block;
				if create then
				do;
					create = FALSE;
					call clear$buf(temp := a$pbuf);
					newlinks(0) = a$ptr$blk;
				end;
				else
				do;
					call absread(newptrblk := links(FLINK), a$pbuf);
				end;
				a$ptr$blk = newptrblk;
				a$ptr$ptr = 2;
			end;
		end;

		adp$dif = 128 - a$data$ptr;
		if a$blk$count <= a$blk$seqno AND READING then
		do;
			eof$dif = a$eof$data$ptr - a$data$ptr;
			if adp$dif > eof$dif then
				adp$dif = eof$dif;
		end;
		countdiff = count - actual;
		if adp$dif > count$diff then	/* check if more in buffer than needed */
			adp$dif = count$diff;


		actual = actual + adp$dif;
		non$sector$request = adp$dif <> 128;
		adp$dif = adp$dif + a$data$ptr;
		work$buf = buffer;
		if non$sector$request then
			work$buf = a$dbuf;
		a$data$blk = links(a$ptr$ptr);
		if a$data$blk = 0 then
		do;
			if reading then
				call clear$buf(work$buf);
			else
			do;
				if non$sector$request then
					call clear$buf(work$buf);
				a$ptr$change = TRUE;
				links(a$ptr$ptr), a$data$blk =  get$block(a$device);
			end;
		end;
		else if a$dbuf$read then
			non$sector$request = TRUE;
		else if non$sector$request OR reading then
			call abs$read(a$data$blk, work$buf);

		if non$sector$request then
		do;
			a$dbuf$read = TRUE;
			datapp = a$data$ptr$p;
			if reading then
				call sysUsr(.buffer, buffer, datum$base);
			else
			do;
				a$data$change = TRUE;
				call usrSys(.buffer, buffer, datum$base);
			end;
			a$data$ptr = adp$dif;
		end;
		else
		do;
			if not reading then
				call abswrite(a$data$blk, work$buf);
			a$data$ptr = 128;
			buffer = buffer + 128;
		end;
	end; /* of do while */
	call adjust$eof;
end;



non$disk$select: PROCEDURE;
	/*
	   set logical file assignments to use monitor routines
	   for doing byte at a time I/O devices
	*/
	call ioset(((iostat := iochk) AND iobyteMasks(a$device)) or iobyteFlags(a$device));
end;


read: PROCEDURE(aftn, buffer, count, actual$p) PUBLIC;
	DECLARE aftn BYTE, (buffer, count, actual$p) ADDRESS;
	DECLARE actual BASED actual$p ADDRESS;
	DECLARE bytes BASED buffer BYTE;

	actual = 0;
	call aft$window(aftn);
	if (a$access AND 1) = 0 then	/* not read */
		call warn(CANT$READ);
	if a$device = 26 then		/* BB */
		return;
	call non$disk$select;
	if a$device <= F9DEV then
	do;
		call rw(aftn, buffer, count, actual$p, TRUE);
		return;
	end;

	do while actual <> count;
		if devClass(a$device) <> 0efh then
			bytes = ci;
		else
		do;
			bytes = ri;
			if CARRY then
				goto done;
		end;
		buffer = buffer + 1;
		actual = actual + 1;
	end;
done:
	call ioset(iostat);
end;



write: PROCEDURE(aftn, buffer, count) PUBLIC;
	DECLARE aftn byte, (buffer, count) ADDRESS;
	DECLARE bytes BASED buffer BYTE;
	DECLARE actual ADDRESS, i BYTE;

	call aft$window(aftn);
	if (a$access and 2) = 0 then
		call warn(CANT$WRITE);
	if a$device = 26 then	/* BB */
		return;
	call non$disk$select;

	do while count <> 0;
		do case devClass(a$device);
		do;		/* case 0 */
			actual = 0;
			call rw(aftn, buffer, count, .actual, FALSE);
			return;
		end;
		do;		/* case 1 */
			call CO(bytes);
			if csts then
			do;
				do i = 0 to 255;	/* delay a little */
				end;
				if csts then
					if (ci AND 7fh) = CONTROL$S then
						do while (ci AND 7fh) <> CONTROL$Q;
						end;

			end;
		end;
		call po(bytes);		/* case 2 */
		call lo(bytes);		/* case 3 */
		end;

		count = count - 1;
		buffer = buffer + 1;
	end;
	call ioset(iostat);
end;



lined: PROCEDURE(aftn, buffer, count, actual$p) PUBLIC;
	DECLARE aftn BYTE, (buffer, count, actual$p) ADDRESS;
	DECLARE actual BASED actual$p ADDRESS;
	DECLARE lbuf ADDRESS,
		in$mode BYTE,
		lit$mode BYTE,
		lptr BYTE,
		char BYTE,
		i BYTE,		/* note read clobbers selector as well */
		selector BYTE;
	DECLARE obuf BASED buffer (1) BYTE;
	DECLARE bytes BASED lbuf (128) BYTE;
	DECLARE addr BASED lbuf (64) ADDRESS;


	echo: PROCEDURE(char);		/* nested sub of lined */
		DECLARE char BYTE;
		call write(a$edit, .char, 1);
		call aft$window(aftn);
	end;

	echoCRLF: PROCEDURE;
		call echo(CR);
		call echo(LF);
	end;

	lineReset: PROCEDURE;		/* nested in lined */
		in$mode = FALSE;
		lptr = 0;
	end;


	lit$mode = FALSE;
	lbuf = aft(aftn).lbuf;
	lptr = bytes(126);
	in$mode = bytes(127);

	do while in$mode;
		call read(aftn, .char, 1, .i);
		if i = 0 then
		do;
			if aftn = AFT$CONSOLE then	/* 11 */
				call abortx(CONSOLE$EOF);
			char = CONTROL$Z;
		end;
		bytes(125) = FALSE;
		char = char AND 7fh;
		if char <> LF then
			call echo(bytes(lptr) := char);

		selector = 0;
		do i = 0 to 9;
			if char = specialChars(i) then
				selector = i;
		end;	
		selector = selector and not lit$mode;
		lit$mode = FALSE;
		do case selector;
			lptr = lptr + 1;	/* case 0 - normal */
			do;			/* case 1, rubout */
				if lptr <> 0 then
				do;
					lptr = lptr - 1;
					if aft(a$edit).device = 13 then
					do;
						call echo(BS);
						bytes(lptr) = ' ';
						call echo(' ');
						call echo(BS);
					end;
					else
						call echo(bytes(lptr));
				end;
				else
					call echo(BELL);
			end;
			do;			/* case 2 - control-Z */
				actual = 0;
				bytes(125) = TRUE;
				addr(63) = 0ff00h;
				call echoCRLF;
				return;
			end;
			do;			/* case 3 - control-R */
				call echoCRLF;
				call write(a$edit, .bytes, lptr);
			end;
			do;			/* case 4 - control-X */
				lptr = 0;
				call echo('#');
				call echoCRLF;
			end;
			do;			/* case 5 - CR */
				bytes(lptr := lptr + 1) = LF;
				call echo(LF);
				call lineReset;
			end;
			do;			/* case 6 - LF */
				if lptr <> 0 then
				do;
					call echo(bytes(lptr) := char);
					call lineReset;
				end;
			end;
			do;			/* case 7 -  ESC */
				call echo(0);
				call echo('$');
				call lineReset;
			end;
			do;			/* case 8 - Control-E */
				if aftn = AFT$CONSOLE then
				do;
					i = aft(AFT$CONSOLE).device;
					aft(AFT$CONSOLE).device = alt$cidev;
					alt$cidev = i;
					call echo('^');
					call echo('E');
				end;
			end;
			lit$mode = TRUE;	/* case 8 - control-P */
		end; /* of case */
		if lptr = 122 then
			call lineReset;
	end;

	actual = 0;
	do while actual < count and not in$mode;
		if lptr < MAXLL then	/* 122 */
		do;
			if (obuf(actual) := bytes(lptr)) = LF OR bytes(lptr) = ESC then
			do;
				in$mode = TRUE;
				lptr = -1;
			end;

			actual = actual + 1;
			lptr = lptr + 1;
		end;
		else
		do;
			in$mode = TRUE;
			lptr = 0;
		end;
	end;
	bytes(126) = lptr;
	bytes(127) = in$mode;
end;



end;
eof
