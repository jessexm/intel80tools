alloc:
do;
$include(alloc.ipx)

DECLARE	tracksTable(10) BYTE PUBLIC,	/* initialised by boot routines */
	sectorsTable(10) BYTE PUBLIC,
	bitmapBuffer(128) BYTE,
	current$bitmap BYTE PUBLIC INITIAL(0ffh),
	map$change BYTE INITIAL(FALSE),
	baseTrackSector ADDRESS,
	baseSector BYTE AT (.baseTrackSector),
	baseTrack BYTE AT (.baseTrackSector + 1),
	bitmapIndex ADDRESS,
	lowBitMapIndex BYTE AT (.bitmapIndex),
	map$dcb DCB$T INITIAL(80h, 4, 1, 2, 2, .bitmapBuffer),
	current$part BYTE INITIAL(0ffh),
	base$part BYTE INITIAL(0),
	next$part BYTE INITIAL(0),
	bitmapByte$p ADDRESS INITIAL(0),
	(lowBitmapByte$p, highBitmapByte$p) BYTE AT (.bitmapByte$p),
	bitmapByte BASED bitmapByte$p BYTE,
	bitmapBit BYTE,
	command BYTE,
	disk BYTE,
	tracksPerDisk BYTE,
	sectorsPerTrack BYTE;


mapio:	PROCEDURE;
	map$change = FALSE;
	map$dcb.ioins = command;	/* set up command */
	map$dcb.tadr = 2;		/* set up partition */
	map$dcb.sadr = current$part + 2;
	call diskio(disk, .map$dcb);
end;


map$write: PROCEDURE(diskNum) PUBLIC;
	DECLARE diskNum BYTE;

	disk = diskNum;
	if  disk = current$bitmap AND map$change then
	do;
		command = CMD$WRITE;	
		call mapio;
	end;
end;

		

map$read: PROCEDURE PUBLIC;
	DECLARE temp BYTE;

	temp = disk <> current$bitmap;
	if current$part <> next$part or temp then
	do;
		if temp then
		do;
			base$part = 0;
			bitmapIndex = 0;
			baseTrackSector = 1;
		end;
		temp = disk;
		call map$write(current$bitmap);
		disk = temp;
		command = CMD$READ;
		current$part = next$part;
		current$bitmap = disk;
		call mapio;
	end;
end;


set$num$sect$trk: PROCEDURE;
	sectorsPerTrack = sectorsTable(disk);
	tracksPerDisk = tracksTable(disk);
end;



get$block: PROCEDURE(diskNum) ADDRESS PUBLIC;
	DECLARE diskNum BYTE;
	DECLARE trackSector ADDRESS,
		sector BYTE AT (.trackSector),
		track BYTE AT (.trackSector + 1);

	disk = diskNum;
	call set$num$sect$trk;
	next$part = base$part;
	if disk <> current$bitmap then
		next$part = 0;
	call map$read;
	bitmapBit = ror(1, lowBitmapIndex and 7);
	do track = baseTrack TO tracksPerDisk;
		do sector = baseSector TO sectorsPerTrack;
			bitmapByte$p = .bitmapBuffer(SHR(bitmapIndex, 3));
			if bitmapByte = 0ffh  AND bitmapBit then	/* no free entry */
			do;
				bitmapIndex = bitmapIndex + 8;
				sector = sector + 7;			/* the do loop adds 1 */
				if sector > sectorsPerTrack then
				do;
					sector = sector - sectorsPerTrack;
					track = track + 1;
					if track > tracksPerDisk then	
						goto full;
				end;
			end;
			else
			do;
				if ((bitmapBit := ROR(bitmapBit, 1)) AND bitmapByte) = 0 then	/* found a slot */
				do;
					map$change = TRUE;
					bitmapByte = bitmapByte OR bitmapBit;
					base$part = current$part;
					return (baseTrackSector := trackSector);
				end;
				bitmapIndex = bitmapIndex + 1;
			end;
			if bitmapIndex > 03ffh then
			do;
				next$part = current$part + 1;
				call map$read;
				bitmapIndex = 0;
			end;
		end;
		baseSector = 1;	
	end;
full:
	call abortx(DISK$FULL);
end;


free$block: PROCEDURE(diskNum, trackSector) PUBLIC;
	DECLARE disknum BYTE, trackSector ADDRESS;
	DECLARE (sector, track) BYTE AT (.trackSector);
	DECLARE temp BYTE;

	disk = disknum;
	call set$num$sect$trk;
	bitmapByte$p = track * sectorsPerTrack + sector - 1;
	next$part = shr(highBitmapByte$p, 2);
	if bitmapByte$p < bitmapIndex + shl(double(base$part),10) then
	do;
		base$part = next$part;
		bitmapIndex = bitmapByte$p AND 03ffh;
		baseTrackSector = trackSector;
	end;
	call map$read;
	temp = lowBitmapByte$p;
	bitmapByte$p = .bitmapBuffer(shr(bitmapByte$p and 03ffh, 3));
	bitmapByte = bitmapByte AND not ROR(80h, temp and 7);
	map$change = TRUE;
end;
end;
eof

