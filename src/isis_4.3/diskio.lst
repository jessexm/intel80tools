:F1:asm80 diskio.asm print(diskio.lst) object(diskio.obj) DEBUG



ISIS-II 8080/8085 MACRO ASSEMBLER, V4.1         DISKIO   PAGE    1


  LOC  OBJ         LINE        SOURCE STATEMENT

                      1 
                      2         name diskio
                      3         CSEG
                      4         extrn   @P0103  ; library routine
                      5 
                      6 
                      7 ; ****************** some notes about this code ********************
                      8 ; most of the function diskio seems to have been originally been in PLM based on
                      9 ; the code sequences generated. However two of the ADDRESS variables have been
                     10 ; initialised to 0 in the final isis.bin file which indicates that this they
                     11 ; have been set as dw 0, statements in assembler as neither the parameter iopb
                     12 ; nor the realTK variable could legally be initialisd in PLM
                     13 ; There also appear to be a few of minor hand crafted code changes
                     14 ; those to ignoring r$byte and r$type could have been overcome by defining
                     15 ; different name entry points in the disk2.asm code
                     16 ; others like noting that the do loop variable is in the hl register at both
                     17 ; the initialisation and the increment so doesnot need to be loaded for the
                     18 ; loop test are not detected in plm80 4.0
                     19 
                     20 ; In this file I have left in the PLM code and the assembly generated from it
                     21 ; the PLM code is commented out and the original code is left in upper case
                     22 ; code that has been optimised out or changed has been commented out with a
                     23 ; leading ;-, and replacement code has been entered in lower case
                     24 
                     25 ; Note the include statements and unrequired declarations have been deleted
                     26 ; to keep the file reasonably clean
                     27 
                     28 ; DECLARE DCB$T LITERALLY 'STRUCTURE (iocw BYTE, ioins BYTE, nsec BYTE, tadr BYTE, sadr BYTE, bu
                        f ADDRESS)',
                     29 ;         TRUE        LITERALLY   '0ffh',
                     30 ;         FALSE       LITERALLY   '0',
                     31 ;         DISK$IO$ERROR   LITERALLY   '24',   /* Disk error */       
                     32 ;         DRIVE$NOT$READY LITERALLY   '30',   /* Drive not ready. */
                     33 ;         c$dk$sat ADDRESS EXTERNAL,
                     34         extrn   cdksat
                     35 ;         errdrv BYTE EXTERNAL;
                     36         extrn   errdrv
                     37 
                     38 ; DECLARE vec$0E ADDRESS EXTERNAL
                     39         extrn   vec0E
                     40 ; abortx: PROCEDURE(errcode) EXTERNAL; DECLARE errcode BYTE; END;
                     41         extrn   abortx
                     42 ; trap0B: PROCEDURE EXTERNAL; END;
                     43         extrn   trap0B
                     44 
                     45 ; dk$stat: PROCEDURE BYTE EXTERNAL; END;
                     46         extrn   dkstat
                     47 ; r$type: PROCEDURE BYTE EXTERNAL; END;
                     48         extrn   rtype
                     49 ; r$byte: PROCEDURE BYTE EXTERNAL; END;
                     50         extrn   rbyte
                     51 ; strt$io: PROCEDURE(iopb) EXTERNAL; DECLARE iopb ADDRESS; END;
                     52         extrn   strtio
                     53 


ISIS-II 8080/8085 MACRO ASSEMBLER, V4.1         DISKIO   PAGE    2


  LOC  OBJ         LINE        SOURCE STATEMENT

                     54 ; DECLARE  a$dev$p ADDRESS EXTERNAL,
                     55         extrn   adevp
                     56 ;          a$device BASED a$dev$p BYTE;
                     57 
                     58 ; DECLARE CMD$RECAL   LITERALLY   '3';
                     59 ; DECLARE CMD$READ    LITERALLY   '4';
                     60 ; DECLARE CMD$WRITE   LITERALLY   '6';
                     61 ; DECLARE DD$TYPE     LITERALLY   '1',
                     62 ;         SD$TYPE     LITERALLY   '2',
                     63 ;         ISD$TYPE    LITERALLY   '3',
                     64 ;         HD$TYPE     LITERALLY   '4';
                     65 
                     66 
                     67 ; DECLARE rcal$pb STRUCTURE(iocw BYTE, ioins BYTE, nsec BYTE, tadr BYTE, sadr BYTE)
                     68 ;                           INITIAL(80h, CMD$RECAL, 1, 0, 0);
  0000 80            69 rcalpb: db      80h, 3, 1, 0, 0
  0001 03              
  0002 01              
  0003 00              
  0004 00              
                     70 
                     71 ; DECLARE absdcb DCB$T INITIAL(80h, 0, 1, 0, 0, 0);
  0005 80            72 absdcb: db      80h, 0, 1, 0, 0
  0006 00              
  0007 01              
  0008 00              
  0009 00              
  000A 0000          73         dw      0
                     74 ; DECLARE dk$cf$tb(10) BYTE PUBLIC,
                     75         public  dkcftb
  000C               76 dkcftb: ds      10
                     77 ;         rdy$msk(10) BYTE PUBLIC,
                     78         public rdymsk
  0016               79 rdymsk: ds      10
                     80 ;         unit$mp(10) BYTE PUBLIC,
                     81         public unitmp
  0020               82 unitmp: ds      10
                     83 ;         dk$ct$tb(10) BYTE PUBLIC,  /* disk controller table */
                     84         public dkcttb
  002A               85 dkcttb: ds      10
                     86 ;         dkcont BYTE PUBLIC,
                     87         public  dkcont
  0034               88 dkcont: ds      1
                     89 ;         track BYTE PUBLIC,
                     90         public  track
  0035               91 track:  ds      1
                     92 ;         sector BYTE PUBLIC,
                     93         public  sector
  0036               94 sector: ds      1
                     95 ;         temp ADDRESS,
                     96 ;         (temp2, temp1) BYTE;
                     97 temp:
  0037               98 temp2:  ds      1
  0038               99 temp1:  ds      1
                    100 


ISIS-II 8080/8085 MACRO ASSEMBLER, V4.1         DISKIO   PAGE    3


  LOC  OBJ         LINE        SOURCE STATEMENT

                    101 ; DECLARE MAX$RETRIES LITERALLY   '10';
  0039              102 drive:  ds      1
  003A 0000         103 iopb:   dw      0
  003C              104 i:      ds      1
  003D              105 diskHW: ds      1
  003E 0000         106 realTk: dw      0       ; tell tail sign of assembly code
  0040              107 ival:   ds      1
  0041              108 sddrv:  ds      1
  0042              109 cmd:    ds      1
  0043              110 disk:   ds      1
  0044 0000         111 block:  dw      0
  0046 0000         112 buffer: dw      0
                    113 
                    114 ; diskio: PROCEDURE(drive, iopb) PUBLIC;
                    115         public  diskio
                    116 DISKIO:
  0048 213B00   C   117          LXI     H,IOPB+1H
  004B 72           118          MOV     M,D
  004C 2B           119          DCX     H
  004D 73           120          MOV     M,E
  004E 2B           121          DCX     H
  004F 71           122          MOV     M,C
                    123 ;     DECLARE drive BYTE, iopb ADDRESS;
                    124 ;     DECLARE dcb BASED iopb DCB$T;
                    125 ;     DECLARE i BYTE,
                    126 ;             diskHW BYTE,
                    127 ;             realTk ADDRESS,
                    128 ;             ival BYTE,
                    129 ;             sd$drv BYTE;
                    130 ;
                    131 ;     track = dcb.tadr;
  0050 010300       132          LXI     B,3H
  0053 2A3A00   C   133          LHLD    IOPB
  0056 09           134          DAD     B
  0057 7E           135          MOV     A,M
  0058 323500   C   136          STA     TRACK
                    137 ;     sector = dcb.sadr;
                    138 ;-         LHLD    IOPB         ; hand optimisation
                    139 ;-         INX     B
                    140 ;-         DAD     B
  005B 23           141         inx     h
  005C 7E           142          MOV     A,M
  005D 323600   C   143          STA     SECTOR
                    144 ;     ival = input(0fch);
  0060 DBFC         145          IN      0FCH
  0062 324000   C   146          STA     IVAL
                    147 ;     output(0fch) = ival or 2;
  0065 F602         148          ORI     2H
  0067 D3FC         149          OUT     0FCH
                    150 ;     dkcont = dk$ct$tb(drive);
  0069 2A3900   C   151          LHLD    DRIVE
  006C 2600         152          MVI     H,0
  006E 012A00   C   153          LXI     B,DKCTTB
  0071 09           154          DAD     B
  0072 7E           155          MOV     A,M


ISIS-II 8080/8085 MACRO ASSEMBLER, V4.1         DISKIO   PAGE    4


  LOC  OBJ         LINE        SOURCE STATEMENT

  0073 323400   C   156          STA     DKCONT
                    157 ;     sd$drv = FALSE;
  0076 214100   C   158          LXI     H,SDDRV
  0079 3600         159          MVI     M,0H
                    160 ;     diskHW = dk$cf$tb(drive);
  007B 2A3900   C   161          LHLD    DRIVE
  007E 2600         162          MVI     H,0
  0080 010C00   C   163          LXI     B,DKCFTB
  0083 09           164          DAD     B
  0084 7E           165          MOV     A,M
  0085 323D00   C   166          STA     DISKHW
                    167 ;     if diskHW = SD$TYPE AND (1 = 1 AND drive) then    /* SD disk (Not ISD) & odd numbered driv
                        e */
  0088 D602         168          SUI     2H
  008A D601         169          SUI     1
  008C 9F           170          SBB     A
  008D F5           171          PUSH    PSW 
  008E 3E01         172          MVI     A,1H   ; this code seems odd and presumably
  0090 D601         173          SUI     1H     ; was masked by LITERALLY defined names
  0092 D601         174          SUI     1
  0094 9F           175          SBB     A
  0095 213900   C   176          LXI     H,DRIVE
  0098 A6           177          ANA     M
  0099 C1           178          POP     B
  009A 48           179          MOV     C,B
  009B A1           180          ANA     C
  009C 1F           181          RAR
  009D D2B000   C   182          JNC     @1
                    183 ;     do;
                    184 ;         sd$drv = TRUE;
  00A0 214100   C   185          LXI     H,SDDRV
  00A3 36FF         186          MVI     M,0FFH
                    187 ;         dcb.sadr = dcb.sadr OR 20h;     /* set selector flag */
  00A5 010400       188          LXI     B,4H
  00A8 2A3A00   C   189          LHLD    IOPB
  00AB 09           190          DAD     B
  00AC 3E20         191          MVI     A,20H
  00AE B6           192          ORA     M
  00AF 77           193          MOV     M,A
                    194 ;     end;
                    195 @1:
                    196 ;     if diskHW = 4 then  /* hard disk */
  00B0 3A3D00   C   197          LDA     DISKHW
  00B3 FE04         198          CPI     4H
  00B5 C22701   C   199          JNZ     @2
                    200 ;     do;
                    201 ;         realTk = DOUBLE(dcb.tadr) * 2;
  00B8 010300       202          LXI     B,3H
  00BB 2A3A00   C   203          LHLD    IOPB
  00BE 09           204          DAD     B
  00BF 4E           205          MOV     C,M
  00C0 0600         206          MVI     B,0
  00C2 60           207          MOV     H,B
  00C3 69           208          MOV     L,C
  00C4 29           209          DAD     H


ISIS-II 8080/8085 MACRO ASSEMBLER, V4.1         DISKIO   PAGE    5


  LOC  OBJ         LINE        SOURCE STATEMENT

  00C5 223E00   C   210          SHLD    REALTK
                    211 ;         if dcb.sadr > 72 then   /* then map to odd track number */
  00C8 010400       212         lxi     b,4     ; PLM v4.0 optimised to an increment of BC
  00CB 2A3A00   C   213          LHLD    IOPB
                    214 ;-         INX     B
  00CE 09           215          DAD     B
  00CF 3E48         216          MVI     A,48H
  00D1 BE           217          CMP     M
  00D2 D2E700   C   218          JNC     @3
                    219 ;         do;
                    220 ;             realTk = realTk + 1;
  00D5 2A3E00   C   221          LHLD    REALTK
  00D8 23           222          INX     H
  00D9 223E00   C   223          SHLD    REALTK
                    224 ;             dcb.sadr = dcb.sadr - 72;
  00DC 010400       225          LXI     B,4H
  00DF 2A3A00   C   226          LHLD    IOPB
  00E2 09           227          DAD     B
  00E3 7E           228          MOV     A,M
  00E4 D648         229          SUI     48H
  00E6 77           230          MOV     M,A
                    231 ;         end;
                    232 @3:
                    233 ;         if dcb.sadr < 37 then
                    234 ;-         LXI     B,4H         ; hand optimised as hl points to dcb.sadr on all paths
                    235 ;-         LHLD    IOPB
                    236 ;=         DAD     B
  00E7 7E           237          MOV     A,M
  00E8 FE25         238          CPI     25H
  00EA D2F800   C   239          JNC      @4
                    240 ;             dcb.ioins = dcb.ioins OR 8; /* select head */
  00ED 2A3A00   C   241          LHLD    IOPB
  00F0 23           242          INX     H
  00F1 3E08         243          MVI     A,8H
  00F3 B6           244          ORA     M
  00F4 77           245          MOV     M,A
  00F5 C30301   C   246          JMP     @5
                    247 @4:
                    248 ;         else
                    249 ;             dcb.sadr = dcb.sadr - 36;
  00F8 010400       250          LXI     B,4H
  00FB 2A3A00   C   251          LHLD    IOPB
  00FE 09           252          DAD     B
  00FF 7E           253          MOV     A,M
  0100 D624         254          SUI     24H
  0102 77           255          MOV     M,A
                    256 @5:
                    257 ;         if realTk > 255 then
  0103 3EFF         258          MVI     A,0FFH
  0105 213E00   C   259          LXI     H,REALTK
  0108 CD0000   E   260          CALL    @P0103 
  010B D21901   C   261          JNC     @6
                    262 ;             dcb.sadr = dcb.sadr + 80h;  /* track extension bit */
  010E 010400       263          LXI     B,4H
  0111 2A3A00   C   264          LHLD    IOPB


ISIS-II 8080/8085 MACRO ASSEMBLER, V4.1         DISKIO   PAGE    6


  LOC  OBJ         LINE        SOURCE STATEMENT

  0114 09           265          DAD     B
  0115 3E80         266          MVI     A,80H
  0117 86           267          ADD     M
  0118 77           268          MOV     M,A
                    269 @6:
                    270 ;         dcb.tadr = realTk;  
  0119 010300       271          LXI     B,3H
  011C 2A3A00   C   272          LHLD    IOPB
  011F 09           273          DAD     B
  0120 E5           274          PUSH    H
  0121 2A3E00   C   275          LHLD    REALTK
  0124 EB           276          XCHG
  0125 E1           277          POP     H
  0126 73           278          MOV     M,E
                    279 ;     end;
                    280 @2:
                    281 ;     dcb.ioins = dcb.ioins OR unit$mp(drive);
  0127 2A3A00   C   282          LHLD    IOPB
  012A 23           283          INX     H
  012B E5           284          PUSH    H
  012C 2A3900   C   285          LHLD    DRIVE
  012F 2600         286          MVI     H,0
  0131 012000   C   287          LXI     B,UNITMP
  0134 09           288          DAD     B
  0135 7E           289          MOV     A,M
  0136 E1           290          POP     H
  0137 B6           291          ORA     M
  0138 77           292          MOV     M,A
                    293 ;     do i = 0 to MAX$RETRIES;    /* 0-10 */
  0139 213C00   C   294          LXI     H,I
  013C 3600         295          MVI     M,0H
                    296 @10:
  013E 3E0A         297          MVI     A,0AH
                    298 ;-         LXI     H,I  ; hand optimised
  0140 BE           299          CMP     M
  0141 DAB901   C   300          JC      @11
                    301 ;         do while (dk$stat AND 4) <> 0;
                    302 @12:
  0144 CD0000   E   303          CALL    DKSTAT
  0147 E604         304          ANI     4H
  0149 FE00         305          CPI     0H
  014B CA5701   C   306          JZ      @13
                    307 ;             temp1 = r$type; /* assignments removed in asm */
  014E CD0000   E   308          CALL    RTYPE
                    309 ;-         STA     TEMP1        ; optimised (but non return version possible)
                    310 ;             temp1 = r$byte;
  0151 CD0000   E   311          CALL    RBYTE
                    312 ;-         STA     TEMP1        ; optimised (but non return version possible)
                    313 ;         end;
  0154 C34401   C   314          JMP     @12
                    315 @13:
                    316 ;         if (dk$stat AND rdy$msk(drive)) = 0 then
  0157 CD0000   E   317          CALL    DKSTAT
  015A 2A3900   C   318          LHLD    DRIVE
  015D 2600         319          MVI     H,0


ISIS-II 8080/8085 MACRO ASSEMBLER, V4.1         DISKIO   PAGE    7


  LOC  OBJ         LINE        SOURCE STATEMENT

  015F 011600   C   320          LXI     B,RDYMSK
  0162 09           321          DAD     B
  0163 A6           322          ANA     M
  0164 FE00         323          CPI     0H
  0166 C26E01   C   324          JNZ     @7
                    325 ;             call abortx(DRIVE$NOT$READY);
  0169 0E1E         326          MVI     C,1EH
  016B CD0000   E   327          CALL    ABORTX
                    328 @7:
                    329 ;         call strt$io(iopb);
  016E 2A3A00   C   330          LHLD    IOPB
  0171 44           331          MOV     B,H
  0172 4D           332          MOV     C,L
  0173 CD0000   E   333          CALL    STRTIO
                    334 ;         temp1 = r$type;
  0176 CD0000   E   335          CALL    RTYPE
  0179 323800   C   336          STA     TEMP1
                    337 ;         if (temp2 := r$byte) = 0 then
  017C CD0000   E   338          CALL    RBYTE
  017F 323700   C   339          STA     TEMP2
  0182 FE00         340          CPI     0H
  0184 C28D01   C   341          JNZ     @8
                    342 ;         do;
                    343 ;             output(0fch) = ival;
  0187 3A4000   C   344          LDA     IVAL
  018A D3FC         345          OUT     0FCH
                    346 ;             return;
  018C C9           347          RET
                    348 ;         end;
                    349 @8:
                    350 ;         if sd$drv then
  018D 3A4100   C   351          LDA     SDDRV
  0190 1F           352          RAR
  0191 D29C01   C   353          JNC     @9
                    354 ;             rcal$pb.sadr = rcal$pb.sadr OR 20h;
  0194 3A0400   C   355          LDA     RCALPB+4H
  0197 F620         356          ORI     20H
  0199 320400   C   357          STA     RCALPB+4H
                    358 @9:
                    359 ;         rcal$pb.ioins = rcal$pb.ioins OR unit$mp(drive);
  019C 2A3900   C   360          LHLD    DRIVE
  019F 2600         361          MVI     H,0
  01A1 012000   C   362          LXI     B,UNITMP
  01A4 09           363          DAD     B
  01A5 3A0100   C   364          LDA     RCALPB+1H
  01A8 B6           365          ORA     M
  01A9 320100   C   366          STA     RCALPB+1H
                    367 ;         call strt$io(.rcal$pb);
  01AC 010000   C   368          LXI     B,RCALPB
  01AF CD0000   E   369          CALL    STRTIO
                    370 ;     end;
                    371 @14:
  01B2 213C00   C   372          LXI     H,I
  01B5 34           373          INR     M
  01B6 C23E01   C   374          JNZ     @10


ISIS-II 8080/8085 MACRO ASSEMBLER, V4.1         DISKIO   PAGE    8


  LOC  OBJ         LINE        SOURCE STATEMENT

                    375 @11:
                    376 ;     errDrv = drive;
  01B9 3A3900   C   377          LDA     DRIVE
  01BC 320000   E   378          STA     ERRDRV
                    379 ;     vec$0E, c$dk$sat, vec$0E = temp2;
  01BF 2A3700   C   380          LHLD    TEMP
  01C2 220000   E   381          SHLD    VEC0E
  01C5 220000   E   382          SHLD    CDKSAT
                    383 ;     output(0fch) = ival;
  01C8 3A4000   C   384          LDA     IVAL
  01CB D3FC         385          OUT     0FCH
                    386 ;     call trap0B;
  01CD CD0000   E   387          CALL    TRAP0B
                    388 ;     output(0fch) = ival OR 2;
  01D0 3A4000   C   389          LDA     IVAL
  01D3 F602         390          ORI     2H
  01D5 D3FC         391          OUT     0FCH
                    392 ;     call abortx(DISK$IO$ERROR);
  01D7 0E18         393          MVI     C,18H
  01D9 CD0000   E   394          CALL    ABORTX
                    395 ; end;
  01DC C9           396          RET
                    397 
                    398 ; absio: PROCEDURE(cmd, disk, block$p, buffer)  PUBLIC;
                    399         public  absio
                    400 ABSIO:
  01DD 214700   C   401          LXI     H,BUFFER+1H
  01E0 72           402          MOV     M,D
  01E1 2B           403          DCX     H
  01E2 73           404          MOV     M,E
  01E3 2B           405          DCX     H
  01E4 70           406          MOV     M,B
  01E5 2B           407          DCX     H
  01E6 71           408          MOV     M,C
  01E7 2B           409          DCX     H
  01E8 D1           410          POP     D       
  01E9 C1           411          POP     B       
  01EA 71           412          MOV     M,C
  01EB 2B           413          DCX     H
  01EC C1           414          POP     B       
  01ED 71           415          MOV     M,C
  01EE D5           416          PUSH    D       
                    417 ;     DECLARE (cmd, disk) BYTE, (block$p, buffer) ADDRESS;
                    418 ;     DECLARE tsadr ADDRESS AT (.absdcb.tadr); /* to allow tadr & sadr write together */
  0008          C   419 tsadr   equ     absdcb+3
                    420 ;     DECLARE block BASED block$p;
                    421 ;     absdcb.ioins = cmd;
                    422 abscom:                         ; major optimisation to share code
  01EF 3A4200   C   423          LDA     CMD
  01F2 320600   C   424          STA     ABSDCB+1H
                    425 ;     tsadr = block;
  01F5 2A4400   C   426          LHLD    BLOCK
                    427 ;         SHLD    TSADR
  01F8 EB           428         xchg
  01F9 210800   C   429         lxi     h,tsadr


ISIS-II 8080/8085 MACRO ASSEMBLER, V4.1         DISKIO   PAGE    9


  LOC  OBJ         LINE        SOURCE STATEMENT

  01FC 72           430         mov     m,d
  01FD 23           431         inx     h
  01FE 73           432         mov     m,e
                    433 ;     absdcb.buf = buffer;
  01FF 2A4600   C   434          LHLD    BUFFER
  0202 220A00   C   435          SHLD    ABSDCB+5H
                    436 ;     call diskio(disk, .absdcb);
  0205 2A4300   C   437          LHLD    DISK
  0208 4D           438          MOV     C,L
  0209 110500   C   439          LXI     D,ABSDCB
  020C CD4800   C   440          CALL    DISKIO
                    441 ; end;
  020F C9           442          RET
                    443 ; abs$rd: PROCEDURE(block, buffer) PUBLIC;
                    444         public  absrd
                    445 ABSRD:
  0210 3E04         446         mvi     a,4     ; CMD$READ
                    447 absrw:
  0212 324200   C   448         sta     cmd     ; store in cmd location for absio
  0215 214700   C   449          LXI     H,BUFFER+1H    ; stores in parameters for absio
  0218 72           450          MOV     M,D
  0219 2B           451          DCX     H
  021A 73           452          MOV     M,E
  021B 2B           453          DCX     H
  021C 70           454          MOV     M,B
  021D 2B           455          DCX     H
  021E 71           456          MOV     M,C
                    457 ;     DECLARE (block, buffer) ADDRESS;
                    458 ;     call absio(CMD$READ, a$device, block, buffer);
                    459 ;-         MVI     C,4H ; put in A reg as part of hand optimisation
                    460 ;-         PUSH    B    ; see ABSRD, ABDWR and storing at absrw
  021F 2A0000   E   461          LHLD    ADEVP
  0222 7E           462         mov     a,m     ; a$device
  0223 324300   C   463         sta     disk    ; store in the disk parameter for absio
  0226 C3EF01   C   464         jmp     abscom  ; jump to shared code
                    465 ;-         MOV     C,M
                    466 ;-         PUSH    B       ; 2
                    467 ;-         LHLD    BLOCK
                    468 ;-         MOV     B,H
                    469 ;-         MOV     C,L
                    470 ;-         LHLD    BUFFER
                    471 ;-         XCHG
                    472 ;-         CALL    ABSIO
                    473 ; end;
                    474 ;-         RET
                    475 ; abs$wr: PROCEDURE(block, buffer) PUBLIC;
                    476         public  abswr
                    477 ABSWR:
  0229 3E06         478         mvi     a,6     ; CMD$WRITE
  022B C31202   C   479         jmp     absrw   ; share code with absrd
                    480 ;-         LXI     H,BUFFER+1H
                    481 ;-         MOV     M,D
                    482 ;-         DCX     H
                    483 ;-         MOV     M,E
                    484 ;-         DCX     H


ISIS-II 8080/8085 MACRO ASSEMBLER, V4.1         DISKIO   PAGE   10


  LOC  OBJ         LINE        SOURCE STATEMENT

                    485 ;-         MOV     M,B
                    486 ;-         DCX     H
                    487 ;-         MOV     M,C
                    488 ;     DECLARE (block, buffer) ADDRESS;
                    489 ;     call absio(CMD$WRITE, a$device, block, buffer);
                    490 ;-         MVI     C,6H
                    491 ;-         PUSH    B
                    492 ;-         LHLD    ADEVP
                    493 ;-         MOV     C,M
                    494 ;-         PUSH    B       ; 2
                    495 ;-         LHLD    BLOCK
                    496 ;-         MOV     B,H
                    497 ;-         MOV     C,L
                    498 ;-         LHLD    BUFFER
                    499 ;-         XCHG
                    500 ;-         CALL    ABSIO
                    501 ; end;
                    502 ;-         RET
                    503 ; end;
                    504 ; eof
                    505         end


PUBLIC SYMBOLS
ABSIO  C 01DD    ABSRD  C 0210    ABSWR  C 0229    DISKIO C 0048    DKCFTB C 000C    DKCONT C 0034    DKCTTB C 002A    
RDYMSK C 0016    SECTOR C 0036    TRACK  C 0035    UNITMP C 0020    

EXTERNAL SYMBOLS
@P0103 E 0000    ABORTX E 0000    ADEVP  E 0000    CDKSAT E 0000    DKSTAT E 0000    ERRDRV E 0000    RBYTE  E 0000    
RTYPE  E 0000    STRTIO E 0000    TRAP0B E 0000    VEC0E  E 0000    

USER SYMBOLS
@1     C 00B0    @10    C 013E    @11    C 01B9    @12    C 0144    @13    C 0157    @14    C 01B2    @2     C 0127    
@3     C 00E7    @4     C 00F8    @5     C 0103    @6     C 0119    @7     C 016E    @8     C 018D    @9     C 019C    
@P0103 E 0000    ABORTX E 0000    ABSCOM C 01EF    ABSDCB C 0005    ABSIO  C 01DD    ABSRD  C 0210    ABSRW  C 0212    
ABSWR  C 0229    ADEVP  E 0000    BLOCK  C 0044    BUFFER C 0046    CDKSAT E 0000    CMD    C 0042    DISK   C 0043    
DISKHW C 003D    DISKIO C 0048    DKCFTB C 000C    DKCONT C 0034    DKCTTB C 002A    DKSTAT E 0000    DRIVE  C 0039    
ERRDRV E 0000    I      C 003C    IOPB   C 003A    IVAL   C 0040    RBYTE  E 0000    RCALPB C 0000    RDYMSK C 0016    
REALTK C 003E    RTYPE  E 0000    SDDRV  C 0041    SECTOR C 0036    STRTIO E 0000    TEMP   C 0037    TEMP1  C 0038    
TEMP2  C 0037    TRACK  C 0035    TRAP0B E 0000    TSADR  C 0008    UNITMP C 0020    VEC0E  E 0000    

ASSEMBLY COMPLETE,   NO ERRORS
