PL/M-80 COMPILER                                                                                                PAGE   1


ISIS-II PL/M-80 V4.0 COMPILATION OF MODULE CONSOL
OBJECT MODULE PLACED IN CONSOL.OBJ
COMPILER INVOKED BY:  :F1:plm80 consol.plm PRINT(CONSOL.LST) OBJECT(CONSOL.OBJ) DEBUG OPTIMIZE CODE



   1          consol:
              DO;
              $include(consol.ipx)
   2   1  =   declare Console literally 'consol';
   3   1  =   declare global$severity literally 'gblSev';
   4   1  =   declare ABORT literally '2';
   5   1  =   declare AFTN$CONSOL$IN literally '11';
   6   1  =   declare AFTN$CONSOL$OUT literally '10';
   7   1  =   declare AFT$T literally 'structure(AFT$T1, AFT$T2, AFT$T3, AFT$T4)';
   8   1  =   declare AFT$T1 literally 'empty BYTE, device BYTE, access BYTE, edit BYTE, lbuf ADDRESS';
   9   1  =   declare AFT$T2 literally 'dbuf ADDRESS, pbuf ADDRESS, data$ptr BYTE, i$no ADDRESS, ptr$ptr BYTE';
  10   1  =   declare AFT$T3 literally 'eofcnt BYTE, ptr$change BYTE, data$change BYTE, blk ADDRESS, blk$seq ADDRESS';
  11   1  =   declare AFT$T4 literally 'ptr$blk ADDRESS, hdr$blk ADDRESS, data$blk$count ADDRESS, dbuf$read BYTE';
  12   1  =   declare BOOLEAN literally 'BYTE';
  13   1  =   declare CIDEV literally '27';
  14   1  =   declare CODEV literally '28';
  15   1  =   declare FALSE literally '0';
  16   1  =   declare READ$MODE literally '1';
  17   1  =   declare TRUE literally '0ffh';
  18   1  =   declare WRITE$MODE literally '2';
  19   1  =   declare aft(18) AFT$T external;
  20   1  =   declare global$severity byte external;
  21   1  =   declare pn(1) byte external;
  22   1  =   close: procedure(aftn) external; declare aftn byte; end;
  25   1  =   open: procedure(pathname, access$mode, lined$aft) byte external;
  26   2  =           declare pathname address, access$mode address, lined$aft address; end;
  28   1  =   unpath: procedure(pathname$p, pn$p) external; declare pathname$p address, pn$p address; end;
  31   1  =   xpath: procedure(p1, p2) external; declare p1 address, p2 address; end;
        
  34   1      DECLARE cur$consol$in  (12) BYTE PUBLIC,
                  cur$consol$out (12) BYTE PUBLIC;
        
  35   1      DECLARE cold$consol$in(5)  BYTE INITIAL(':XI: '),
                  cold$consol$out(5) BYTE INITIAL(':XO: ');
        
  36   1      DECLARE cold$start$flag BOOLEAN INITIAL (TRUE);
        
  37   1      DECLARE (cold$cidev, alt$cidev) BYTE PUBLIC;
        
  38   1      console: PROCEDURE(infile, outfile) PUBLIC;
                                                 ; STATEMENT # 38
                         ; PROC  CONSOL
           0002  212800          LXI     H,OUTFILE+1H
           0005  72              MOV     M,D
           0006  2B              DCX     H
           0007  73              MOV     M,E
           0008  2B              DCX     H
           0009  70              MOV     M,B
           000A  2B              DCX     H
           000B  71              MOV     M,C
  39   2          DECLARE (infile, outfile) ADDRESS;
PL/M-80 COMPILER                                                                                                PAGE   2


  40   2          DECLARE instring based infile BYTE,
                      outstring based outfile BYTE;
  41   2          DECLARE temp BYTE;
  42   2          DECLARE tdrv(2) BYTE DATA ('TV');   /* T or V is 1st letter of device name */
  43   2          DECLARE initio BYTE AT (6);
        
  44   2          if cold$start$flag then
                                                 ; STATEMENT # 44
           000C  3A2200          LDA     COLDSTARTFLAG
           000F  1F              RAR
           0010  D23200          JNC     @1
  45   2          do;
  46   3            cold$consol$in(1), cold$consol$out(1) = tdrv(initio and 1);
                                                 ; STATEMENT # 46
           0013  3A0600          LDA     INITIO
           0016  E601            ANI     1H
           0018  4F              MOV     C,A
           0019  0600            MVI     B,0
           001B  210000          LXI     H,TDRV
           001E  09              DAD     B
           001F  7E              MOV     A,M
           0020  321900          STA     COLDCONSOLIN+1H
           0023  321E00          STA     COLDCONSOLOUT+1H
  47   3            infile = .cold$consol$in;
                                                 ; STATEMENT # 47
           0026  211800          LXI     H,COLDCONSOLIN
           0029  222500          SHLD    INFILE
  48   3            outfile = .cold$consol$out;
                                                 ; STATEMENT # 48
           002C  211D00          LXI     H,COLDCONSOLOUT
           002F  222700          SHLD    OUTFILE
  49   3          end;
                                                 ; STATEMENT # 49
                         @1:
                  
  50   2          global$severity = ABORT;
                                                 ; STATEMENT # 50
           0032  210000          LXI     H,GBLSEV
           0035  3602            MVI     M,2H
  51   2          call xpath(outfile, .pn);
                                                 ; STATEMENT # 51
           0037  2A2700          LHLD    OUTFILE
           003A  44              MOV     B,H
           003B  4D              MOV     C,L
           003C  110000          LXI     D,PN
           003F  CD0000          CALL    XPATH
  52   2          if pn(0) <> CODEV then
                                                 ; STATEMENT # 52
           0042  3A0000          LDA     PN
           0045  FE1C            CPI     1CH
           0047  CA6A00          JZ      @2
  53   2          do;
  54   3            call close(AFTN$CONSOL$OUT);
                                                 ; STATEMENT # 54
           004A  0E0A            MVI     C,0AH
           004C  CD0000          CALL    CLOSE
  55   3            temp = open(outfile, WRITE$MODE, FALSE);
PL/M-80 COMPILER                                                                                                PAGE   3


                                                 ; STATEMENT # 55
           004F  2A2700          LHLD    OUTFILE
           0052  E5              PUSH    H       ; 1
           0053  110000          LXI     D,0H
           0056  010200          LXI     B,2H
           0059  CD0000          CALL    OPEN
           005C  322900          STA     TEMP
  56   3            call xpath(outfile, .cur$consol$out);
                                                 ; STATEMENT # 56
           005F  2A2700          LHLD    OUTFILE
           0062  44              MOV     B,H
           0063  4D              MOV     C,L
           0064  110C00          LXI     D,CURCONSOLOUT
           0067  CD0000          CALL    XPATH
  57   3          end;
                                                 ; STATEMENT # 57
                         @2:
  58   2          call xpath(infile, .pn);
                                                 ; STATEMENT # 58
           006A  2A2500          LHLD    INFILE
           006D  44              MOV     B,H
           006E  4D              MOV     C,L
           006F  110000          LXI     D,PN
           0072  CD0000          CALL    XPATH
  59   2          if pn(0) <> CIDEV then 
                                                 ; STATEMENT # 59
           0075  3A0000          LDA     PN
           0078  FE1B            CPI     1BH
           007A  CAB000          JZ      @3
  60   2          do;
  61   3            call close(AFTN$CONSOL$IN);
                                                 ; STATEMENT # 61
           007D  0E0B            MVI     C,0BH
           007F  CD0000          CALL    CLOSE
  62   3            temp = open(infile, READ$MODE, 100h);
                                                 ; STATEMENT # 62
           0082  2A2500          LHLD    INFILE
           0085  E5              PUSH    H       ; 1
           0086  110001          LXI     D,100H
           0089  010100          LXI     B,1H
           008C  CD0000          CALL    OPEN
           008F  322900          STA     TEMP
  63   3            if cold$start$flag then
                                                 ; STATEMENT # 63
           0092  3A2200          LDA     COLDSTARTFLAG
           0095  1F              RAR
           0096  D29F00          JNC     @4
  64   3              cold$cidev = aft(AFTN$CONSOL$IN).device;
                                                 ; STATEMENT # 64
           0099  3A3501          LDA     AFT+135H
           009C  322300          STA     COLDCIDEV
                         @4:
  65   3            alt$cidev = cold$cidev;
                                                 ; STATEMENT # 65
           009F  3A2300          LDA     COLDCIDEV
           00A2  322400          STA     ALTCIDEV
  66   3            call xpath(infile, .cur$consol$in);
PL/M-80 COMPILER                                                                                                PAGE   4


                                                 ; STATEMENT # 66
           00A5  2A2500          LHLD    INFILE
           00A8  44              MOV     B,H
           00A9  4D              MOV     C,L
           00AA  110000          LXI     D,CURCONSOLIN
           00AD  CD0000          CALL    XPATH
  67   3          end;
                                                 ; STATEMENT # 67
                         @3:
  68   2          cold$start$flag = FALSE;
                                                 ; STATEMENT # 68
           00B0  212200          LXI     H,COLDSTARTFLAG
           00B3  3600            MVI     M,0H
  69   2      end;
                                                 ; STATEMENT # 69
           00B5  C9              RET
        
        
  70   1      whocon: PROCEDURE(aftn, bufferloc) PUBLIC;
                                                 ; STATEMENT # 70
                         ; PROC  WHOCON
           00B6  212C00          LXI     H,BUFFERLOC+1H
           00B9  72              MOV     M,D
           00BA  2B              DCX     H
           00BB  73              MOV     M,E
           00BC  2B              DCX     H
           00BD  71              MOV     M,C
  71   2          DECLARE aftn BYTE;
  72   2          DECLARE bufferloc ADDRESS;
  73   2          DECLARE nameloc ADDRESS;
        
  74   2          nameloc = .cur$consol$out;
                                                 ; STATEMENT # 74
           00BE  210C00          LXI     H,CURCONSOLOUT
           00C1  222D00          SHLD    NAMELOC
  75   2          if aftn then
                                                 ; STATEMENT # 75
           00C4  3A2A00          LDA     AFTN
           00C7  1F              RAR
           00C8  D2E700          JNC     @5
  76   2          do;
  77   3            if (aftn := aft(AFTN$CONSOL$IN).device) <> cur$consol$in(0) then
                                                 ; STATEMENT # 77
           00CB  3A3501          LDA     AFT+135H
           00CE  322A00          STA     AFTN
           00D1  210000          LXI     H,CURCONSOLIN
           00D4  BE              CMP     M
           00D5  CAE100          JZ      @6
  78   3              nameloc = .aftn;
                                                 ; STATEMENT # 78
           00D8  212A00          LXI     H,AFTN
           00DB  222D00          SHLD    NAMELOC
           00DE  C3E700          JMP     @7
                         @6:
                    else
  79   3              nameloc = .cur$consol$in;
                                                 ; STATEMENT # 79
PL/M-80 COMPILER                                                                                                PAGE   5


           00E1  210000          LXI     H,CURCONSOLIN
           00E4  222D00          SHLD    NAMELOC
                         @7:
  80   3          end;
                                                 ; STATEMENT # 80
                         @5:
  81   2          call unpath(nameloc, bufferloc);
                                                 ; STATEMENT # 81
           00E7  2A2D00          LHLD    NAMELOC
           00EA  44              MOV     B,H
           00EB  4D              MOV     C,L
           00EC  2A2B00          LHLD    BUFFERLOC
           00EF  EB              XCHG
           00F0  CD0000          CALL    UNPATH
  82   2      end;
                                                 ; STATEMENT # 82
           00F3  C9              RET
  83   1      end;
              eof



MODULE INFORMATION:

     CODE AREA SIZE     = 00F4H    244D
     VARIABLE AREA SIZE = 002FH     47D
     MAXIMUM STACK SIZE = 0004H      4D
     93 LINES READ
     0 PROGRAM ERRORS

END OF PL/M-80 COMPILATION
