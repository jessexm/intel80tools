exit.pl3
EXIT: DO;
isis: procedure (type, parameter$ptr) external;
    declare type byte,
            parameter$ptr address;
end isis;

declare I$EXIT literally '9';

exit: procedure public;
    declare status address;

    status = .status;

    call isis(I$EXIT, .status);
end exit;

end;
attrib.pl3
ATTRIB: DO;
isis: procedure (type, parameter$ptr) external;
    declare type byte,
            parameter$ptr address;
end isis;

declare I$ATTRIB literally '10';

attrib: procedure (path$p, attrib, on$off, status$p) public;
    declare (path$p, attrib, on$off, status$p) address;

    call isis(I$ATTRIB, .path$p);

end attrib;

end;
close.pl3
CLOSE: DO;
isis: procedure (type, parameter$ptr) external;
    declare type byte,
            parameter$ptr address;
end isis;

declare I$CLOSE literally '1';

close: procedure (conn, status$p) public;
    declare (conn, status$p) address;

    call isis(I$CLOSE, .conn);
end close;

end;
consol.pl3
CONSOL: DO;
isis: procedure (type, parameter$ptr) external;
    declare type byte,
            parameter$ptr address;
end isis;

declare I$CONSOL literally '8';

consol: procedure (ci$p, co$p, status$p) public;
    declare (ci$p, co$p, status$p) address;

    call isis(I$CONSOL, .ci$p);
end consol;

end;

delete.pl3
DELETE: DO;
isis: procedure (type, parameter$ptr) external;
    declare type byte,
            parameter$ptr address;
end isis;

declare I$DELETE literally '2';

delete: procedure (path$p, status$p) public;
    declare (path$p, status$p) address;

    call isis(I$DELETE, .path$p);
end delete;
end;

load.pl3
LOAD: DO;
isis: procedure (type, parameter$ptr) external;
    declare type byte,
            parameter$ptr address;
end isis;

declare I$LOAD literally '6';

load: procedure (path$p, load$offset, switch, entry$p, status$p) public;
    declare (path$p, load$offset, switch, entry$p, status$p) address;

    call isis(I$LOAD, .path$p);

end load;
end;
open.pl3
OPEN: DO;
isis: procedure (type, parameter$ptr) external;
    declare type byte,
            parameter$ptr address;
end isis;

declare I$OPEN literally '0';

open: procedure (conn$p, path$p, access, echo, status$p) public;
    declare (conn$p, path$p, access, echo, status$p) address;

    call isis(I$OPEN, .conn$p);

end open;

end;
read.pl3
READ: DO;
isis: procedure (type, parameter$ptr) external;
    declare type byte,
            parameter$ptr address;
end isis;

declare I$READ literally '3';

read: procedure (conn, buff$p, count, actual$p, status$p) public;
    declare (conn, buff$p, count, actual$p, status$p) address;

    call isis(I$READ, .conn);

end read;

end;
rename.pl3
RENAME: DO;
isis: procedure (type, parameter$ptr) external;
    declare type byte,
            parameter$ptr address;
end isis;

declare I$RENAME literally '7';

rename: procedure (old$p, new$p, status$p) public;
    declare (old$p, new$p, status$p) address;

    call isis(I$RENAME, .old$p);

end rename;

end;
rescan.pl3
RESCAN: DO;
isis: procedure (type, parameter$ptr) external;
    declare type byte,
            parameter$ptr address;
end isis;

declare I$RESCAN literally '11';

rescan: procedure (conn, status$p) public;
    declare (conn, status$p) address;

    call isis(I$RESCAN, .conn);

end rescan;

end;
seek.pl3
SEEK: DO;
isis: procedure (type, parameter$ptr) external;
    declare type byte,
            parameter$ptr address;
end isis;

declare I$SEEK literally '5';

seek: procedure (conn, mode, block$p, byte$p, status$p) public;
    declare (conn, mode, block$p, byte$p, status$p) address;

    call isis(I$SEEK, .conn);

end seek;

end;

spath.pl3
SPATH: DO;

declare I$SPATH literally '14';
declare	isis address data(40h);

spath: procedure (path$p, info$p, status$p) public;
    declare (path$p, info$p, status$p) address;

    call isis(I$SPATH, .path$p);

end spath;

end;
ui.pl3
UI: DO;
declare	UI address at(0F826H);
end;

uo.pl3
UO: DO;
declare	UI address at(0F829H);
end;

upps.pl3
UPPS: DO;
declare UPPS address at (0F82CH);
end;

whocon.pl3
WHOCON: DO;
isis: procedure (type, parameter$ptr) external;
    declare type byte,
            parameter$ptr address;
end isis;

declare I$WHOCON literally '13';

whocon: procedure (conn, buff$p) public;
    declare (conn, buff$p) address;
    declare status address;

    status = .status;
    call isis(I$WHOCON, .conn);

end whocon;

end;

write.pl3
WRITE: DO;
isis: procedure (type, parameter$ptr) external;
    declare type byte,
            parameter$ptr address;
end isis;

declare I$WRITE literally '4';

write: procedure (conn, buff$p, count, status$p) public;
    declare (conn, buff$p, count, status$p) address;

    call isis(I$WRITE, .conn);

end write;

end;
chgacs.asm
	name	CHGACS
	public	CHGACS
	cseg

CHGACS: jmp	0E800H

	end

ci.asm
	name	CI
	public	CI
	ASEG

CI	equ	0F803H

	end

co.asm
	name	CO
	public	CO
	aseg

CO	equ	0F809H

	end
csts.asm
	name	CSTS
	public	CSTS

	aseg
CSTS	equ	0F812H

	end
detime.asm
	name	DETIME
	public	DETIME
	cseg

DETIME: jmp	0E803H
	end
error.asm
	name	ERROR
	public	ERROR
	extrn	ISIS

;	error: procedure (error$num) public;
;	    declare (error$num) address;
;	end error;

IERROR	equ	12

	dseg
status:	ds	2
arg:	ds	2	; the isis arg
statp:	dw	status	; and notional return status$p

	cseg
ERROR:	mvi	a,IERROR
	lxi	h,statp
	dcx	h
	mov	m,b	; save the error$num
	dcx	h
	mov	m,c
	mov	c,a
	xchg
	jmp	ISIS

	end

filinf.asm
	name	FILINF
	public	FILINF
	cseg

FILINF:	jmp	0E800H
	end

getatt.asm
	name	GETATT
	public	GETATT
	extrn	ISIS

;	declare I$GETATT literally '17';
;	getatt(arg1, arg2, arg3) public;
;	    declare (arg1, arg2, arg3) address;
;	    call ISIS(I$GETATT, .arg1);
;	end;


IGTATT	equ	17
	dseg
D0000:	ds	6
D0006:
	cseg
GETATT:	mvi	a,IGTATT
	lxi	h,D0006
	dcx	h
	mov	m,d
	dcx	h
	mov	m,e
	dcx	h
	mov	m,b
	dcx	h
	mov	m,c
	pop	b
	pop	d
	dcx	h
	mov	m,d
	dcx	h
	mov	m,e
	push	b
	mov	c,a
	xchg
	jmp	ISIS

	end;
getd.asm
	name	GETD
	public	GETD
	cseg

GETD:	jmp	0E800H
	end

iochk.asm
	name	IOCHK
	public	IOCHK
	aseg

IOCHK	equ	0F815H

	end
iodef.asm
	name	IODEF
	public	IODEF
	aseg

IODEF	equ	0F81EH

	end
ioset.asm
	name	IOSET
	public	IOSET
	aseg

IOSET	equ	0F818H

	end
isis.asm
	name	ISIS
	public	ISIS
	aseg

ISIS	equ	40H

	end
lo.asm
	name	LO
	public	LO
	aseg

LO	equ	0F80FH

	end

memck.asm
	name	MEMCK
	public	MEMCK
	cseg

MEMCK:	call	0F81BH
	mov	h,b
	mov	l,a
	ret

	end

po.asm
	name	PO
	public	PO
	aseg

PO	equ	0F80CH

	end

ri.asm
	name	RI
	public	RI
	aseg

RI	equ	0F806H

	end

v1p5.asm
	name	V1P5
	public	V1P5
	cseg
V1P5:	db	0
	end

makefile
# common makefile info
ROOT=../..
ISIS=$(ROOT:/=\)\thames
TOOLS=$(ROOT:/=\)\tools
F0=./
# alternatives for :F1:
V4=$(ROOT)/plm80v4
V3=$(ROOT)/plm80v3

TARGET=system.lib

PLMFLAGS=code optimize
ASMFLAGS=

OBJS= 	attrib.obj ci.obj close.obj co.obj consol.obj csts.obj delete.obj exit.obj\
	iochk.obj iodef.obj ioset.obj isis.obj lo.obj load.obj memck.obj open.obj\
	po.obj read.obj rename.obj rescan.obj ri.obj seek.obj WHOCON.obj write.obj\
	ui.obj uo.obj upps.obj

.SUFFIXES: .asm .plm .pl3
.plm.obj:
	@SET ISIS_F0=$(F0)
	@SET ISIS_F1=$(V4)
	$(ISIS) :F1:PLM80 $< $(PLMFLAGS) code
	@if not exist $*.obj exit /b 1

.pl3.obj:
	@SET ISIS_F0=$(F0)
	@SET ISIS_F1=$(V3)
	$(ISIS) :F1:PLM80 $< $(PLMFLAGS) code
	@find $*.lst "     0 PROGRAM ERROR(S)" >nul || (del $*.obj & exit /b 1)

.asm.obj:
	@SET ISIS_F0=$(F0)
	@SET ISIS_F1=$(V4)
	$(ISIS) :F1:ASM80 $< $(ASMFLAGS)
	@find $*.lst "ASSEMBLY COMPLETE,   NO ERRORS" >nul || (del $*.obj & exit /b 1)


$(TARGET): $(OBJS)
	@SET ISIS_F0=.
	@SET ISIS_F1=$(V4)
	del $@
	$(ISIS) :F1:lib < <<
create $@
add $(**: =,&
) TO $@
exit
<<NOKEEP

verify: $(OBJS)
	$(TOOLS)\delib.pl $(V4)/$(TARGET) ref
	for %i in ($**) do $(TOOLS)\diffbin %i ref/%i

clean:
       	del *.*~ *.obj *.lst *~

vclean: clean
	del $(TARGET) 

uclean:	vclean
	del /q makefile *.asm *.pl3 ref\*.obj

gitprep: uclean
	..\..\unpack.pl

# auto generated
