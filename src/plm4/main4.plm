main4: DO;
$include(main4.ipx)

declare copyright(*) byte data('(C) 1976, 1977, 1982 INTEL CORP'),
	objEOF(*) byte data(0eh, 1, 0, 0f1h),
	errCont label public;



	sub$3FC8: procedure;
		declare cmd BASED cmdLine$p STRUCTURE(link ADDRESS, pstr(1) BYTE);
		if PRINT then
		do;
			call newPageNextChLst;
			call xputstr2cLst(.('ISIS-II PL/M-80 ',0), 0);
			call xwrnstrLst(.version, 4);
			call xputstr2cLst(.(' COMPILATION OF MODULE ',0), 0);
			curInfo$p = botInfo + procInfo(1);
			curSymbol$p = getSymbol;
			if curSymbol$p <> 0 then
				call xwrnstrLst(.cursym.name(1), cursym.name(0));
			call newLineLst;
			if OBJECT then
			do; 
				call xputstr2cLst(.('OBJECT MODULE PLACED IN ',0), 0);
				call xputstr2cLst(.objFile.fNam, ' ');
			end;
			else
				call xputstr2cLst(.('NO OBJECT MODULE REQUESTED',0), 0);

			call newLineLst;
			if w382A = 1 then
			do;
				call xputstr2cLst(.('COMPILER INVOKED BY:  ',0), 0);
				cmdLine$p = startCmdLine$p;
				do while cmdLine$p <> 0;
					call tabLst(-23);
					call xputstr2cLst(.cmd.pstr(1), cr);
					cmdLine$p = cmd.link;
				end;
				call newLineLst;
			end;
		end;
	end;

	sub$408B: procedure;
		if PRINT then
		do; 
			lBuf$p = .lstbuf;
			lBufSz = 639;
		end;

		call sub$3FC8;
		if .MEMORY + 256 > botMem then
			call fatal(.('COMPILER ERROR: INSUFFICIENT MEMORY FOR FINAL ASSEMBLY'), 54);
		stmtNo = 0;
		if PRINT then
		do;
			srcFileIdx = 0;
			call initF(.srcFil, .('SOURCE'), .srcFileTable(srcFileIdx));
			call openF(.srcFil, 1);
		end;

		call creatF(.tx1File, .tx1buf, 640, 1);
		call creatF(.objFile, .objbuf, 640, 2);
		curInfo$p = procInfo(1) + botInfo;
		baseAddr, rec6$4.addr = getLinkVal;
		call setSkipLst(3);
		call setMarkerInfo(11, '-', 15);
		if fatalErrorCode > 0 then
		do;
			wa8125(2), wa8125(1) = 0;
			wa8125(0) = fatalErrorCode;
			call emitError;
			call setSkipLst(2);
		end;
		listing = PRINT;
		listOff = false;
		codeOn = false;
		programErrCnt, linesRead = 0;
	end;



	sub$4162: procedure;
		declare helpers based helpers$p(1) address;

		if not standAlone then
			return;
		do helperModId = 0 to 45;
			helperId = b42D6(helperModId);
			endHelperId = helperId + b42A8(helperModId);
			do while helperId < endHelperId;
				if helpers(helperId) <> 0 then
				do;
					baseAddr = helpers(helperId);
					b969C = b4304(helperModId);
					b969D = b457C(b969C);
					call sub$5FE7(w4919(helperId), b4A03(helperId));
					goto break;
				end;
				helperId = helperId + 1;
			end;
		break:
		end;
	end sub$4162;

	sub$4208: procedure;
		if haveModule then
		do; 
			rec4.subtype = 1;
			curInfo$p = procInfo(1) + botInfo;
			rec4.addr = getLinkVal;
		end;
		else
		do;
			rec4.subtype = 0;
			rec4.addr = 0;
		end;
		call writeRec(.rec4.type, 0);
	end;


	sub$423C: procedure;
		linesRead = w812F;
		call sub$4208;
		call closeF(.tx1File);
		if OBJECT then
		do;
			call fwrite(.objFile, .objEOF, 4);
			call fflush(.objFile);
			call closeF(.objFile);
		end;

		if PRINT then
		do;
			call tellF(.srcFil, .srcFileTable(srcFileIdx + 8));
			call backup(.srcFileTable(srcFileIdx + 8), olstch - ocurch);
			call closeF(.srcFil);
			call flushLstBuf;
		end;

		call deletF(.tx1File);
	end sub$423C;


	call sub$408B;

	do while bo812B;
		call sub$54BA;
	end;
	call sub$4162;
	call flushRecs;
	call sub$5BD3;
errCont:
	call sub$423C;
	if IXREF then
		call chain(.overlay5);
	if PRINT then
	do;
		if XREF or SYMBOLS then
			call chain(.overlay5);
		else
			call lstModuleInfo;
	end;
	call endCompile;
	call exit;
end;
