main4: DO;
declare lit literally 'literally',
	true lit '0ffh',
	false lit '0',
	cr lit '0dh',
	lf lit '0ah';

$nolist
$include(:f3:data.inc)
declare (helperModId, endHelperId) byte external,
	listing byte external,
	listOff byte external,
	codeOn byte external,
	locLabStr(32) byte external,
	wa8125(3) address external,
	bo812B  byte external,
	baseAddr address external,
	cfCode byte external,
	w812F address external,
	lineNo address external,
	depth address external,
	stmtNo address external,
	olstch address external,
	ocurch address external,
	bo813B byte external,
	bo813C byte external,
	lstLineLen byte external,
	lstLine(130) byte external,
	rec6$4 structure(type byte, len address, seg byte, addr address, val(1018) byte) external,
	rec22 structure(type byte, len address, val(1019) byte) external,
	rec24$1 structure(type byte, len address, val(1019) byte) external,
	rec24$2 structure(type byte, len address, val(101) byte) external,
	rec24$3 structure(type byte, len address, val(101) byte) external,
	rec20 structure(type byte, len address, val(1019) byte) external,
	rec8 structure(type byte, len address, val(1021) byte) external,
	rec4 structure(type byte, len address, subtype byte, seg byte, addr address, crc byte) external,
	b9692 byte external,
	helperId byte external,
	helperStr(1) byte external,
	b969C byte external,
	b969D byte external,
	w969E address external,
	wValAry(4) address external,
	sValAry(4) address external,
	b96B0 byte external,
	b96B1(37) byte external,
	b96D6 byte external,
	w96D7 address external,
	curExtId byte external,
	commentStr(41) byte external,
	lineLen byte external,
	line(80) byte external,
	opByteCnt byte external,
	opBytes(3) byte external,
	dstRec byte external,
	srcbuf(640) byte external,
	tx1buf(640) byte external,
	objbuf(640) byte external,
	lstbuf(640) byte external;


newPageNextChLst: procedure external; end;
newLineLst: procedure external; end;
xputstr2cLst: procedure(str, endch) external; declare str address, endch byte; end;
xwrnstrLst: procedure(str, cnt) external; declare str address, cnt byte; end;
tabLst: procedure(tpos) external; declare tpos byte; end;
$include(:f3:fatal.pex)
$include(:f3:gilnkv.pex)
$include(:f3:gisym.pex)
$include(:f3:openf.pex)
setSkipLst: procedure(lcnt) external; declare lcnt byte; end;
setMarkerInfo: procedure(arg1b, arg2b, arg3b) external; declare (arg1b, arg2b, arg3b) byte; end;
emitError: procedure external; end;
$include(:f3:endcom.pex)
$include(:f3:exit.pex)
$include(:f3:chain.pex)
lstModuleInfo: procedure external; end;
flushRecs: procedure external; end;
sub$5BD3: procedure external; end;
sub$54BA: procedure external; end;
sub$5FE7: procedure(arg1w, arg2b) external; declare arg1w address, arg2b byte; end;
$include(:f3:creatf.pex)
$include(:f3:fflush.pex)
$include(:f3:closef.pex)
$include(:f3:deletf.pex)
$include(:f3:initf.pex)
$include(:f3:fwrite.aex)
$include(:f3:tellf.pex)
$include(:f3:backup.pex)
flushLstBuf: procedure external; end;
writeRec: procedure(rec$p, arg2b) external; declare rec$p address, arg2b byte; end;

declare	b42D6(1) byte external,
	b4304(1) byte external,
	b457C(1) byte external,
	b42A8(1) byte external,
	w4919(1) address external,
	b4A03(1) byte external;

$list
declare copyright(*) byte data('(C) 1976, 1977, 1982 INTEL CORP'),
	objEOF(*) byte data(0eh, 1, 0, 0f1h),
	errCont label public;



	sub$3FC8: procedure;
		declare cmd BASED cmdLine$p STRUCTURE(link ADDRESS, pstr(1) BYTE);
		if PRINT then
		do;
			call newPageNextChLst;
			call xputstr2cLst(.('ISIS-II PL/M-80 ',0), 0);
			call xwrnstrLst(.version, 4);
			call xputstr2cLst(.(' COMPILATION OF MODULE ',0), 0);
			curInfo$p = botInfo + procInfo(1);
			curSymbol$p = getSymbol;
			if curSymbol$p <> 0 then
				call xwrnstrLst(.sym.name(1), sym.name(0));
			call newLineLst;
			if OBJECT then
			do; 
				call xputstr2cLst(.('OBJECT MODULE PLACED IN ',0), 0);
				call xputstr2cLst(.objFile.fNam, ' ');
			end;
			else
				call xputstr2cLst(.('NO OBJECT MODULE REQUESTED',0), 0);

			call newLineLst;
			if w382A = 1 then
			do;
				call xputstr2cLst(.('COMPILER INVOKED BY:  ',0), 0);
				cmdLine$p = startCmdLine$p;
				do while cmdLine$p <> 0;
					call tabLst(-23);
					call xputstr2cLst(.cmd.pstr(1), cr);
					cmdLine$p = cmd.link;
				end;
				call newLineLst;
			end;
		end;
	end;

	sub$408B: procedure;
		if PRINT then
		do; 
			lBuf$p = .lstbuf;
			lBufSz = 639;
		end;

		call sub$3FC8;
		if .MEMORY + 256 > botMem then
			call fatal(.('COMPILER ERROR: INSUFFICIENT MEMORY FOR FINAL ASSEMBLY'), 54);
		stmtNo = 0;
		if PRINT then
		do;
			srcFileIdx = 0;
			call initF(.srcFil, .('SOURCE'), .srcFileTable(srcFileIdx));
			call openF(.srcFil, 1);
		end;

		call creatF(.tx1File, .tx1buf, 640, 1);
		call creatF(.objFile, .objbuf, 640, 2);
		curInfo$p = procInfo(1) + botInfo;
		baseAddr, rec6$4.addr = getLinkVal;
		call setSkipLst(3);
		call setMarkerInfo(11, '-', 15);
		if fatalErrorCode > 0 then
		do;
			wa8125(2), wa8125(1) = 0;
			wa8125(0) = fatalErrorCode;
			call emitError;
			call setSkipLst(2);
		end;
		listing = PRINT;
		listOff = false;
		codeOn = false;
		programErrCnt, linesRead = 0;
	end;



	sub$4162: procedure;
		declare helpers based helpers$p(1) address;

		if not standAlone then
			return;
		do helperModId = 0 to 45;
			helperId = b42D6(helperModId);
			endHelperId = helperId + b42A8(helperModId);
			do while helperId < endHelperId;
				if helpers(helperId) <> 0 then
				do;
					baseAddr = helpers(helperId);
					b969C = b4304(helperModId);
					b969D = b457C(b969C);
					call sub$5FE7(w4919(helperId), b4A03(helperId));
					goto break;
				end;
				helperId = helperId + 1;
			end;
		break:
		end;
	end sub$4162;

	sub$4208: procedure;
		if haveModule then
		do; 
			rec4.subtype = 1;
			curInfo$p = procInfo(1) + botInfo;
			rec4.addr = getLinkVal;
		end;
		else
		do;
			rec4.subtype = 0;
			rec4.addr = 0;
		end;
		call writeRec(.rec4.type, 0);
	end;


	sub$423C: procedure;
		linesRead = w812F;
		call sub$4208;
		call closeF(.tx1File);
		if OBJECT then
		do;
			call fwrite(.objFile, .objEOF, 4);
			call fflush(.objFile);
			call closeF(.objFile);
		end;

		if PRINT then
		do;
			call tellF(.srcFil, .srcFileTable(srcFileIdx + 8));
			call backup(.srcFileTable(srcFileIdx + 8), olstch - ocurch);
			call closeF(.srcFil);
			call flushLstBuf;
		end;

		call deletF(.tx1File);
	end sub$423C;


	call sub$408B;

	do while bo812B;
		call sub$54BA;
	end;
	call sub$4162;
	call flushRecs;
	call sub$5BD3;
errCont:
	call sub$423C;
	if IXREF then
		call chain(.overlay5);
	if PRINT then
	do;
		if XREF or SYMBOLS then
			call chain(.overlay5);
		else
			call lstModuleInfo;
	end;
	call endCompile;
	call exit;
end;
