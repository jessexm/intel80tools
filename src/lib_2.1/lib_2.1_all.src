lib.pex
lit             'literally'
/* user types */
SYMBOL$T        'STRUCTURE(SYMBOL$T1)'
SYMBOL$T1       'link ADDRESS, curCmd ADDRESS, moduleCnt ADDRESS, symbol(1) BYTE'

LIBHDR$T        'STRUCTURE(modCnt ADDRESS, idxBlk ADDRESS, idxByte ADDRESS)'

LIBREC$T        'STRUCTURE(LIBREC$T1,LIBREC$T2)'
LIBREC$T1       'crc BYTE, type BYTE, len ADDRESS, bytesLeft ADDRESS'
LIBREC$T2       'curBlk ADDRESS, curByte ADDRESS, posBlk ADDRESS, posByte ADDRESS'

ARG$T           'STRUCTURE(link ADDRESS, modules ADDRESS, name ADDRESS)'

MODULE$T        'STRUCTURE(MODULE$T1,MODULE$T2)'
MODULE$T1       'link ADDRESS, blk ADDRESS, byt ADDRESS'
MODULE$T2       'found BYTE, name(1) BYTE'

FILE$T          'STRUCTURE(link ADDRESS, path$p ADDRESS, isOpen BYTE, conn BYTE)'

LINE$T          'STRUCTURE(next ADDRESS, len ADDRESS, text(1) BYTE)'

/* ErrorCODES */
ERR2            '2'	/* ILLEGAL AFTN ARGUMENT */
ERR4            '4'	/* INCORRECTLY SPECIFIED FILE */
ERR5            '5'	/* UNRECOGNIZED DEVICE NAME */
ERR6            '6'	/* ATTEMPT TO Write TO INPUT DEVICE */
ERR8            '8'	/* ATTEMPT TO Read FROM OUTPUT DEVICE */
ERR10           '10'	/* NOT ON SAME DISK */
ERR11           '11'	/* FILE ALReadY EXISTS */
ERR12           '12'	/* FILE IS ALReadY Open */
ERR13           '13'	/* NO SUCH FILE */
ERR14           '14'	/* Write PROTECTED */
ERR17           '17'	/* NOT A DISK FILE */
ERR18           '18'	/* ILLEGAL ISIS COMMAND */
ERR19           '19'	/* ATTEMPTED Seek ON NON-DISK FILE */
ERR20           '20'	/* ATTEMPTED BACK Seek TOO FAR */
ERR21           '21'	/* CAN'T RESCAN */
ERR22           '22'	/* ILLEGAL ACCESS MODE TO Open */
ERR23           '23'	/* MISSING FILENAME */
ERR25           '25'	/* ILLEGAL ECHO FILE */
ERR26           '26'	/* ILLEGAL ATTRIBUTE IDENTIFIER */
ERR27           '27'	/* ILLEGAL Seek COMMAND */
ERR28           '28'	/* MISSING EXTENSION */
ERR31           '31'	/* CAN'T Seek ON Write ONLY FILE */
ERR32           '32'	/* CAN'T Delete Open FILE */
ERR35           '35'	/* Seek PAST EOF */
ERR201          '201'	/* UNRECOGNIZED CONTROL */
ERR202          '202'	/* UNRECOGNIZED DELIMITER */
ERR203          '203'	/* INVALID SYNTAX */
ERR204          '204'	/* PREMATURE EOF */
ERR206          '206'	/* ILLEGAL DISKETTE LABEL */
ERR208          '208'	/* CHECKSUM Error */
ERR209          '209'	/* RELO FILE SEQUENCE Error */
ERR210          '210'	/* INSUFFICIENT MEMORY */
ERR211          '211'	/* RECORD TOO LONG */
ERR212          '212'	/* ILLEGAL RELO RECORD */
ERR213          '213'	/* FIXUP BOUNDS Error */
ERR214          '214'	/* ILLEGAL SUBMIT PARAMETER */
ERR215          '215'	/* ARGUMENT TOO LONG */
ERR216          '216'	/* TOO MANY PARAMETERS */
ERR217          '217'	/* OBJECT RECORD TOO SHORT */
ERR218          '218'	/* ILLEGAL RECORD FORMAT */
ERR219          '219'	/* PHASE Error */
ERR220          '220'	/* NO EOF */
ERR221          '221'	/* SEGMENT TOO LARGE */
ERR222          '222'	/* UNRECOGNIZED RECORD TYPE */
ERR223          '223'	/* BAD FIXUP RECORD */
ERR224          '224'	/* BAD RECORD SEQUENCE */
ERR225          '225'	/* INVALID MODULE NAME */
ERR226          '226'	/* MODULE NAME TOO LONG */
ERR227          '227'	/* LEFT PARENTHESIS EXPECTED */
ERR228          '228'	/* RIGHT PARENTHESIS EXPECTED */
ERR229          '229'	/* UNRECOGNIZED CONTROL */
ERR230          '230'	/* DUPLICATE SYMBOL IN INPUT */
ERR232          '232'	/* UNRECOGNIZED COMMAND */
ERR233          '233'	/* 'TO' EXPECTED */
ERR235          '235'	/* NOT LIBRARY */
ERR238          '238'	/* ILLEGAL STACK CONTENT RECORD */
ERR239          '239'	/* NO MODULE HEADER RECORD */
ERR240          '240'	/* PROGRAM EXCEEDS 64K */

/* enum FILEIO */
ReadOnly        '1'
WriteOnly       '2'
ReadWrite       '3'
/* omf records */
OBJHDR          '2'
OBJEND          '4'
OBJDATA         '6'
ENDFILE         '0Eh'
PUBLICS         '16h'
LIBLOC          '26h'
NAMES           '28h'
LIBDICT         '2Ah'
LIBHDR          '2Ch'

/* MISC */
CR              '0dh'
LF              '0ah'

/* ISIS sys codes */
IOpen           '0'
IClose          '1'
IDelete         '2'
IRead           '3'
IWrite          '4'
ISeek           '5'
ILOAD           '6'
IRename         '7'
ICONSOL         '8'
IExit           '9'
IATTRIB         '10'
IRESCAN         '11'
IError          '12'
IWHOCON         '13'
ISPATH          '14'

$file(isis1.plm)
Close           P(A conn,A status$p)
Delete          P(A path$p,A status$p)
Error           P(A Error$num)
Exit            P

$file(isis2.plm)
Open            P(A conn$p,A path$p,A access,A echo,A status$p)
Read            P(A conn,A buff$p,A count,A actual$p,A status$p)
Rename          P(A old$p,A new$p,A status$p)
Seek            P(A conn,A mode,A block$p,A byte$p,A status$p)
Write           P(A conn,A buff$p,A count,A status$p)

$file(isisa.asm)
isis            P(B type,A parameter$ptr)
memck           PA

$file(lib.plm)
actual          A
argFilename     A
HashTable       AS
inConn          A
reset           L
status          A
FinaliseLib     P(A buf)
LookupModule    PB
arg             "ARG$T"..argChain
file            "FILE$T"..file$p
module          "MODULE$T"..module$p
token           BS..token$p

$file(lib1.plm)
curLine$p       A
curRec          "LIBREC$T"
fileHead        A
file$p          A
heapTop         A
inModuleList    B
lookAheadLen    B
lookAhead$p     A
memTop          A
savedRec        "LIBREC$T"
token$p         A
tokLen          B
AcceptRecord    P(B type)
AllocDown       P(A cnt)A
AllocUp         P(A cnt)A
CloseFile       P(A conn,A status$p)
DeleteFile      P(A path$p,A status$p)
Fatal           P(B err)
FileStatusChk   P(A errCode,A path$p,B isFatal)
GetCmd          P
GetName         P(A buf)
GetRecordBytes  P(A count,A buf$p)
GetToken        P
Hash            P(A pstr)B
IllegalRecord   P
LibError        P(B err)
LibSeek         P(B mode$b,A blkByte$p)
Log             P(A buf,A cnt)
LogCrLf         P(A buf,A cnt)
LookupSymbol    P(A modName$p,A Hash$p)B
MatchLookAhead  P(A cha$p,B len)B
MatchToken      P(A cha$p,B len)B
OpenFile        P(A conn$p,A path$p,A access,A echo,A status$p)
OpenLib         P
PrepRecord      P
ReadChkCrc      P
ReadFile        P(A conn,A buff$p,A count,A actual$p,A status$p)
RenameFile      P(A old$p,A new$p,A status$p)
RestoreCurPos   P
SaveCurPos      P
SeekFile        P(A conn,A mode,A block$p,A byte$p,A status$p)
SkipCurRec      P
SkipModule      P
SwapCurSavedRec P
WriteErrStr     P(A errCode)
WriteFile       P(A conn,A buff$p,A count,A status$p)

$file(lib3.plm)
PastFileName    P(A ch$p)A
SkipSpc         P(A ch$p)A

$file(lib4.plm)
BinAsc          P(A num,B base,B padch,A cha$p,B width)
lib.plm

LIB: DO;
$include(lib.ipx)

DECLARE
	actual		ADDRESS PUBLIC,
	status		ADDRESS PUBLIC,
	outConn	ADDRESS,
	libOutFile	ADDRESS,
	inConn		ADDRESS PUBLIC,
	argFilename	ADDRESS PUBLIC,
	argHead		ADDRESS,
	argChain	ADDRESS,
	moduleHead	ADDRESS,
	module$p	ADDRESS;

DECLARE HashTable(128) ADDRESS PUBLIC,
	Hashptr	ADDRESS,	/* probably Hash item */
	junk1 ADDRESS INITIAL(0),
	junk2(4)	BYTE,
	libModuleCnt ADDRESS,
	addCnt BYTE,
	moduleName(33) BYTE,
	zeroBlk ADDRESS INITIAL(0),
	zeroByte ADDRESS INITIAL(0),
	junk3 ADDRESS INITIAL(10),
	one ADDRESS INITIAL(1),
	copyBuf(1028) BYTE,
	recBlk ADDRESS,
	recByt	ADDRESS,
	outCRC	BYTE,
	outRecLen ADDRESS;

DECLARE
	copyright(*) BYTE DATA ('(C) 1976, 1977 INTEL CORP'),
	aIsisIiLibraria(*) BYTE DATA ('ISIS-II LIBRARIAN V2.1', CR, LF),
	aNotFound(*) BYTE DATA ('): NOT FOUND'),
	aPublicSymbolAl(*) BYTE DATA (' - PUBLIC SYMBOL ALREADY IN LIBRARY'),
	initLibContent(*) BYTE DATA (LIBHDR, 7, 0, 0, 0, 0, 0, 0Ah, 0, 0C3h,
				     NAMES, 1, 0, 0D7h,
				     LIBLOC, 1, 0, 0D9h,
				     LIBDICT, 1, 0, 0D5h,
				     ENDFILE, 1, 0, 0F1h);


/* override the correct defintion for this file */
WriteErrStr: PROCEDURE(errCode) EXTERNAL; DECLARE errCode BYTE; end;

DECLARE token based token$p(1) BYTE;
DECLARE file BASED file$p FILE$T;
DECLARE arg BASED argChain ARG$T;
/* explicit based as base var is defined after include */
DECLARE module BASED module$p MODULE$T;
DECLARE reset LABEL PUBLIC;


WriteBuf: PROCEDURE(count, buf$p);
	DECLARE (count, buf$p) ADDRESS;
	DECLARE i ADDRESS;
	DECLARE buf BASED buf$p(1) BYTE;
	call WriteFile(outConn, buf$p, count, .status);
	count = count - 1;	/* adjust for 0 based offset */
	do i = 0 to count;
		outCRC = outCRC + buf(i);
	end;
	outRecLen = outRecLen + 1 + count;
end WriteBuf;

OutRecInit: PROCEDURE(recLen);
	DECLARE recLen ADDRESS;
	outCRC = 0;
	/* record where start of record is */
	call SeekFile(outConn, 0, .recBlk, .recByt, .status);
	/* Write type and length */
	call WriteBuf(1, .curRec.type);
	call WriteBuf(2, .recLen);
	outRecLen = 1;
end;


WriteName: PROCEDURE(name$p);
	DECLARE name$p address;
	DECLARE name BASED name$p(1) BYTE;

	call WriteBuf(name(0) + 1, name$p);
end;

WriteCRC: PROCEDURE;
	outCRC = -outCRC;
	call WriteFile(outConn, .outCRC, 1, .status);
end;


FixupLen: PROCEDURE;
	DECLARE (savblk, savbyt) ADDRESS;

	call SeekFile(outConn, 0, .savblk, .savbyt, .status);	/* where we are */
	call SeekFile(outConn, 2, .recBlk, .recByt, .status);	/* start of record */
	call SeekFile(outConn, 3, .zeroByte, .one, .status);	/* offset of length */
	call WriteBuf(2, .outRecLen);				/* the 2 byte length */
	call SeekFile(outConn, 2, .savblk, .savbyt, .status);	/* back to where we were */
end;

DECLARE lib$tmp(*) BYTE INITIAL(':  :LIB.TMP ');

CreateTmpFile: PROCEDURE(path$p);
	DECLARE path$p ADDRESS;
	DECLARE path BASED path$p(1) BYTE;

	lib$tmp(1) = 'F';	/* assume temp is on F0 */
	lib$tmp(2) = '0';
	path$p = SkipSpc(path$p);
	if path(0) = ':' then
	do;
		lib$tmp(1) = path(1);
		lib$tmp(2) = path(2);
	end;
	libOutFile = .lib$tmp;
	call Delete(.lib$tmp, .status);
	call OpenFile(.outConn, .lib$tmp, 3, 0, .status);
end;



ReplaceLib: PROCEDURE(path$p);
	DECLARE path$p ADDRESS;
	
	call CloseFile(outConn, .status);
	call CloseFile(inConn, .status);
	call DeleteFile(path$p, .status);
	call RenameFile(libOutFile, path$p, .status);
end;


ModNotFound: PROCEDURE;
	DECLARE s ADDRESS;
	DECLARE module BASED module$p MODULE$T;
	DECLARE arg BASED argChain ARG$T;

	s = arg.name;
	call Log(.('  '), 2);	/* "  " */
	call Log(s, PastFileName(SkipSpc(s)) - s);	/* emit the file name */
	call Log(.('('), 1);	/* ( */
	call Log(.module.name(1), module.name(0));	/* and the module name */
	call LogCrLf(.aNotFound, 12); /* ): NOT FOUND */
end;


LookupModule: PROCEDURE BYTE PUBLIC;
	DECLARE (i, found) BYTE;
	DECLARE module BASED module$p MODULE$T;
	DECLARE module$a BASED module$p(1) BYTE;
	DECLARE arg BASED argChain ARG$T;

	found = 0;
	module$p = .arg.modules;	/* chase down the list of modules requested */
	do while module.link <> 0;
 
		module$p = module.link;
		found = 0FFH;		/* assume found */
	
		/* compare names */	
		do i = 0 to moduleName(0);
			if moduleName(i) <> module$a((i + 8) - 1) THEN
				found = 0;
		end;
		if found then
			return found;
	end;
	return found;
end;




ChainModules: PROCEDURE;
	moduleHead = 0;
	module$p = .moduleHead;
	argChain = .argHead;

	do while arg.link <> 0;
		argChain = arg.link;
		module.link = arg.modules;
		/* Seek to the end of the module list */
		do while module.link <> 0;
			module$p = module.link;
		end;
	end;
end;


GetFileAndModuleNames: PROCEDURE;
	DECLARE arg BASED argChain ARG$T;
	DECLARE lookAhead BASED lookAhead$p(1) BYTE;
	DECLARE token BASED token$p(1) BYTE;
	DECLARE module BASED module$p MODULE$T;
	DECLARE module$a BASED module$p(1) BYTE;
	DECLARE i BYTE;

	call GetToken;
	/* add another arg entry to the chain */
	arg.link = AllocUp(6);
	argChain = arg.link;
	arg.link = 0;
	module$p = .arg.modules;
	arg.name = token$p;
	if lookAhead(0) = '(' then	/* add the list of modules if present */
	do;
		inModuleList = 0FFH;
		call GetToken;

		do while token(0) = '(' or token(0) = ',';
			inModuleList = 0;	/* alReady seen the file name, so we should get ( , or ) */
			call GetToken;
			inModuleList = 0FFH;	/* assume we are going to get another module */
			module.link = AllocUp(tokLen + 8);
			module$p = module.link;
			module.link = 0;
			module.found = 0;
			module.name(0) = tokLen;
			/* add the module name */
			do i = 0 to tokLen - 1;
				module$a(8+i) = token(i); 	
			end;
			call GetToken;
		end;
		if token(0) <> ')' then
			call LibError(ERR228);	/* RIGHT PARENTHESIS EXPECTED */
	end;
	module.link = 0;	
	inModuleList = 0;
end;


GetXField: PROCEDURE ADDRESS;
	DECLARE b BYTE;
	call GetRecordBytes(1, .b);
	return .b;
end;	


XFieldSize: PROCEDURE(arg1) ADDRESS;
	DECLARE arg1 ADDRESS;
	return 1;
end;


Sub3C80: PROCEDURE(arg1w, arg2w) BYTE;
	DECLARE (arg1w, arg2w) ADDRESS;
	DECLARE b1 BASED arg1w BYTE;
	DECLARE b2 BASED arg2w BYTE;

	return b1 = b2;
end;



Sub3C98: PROCEDURE(arg1w, arg2w);
	DECLARE (arg1w, arg2w) ADDRESS;
	DECLARE b1 BASED arg1w BYTE;
	DECLARE b2 BASED arg2w BYTE;
	b2 = b1;
end;


Sub3CAD: PROCEDURE(arg1w);
	DECLARE arg1w ADDRESS;
	call WriteBuf(1, arg1w);
end;

CopyRestRec: PROCEDURE;
	DECLARE cnt ADDRESS;
	do while curRec.bytesLeft > 1;
		if curRec.bytesLeft > 1028 then
			cnt = 1028;
		else
			cnt = curRec.bytesLeft - 1;
		call GetRecordBytes(cnt, .copyBuf);
		call WriteBuf(cnt, .copyBuf);
	end;
	call ReadChkCrc;
	call WriteCRC;
end;


AddModule: PROCEDURE(addName);
	DECLARE addName BYTE;
	DECLARE module BASED module$p MODULE$T;
	DECLARE xfield ADDRESS, offset ADDRESS, tmpByte BYTE, objNameLen BYTE;
	DECLARE junk(4) BYTE;	/* safety net for GetRecordBytes */
	DECLARE symbol BASED Hashptr SYMBOL$T;
	DECLARE symbol$a BASED Hashptr(1) BYTE;

	addCnt = addCnt + 1;
	call OutRecInit(curRec.len);
	call GetRecordBytes(1, .objNameLen);
	if addName then
	do;
		/* get to the end of the current list of modules */
		do while module.link <> 0;
			module$p = module.link;
		end;

		module.link = AllocUp(objNameLen + 8);
		module$p = module.link;
		module.link = 0;
		module.found = 0FFh;
	end;

	/* record location */
	module.blk = recBlk;
	module.byt = recByt;
	/* set the name */
	module.name(0) = objNameLen;
	call GetRecordBytes(objNameLen, .module.name(1));
	call WriteBuf(objNameLen + 1, .module.name);
	/* copy the header to the new file */
	call CopyRestRec;
	call PrepRecord;

	do while curRec.type <> OBJEND;	/* loop over all of this module */
		call OutRecInit(curRec.len);
		if  curRec.Type = PUBLICS  then
		do;
			call GetRecordBytes(1, .tmpByte);	/* copy segid */
			call WriteBuf(1, .tmpByte);

			do while curRec.bytesLeft > 1;
				call GetRecordBytes(2, .offset); /* symbol entry offset */
				call GetName(.moduleName);
				xfield = GetXField;
				/* check for duplicate public symbols */
				if LookupSymbol(.moduleName, .Hashptr) then
					call Fatal(ERR230);	/* DUPLICATE SYMBOL IN INPUT */

				/* create the symbol entry */
				symbol.link =  AllocUp(moduleName(0) + 7);	/* sizeof symbol entry */
				HashPtr = symbol.link;
				symbol.link = 0;
				symbol.curCmd = argFilename;
				symbol.moduleCnt = libModuleCnt;
				do objNameLen = 0 to moduleName(0);
					symbol$a(6+objNameLen) = moduleName(objNameLen);	
				end;

				/* Write the offset, name and xfield */
				call WriteBuf(2, .offset);
				call WriteBuf(moduleName(0)+1, .moduleName);
				call WriteBuf(XFieldSize(xfield), xfield);
			end;
		end;
		/* copy the rest of the record and prep for the next loop */
		call CopyRestRec;
		call PrepRecord;
	end;	/* of while */
	
	/* copy the objend record */
	call OutRecInit(curRec.len);
	call CopyRestRec;
	/* keep tally for the new library */
	libModuleCnt = libModuleCnt + 1;
end;


FinaliseLib: PROCEDURE(buf) PUBLIC;
	DECLARE buf ADDRESS;
	/* Write the end of file marker */
	curRec.type = ENDFILE;
	call OutRecInit(1);
	call WriteCRC;
	/* rewind the output file */
	call SeekFile(outConn, 2, .zeroByte, .zeroByte, .status);
	call LibSeek(2, .zeroBlk);	/* rewind the input */
	call PrepRecord;		/* pick up the original lib header */
	call OutRecInit(curRec.len);	/* Write the start out */
	call WriteBuf(2, .libModuleCnt); /* Write the module count */
	call WriteBuf(4, buf);		/* Write the module offset */
	call WriteCRC;			/* and CRC */
end;


AddCmd:	PROCEDURE;
	DECLARE lookAhead BASED lookAhead$p(1) BYTE;
	DECLARE HashItem BASED Hashptr SYMBOL$T;
	DECLARE module$a BASED module$p(1) BYTE;

	DECLARE blkIdx		ADDRESS,
		byteIdx		ADDRESS,
		addLibHdr	LIBHDR$T,
		oldLibHdr 	LIBHDR$T,
		inLibConn 	ADDRESS,
		junk1		ADDRESS,
		j 	ADDRESS,
		libFileName	ADDRESS,
		junk2		ADDRESS,
		chunk		BYTE,
		found	BYTE;

	/* utility procedure to copy data from in to out */
	CopyFileBytes: PROCEDURE(cnt);
		DECLARE cnt ADDRESS;

		call ReadFile(inConn, .copyBuf, cnt, .actual, .status);
		if actual < cnt then
			call Fatal(ERR204);	/* PREMATURE EOF */

		call WriteFile(outConn, .copyBuf, cnt, .status);
	end;

	DECLARE i	BYTE,
		nameIdx	ADDRESS,
		addBlk	ADDRESS,
		addByt	ADDRESS,
		junk3(4)	BYTE,
		locFields(4)	BYTE,	/* used to copy the location data over */
		group	ADDRESS,
		k	BYTE,
		n	ADDRESS;



	call GetFileAndModuleNames;

	/* loop if more */
	do while lookAhead(0) = ',';
		call GetToken;
		call GetFileAndModuleNames;
	end;

	/* need a TO */
	if not MatchLookAhead(.('TO'),2) THEN	/* "TO" */
		call LibError(ERR233);	/* 'TO' EXPECTED */

	call GetToken;	/* waste the TO */
	libFileName = lookAhead$p;	/* pick up filename to create */
	call GetToken;
	if lookAhead(0) <> CR then	/* check this is the end */
		call LibError(ERR203);	/* INVALID SYNTAX */

	call CreateTmpFile(libFileName);
	/* Open the existing file */
	call OpenFile(.inLibConn, libFileName, ReadOnly, 0, .status);
	inConn = inLibConn;
	argFilename = libFileName;
	curRec.bytesLeft = 0;
	call AcceptRecord(LIBHDR);
	call GetRecordBytes(6, .oldLibHdr);
	call ReadChkCrc;
	libModuleCnt = oldLibHdr.modCnt;
	blkIdx, byteIdx = 0;
	call LibSeek(2, .zeroBlk);	/* rewind */
	/*
	   copy all the existing module over i.e. until the NAMES record
	   the algorithm copies up to 1024 bytes at a time shrinking to smaller
	   blocks if there are less bytes
	*/
	chunk = 8;
	do while chunk > 0;		/* continue while there are blocks */
		if oldLibHdr.idxBlk - blkIdx >= chunk then
		do;
			call CopyFileBytes(chunk * 128);
			blkIdx = blkIdx + chunk;
		end;
		else
			chunk = shr(chunk,1);	/* shrink the chunk size */
	end;

	call CopyFileBytes(oldLibHdr.idxByte); /* copy remaining bytes */

	call AcceptRecord(NAMES);
	addCnt = 0;

	/* scan all of the files to add */
	argChain = .argHead;
	do while arg.link <> 0;
		argChain = arg.link;
		argFilename = arg.name;
		call OpenLib;
		call PrepRecord;
		if curRec.type = LIBHDR then	/* library to add? */
		do;
			call GetRecordBytes(6, .addLibHdr);	/* load the 'add file' module header */
			call ReadChkCrc;	/* check ok */
			if arg.modules = 0 then /* adding all of the library */
			do;
				module$p = .arg.modules;
				call PrepRecord;
				do while curRec.type = OBJHDR;
					call AddModule(0FFh);
					call PrepRecord;
				end;
			end;
			else
			do;
				nameIdx = 0;
				/* find the names record */
				call LibSeek(2, .addLibHdr.idxBlk);
				call AcceptRecord(NAMES);

				do while curRec.bytesLeft > 1;	/* process the names record */
					call GetName(.moduleName);
					
					found = 0;
					module$p = .arg.modules;
					do while module.link <> 0 and not found;
						found = 0FFh;
						module$p = module.link;
						do i = 0 to moduleName(0);
							if moduleName(i) <> module$a(8 + i - 1) then
								found = 0;
						end;
						module.found = module.found or found;
					end;

					if found then	/* record the index into the locations */
						module.blk = nameIdx;
					nameIdx = nameIdx + 1;
				end;

				call AcceptRecord(LIBLOC);
				call SaveCurPos;	/* position of the locations block/byte number */
				module$p = .arg.modules;

				do while module.link <> 0;
					module$p = module.link;
					if not module.found then
						call ModNotFound;
					else
					do;
						/* convert the name index into a block / byte offset */
						addByt = module.blk * 4;
						addBlk = shl(shr(module.blk, 14), 9);
						call RestoreCurPos;	/* get to start of locations */
						call LibSeek(3, .addBlk);	/* index into them */
						call GetRecordBytes(4, .module.blk);	/* set the real block/byte */
					end;
				end;

				/* scan over the modules */
				module$p = .arg.modules;
				do while module.link <> 0;
					module$p = module.link;
					if module.found then
					do;
						/* locate the OBJHDR */
						call LibSeek(2, .module.blk);
						call AcceptRecord(OBJHDR);
						call AddModule(0);
					end;
				end;
			end;
		end;
		else if curRec.type = OBJHDR then	/* standard object file to add */
		do;
			if arg.modules <> 0 then	/* user thought it was a library */
				call Fatal(ERR235);	/* NOT LIBRARY */

			module$p = .arg.modules;

			do while curRec.type = OBJHDR;
				call AddModule(0FFh);
				call PrepRecord;
			end;
			if curRec.type <> ENDFILE then
				call Fatal(ERR224);	/* BAD RECORD SEQUENCE */
		end;
		else
			call Fatal(ERR224);	/* BAD RECORD SEQUENCE */

		call CloseFile(inConn, .status);
	end;

	call ChainModules;
	inConn = inLibConn;
	argFilename = libFileName;
	curRec.bytesLeft = 0;
	/* locate the old library NAMES record */
	call LibSeek(2, .oldLibHdr.idxBlk);
	call AcceptRecord(NAMES);
	call OutRecInit(0);

	/* Read in the names */
	do while curRec.bytesLeft > 1;
		call GetName(.moduleName);
		call WriteBuf(moduleName(0) + 1, .moduleName);
		module$p = .moduleHead;
		/* check there is not a duplicate module */
		do while module.link <> 0;
			module$p = module.link;
			do j = 0 to moduleName(0);
				if moduleName(j) <> module$a((j + 8) - 1) then
					goto outerloop;
			end;
			call Log(.moduleName(1), moduleName(0));
			call LogCrLf(.(' - ATTEMPT TO ADD DUPLICATE MODULE NAME'), 22h);
			goto reset;
	outerloop:
		end;
	end;

	/* scan the modules end emit all of the module names needed */

	module$p = .moduleHead;

	do while module.link <> 0;
		module$p = module.link;
		if module.found then
			call WriteBuf(module.name(0) + 1, .module.name);
	end;

	call FixupLen;	/* fix the names record length & Write CRC */
	call WriteCRC;
	/* record in the header where the NAMES record is located */
	oldLibHdr.idxBlk = recBlk;
	oldLibHdr.idxByte = recByt;
	/* prep the lib locations record */
	call AcceptRecord(LIBLOC);
	call OutRecInit(libModuleCnt * 4 + 1);

	/* copy the original library locations information over */
	do while curRec.bytesLeft > 1;
		call GetRecordBytes(4, .locFields);
		call WriteBuf(4, .locFields);
	end;

	/* now add the new locations */
	module$p = .moduleHead;

	do while module.link <> 0;
		module$p = module.link;
		if module.found then
			call WriteBuf(4, .module.blk);

	end;

	call WriteCRC;

	call AcceptRecord(LIBDICT);
	call OutRecInit(0);

	/* copy the existing dictionary checking that the new publics added don't
	   alReady exist
	*/
	do while curRec.bytesLeft > 1;
		call GetName(.moduleName);
		if moduleName(0) = 0 then
			group = group + 1;
		else if LookupSymbol(.moduleName, .Hashptr) then
		do;
			call Log(.moduleName(1), moduleName(0));
			call LogCrLf(.aPublicSymbolAl, 23h);
			goto reset;
		end;

		call WriteName(.moduleName);
	end;

	/* if there are modules then add any new ones */
	if libModuleCnt <> 0 then
		do n = oldLibHdr.modCnt to libModuleCnt - 1;
			/* search the Hashtable */
			do k = 0 to 127;
				Hashptr = .HashTable(k);
				do while HashItem.link <> 0;
					Hashptr = HashItem.link;
					/* is this the correct module number */
					if HashItem.moduleCnt = n then
						call WriteBuf(HashItem.symbol(0) + 1, .HashItem.symbol);
				end;
			end;
			/* Write the module separator */
			call WriteBuf(1, .zeroByte);
		end;

	call SkipCurRec; /* ignore the rest of the LIBDICT in the original */
	call FixupLen;	/* fixup the LIBDICT len */
	call WriteCRC;	/* and make the CRC work */
	call FinaliseLib(.oldLibHdr.idxBlk);
	call ReplaceLib(libFileName);
end;




DeleteCmd: PROCEDURE;
	DECLARE lookAhead BASED lookAhead$p(1) BYTE;
	DECLARE tmpLibHdr LIBHDR$T, junk$6429 ADDRESS,
		nothingToDelete BYTE, (junk$642C, delmod$p) ADDRESS;
	DECLARE modules BASED module$p MODULE$T;
	DECLARE delmod BASED delmod$p MODULE$T;	/* actually on start of structure */


	call GetFileAndModuleNames;
	if lookAhead(0) <> CR then
		call LibError(ERR203);	/* INVALID SYNTAX */

	if arg.modules = 0 then		/* nothing to do !! */
		call LibError(ERR203);	/* INVALID SYNTAX */

	argFilename = arg.name;
	call OpenLib;
	call AcceptRecord(LIBHDR);
	call GetRecordBytes(6, .tmpLibHdr);	/* Read in the existing header */
	call ReadChkCrc;			/* check not corrupt */
	call LibSeek(2, .tmpLibHdr.idxBlk);	/* Seek to names module */
	call AcceptRecord(NAMES);

	delmod$p = .moduleHead;
	do while curRec.bytesLeft > 1;		/* pull in all the names */
		call GetName(.moduleName);
		delmod.link = AllocUp(7);		/* allocate a module entry */
		delmod$p = delmod.link;
		if (delmod.found := LookupModule) then	/* set the flag is this is one to Delete */
			module.found = 0FFH;		/* and flagged as found in the user list */
		else
			libModuleCnt = libModuleCnt + 1;

	end;
	delmod.link = 0;
	call ReadChkCrc;		/* check for good OMF */

	nothingToDelete = 0FFh;
	module$p = .arg.modules;

	do while modules.link <> 0;	/* check we found at least one of the user's modules */
		module$p = module.link;
		if not modules.found then
			call ModNotFound;
		else
			nothingToDelete = 0;
	end;

	if nothingToDelete then
		goto reset;

	call CreateTmpFile(argFilename);
	call LibSeek(2, .zeroBlk);	/* rewind library */
	call AcceptRecord(LIBHDR);
	call OutRecInit(curRec.len);	/* Write the LIBHDR type and record length */
	call CopyRestRec;		/* copy the rest of the record */

	/* copy the objmodules unless Delete requested */
	delmod$p = .moduleHead;
	do while delmod.link <> 0;
		delmod$p = delmod.link;
		call AcceptRecord(OBJHDR);
		if delmod.found then	/* one to Delete */
			call SkipModule;
		else			
		do;			/* record where this module is going */
			call SeekFile(outConn, 0, .delmod.blk, .delmod.byt, .status);

			/* copy until we get an end of module */
			do while curRec.type <> OBJEND;
				call OutRecInit(curRec.len);
				call CopyRestRec;
				call PrepRecord;
			end;
			/* copy the OBJEND record */
			call OutRecInit(curRec.len);
			call CopyRestRec;
		end;
	end;

	/* copy only the none Deleted NAME record entries */
	delmod$p = .moduleHead;
	call AcceptRecord(NAMES);
	call OutRecInit(0);

	do while delmod.link <> 0;
		delmod$p = delmod.link;
		call GetName(.moduleName);
		if not delmod.found then
			call WriteName(.moduleName);
	end;

	call FixupLen;
	call WriteCRC;
	tmpLibHdr.idxBlk = recBlk;	/* save where the NAMES record is */
	tmpLibHdr.idxByte = recByt;

	/* scan included modules writing the locations */
	delmod$p = .moduleHead;
	call AcceptRecord(LIBLOC);
	call OutRecInit(0);

	do while delmod.link <> 0;
		delmod$p = delmod.link;
		if not delmod.found then
			call WriteBuf(4, .delmod.blk);
	end;

	call FixupLen;
	call WriteCRC;

	/* scan included modules writing the dictionary */
	delmod$p = .moduleHead;
	call AcceptRecord(LIBDICT);
	call OutRecInit(0);

	do while delmod.link <> 0;
		delmod$p = delmod.link;
		call GetName(.moduleName);
		
		do while moduleName(0) <> 0;	/* copy the module names if needed */
			if not delmod.found then
				call WriteName(.moduleName);

			call GetName(.moduleName);
		end;

		/* terminate with a 0 if the group is included */
		if not delmod.found then
			call WriteBuf(1, .zeroByte);

	end;

	call FixupLen;
	call WriteCRC;
	call FinaliseLib(.tmpLibHdr.idxBlk);	/* endfile & header update */
	call ReplaceLib(argFilename);		/* replace the library */
end;


CreateCmd: PROCEDURE;
	DECLARE lookAhead BASED lookAhead$p(1) BYTE;

	call GetToken;
	if lookAhead(0) <> CR then		/* should have no other data */
		call LibError(ERR203);	/* INVALID SYNTAX */

	argFilename = token$p;	/* try to Open library */
	call Open(.inConn, argFilename, ReadOnly, 0, .status);
	if status = 0 then	/* if no Error then alReady exists so Error */
	do;
		call CloseFile(inConn, .status);
		call FileStatusChk(0E7h, argFilename, 0FFh);	/* Error 231 not defined !!! */
								/* should be FILE ALReadY EXISTS */
	end;
	call CloseFile(inConn, .status);
	call OpenFile(.outConn, argFilename, WriteOnly, 0, .status);
	/* initialise with a minimal content */
	call WriteFile(outConn, .initLibContent, 26, .status);
	call CloseFile(outConn, .status);
end;



ListCmd: PROCEDURE;
	DECLARE arg BASED argChain ARG$T;
	DECLARE token BASED token$p(1) BYTE;
	DECLARE lookAhead BASED lookAhead$p(1) BYTE;

	DECLARE listPublics	BYTE,
		listThisModule	BYTE,
		newLibHdr	LIBHDR$T;

	OutName: PROCEDURE(leadSpaces,name$p);
		DECLARE leadSpaces BYTE, name$p ADDRESS;
		DECLARE len BASED name$p BYTE;

		call WriteFile(outConn, .('      '), leadSpaces, .status);
		call WriteFile(outConn, name$p + 1, len, .status);
		call WriteFile(outConn, .(CR, LF), 2, .status);	/* crlf */
	end;


	/* collect the users list of libraries */
	call GetFileAndModuleNames;		/* add the name to the chain and get any module list */
	do while lookAhead(0) = ',';
		call GetToken;
		call GetFileAndModuleNames;
	end;

	libOutFile = .(':CO: ');		/* assume console output */
	if MatchLookAhead(.('TO'), 2) then
	do;
		call GetToken; 	/* get the filename  to lookAhead */
		call GetToken; 	/* and again to get to token */
		libOutFile = token$p;
	end;

	call GetToken;	/* lookAhead to token */
	if (listPublics := MatchToken(.('PUBLICS'), 7)) then
		call GetToken;

	if token(0) <> CR then	/* should be it */
		call LibError(ERR203);	/* INVALID SYNTAX */

	call OpenFile(.outConn, libOutFile, 2, 0, .status);
	argChain = .argHead;

	do while ((argChain := arg.link) <> 0);	/* loop through the files */
		argFilename = arg.name;
		call OpenLib;
		/* header line "  file\n\n" */
		call WriteFile(outConn, .('  '), 2, .status);
		call WriteFile(outConn, argFilename, PastFileName(argFilename) - argFilename, .status);
		call WriteFile(outConn, .(CR, LF), 2, .status);

		call AcceptRecord(LIBHDR);
		call GetRecordBytes(6, .newLibHdr);	/* Read module count, block number and byte number */
		call ReadChkCrc;			/* check not corrupt */
		call LibSeek(2, .newLibHdr.idxBlk);	/* Seek to the names */
		call AcceptRecord(NAMES);		/* check we get the names */
		if listPublics then
		do;
			call SaveCurPos;		/* save where we are */
			call AcceptRecord(LIBLOC);	/* check locations and dictionary exist */
			call AcceptRecord(LIBDICT);
			call SwapCurSavedRec;
		end;

		do while curRec.bytesLeft > 1;		/* scan the names until the CRC */
			call GetName(.moduleName);	/* get the name */
			if arg.modules = 0 then		/* listing all ? */
				listThisModule = 0FFH;
			else
				listThisModule = LookupModule;	/* no so check if needed */

			if listThisModule then		/* list name with 4 leading spaces */
				call OutName(4, .moduleName);

			if listPublics then
			do;
				call SwapCurSavedRec;	/* get to dictionary current location*/
				call GetName(.moduleName);

				do while moduleName(0) <> 0;	/* scan the names until the end of the group */
					if listThisModule then	/* emit name with 6 leading spaces if required */
						call OutName(6, .moduleName);

					call GetName(.moduleName);
				end;
				call SwapCurSavedRec;	/* back to where we were and save the current dictionary location */
			end;
		end;
		call CloseFile(inConn, .status);	/* Close the library */
	end;
	/* Close the listing file */
	call CloseFile(outConn, .status);
end;



DECLARE i BYTE;

start:
		call Write(0, .aIsisIiLibraria, 24, .status);
		call Read(1, .MEMORY, 122, .actual, .status); 	/* flush cmdline */

		goto main;


reset:	
		file$p = .fileHead;

		do while ((file$p := file.link) <> 0);
			if file.isOpen then
				call Close(file.conn, .status);
		end;

main:
	do while(1);
		libModuleCnt = 0;		/* reset key vars and memory usage */
		heapTop = .MEMORY;
		memTop = memCk;
		file$p = .fileHead;
		file.link = 0;
		argChain = .argHead;
		arg.link = 0;
		moduleHead = 0;
		module$p = .moduleHead;
		do i = 0 to 127;
			HashTable(i) = 0;
		end;

		call Write(0, .('*'), 1, .status);
		call GetCmd;
		if MatchToken(.('EXIT'), 4) then
			call Exit;
		else if MatchToken(.('ADD'), 3) then
			call AddCmd;
		else if MatchToken(.('CREATE'), 6) then
			call CreateCmd;
		else if MatchToken(.('LIST'), 4) then
			call ListCmd;
		else if MatchToken(.('DELETE'), 6) then
			call DeleteCmd;
		else if token(0) = CR then
			;
		else
			call WriteErrStr(ERR232);	/* UNRECOGNIZED COMMAND */
	end;

end;

lib1.plm

lib1: DO;
$include(lib1.ipx)

DECLARE errstrs(*) BYTE DATA(
	0,0,
	2,'ILLEGAL AFTN ARGUMENT',0,
	4,'INCORRECTLY SPECIFIED FILE',0,
	5,'UNRECOGNIZED DEVICE NAME',0,
	6,'ATTEMPT TO WRITE TO INPUT DEVICE',0,
	8,'ATTEMPT TO READ FROM OUTPUT DEVICE',0,
	10,'NOT ON SAME DISK',0,
	11,'FILE ALREADY EXISTS',0,
	12,'FILE IS ALREADY OPEN',0,
	13,'NO SUCH FILE',0,
	14,'WRITE PROTECTED',0,
	17,'NOT A DISK FILE',0,
	18,'ILLEGAL ISIS COMMAND',0,
	19,'ATTEMPTED SEEK ON NON-DISK FILE',0,
	20,'ATTEMPTED BACK SEEK TOO FAR',0,
	21,'CAN''T RESCAN',0,
	22,'ILLEGAL ACCESS MODE TO OPEN',0,
	23,'MISSING FILENAME',0,
	25,'ILLEGAL ECHO FILE',0,
	26,'ILLEGAL ATTRIBUTE IDENTIFIER',0,
	27,'ILLEGAL SEEK COMMAND',0,
	28,'MISSING EXTENSION',0,
	31,'CAN''T SEEK ON WRITE ONLY FILE',0,
	32,'CAN''T DELETE OPEN FILE',0,
	35,'SEEK PAST EOF',0,
	201,'UNRECOGNIZED CONTROL',0,
	202,'UNRECOGNIZED DELIMITER',0,
	203,'INVALID SYNTAX',0,
	204,'PREMATURE EOF',0,
	206,'ILLEGAL DISKETTE LABEL',0,
	208,'CHECKSUM ERROR',0,
	209,'RELO FILE SEQUENCE ERROR',0,
	210,'INSUFFICIENT MEMORY',0,
	211,'RECORD TOO LONG',0,
	212,'ILLEGAL RELO RECORD',0,
	213,'FIXUP BOUNDS ERROR',0,
	214,'ILLEGAL SUBMIT PARAMETER',0,
	215,'ARGUMENT TOO LONG',0,
	216,'TOO MANY PARAMETERS',0,
	217,'OBJECT RECORD TOO SHORT',0,
	218,'ILLEGAL RECORD FORMAT',0,
	219,'PHASE ERROR',0,
	220,'NO EOF',0,
	221,'SEGMENT TOO LARGE',0,
	222,'UNRECOGNIZED RECORD TYPE',0,
	223,'BAD FIXUP RECORD',0,
	224,'BAD RECORD SEQUENCE',0,
	225,'INVALID MODULE NAME',0,
	226,'MODULE NAME TOO LONG',0,
	227,'LEFT PARENTHESIS EXPECTED',0,
	228,'RIGHT PARENTHESIS EXPECTED',0,
	229,'UNRECOGNIZED CONTROL',0,
	230,'DUPLICATE SYMBOL IN INPUT',0,
	233,'''TO'' EXPECTED',0,
	235,'NOT LIBRARY',0,
	232,'UNRECOGNIZED COMMAND',0,
	238,'ILLEGAL STACK CONTENT RECORD',0,
	239,'NO MODULE HEADER RECORD',0,
	240,'PROGRAM EXCEEDS 64K',0);

DECLARE debugLog BYTE INITIAL (0FFh);
DECLARE debugConn ADDRESS INITIAL(0);

SkipAfn: PROCEDURE(path$p) ADDRESS;
	DECLARE path$p ADDRESS;
	DECLARE ch BASED path$p BYTE;

	do while 1;
		path$p = PastFileName(path$p);
		if ch = '*' or ch = '?' then
			path$p = path$p + 1;
		else
			return path$p;
	end;
end;

WriteErrStr: PROCEDURE(errCode) PUBLIC;
	DECLARE errCode ADDRESS;
	DECLARE junk(3) BYTE;
	DECLARE i ADDRESS;
	DECLARE status ADDRESS;

	IF errCode <> 0 THEN
	DO;
	    i = 0;
	    DO WHILE i < LENGTH(errStrs);
		IF errCode = errStrs(i) AND errStrs(i + 1) <> 0 THEN
		DO;
			i = i + 1;
			CALL Write(0, .(' '), 1, .status);
			DO WHILE errStrs(i) <> 0;
				CALL Write(0, .errStrs(i), 1, .status);
				i = i + 1;
			END;
			CALL Write(0, .(CR, LF), 2, .status);
			RETURN;
		END;
		ELSE DO;
			DO WHILE errStrs(i) <> 0;
				i = i + 1;
			END;
			i = i + 1;
		END;
            END;
	    CALL Error(errCode);	/* pass to ISIS */
	END;

end;



FileStatusChk: PROCEDURE(errCode, path$p, isFatal) PUBLIC;
	DECLARE (errCode, path$p) ADDRESS, isFatal BYTE;
	DECLARE fstatus ADDRESS;

	if errCode <> 0 then
	do;
		path$p = SkipSpc(path$p);
		call Write(0, .(' '), 1, .fstatus);
		call Write(0, path$p, SkipAfn(path$p) - path$p, .fstatus);
		call Write(0, .(','), 1, .fstatus);
		call WriteErrStr(errCode);
		goto reset;
	end;
end;

Log: PROCEDURE(buf, cnt) PUBLIC;
	DECLARE (buf, cnt) ADDRESS;

	call Write(0, buf, cnt, .status);
	/* code cannot be reached as nothing modifies debugConn
	   looks like debug code to Log the data into another file
           debugConn is the fileid and debugLog is the Log on /off
	*/
	if debugConn <> 0 and debugLog then
		call Write(debugConn, buf, cnt, .status);
end;

LogCrLf: PROCEDURE(buf, cnt) PUBLIC;
	DECLARE (buf, cnt) ADDRESS;

	call Log(buf, cnt);
	call Log(.(CR, LF), 2);
end;


Fatal: PROCEDURE(err) PUBLIC;
	DECLARE err BYTE;
	call FileStatusChk(err, argFilename, 0FFH);
	call Exit;
end;

IllegalRecord: PROCEDURE PUBLIC;
	call FileStatusChk(ERR218, argFilename, 0FFH);	/* ILLEGAL RECORD FORMAT */
end;


DECLARE memTop ADDRESS PUBLIC,
	heapTop ADDRESS PUBLIC;


AllocUp: PROCEDURE(cnt) ADDRESS PUBLIC;
	DECLARE cnt address;

	if memTop - heapTop >= cnt then
	do;
		heapTop = heapTop + cnt;
		return heapTop - cnt;
	end;
	call WriteErrStr(ERR210);	/* INSUFFICIENT MEMEORY */
	goto reset;
end;




AllocDown: PROCEDURE(cnt) ADDRESS PUBLIC;
	DECLARE cnt address;

	if memTop - heapTop >= cnt then
		return (memTop := memTop - cnt);
	call WriteErrStr(ERR210);	/* INSUFFICIENT MEMEORY */
	goto reset;
end;

DECLARE fileHead ADDRESS PUBLIC,
	file$p ADDRESS PUBLIC;


StatusChk: PROCEDURE(conn$b, status$p);
	DECLARE conn$b BYTE, status$p ADDRESS;
	DECLARE status BASED status$p ADDRESS;
	DECLARE file BASED file$p FILE$T;

	if status = 0 then
		return;

	file$p = .fileHead;
	do while (file$p := file.link) <> 0;
		if file.conn = conn$b and file.isOpen then
		do;
			call FileStatusChk(status, file.path$p, 0);
			goto reset;
		end;
	end;
end;





OpenFile: PROCEDURE(conn$p, path$p, access, echo, status$p) PUBLIC;
	DECLARE (conn$p, path$p, access, echo, status$p) ADDRESS;
	DECLARE status BASED status$p ADDRESS;
	DECLARE head BASED fileHead FILE$T;
	DECLARE file BASED file$p FILE$T;
	DECLARE conn BASED conn$p BYTE;

	call Open(conn$p, path$p, access, echo, status$p);
	if status <> 0 then
	do;
		call FileStatusChk(status, path$p, 0);
		goto reset;
	end;

	file$p = AllocUp(6);
	file.link = fileHead;
	fileHead = file$p;
	file.path$p = path$p;	
	file.isOpen = 0FFH;
	file.conn = conn;
end;

CloseFile: PROCEDURE(conn, status$p) PUBLIC;
	DECLARE (conn, status$p) ADDRESS;
	DECLARE status BASED status$p ADDRESS;
	DECLARE file BASED file$p FILE$T;

	call Close(conn, status$p);	/* Close on ISIS */

	/* clear down the connection on the file list */
	file$p = .fileHead;
	do while (file$p := file.link) <> 0;
		if file.conn = conn then	/* found the file */
		do;
			file.isOpen = 0;
			call FileStatusChk(status, file.path$p, 0FFH);	
		end;
	end;
end;


ReadFile: PROCEDURE(conn, buff$p, count, actual$p, status$p) PUBLIC;
	DECLARE (conn, buff$p, count, actual$p, status$p) ADDRESS;

	call Read(conn, buff$p, count, actual$p, status$p);
	call StatusChk(conn, status$p);
end;

WriteFile: PROCEDURE(conn, buff$p, count, status$p) PUBLIC;
	DECLARE (conn, buff$p, count, status$p) ADDRESS;

	call Write(conn, buff$p, count, status$p);
	call StatusChk(conn, status$p);
end;


SeekFile: PROCEDURE (conn, mode, block$p, byte$p, status$p) PUBLIC;
	DECLARE (conn, mode, block$p, byte$p, status$p) ADDRESS;

	call Seek(conn, mode, block$p, byte$p, status$p);
	call StatusChk(conn, status$p);
end;

DeleteFile: PROCEDURE(path$p, status$p) PUBLIC;
	DECLARE (path$p, status$p) ADDRESS;
	DECLARE status BASED status$p ADDRESS;

	call Delete(path$p, status$p);
	if status <> 0 then
	do;
		call FileStatusChk(status, path$p, 0);
		goto reset;
	end;
end;

RenameFile: PROCEDURE(old$p, new$p, status$p) PUBLIC;
	DECLARE (old$p, new$p, status$p) ADDRESS;
	DECLARE status BASED status$p ADDRESS;

	call Rename(old$p, new$p, status$p);
	if status <> 0 then
	do;	
		call FileStatusChk(status, old$p, 0);
		goto reset;
	end;
end;

DECLARE curRec LIBREC$T PUBLIC,
	savedRec LIBREC$T PUBLIC;

/* EXTERNALS */

OpenLib: PROCEDURE PUBLIC;
	call OpenFile(.inConn, argFilename, 1, 0, .status);
	curRec.bytesLeft = 0;
end;

GetRecordBytes: PROCEDURE(count, buf$p) PUBLIC;
	DECLARE  (count, buf$p) ADDRESS;
	DECLARE buf BASED buf$p(1) BYTE;

	call ReadFile(inConn, buf$p, count, .actual, .status);
	if actual <> count or count > curRec.bytesLeft then
		call FileStatusChk(ERR217, argFilename, 0FFH);
	
	curRec.bytesLeft = curRec.bytesLeft - count;
	do while count <> 0;
		curRec.crc = curRec.crc + buf(count := count - 1);
	end;
end;


ReadChkCrc: PROCEDURE PUBLIC;
	DECLARE recByte BYTE;

	call GetRecordBytes(1, .recByte);
	if curRec.crc <> 0 then
		call FileStatusChk(ERR208, argFilename, 0FFH);	/* CHECKSUM Error */
end;


/* skip current record if one being processed */

SkipCurRec: PROCEDURE PUBLIC;
	if curRec.bytesLeft = 1 then
		call ReadChkCrc;
	else
		call SeekFile(inConn, 3, .(0, 0), .curRec.bytesLeft, .status);
	curRec.bytesLeft = 0;
end;


PrepRecord: PROCEDURE PUBLIC;
	call SkipCurRec; 	/* skip current record if one being processed */
	call SeekFile(inConn, 0, .curRec.curBlk, .curRec.curByte, .status);
	curRec.bytesLeft = 3;	/* 3 bytes for rectype and record length */
	curRec.crc = 0;		/* reset crc */
	call GetRecordBytes(3, .curRec.type);
	curRec.bytesLeft = curRec.len;	/* correct the length using the record length */
end;

AcceptRecord: PROCEDURE(type) PUBLIC;
	DECLARE type BYTE;

	call PrepRecord;
	if curRec.type <> type then
		call Fatal(ERR218);	/* ILLEGAL RECORD FORMAT */
end;

GetName: PROCEDURE(buf) PUBLIC;
	DECLARE buf ADDRESS;
	DECLARE len BASED buf BYTE;

	call GetRecordBytes(1, buf);

	if len > 31 then
		call IllegalRecord;

	call GetRecordBytes(len, buf + 1);
end;


SkipModule: PROCEDURE PUBLIC;
	do while curRec.type <> OBJEND;
		call PrepRecord;
	end;
	call SkipCurRec;	/* skip the OBJ end as well */
end;

LibSeek: PROCEDURE(mode$b, blkByte$p) PUBLIC;
	DECLARE mode$b BYTE, blkByte$p ADDRESS;

	call SeekFile(inConn, mode$b, blkByte$p, blkByte$p + 2, .status);
	if mode$b = 2 then
		curRec.bytesLeft = 0;
	return;
end;


SaveCurPos: PROCEDURE PUBLIC;
	DECLARE i BYTE;
	DECLARE w$cur(1) ADDRESS AT (.curRec);
	DECLARE w$save(1) ADDRESS AT (.savedRec);

	call LibSeek(0, .curRec.posBlk);
	do i = 0 to 6;
		w$save(i) = w$cur(i);
	end;
end;


RestoreCurPos: PROCEDURE PUBLIC;
	DECLARE i BYTE;
	DECLARE w$cur(1) ADDRESS AT (.curRec);
	DECLARE w$save(1) ADDRESS AT (.savedRec);

	call LibSeek(2, .savedRec.posBlk);
	do i = 0 to 6;
		w$cur(i) = w$save(i);
	end;
end;

SwapCurSavedRec: PROCEDURE PUBLIC;
	DECLARE i BYTE;
	DECLARE tmp ADDRESS;
	DECLARE w$cur(1) ADDRESS AT (.curRec);
	DECLARE w$save(1) ADDRESS AT (.savedRec);

	call LibSeek(0, .curRec.posBlk);	
	tmp = curRec.bytesLeft;
	call LibSeek(2, .savedRec.posBlk);
	curRec.bytesLeft = tmp;
	do i = 0 to 6;
		tmp = w$cur(i);
		w$cur(i) = w$save(i);
		w$save(i) = tmp;
	end;
end;


Hash: PROCEDURE(pstr) BYTE PUBLIC;
	DECLARE pstr ADDRESS;
	DECLARE str BASED pstr (1) BYTE;
	DECLARE (i, j) BYTE;

	j = 0;
	DO i = 0 TO str(0);
		j = ROR(j, 1) XOR str(i);
	END;
	RETURN j mod 128;
END Hash;

LookupSymbol: PROCEDURE(modName$p, Hash$p) BYTE PUBLIC;
	DECLARE (modName$p, Hash$p) ADDRESS;
	DECLARE curSym$p ADDRESS,
		symbol ADDRESS,
		i BYTE;
	DECLARE curSym BASED curSym$p SYMBOL$T;
	DECLARE name BASED modName$p(1) BYTE;
	DECLARE symName BASED symbol(1) BYTE;
	DECLARE retHash based Hash$p ADDRESS;

	/* using Hashing find the start of the symbol chain */
	curSym$p = .HashTable(Hash(modName$p));

	/* scan the chain looking for a match */
	do while curSym.link <> 0;
		curSym$p = curSym.link;
		symbol = .curSym.symbol;

		do i = 0 to name(0);
			if symName(i) <> name(i) then
				goto outerloop;
		end;
		retHash = curSym$p;	
		return 0ffh;	/* found it */
outerloop:
	end;
	retHash = curSym$p;
	return 0;		/* not found */
end;

DECLARE lineHead	ADDRESS,
	curLine$p	ADDRESS PUBLIC,
	lookAhead$p		ADDRESS PUBLIC,
	lookAheadLen		BYTE PUBLIC,
	token$p	ADDRESS PUBLIC,
	tokLen	BYTE PUBLIC,
	junk1		BYTE,
	inModuleList	BYTE PUBLIC;


LibError: PROCEDURE(err) PUBLIC;
	DECLARE err BYTE;
	DECLARE line$p ADDRESS;
	DECLARE s ADDRESS;
	DECLARE curLine BASED curLine$p LINE$T;
	DECLARE line BASED line$p LINE$T;

	s = token$p + tokLen;	/* assumes these are set up correctly, doesn't always seem to be correct */
	call WriteErrStr(err);
	line$p = lineHead;

	/*
		print out lines that are in the chain before this one
		basically s will not be in the range of the line pointed
		to by line$p
	*/
	do while s < line$p or line$p + line.len + 4 < s;
		call Write(0, .line.text, line.len, .status);
		line$p = line.next;
	end;
	/* this Logic looks flawed I suspect the else clause is generally taken */
	/* would be reasonable if curLine.len was used */
	if s > curLine$p  and curLine$p + 5 + curLine.next > s then
		call Write(0, .curLine.text, s - .curLine.text, .status);
	else
		call Write(0, .line.text, s - .line.text, .status);

	call Write(0, .('#', CR, LF), 3, .status);
	goto reset;
end;

GetTokenLen: PROCEDURE(str) ADDRESS;
	DECLARE str ADDRESS;
	DECLARE junk BYTE;
	DECLARE tmp ADDRESS;
	DECLARE ch BASED str BYTE;

	if ch = CR then
		return 0;

	if inModuleList then
	do;
		if ch < '?' or ch > 'Z' then
			call LibError(ERR225);	/* INVALID MODULE NAME */

		tmp = str;

		do while ((ch >= '0' AND ch <= '9') or (ch <= 'Z' and ch >= '?' AND (str - tmp < 33)));
			str = str + 1;
		end;

		if str - tmp > 32 then
			call LibError(ERR226);	/* MODULE NAME TOO LONG */

		return str - tmp;
	end;
	if ch = '(' then
		return 1;
	else if ch = ')' then
		return 1;
	else if ch = ',' then
		return 1;
	tmp = PastFileName(str) - str;
	if tmp > 0 then
		return tmp;
	else
		call LibError(ERR203);	/* INVALID SYNTAX */
end;




GetLine: PROCEDURE;
	DECLARE curLine BASED curLine$p LINE$T;
	DECLARE curLine$a BASED curLine$p(1) BYTE;
	DECLARE lookAhead BASED lookAhead$p(1) BYTE;
	DECLARE i BYTE;

loop:
	/* allocate a line buffer and insert into the chain */
	curLine.next = AllocDown(126);
	curLine$p = curLine.next;
	curLine.next = 0;
	/* Read line and convert to upper case */
	call Read(1, .curLine.text, 122, .curLine.len, .status);
	do i = 4 to 125;	/* 4 is offset of text in line structure */
		if curLine$a(i) >= 'a' AND curLine$a(i) <= 'z' then
			curLine$a(i) = curLine$a(i) - 20H;	/* convert to upper case */
	end;

	if tokLen = 0 then			/* initialise token if first one */
		token$p = .curLine.text;
	lookAhead$p = SkipSpc(.curLine.text);
	/* check line with just & on it */
	if lookAhead(0) = '&' then
	do;
		/* make sure nothing after the & */
		lookAhead$p = SkipSpc(lookAhead$p + 1);
		if lookAhead(0) <> CR THEN
			call LibError(ERR203);	/* INVALID SYNTAX */
		/* prompt user and get another line */
		call Write(0, .('**'), 2, .status);
		/* note potentially wasteful on memory as this line buffer could be reused */
		/* loop could be to the Read call */
		goto loop;
	end;
	lookAheadLen = GetTokenLen(lookAhead$p);
end;

GetToken: PROCEDURE PUBLIC;
	DECLARE lookAhead BASED lookAhead$p(1) BYTE;
	token$p = lookAhead$p;		/* record latest token */
	tokLen = lookAheadLen;
	/* track in / out of module list */
	if lookAhead(0) = ')' then
		inModuleList = 0;	/* no longer in module list */
	lookAhead$p = SkipSpc(lookAhead$p + lookAheadLen);
	/* continuation line ? */
	if lookAhead(0) = '&' then
	do;
		lookAhead$p = SkipSpc(lookAhead$p + 1);
		/* can't be anything other than blanks after the & */
		if lookAhead(0) <> CR then
		do;
			token$p = lookAhead$p;	/* point to the Error character */
			/* this code is flawed as tokLen will be wrong for LibError */
			call LibError(ERR203);	/* INVALID SYNTAX */
		end;
		/* get another line */
		call Write(0, .('**'), 2, .status);
		call GetLine;
	end;
	lookAheadLen = GetTokenLen(lookAhead$p);
end;


MatchToken: PROCEDURE(cha$p, len) BYTE PUBLIC;
	DECLARE cha$p ADDRESS, len BYTE;
	DECLARE cha BASED cha$p(1) BYTE;
	DECLARE token BASED token$p(1) BYTE;

	DECLARE i BYTE;

	if tokLen <> len then
		return 0;
	if len = 0 then
		return 0FFh;

	do i = 0 to len - 1;
		if cha(i) <> token(i) then
			return 0;
	end;
	return 0FFh;
end; 	


MatchLookAhead: PROCEDURE(cha$p, len) BYTE PUBLIC;
	DECLARE cha$p ADDRESS, len BYTE;
	DECLARE cha BASED cha$p(1) BYTE;
	DECLARE lookAhead BASED lookAhead$p(1) BYTE;

	DECLARE i BYTE;

	if lookAheadLen <> len then
		return 0;
	if len = 0 then
		return 0FFh;
	do i = 0 to len - 1;
		if cha(i) <> lookAhead(i) then
			return 0;
	end;
	return 0FFh;
end;

GetCmd: PROCEDURE PUBLIC;
		inModuleList, junk1, tokLen = 0;
		lineHead = 0;		/* no line chain */
		curLine$p = .lineHead;
		call GetLine;		/* get first line token and lookAhead token */
		call GetToken;
end;

end;
lib3.plm
lib3:
DO;

SkipSpc: PROCEDURE(ch$p) ADDRESS PUBLIC;
	DECLARE ch$p ADDRESS;
	DECLARE ch BASED ch$p BYTE;

	DO WHILE ch = ' ';
		ch$p = ch$p + 1;
	END;
	RETURN ch$p;
END SkipSpc;

PastFileName: PROCEDURE(ch$p) ADDRESS PUBLIC;
	DECLARE ch$p ADDRESS;
	DECLARE ch BASED ch$p BYTE;

	DO WHILE ch = ':' OR ch = '.' OR (ch >= '0' AND ch <= '9') OR (ch >= 'A' AND ch <= 'Z');
		ch$p = ch$p + 1;
	END;
	RETURN ch$p;
END PastFileName;
end;

lib4.plm
itoa:
DO;
DECLARE hexdigits(*) BYTE DATA ('0123456789ABCDEF');

BinAsc: PROCEDURE(num, base, padch, cha$p, width) PUBLIC;
	DECLARE num ADDRESS;
	DECLARE (base, padch) BYTE;
	DECLARE cha$p ADDRESS;
	DECLARE width BYTE;

	DECLARE i BYTE;
	DECLARE cha BASED cha$p (1) BYTE;

	DO i = 1 TO width;
		cha(width - i) = hexdigits(num MOD base);
		num = num / base;
	END;
	i = 0;
	DO WHILE cha(i) = '0' AND i < width - 1;
		cha(i) = padch;
		i = i + 1;
	END;
END BinAsc;


end;

isis1.plm
isis1: DO;
$include(isis1.ipx)

Close: PROCEDURE(conn, status$p) public;
	declare (conn, status$p) address;
	CALL ISIS(IClose, .conn);
end Close;

Delete: procedure (path$p, status$p) public;
    declare (path$p, status$p) address;
    call ISIS(IDelete, .path$p);
end Delete;

Error: procedure (Error$num) public;
    declare (Error$num) address;
    declare junk address;
    junk = .junk;
    call ISIS(IError, .Error$num);
end Error;

Exit: procedure public;
    declare tmp address;
    tmp = .tmp;
    call ISIS(IExit, .tmp);
end Exit;


end;

isisa.asm
	public MEMCK
	public ISIS
	ASEG
	ORG	40H
ISIS:

	CSEG

MEMCK:		
	call	0F81Bh
	mov	h, b
	mov	l, a
	ret

	end;

isis2.plm

isis2: DO;
$include(isis2.ipx)

Open: procedure (conn$p, path$p, access, echo, status$p) public;
    declare (conn$p, path$p, access, echo, status$p) address;
    CALL ISIS(IOpen, .conn$p);
end Open;

Read: procedure (conn, buff$p, count, actual$p, status$p) public;
    declare (conn, buff$p, count, actual$p, status$p) address;
    call ISIS(IRead, .conn);
end Read;

Rename: procedure (old$p, new$p, status$p) public;
    declare (old$p, new$p, status$p) address;
    CALL ISIS(IRename, .old$p);
end Rename;
Seek: procedure (conn, mode, block$p, byte$p, status$p) public;
    declare (conn, mode, block$p, byte$p, status$p) address;
    CALL ISIS(ISeek, .conn);
end Seek;


Write: procedure (conn, buff$p, count, status$p) public;
    declare (conn, buff$p, count, status$p) address;
    call ISIS(IWrite, .conn);
end Write;


end;
