asm4E:
do;

declare r$extnames1 structure(type byte, len address, dta(1) byte) external,
	r$publics structure(type byte, len address, segid byte, dta(1) address) external,
	r$reloc structure(type byte, len address, hilo byte, dta(1) address) external,
	r$interseg structure(type byte, len address, segid byte, hilo byte, dta(1) address) external,
	r$extref structure(type byte, len address, hilo byte, dta(30) address) external, 
	r$extnames2 structure(type byte, len address, dta(1) byte) external,
	r$content structure(type byte, len address, segid byte, offset address, dta(1) byte) external,
	r$modend structure(type byte, len address, modtyp byte, segid byte, offset address, crc byte) external;


declare tokenSize literally 'toksiz',
	tokStart literally 'tokst';
declare (aF0Asmac$tmp, aF0Asxref, aF0Asxref$tmp, aIsisIi80808085, spaces24)(1) byte external,
	(objFile, lstFile, tokenSize, tokenAttr, b68AE)(1) byte external,
	(b68B8, asciiLineNo, b6A57, controlSeen, ctlTITLESTR, b8FD5, cmdLineBuf,
	 macroCondStk, opStack, b674A)(1) byte external,
	(bZERO, bTRUE, activeSeg, b6857, curChar, lookAhead, b6882) byte external,
	(asmErrCode, primaryValid, b689B, curCol, b68AB, b68AD, b6A56, ctlDEBUG, ctlMACRODEBUG) byte external,
	(ctlXREF, ctlSYMBOLS, ctlPAGING, ctlTTY, ctlPRINT, ctlOBJECT, ctlPAGEWIDTH, ctlPAGELENGTH, ctlTITLE) byte external,
	(ctlEJECT, ctlLIST, ctlGEN, ctlCOND, b6A6F, titleLen, saveIdx, scanCmdLine, b6B23) byte external,
	(opType, b6B2C, finished, b6B33, b6B34, ii, jj, b6C21, fileIdx) byte external,
	(b6C30, b905B, b905C, b905E, b9063, b9064, b6742, b6743) byte external,
	(ifDepth, skipping, inElse, macroCondSP, opSP, b6A00) byte external,
	(b9A77, b6B24) byte external,
	(cmdch$p, actRead, off$6C25, off$6C2C, off$6C2E, outfd, statusIO) address external,
	curTokenSym$p address external,
	curTokenSym based curTokenSym$p structure(w0 address, w2 address, w4 address, type byte, flags byte),
	(w6750, w686E, w6870, objfd) address external,
	(infd, macrofd, w68A0, w68A2, lineCnt, w68A6, pageCnt, endOutBuf) address external,
	(w6A4E, errCnt, zero) address external,
	w6868(3) address external,
	(controls$p, includefd, rootfd, off$9056, curMacroBlk, w9114, w919B, wZERO) address external,
	(w6B41, segSize, symTab, tokStart, extKeywords)(1) address external,
	files(6) structure(name(15) byte, blk address, byt address, b19 byte) external,
	CR literally '0Dh';



ioErrChk: procedure external; end;
closeF: procedure(w) external; declare w address; end;
physmem: procedure address external; end;

read: procedure(w1, w2, w3, w4, w5) external; declare (w1, w2, w3, w4, w5) address; end;
rescan: procedure(w1, w2) external; declare (w1, w2) address; end;
seek: procedure(w1, w2, w3, w4, w5) external; declare (w1, w2, w3, w4, w5) address; end;
isPhase1: procedure byte external; end;
runtimeError: procedure(b) external; declare b byte; end;
sub$3DFB: procedure external; end;
inOpen: procedure(w1, w2) address external; declare (w1, w2) address; end;

declare aExtents(*) byte public initial(' LSTOBJ'),
    aDebug(*) byte public initial('DEBUG');


cmdSkipWhite: procedure public;
    declare cmdch based cmdch$p byte;
    
    do while (cmdch = ' ' or cmdch = 9) and cmdch$p <> actRead;
        cmdch$p = cmdch$p + 1;
    end;
end;

getDrive: procedure byte public;
    declare cmdch based cmdch$p byte;

    if cmdch = ':' then
    do;
        cmdch$p = cmdch$p + 2;
        return cmdch;
    end;
    else
        do ii = 0 to 4;
        if cmdch <> aDebug(ii) and aDebug(ii) + 20h <> cmdch then
                return '0';
            cmdch$p = cmdch$p + 1;
        end;
    call cmdSkipWhite;
    if cmdch <> ':' then
        return '0';
    cmdch$p = cmdch$p + 2;
    return cmdch;
end;

addExtents: procedure public;
    do ii = 1 to 3;
        lstFile(jj + ii) = aExtents(ii);
        objFile(jj + ii) = aExtents(ii+3);
    end;
end;


getAsmFile: procedure public;
    declare cmdch based cmdch$p byte;

    cmdIsWhite: procedure byte;
        declare cmdch based cmdch$p byte;
        return cmdch = ' ' or cmdch = 9 or cmdch = CR;
    end;


    symTab(0) = .extKeywords;
    w686E, w6868(0), symTab(1), w6868(1) = .MEMORY;
    call rescan(1, .statusIO);
    call ioErrChk;
    call read(1, .cmdLineBuf, 128, .actRead, .statusIO);
    call ioErrChk;
    actRead = actRead + .cmdLineBuf;
    scanCmdLine = 0FFh;
    call cmdSkipWhite;
    aF0Asxref(2) = getDrive;

    do while not cmdIsWhite;
        cmdch$p = cmdch$p + 1;
    end;

    call cmdSkipWhite;
    if cmdch = 0Dh then
        call runtimeError(4);	/* file */

    infd = inOpen(cmdch$p, 1);
    rootfd, includefd = infd;
    ii = 0FFh;

    jj = 0;

    do while not cmdIsWhite;
        files(0).name(jj) = cmdch;
        if ii then
            lstFile(jj), objFile(jj) = cmdch;

        if cmdch = '.' then
        do;
            ii = 0;
            call addExtents;
        end;

        jj = jj + 1;
        cmdch$p = cmdch$p + 1;
    end;

    controls$p = cmdch$p;
    if ii then
    do;
        lstFile(jj) = '.';
        objFile(jj) = '.';
        call addExtents;
    end;

    files(0).name(jj) = ' ';
    if lstFile(0) = ':' and lstFile(2) <> '0' then
        aF0Asmac$tmp(2), aF0Asxref$tmp(2) = lstFile(2);
end;


resetData: procedure public;	/* extended initialisation */

    call sub$3DFB;

    b6B33, scanCmdLine, skipping, b6B2C, inElse, finished, b674A(0), b674A(1), b6742,
    b$905B, b$905C, b$905E, b6857, b6C21 = bZERO;
    b6743, primaryValid, ctlLIST, b6A6F, ctlGEN, ctlCOND = bTRUE;
    b$9063, b$9064, macroCondStk(0), macroCondSP, saveIdx, lookAhead, activeSeg, ifDepth, opSP, opStack(0) = bZERO;
    w$9114, segSize(0), segSize(1), segSize(2), w6B41(0), w6B41(1), w6B41(2), w68A6, w$919B, w6750, errCnt = wZERO;
    b6882 = b6882 + 1;
    w6A4E, opType, pageCnt, lineCnt = 1;
    b68AE(0) = 0;
    curChar = 20h;
    do ii = 0 to 11;
        controlSeen(ii) = 0;
    end;

    curMacroBlk = 0FFFFh;
    if not isPhase1 then
    do;
        if fileIdx <> 0 then
        do;
            call closeF(includefd);
            call ioErrChk;
            includefd = rootfd;
        end;

        fileIdx = bZERO;
        off$6C25 = .b68B8;
        off$6C2C = off$6C25 - 1;
        off$6C2E = .b68B8;
        call seek(infd, 2, .zero, .zero, .statusIO);	/* SEEKABS */
        call ioErrChk;
    end;

    w6870 = physmem + 0BFh;
    endOutBuf = .b6A00;
end;

sub$70EE: procedure public;
    r$content.type = 6;
    r$content.len = 3;
    r$publics.type = 22h;
    r$publics.len = 1;
    r$interseg.type = 24h;
    r$interseg.len = 2;
    r$extref.type = 20h;
    r$extref.len = 1;
end;

end;
