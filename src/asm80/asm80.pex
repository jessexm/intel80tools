/* assembler routines & linkage */
ISIS            P(B b,A w)
pckTkn          P
EDATA		B

packToken       'pckTkn'
tokenSize       'toksiz'
tokStart        'tokst'


lit             'literally'
TRUE            '0FFh'
FALSE           '0'
CR              '0Dh'
FF              '0Ch'
LF              '0Ah'
TAB             '9'
MACROEOB	'0FEh'

# primiative types
bool             'byte'
word             'address'
pointer          'address'

/* character classes */
CC$BAD          '0'
CC$WS           '1'
CC$SEMI         '2'
CC$COLON        '3'
CC$CR           '4'
CC$PUNCT        '5'
CC$DOLLAR       '6'
CC$QUOTE        '7'
CC$DIGIT        '8'
CC$LET          '9'
CC$ESC          '11'

TT$ID           '0'
TT$NUM          '2'
TT$STR          '4'

/* ISIS syscall ids */
IOPEN           '0'
ICLOSE          '1'
IDELETE         '2'
IREAD           '3'
IWRITE          '4'
ISEEK           '5'
ILOAD           '6'
IEXIT           '9'
IRESCAN         '11'
IERROR          '12'
/* seek operations */
SEEKTELL        '0'
SEEKBACK        '1'
SEEKABS         '2'
SEEKFWD         '3'
SEEKEND         '4'
/* segments */
SEG$ABS         '0'
SEG$CODE        '1'
SEG$DATA        '2'
SEG$STACK       '3'
SEG$MEMORY      '4'

/* relocatable record types */
OMF$MODHDR      '2'
OMF$MODEND      '4'
OMF$CONTENT     '6'
OMF$LINENO      '8'
OMF$EOF	        '0EH'
OMF$ANCESTOR    '10H'
OMF$LOCALS      '12H'
OMF$PUBLICS     '16H'
OMF$EXTNAMES    '18H'
OMF$EXTREF      '20H'
OMF$RELOC       '22H'
OMF$INTERSEG    '24H'
OMF$LIBLOCS     '26H'
OMF$LIBNAMES    '28H'
OMF$LIBDICT     '2AH'
OMF$LIBHDR      '2CH'
OMF$COMDEF      '2EH'

/* op types */
T$CR            '1'
T$LPAREN        '2'
T$RPAREN        '3'
T$STAR          '4'
T$PLUS          '5'
T$COMMA         '6'
T$MINUS         '7'
T$UPLUS         '8'
T$SLASH         '9'
T$UMINUS        '0Ah'
O$NONE          '0'
O$LABEL         '3'
O$ID            '9'
O$STRING        '0Ah'
O$DATA          '0Bh'
O$NUMBER        '0Ch'
K$SPECIAL       '5'
K$REGNAME       '7'
K$SP            '8'
K$EQ            '0Bh'
K$LT            '0Ch'
K$LE            '0Dh'
K$GT            '0Eh'
K$GE            '0Fh'
K$NE            '10h'
K$NOT           '11h'
K$AND           '12h'
K$OR            '13h'
K$XOR           '14h'
K$MOD           '15h'
K$SHL           '16h'
K$SHR           '17h'
K$HIGH          '18h'
K$LOW           '19h'
K$DB            '1Ah'
K$DW            '1Bh'
K$DS            '1Ch'
K$EQU           '1Dh'
K$SET           '1Eh'
K$ORG           '1Fh'
K$END           '20h'
K$IF            '21h'
K$ELSE          '22h'
K$ENDIF         '23h'
K$LXI           '24h'
K$REG16         '25h'
K$LDSTAX        '26h'
K$ARITH         '27h'
K$IMM8          '28h'
K$MVI           '29h'
K$INRDCR        '2Ah'
K$MOV           '2Bh'
K$IMM16         '2Ch'
K$SINGLE        '2Dh'
K$RST           '2Eh'
K$ASEG          '2Fh'
K$CSEG          '30h'
K$DSEG          '31h'
K$PUBLIC        '32h'
K$EXTRN         '33h'
K$NAME          '34h'
K$STKLN         '35h'
K$MACRO         '36h'
O$37            '37h'
K$ENDM          '38h'
K$EXITM         '39h'
O$3A            '3Ah'
K$IRP           '3Bh'
K$IRPC          '3Ch'
O$3D            '3Dh'
K$REPT          '3Eh'
K$LOCAL         '3Fh'
K$NUL           '41h'
O$64            '64h'

/* type flags */
UF$SEGMASK	'7'
UF$LOW          '8'
UF$HIGH         '10h'
UF$BOTH         '18h'
UF$PUBLIC       '20h'
UF$EXTRN        '40h'

/* user defined types */
TOKENSYM$T      'structure(tok(2) address, val address, type byte, flags byte)'
FILE$T          'structure(name(15) byte, blk address, byt address, b19 byte)'
MACRO$T1	'macroCondSP byte, ifDepth byte, mtype byte, b3 byte,w4 address'
MACRO$T2        'buf$p address, blk address, w10 address, w12 address, w14 address'
MACRO$T         'structure(MACRO$T1,MACRO$T2)'
CONTENT$T       'structure(type byte, len address, segid byte, offset address, dta(122) byte, crc byte)'
EOF$T           'structure(type byte, len address, crc byte)'
EXTNAMES$T	'structure(type byte, len address, dta(125) byte)'
EXTREF$T        'structure(type byte, len address, hilo byte, dta(30) address, crc byte)'
INTERSEG$T      'structure(type byte, len address, segid byte, hilo byte, dta(29) address, crc byte)'
MODEND$T        'structure(type byte, len address, modtyp byte, segid byte, offset address, crc byte)'
MODHDR$T	'structure(type byte, len address, dta(26) byte)'
PUBLICS$T       'structure(type byte, len address, segid byte, dta(124) byte, crc byte)'
RELOC$T         'structure(type byte, len address, hilo byte, dta(62) address)'
KEYWORD$T	'structure(tok(2) address, base byte, delta byte, type byte, flags byte)'

/* common based variables */
curTokenSym     "TOKENSYM$T"..curTokenSym$p

$file(asm41.plm)
b$3782          B
b$3783          B
w$3780          A
isGT            PB
isLT            PB
sub$3D34        P(B c)
sub$3D55        P(B c)

$file(asm41.plm,asm51.plm,asm801.plm)
aBadSyntax      BS
aCo             BS
aCommand        BS
aEof            BS
aError          BS
aError$0        BS
aFile           BS
asmHeader BS
aMemory         BS
aModulePage     BS
ascCRLF         BS
aStack          BS
aTable          BS
bTRUE           B
bZERO           B
errStrs         AS
errStrsLen      BS
signonMsg       BS
spaces15        BS
spaces2         BS
spaces24        BS
spaces4         BS
spaces5         BS
spaces6         BS
blankAsmErrCode PB
blankMorPAsmErrCode PB
chkGenObj       PB
closeF          P(A conn)
flushout        P
getNibble       P(A bp,B idx)B
initialControls P
inOpen          P(A path$p,A access)A
ioErrChk        P
ioError         P("pointer" s)
isComma         PB
isCR            PB
isPhase1        PB
isPhase2Print   PB
isRParen        PB
isSpace         PB
isTab           PB
isWhite         PB
nibble2Ascii    P(B n)B
getCmdCh        PB
outch           P(B c)
outStrN         P(A s,B n)
physmem         PA
parseControlLines P
put2Hex         P(A pfunc,B val)
runtimeError    P(B errCode)
skip2EOL        P
sourceError     P(B errCh)
initLine        P
wrConsole       P(A buf$p,A count)


$file(asm43.pl3)
readM           P(A blk)
sub$3FA9        PB
sub$40B9        P
writeM          P

$file(asm43.pl3,asm82.pl3)
skip2NextLine   P
skipWhite       P
skipWhite$2     P
tokeniseLine        P

/* $file(asm44.plm) */

$file(asm44.plm,asm83.plm)
b4181           BS
getPrec         P(B arg1b)B
isReg        P(B arg1b)"bool"
sub$4274        P
sub$4291        P
setExpectOperands        P
getNumVal        PA
mkCode        P(B arg1b)
nxtTokI        PB
showLine        PB
emitXref        P(B arg1b,A arg2w)
swapAccBytes    P
testBit         P(B bitIdx,"pointer" bitVector)"bool"

/* $file(asm45.plm) */

$file(asm45.plm,asm55.plm,asm851.plm)
isSkipping      PB
strUCequ        P("pointer" s,"pointer" t)"bool"
finishLine    P
sub$546F        P

$file(asm46.pl3)
needToOpenFile   "bool"
includeOnCmdLine "bool"
b6C23           B
missingEnd      "bool"
lineChCnt           B
fileIdx         B
files           "FILE$T"S
srcfd       A
endInBuf$p         A
inCh$p         "pointer"
startLine$p         A
rootfd          A
closeSrc          P
readF           P(B arg1b,A arg2w,A arg3w)
readSrc           P(A arg1w)
seekI           P(B arg1b)
getSrcCh        PB
openSrc        P

/* $file(asm47.pl3) */

$file(asm47.pl3,asm85.pl3)
cond2Acc        P(B arg1b)
sub$4AAA        P(B arg1b)
updateHiLo        P(B hilo)
doPass        P

$file(asm48.pl3)
sub$5CAD        P(A arg1w,B type)
sub$65D9        P

$file(asm48.pl3,asm86.pl3)
b6EC4$9C3A          B
getCh           PB
getChClass      PB
lookup          P(B tableId)B
sub5819$5CE8        P(A arg1w,B arg2b)
unpackToken     P("pointer" src,"pointer" dst)

/* $file(asm49.pl3) */

$file(asm49.pl3,asm861.plm)
balanceError    P
collectByte     P(B arg1b)
commandError    P
doubleDefError  P
expressionError P
fileError       P
getId           P(B arg1b)
atoi          P
getStr          P
haveTokens      PB
illegalCharError P
locationError   P
multipleDefError P
nameError       P
nestIF         P(B arg1b)
nestingError    P
OpcodeOperandError P
operandError    P
phaseError      P
popToken        P
pushToken       P(B arg1b)
stackError      P
syntaxError     P
undefinedSymbolError P
unnestIF        P(B arg1b)
valueError      P

/* $file(asm4A.pl3) */
$file(asm4A.pl3,asmov0.pl3)
parseControls   P

$file(asm4B.pl3)
b9C77          B
sub$72A4        P(B arg1b)
sub$7327        P
sub$73AD        P
sub$7517        P
sub$753E        P
sub$75FF        P
sub$76CE        P
sub$770B        P
sub$7844        P
sub$787A        P
sub$78CE        P

/* $file(asm4C.pl3) */

$file(asm4C.pl3,asmov2.pl3)
ovl11           P
ovl8            P
reinitFixupRecs        P
writeExtName    P
writeModend     P
writeModhdr     P
writeRec        P(A rec$p)

/* $file(asm4D.pl3) */

$file(asm4D.pl3,asmov1.pl3)
asmComplete     P
newPage         P
newPageHeader   P
outStr          P(A arg1w)
printLine            P
ovl9            P
ovl10           P
printCmdLine    P
printDecimal    P(A arg1w)
skipToEOP       P
doEject        P
sub7041$8447    P
moreBytes        PB
sub$7229        P
sub$72D8        P

/* $file(asm4E.plm) */

$file(asm4E.plm,asm5D.plm,asmov3.plm)
aDebug          BS
aExtents        BS
addExtents      P
cmdSkipWhite    P
getAsmFile      P
getDrive        PB
resetData       P
initRecTypes        P



/* $file(asm51.plm) */

/* $file(asm52.plm) */

/* $file(asm55.plm) */

/* $file(asm57.pl3) */
$file(asm57.pl3,asm85.pl3)
handleOp        P
parseLine        P

/* $file(asm5D.plm) */


$file(asm801.plm)
ovlFile         BS
ovlMgr          P(B ovl)

/* $file(asm82.pl3) */
/* $file(asm83.plm) */
/* $file(asm85.pl3) */
/* $file(asm851.plm) */

$file(asm86.pl3)
chkLF           P
insertSym       P

/* $file(asm861.plm) */

/* $file(asmov0.pl3) */

/* $file(asmov1.pl3) */

/* $file(asmov2.pl3) */

/* $file(asmov3.plm) */

$file(close.plm)
close           P(A conn,A status$p)

$file(delete.plm)
delete          P(A path$p,A status$p)

$file(error.plm)
error           P(A error$num)

$file(exit.plm)
exit            P

/* these share a common file with build controlled by $IF statements */
$file(glb.plm,glb4.plm,glb5.plm)
accum1          A
accum1$hb       B
accum1$lb       B
accum2          A
accum2$hb       B
accum2$lb       B
activeSeg       B
actRead         "pointer"
asmax$ref    BS
asxref       BS
asxref$tmp   BS
alignTypes      BS
argNestCnt      B		/* glb4 */
asciiLineNo     BS
asmErrCode      B
azero           A
fixupSeg        B
curFixupHiLoSegId B
curFixupType    B
fixIdxs         BS
initFixupReq    "bool"S
firstContent    "bool"
b6742           "bool"
b6743           "bool"
nameLen         B
inPublic           B
inExtrn           B
segHasData           BS
b6754           B
acc1Flags           B
acc2Flags           B
b6857           B
acc1ValType           B
acc2ValType           B
gotLabel           B
name         BS
savName           BS
b687F           "bool"
haveUserSymbol  "bool"
b6881           "bool"
b6882           B
b6883           "bool"
b6884           "bool"
b6885           "bool"
b6897           "bool"
tokI           B
b689B           B
atStartLine           B
showAddr        "bool"
b68AD           "bool"
b68AE           "bool"
inBuf           BS
b6A00           B
spIdx           B
b6A57           BS
b6A6F           "bool"
b6A71           B
isControlLine      B		
inDB           B
inDW           B
inExpression           "bool"
b6B28           B
effectiveToken           B
op              B
b6B2C           "bool"
b6B2D           B
inNestedParen           B
expectingOperands     "bool"
expectingOpcode       "bool"
b6B32           "bool"
b6B33           "bool"
b6B34           "bool"
inParen           "bool"
b6B36           "bool"
b6BD9           "bool"
b6BDA           "bool"
jj           B
macroLine          BS		/* glb4 */
b9058          "bool"		/* glb4 */
b9059          "bool"		/* glb4 */
b905A          B		/* glb4 */
expandingMacro B		/* glb4 */
b905C          B		/* glb4 */
b905D          "bool"		/* glb4 */
b905E          B		/* glb4 */
b9060          "bool"		/* glb4 */
b9061          "bool"		/* glb4 */
b9062          B		/* glb4 */
macroDepth          B		/* glb4 */
b9064          B		/* glb4 */
b9065          B		/* glb4 */
b9066          B		/* glb4 */
b91A1          B		/* glb4 */
b91A2          B		/* glb4 */
b91A3          B		/* glb4 */
b91A4          BS		/* glb4 */
bp6A4E          BS
accFixFlags          BS
cmdch$p         "pointer"
cmdLineBuf      BS
controlId       B
controls        BS
controlSeen     "bool"S
controls$p      A
ctlCOND         "bool"
ctlDEBUG        "bool"
ctlEJECT        B
ctlGEN          "bool"
ctlLIST         "bool"
ctlMACRODEBUG   "bool"
ctlMACROFILE    "bool"
ctlMOD85        "bool"
ctlOBJECT       "bool"
ctlPAGELENGTH   B
ctlPAGEWIDTH    B
ctlPAGING       "bool"
ctlPRINT        "bool"
ctlSYMBOLS      "bool"
ctlTITLE        "bool"
ctlTITLESTR     BS
ctlTTY          "bool"
ctlXREF         "bool"
curChar         B
curCol          B
curFileName$p   A
curMacroBlk     A		/* glb4 */
curTokenSym$p   "pointer"
tokPtr          "pointer"
endLineBuf      A
endOutBuf       A
endSymTab       AS
errCnt          A
extNamIdx       B
finished        "bool"
fix20Idx        B
fix22Idx        B
fix24Idx        B
fix6Idx         B
has16bitOperand B
ifDepth         B
ii              B
inElse          "bool"S
infd            A
kk              B
lineBuf         BS
pageLineCnt         A
lookAhead       B
lstFile         BS
macroBuf        BS		/* glb4 */
macroCondSP     B		/* glb4 */
macroCondStk    BS		/* glb4 */
MacroDebugOrGen B		/* glb & glb5 */
macrofd         A
macroStk        "MACRO$T"S	/* glb4 */
maxMacroBlk     A		/* glb4 */
maxSegSize      AS
byteAt          BS		/* glb4 */
moduleNameLen   B
nxtMacroBlk     A		/* glb4 */
objfd           A
objFile         BS
macro$p         "pointer"	/* glb4 */
openStatus      A
opSP            B
opStack         BS
opType          B
outbuf          BS
outfd           A
out$p           "pointer"
pageCnt         A
phase           B
primaryValid    B
r$content       "CONTENT$T"
reget           B
r$eof           "EOF$T"
r$extnames1     "EXTNAMES$T"
r$extnames2     "EXTNAMES$T"
r$extref        "EXTREF$T"
r$interseg      "INTERSEG$T"
r$modend        "MODEND$T"
r$publics       "PUBLICS$T"
r$reloc         "RELOC$T"
saveIdx         B
saveStack       BS
scanCmdLine     B
segSize         AS
skipping        "bool"S
startDefined    B
startOffset     A
startSeg        B
statusIO        A
symTab          AS
titleLen        B
tmac$b3         B		/* glb4 */
tmac$blk        A		/* glb4 */
tmac$buf$p      "pointer"	/* glb4 */
tmac$ifDepth    B		/* glb4 */
tmac$macroCondSP B		/* glb4 */
tmac$mtype      B		/* glb4 */
tmac$w10        A		/* glb4 */
tmac$w12        A		/* glb4 */
tmac$w14        A		/* glb4 */
tmac$w4         A		/* glb4 */
tokBuf          BS
tokBufIdx       B
tokBufLen       B
tokenAttr       BS
tokenIdx         B
tokStr          BS
tokenSym        AS
tokenSymId      AS
tokenType       BS
toksiz          BS
tokst           AS
tokType         B
contentBytePtr  "pointer"
fixOffset           A
externId           A
itemOffset           A
acc1NumVal           A
acc2NumVal           A
symHighMark           A
w6870           "pointer"
endItem           A
startItem           A
effectiveAddr           A
sizeInBuf           A
srcLineCnt           A
tokNumVal           A
w6BCE           A
w6BE0          "pointer" 
controlFileType           A
endMacroLine   BS		/* glb4 */
w9068          "pointer"	/* glb4 */
w906A          "pointer"	/* glb4 */
macroBlkCnt          A		/* glb4 */
w9197          A		/* glb4 */
w9199          A		/* glb4 */
w919B          A		/* glb4 */
w919D          A		/* glb4 */
w919F          A		/* glb4 */
wZERO           A
xreffd          A

$file(key4.plm)
extKeywords     AS

$file(keywrd.plm)
stdKeywords     AS

$file(load.plm)
load            P(A path$p,A load$offset,A switch,A entry$p,A status$p)

$file(open.plm)
open            P(A conn$p,A path$p,A access,A echo,A status$p)

$file(read.plm)
read            P(A conn,A buff$p,A count,A actual$p,A status$p)

$file(rescan.plm)
rescan          P(A conn,A status$p)

$file(seek.plm)
seek            P(A conn,A mode,A block$p,A byte$p,A status$p)

$file(write.plm)
write           P(A conn,A buff$p,A count,A status$p)

