asm80$6: do;

$include(asm86.ipx)


declare	b5666(*) byte data(9, 2Dh, 80h),
	b5669(*) byte data(3Ah, 8, 80h, 0, 0, 0, 0, 0, 20h),
			/* 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
	op16(*) byte data(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
			   0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1),
			  /* 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
	chClass(*) byte data(0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 4, 0, 0,	/* 00 */
			     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 10 */
			     1, 0, 0, 0, 6, 0, 0, 7, 5, 5, 5, 5, 5, 5, 0, 5,	/* 20 */
			     8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 3, 2, 0, 0, 0, 9,	/* 30 */
			     9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,	/* 40 */
			     9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0,	/* 50 */
			     0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,	/* 60 */
			     9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0);	/* 70 */



unpackToken: procedure(src, dst) public;
	declare (src, dst) address;
	declare wrd based src address;
	declare ch based dst byte;
	declare packedword address;

	unpack1: procedure;
		ch = packedword mod 40;	
		if ch = 0 then
			ch = ' ';
		else if ch <= 10 then
			ch = ch + 2Fh;	/* digit */
		else 
			ch = ch + 34h;	/* ? @ and letters */
		packedword = packedword / 40;
		dst = dst - 1;
	end;


	src = src + 2;
	dst = dst + 5;
	packedword = wrd;
	call unpack1;
	call unpack1;
	call unpack1;
	src = src - 2;
	packedword = wrd;
	call unpack1;
	call unpack1;
	call unpack1;
end;




insertSym: procedure public;
	declare (w6CE0, w6CE2) address;
	declare ch1 based w6CE0 byte,
		ch2 based w6CE2 byte;

	w686E, w6CE0 = (w6CE2 := w686E) + 8;
	if w6CE0 > w6870 then
		call runtimeError(1);	/* table error */

	do while w6CE2  > curTokenSym$p;
		w6CE0 = w6CE0 - 1;
		w6CE2 = w6CE2 - 1;
		ch1 = ch2;
	end;

	call move(4, curTokStart, curTokenSym$p);
	curTokenSym.type = 0;
end;

declare b6EC4$9C3A byte public;

sub5819$5CE8: procedure(arg1w, arg2b) public;
	declare arg1w address, arg2b byte;
	declare (b6CE8, b6CE9, b6CEA, b6CEB, b6CEC) byte;

	sub$5B9A: procedure;
		tokenType(0) = arg2b;
		if (b6858 = 7 or b6858 = 8) and b6CEB then
			tokenType(0) = 12 - arg2b;
	end;


	b6CEC = tokenType(0);
	b6CEB = arg2b = 5 or arg2b = 4;
	b6CE9 = 0;
	b6CE8 = curTokenSym.flags;
	b6CEA = 0;
	if curTokenSym$p > w6868(1) or curTokenSym$p < symTab(1) then
	do;
		call syntaxError;
		return;
	end;

	if tokenSP > 1 then
		call syntaxError;

	if isPhase1 then
		if tokenType(0) = 9 then
		do;
			if b6883 then
			do;
				if curTokenSym.type >= 80h then
				do;
					call locationError;
					b6CE9 = 80h;
				end;
			end;
			else
			do;
				call insertSym;
				w6868(1) = w6868(1) + 8;
				b6CE8 = 0;
			end;

			b6CE8 = (activeSeg <> 0 and 18h) or (b6748 and 20h) or (b6749 and 58h);
			if b6EC4$9C3A = 1 then
				b6CE8 = b6855;

			if b6EC4$9C3A = 2 then
				b6CE8 = b6CE8 or activeSeg;
			if b6857 and b6CEB then
				tokenType(0) = 64h;
			else
				call sub$5B9A;
			goto L5A9B;
		end;

	if b6882 = 2 then
		if tokenType(0) = 9 then
			if b6858 <> 9 then
				if b6CEB then
				do;
					call sub$5B9A;
					if curTokenSym.type < 128 then
					do;
						curTokenSym.type = tokenType(0);
						curTokenSym.w4 = arg1w;
						b6CE8 = b6855;
						b6CEA = 0FFh;
					end;
					goto L5A9B;
				end;

	if isPhase1 then
		if tokenType(0) = 6 then
			if testBit(arg2b, .b5666) then
			do;
				if b6749 then
					tokenType(0) = 3;
				else
				do;
					tokenType(0) = arg2b;
					b6CE8 = b6CE8 and 0E0h;
					if b6EC4$9C3A = 1 then
						b6CE8 = b6855 or 20h;
					if b6EC4$9C3A = 2 then
						if activeSeg <> 0 then
							b6CE8 = b6CE8 or activeSeg or 38h;
				end;
				goto L5A9B;
			end;

	if isPhase1 then
		if arg2b = 6 then
			if testBit(tokenType(0), .b5666) then
			do;
				if (b6CE8 and 60h) <> 0 then
					tokenType(0) = 3;
				else
					b6CE8 = b6CE8 or 20h;
				goto L5A9B;
			end;

	if isPhase1 then
		if tokenType(0) <> arg2b and tokenType(0) <> 8 or arg2b = 5 then
			tokenType(0) = 3;

	if not b6748 and testBit(tokenType(0), .b5669) then
		b6CE8 = (b6CE8 and 20h) and tokenType(0) <> 3Ah or b6855;
	else
	do;
		if isPhase1 then
			tokenType(0) = 3;

		if not (b6748 or b6749) then
			if curTokenSym.w4 <> arg1w then
				call phaseError;
	end;

L5A9B:
	b6CE9 = b6CE9 or (curTokenSym.type and 80h);
	if isPhase1 and (arg2b = 9 or arg2b = 6 or b6CEC <> tokenType(0)) then
		curTokenSym.type = tokenType(0) or b6CE9;

	jj = curTokenSym.type;
	if tokenType(0) = 3 or jj = 3 then
		call multipleDefError;

	if jj >= 80h then
		call locationError;

	if isPhase1 and (tokenType(0) = arg2b or arg2b = 5 and tokenType(0) = 7) or arg2b = 4 and blankAsmErrCode or b6CEA then
		curTokenSym.w4 = arg1w;
	curTokenSym.flags = b6CE8;
	b6748 = 0;
	b6749 = 0;
	if curTokenSym.type = 6 then
		call undefinedSymbolError;

	b6857 = 0;
	if b6883 then
		call popToken;
end;



lookup: procedure(arg1b) byte public;
	declare arg1b byte;
	declare (lowOffset, highOffset, midOffset, deltaToNext, entryOffset, packedTok$p) address,
		x structure(i byte), b6CFB byte;
	declare symEntry based entryOffset SYMENTRY$T,
		packedTok based packedTok$p (2) address; 
	declare addr based w6BE0 address,
		addrAlt based w6BE0 address;


	packedTok$p = curTokStart;
	if arg1b = 0 then
	do;
		entryOffset = 0;	/* offset to current symbol to compare */
					/* offset of fist to use - hashes packed symbol name */
		deltaToNext = symTab(0) + ((packedTok(0) + packedTok(1)) mod 151) * 8;

		do while deltaToNext <> 0;	/* while not end of chain */
			entryOffset = entryOffset + deltaToNext;	/* point to the next in chain */
			if symEntry.tok(0) = packedTok(0) then		/* check for exact match */
				if symEntry.tok(1) = packedTok(1) then
				do;
					curTokenSym$p = entryOffset;
					tokenType(0) = curTokenSym.type;
					if tokenType(0) < 2Dh then	/* not pseudo op */
						if op16(tokenType(0)) then
							has16bitOperand = 0FFh;

					if curTokenSym.flags = 2 and not ctlMOD85 then	/* RIM/SIM only valid on 8085 */
						call sourceError('O');

					if tokenType(0) = 8 then		/* SP */
					do;
						if not(opType = 24h or opType = 25h) then /* lxi or push/pop/dad/inx/dcx */
							call sourceError('X');
						tokenType(0) = 7;		/* reg */
					end;
					return tokenType(0) and 7Fh;
				end;
			deltaToNext = symEntry.delta;
		end;
		return 9;
	end;

	lowOffset = symTab(arg1b);
	highOffset, entryOffset = w6868(arg1b);

	do while (midOffset := lowOffset + shr((highOffset - lowOffset) and 0FFF0h, 1)) <> entryOffset;
		entryOffset = midOffset;
		if packedTok(0) = symEntry.tok(0) then
		do;
			if packedTok(1) = symEntry.tok(1) then
			do;
				curTokenSym$p = entryOffset;
				tokenType(0) = curTokenSym.type;
				if tokenType(0) = 64h then
					tokenType(0) = 9;
				if (b6884 := (jj := tokenType(0) and 7Fh) = 9) then
					if b6885 then
						curTokenSym.type = 89h;
				return jj;
			end;
			else
				b6CFB = symEntry.tok(1) > packedTok(1);
		end;
		else
			b6CFB = symEntry.tok(0) > packedTok(0);

		entryOffset = midOffset;
		if b6CFB then
			highOffset = entryOffset;
		else
			lowOffset = entryOffset;
	end;

	curTokenSym$p = highOffset;
	if arg1b = 1 and not isSkipping then
	do;
		b6883 = 0;
		b6EC4$9C3A = 0;
		call sub5819$5CE8(w6A4E, b6885 and 80h or 9);
		w6BE0 = .tokenSym;
		do x.i = 1 to tokenSP;
			w6BE0 = w6BE0 + 2;
			if addr >= curTokenSym$p then
				addrAlt = addr + 8;
		end;
		b6883 = 0FFh;
	end;
	return 9;
end;

getCh: procedure byte public;
	declare (curCH, prevCH) byte;

	if not reget then
	do;
		prevCH = curCH;
	L5E54:
		curCH = lookAhead;
		if scanCmdLine then
			lookAhead = nxtCmdCh;
		else
			lookAhead = sub$4879;

		if chClass(curCH) = CC$BAD then
			if curCH = 0 or curCH = 7Fh or curCH = 0Ch then
				goto L5E54;
	end;
	reget = 0;
	return (curChar := curCH);
end;

getChClass: procedure byte public;
	curChar = getCh;
	return chClass(curChar);
end;


chkLF: procedure public;
	if lookAhead = 0Ah then
		lookAhead = 0;
	else
		call illegalCharError;
end;
end;
