asm52: do;

declare TRUE literally '0FFh',
	FALSE literally '0';

close: procedure(w1, w2) external; declare (w1, w2) address; end;
error: procedure(w1) external; declare w1 address; end;
exit: procedure external; end;
load: procedure(w1, w2, w3, w4, w5) external; declare (w1, w2, w3, w4, w5) address; end;
open: procedure(w1, w2, w3, w4, w5) external; declare (w1, w2, w3, w4, w5) address; end;
printCmdLine: procedure external; end;
parseControls: procedure external; end;
skip2NextLine: procedure external; end;
sub$4904: procedure external; end;
sub$54FD: procedure external; end;
printDecimal: procedure(w1) external; declare w1 address; end;		/* overlay 1 */
write: procedure(w1, w2, w3, w4) external; declare (w1, w2, w3, w4) address; end;

getCh: procedure byte external; end;
isSkipping: procedure byte external; end;

declare tokenSize literally 'toksiz',
	tokStart literally 'tokst';

declare (w6A4E, curFileName$p, w6BE0, cmdch$p, statusIO, outfd, out$p, endOutBuf) address external,
	(openStatus, errCnt, controls$p, off6C2C, off6C2E) address external,
	(outbuf, aError, aError$0, errStrsLen)(1) byte external,
	(aBadSyntax, ascCRLF)(1) byte external,
	errStrs(1) address external,
	(phase, ctlPRINT, ctlOBJECT, tokBufIdx, scanCmdLine, b6B33, b6BD9) byte external,
	(b6C27, asmErrCode, b6B2B, b6749, b6754, curChar, b6B20, reget) byte external,
	(b6C21, bZERO, bTRUE, primaryValid, ctlDEBUG, ctlXREF, ctlSYMBOLS, ctlPAGING, b6C30) byte external,
	(b6742, b6855, b6857, b6858, b6859, b6872) byte external,
	(b687F, b6880, b6881, b6884, b6885, b689A, b689B, b689C, b68AB) byte external,
	(b68AD, ctlEJECT, b6B23, b6B24, b6B25, has16bitOperand, b6B30, b6B31, b6B32) byte external,
	(b6B34, b6B35, tokenSP) byte external,
	(tokenSize, skipping, tokenType)(1) byte external;

physmem: procedure address public;
	declare top address at(4);

	return (top - 100h) and 0FF00h;
end;


nxtCmdCh: procedure byte public;
	declare cmdch based cmdch$p byte;
	declare ch byte;

	ch = cmdch;
	cmdch$p = cmdch$p + 1;
	if 'a' <= ch and ch <= 'z' then
		ch = ch and 5Fh;
	return ch;
end;


ioErrChk: procedure public;
	if statusIO = 0 then
		return;
	call error(statusIO);
	call exit;
end;


flushout: procedure public;
	call write(outfd, .outbuf, out$p - .outbuf, .statusIO);
	out$p = .outbuf;
end;

outch: procedure(arg1b) public;
	declare arg1b byte;
	declare ch based out$p byte;

	if out$p = endOutBuf then
		call flushout;
	ch = arg1b;
	out$p = out$p + 1;
end;

outStrN: procedure(arg1w, arg2b) public;
	declare arg1w address, arg2b byte;
	declare ch based arg1w byte;

	do while arg2b > 0;
		call outch(ch);
		arg1w = arg1w + 1;
		arg2b = arg2b - 1;
	end;
end;


closeF: procedure(arg1w) public;
	declare arg1w address;

	call close(arg1w, .statusIO);
end;

isSpace: procedure byte public;
	return curChar = 20h;
end;

isTab: procedure byte public;
	return curChar = 9;
end;

isWhite: procedure byte public;
	return isSpace or isTab;
end;

isRParen: procedure byte public;
	return curChar = 29h;
end;

isCR: procedure byte public;
	return curChar = 0Dh;
end;

isComma: procedure byte public;
	return curChar = 2Ch;
end;

isPhase1: procedure byte public;
	return phase = 1;
end;


skip2EOL: procedure public;
	if not isCR then
		do while getCh <> 0Dh;
		end;
end;

chkGenObj: procedure byte public;
	return (phase = 2) and ctlOBJECT;
end;


isPhase2Print: procedure byte public;
	return phase = 2 and ctlPRINT;
end;

wrConsole: procedure(arg1w, arg2w) public;
	declare (arg1w, arg2w) address;

	call write(0, arg1w, arg2w, .statusIO);
	call ioErrChk;
end;

runtimeError: procedure(arg1b) public;
	declare arg1b byte;

	if b6BD9 then
		return;

	if isPhase1 and arg1b = 0 then
	do;
		b6B33 = TRUE;
		return;
	end;

	w6BE0 = .aError;
	if arg1b = 4 then
		w6BE0 = .aError$0;

	call wrConsole(errStrs(arg1b), errStrsLen(arg1b));
	call wrConsole(w6BE0, 8);
	if isPhase2Print then
	do;
		call outStrN(errStrs(arg1b), errStrsLen(arg1b));
		call outStrN(w6BE0, 8);
	end;
	if arg1b = 4 or arg1b = 3 then
	do;
		if tokBufIdx = 0 then
		do;
			call wrConsole(.aBadSyntax, 12);
			if not scanCmdLine then
			do;
				call skip2NextLine;
				outfd = 0;
				call printDecimal(w6A4E);		/* overlay 1 */
				call outch(0Ah);
			end;
		end;
		else
		do;
			call wrConsole(curFileName$p, tokBufIdx);
			call wrConsole(.ascCRLF, 2);
		end;
	end;
	if arg1b = 0 then
	do;
		b6BD9 = TRUE;
		return;
	end;
	call exit;
end;

ioError: procedure(arg1w) public;
	declare arg1w address;
	declare ch based arg1w byte;

	tokBufIdx = 0;
	curFileName$p = arg1w;

	do while ch <> ' ' and ch <> 0dh and ch <> 9;
		tokBufIdx = tokBufIdx + 1;
		arg1w = arg1w + 1;
	end;
	if b6C27 then
		call runtimeError(3);	/* eof */
	call runtimeError(4);
end;

inOpen: procedure(arg1w, arg2w) address public;
	declare (arg1w, arg2w) address;
	declare open$infd address;

	call open(.open$infd, arg1w, arg2w, 0, .openStatus);
	if openStatus <> 0 then
		call ioError(arg1w);
	return open$infd;
end;


nibble2Ascii: procedure(n) byte public;
	declare n byte;
	n = (n and 0Fh) + '0';
	if n > '9' then
		n = n + 7;
	return n;
end;

put2Hex: procedure(arg1w, arg2b) public;
	declare arg1w address, arg2b byte;

	call arg1w(nibble2Ascii(ror(arg2b, 4)));
	call arg1w(nibble2Ascii(arg2b));
end;

blankAsmErrCode: procedure byte public;
	return asmErrCode = ' ';
end;

blankMorPAsmErrCode: procedure byte public;
	return blankAsmErrCode or asmErrCode = 'M' or asmErrCode = 'P';
end;


getNibble: procedure(bp, idx) byte public;
	declare bp address, idx byte;
	declare b based bp byte;
	declare n byte;

	bp = bp + shr(idx, 1);		/* index into buffer the number of nibbles */
	n = b;				/* pick up the byte there */
	if not idx then			/* pick up the right nibble */
		n = ror(n, 4);
	return n and 0Fh;		/* mask to leave just the nibble */
end;

sourceError: procedure(arg1b) public;
	declare arg1b byte;

	if not isSkipping or b6B2B = 22h then		/* ELSE */
	do;
		if b6749 then
			b6754 = TRUE;
		if blankAsmErrCode then
			errCnt = errCnt + 1;

		if blankMorPAsmErrCode or arg1b = 'L' or arg1b = 'U' then	/* no error or M, P L or U */
			if asmErrCode <> 'L' then	/* override unless already location counter error */
				asmErrCode = arg1b;
	end;
end;

preStatementControls: procedure public;
	do while getCh = '$';
		if isSkipping then
		do;
			call skip2NextLine;
			b6B20 = 0FFh;
		end;
		else
		do;
			call parseControls;
		end;
		call sub$54FD;
	end;
	reget = 1;
end;


sub$3D6D: procedure public;
	cmdch$p = controls$p;
	scanCmdLine = TRUE;
	call parseControls;
	if isPhase2Print then
	do;
		call printCmdLine;
	end;

	if b6C21 then
		call sub$4904;

	b6C21, b6B20, scanCmdLine = bZERO;
	call preStatementControls;
	primaryValid = 0;
	ctlDEBUG = ctlDEBUG and ctlOBJECT;
	ctlXREF = ctlXREF and ctlPRINT;
	ctlSYMBOLS = ctlSYMBOLS and ctlPRINT;
	ctlPAGING = ctlPAGING and ctlPRINT;
end;



sub$3DCE: procedure public;
	off6C2E = off6C2C + 1;
	b6C30 = 0;
	if b6C21 then
		call sub$4904;

	b68AD, has16bitOperand, b6B20, b689B, b687F, b6B25, b6B30, b6881, b6872, b6880,
	b6B23, b6B24, b6B32, b68AB, b6884, b6885 = bZERO;
	b689C, b6B31, b6B34, b6B35 = bTRUE;
	ctlEJECT, b6857, tokenSP, tokenSize(0), tokenType(0), b6858, b6859, b6742, b6855 = bZERO;
	asmErrCode = 20h;
	b689A = 1;
	w6A4E = w6A4E + 1;
	skipping(0) = skipping(0) > 0;
end;

end;
