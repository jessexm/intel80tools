asm52: do;

$include(asm52.ipx)

physmem: procedure address public;
	declare top address at(4);

	return (top - 100h) and 0FF00h;
end;


nxtCmdCh: procedure byte public;
	declare cmdch based cmdch$p byte;
	declare ch byte;

	ch = cmdch;
	cmdch$p = cmdch$p + 1;
	if 'a' <= ch and ch <= 'z' then
		ch = ch and 5Fh;
	return ch;
end;


ioErrChk: procedure public;
	if statusIO = 0 then
		return;
	call error(statusIO);
	call exit;
end;


flushout: procedure public;
	call write(outfd, .outbuf, out$p - .outbuf, .statusIO);
	out$p = .outbuf;
end;

outch: procedure(arg1b) public;
	declare arg1b byte;
	declare ch based out$p byte;

	if out$p = endOutBuf then
		call flushout;
	ch = arg1b;
	out$p = out$p + 1;
end;

outStrN: procedure(arg1w, arg2b) public;
	declare arg1w address, arg2b byte;
	declare ch based arg1w byte;

	do while arg2b > 0;
		call outch(ch);
		arg1w = arg1w + 1;
		arg2b = arg2b - 1;
	end;
end;


closeF: procedure(arg1w) public;
	declare arg1w address;

	call close(arg1w, .statusIO);
end;

isSpace: procedure byte public;
	return curChar = 20h;
end;

isTab: procedure byte public;
	return curChar = 9;
end;

isWhite: procedure byte public;
	return isSpace or isTab;
end;

isRParen: procedure byte public;
	return curChar = 29h;
end;

isCR: procedure byte public;
	return curChar = 0Dh;
end;

isComma: procedure byte public;
	return curChar = 2Ch;
end;

isPhase1: procedure byte public;
	return phase = 1;
end;


skip2EOL: procedure public;
	if not isCR then
		do while getCh <> 0Dh;
		end;
end;

chkGenObj: procedure byte public;
	return (phase = 2) and ctlOBJECT;
end;


isPhase2Print: procedure byte public;
	return phase = 2 and ctlPRINT;
end;

wrConsole: procedure(arg1w, arg2w) public;
	declare (arg1w, arg2w) address;

	call write(0, arg1w, arg2w, .statusIO);
	call ioErrChk;
end;

runtimeError: procedure(arg1b) public;
	declare arg1b byte;

	if b6BD9 then
		return;

	if isPhase1 and arg1b = 0 then
	do;
		b6B33 = TRUE;
		return;
	end;

	w6BE0 = .aError;
	if arg1b = 4 then
		w6BE0 = .aError$0;

	call wrConsole(errStrs(arg1b), errStrsLen(arg1b));
	call wrConsole(w6BE0, 8);
	if isPhase2Print then
	do;
		call outStrN(errStrs(arg1b), errStrsLen(arg1b));
		call outStrN(w6BE0, 8);
	end;
	if arg1b = 4 or arg1b = 3 then
	do;
		if tokBufIdx = 0 then
		do;
			call wrConsole(.aBadSyntax, 12);
			if not scanCmdLine then
			do;
				call skip2NextLine;
				outfd = 0;
				call printDecimal(w6A4E);		/* overlay 1 */
				call outch(0Ah);
			end;
		end;
		else
		do;
			call wrConsole(curFileName$p, tokBufIdx);
			call wrConsole(.ascCRLF, 2);
		end;
	end;
	if arg1b = 0 then
	do;
		b6BD9 = TRUE;
		return;
	end;
	call exit;
end;

ioError: procedure(arg1w) public;
	declare arg1w address;
	declare ch based arg1w byte;

	tokBufIdx = 0;
	curFileName$p = arg1w;

	do while ch <> ' ' and ch <> 0dh and ch <> 9;
		tokBufIdx = tokBufIdx + 1;
		arg1w = arg1w + 1;
	end;
	if b6C27 then
		call runtimeError(3);	/* eof */
	call runtimeError(4);
end;

inOpen: procedure(arg1w, arg2w) address public;
	declare (arg1w, arg2w) address;
	declare open$infd address;

	call open(.open$infd, arg1w, arg2w, 0, .openStatus);
	if openStatus <> 0 then
		call ioError(arg1w);
	return open$infd;
end;


nibble2Ascii: procedure(n) byte public;
	declare n byte;
	n = (n and 0Fh) + '0';
	if n > '9' then
		n = n + 7;
	return n;
end;

put2Hex: procedure(arg1w, arg2b) public;
	declare arg1w address, arg2b byte;

	call arg1w(nibble2Ascii(ror(arg2b, 4)));
	call arg1w(nibble2Ascii(arg2b));
end;

blankAsmErrCode: procedure byte public;
	return asmErrCode = ' ';
end;

blankMorPAsmErrCode: procedure byte public;
	return blankAsmErrCode or asmErrCode = 'M' or asmErrCode = 'P';
end;


getNibble: procedure(bp, idx) byte public;
	declare bp address, idx byte;
	declare b based bp byte;
	declare n byte;

	bp = bp + shr(idx, 1);		/* index into buffer the number of nibbles */
	n = b;				/* pick up the byte there */
	if not idx then			/* pick up the right nibble */
		n = ror(n, 4);
	return n and 0Fh;		/* mask to leave just the nibble */
end;

sourceError: procedure(arg1b) public;
	declare arg1b byte;

	if not isSkipping or b6B2B = 22h then		/* ELSE */
	do;
		if b6749 then
			b6754 = TRUE;
		if blankAsmErrCode then
			errCnt = errCnt + 1;

		if blankMorPAsmErrCode or arg1b = 'L' or arg1b = 'U' then	/* no error or M, P L or U */
			if asmErrCode <> 'L' then	/* override unless already location counter error */
				asmErrCode = arg1b;
	end;
end;

preStatementControls: procedure public;
	do while getCh = '$';
		if isSkipping then
		do;
			call skip2NextLine;
			b6B20 = 0FFh;
		end;
		else
		do;
			call parseControls;
		end;
		call sub$54FD;
	end;
	reget = 1;
end;


initialControls: procedure public;
	cmdch$p = controls$p;
	scanCmdLine = TRUE;
	call parseControls;
	if isPhase2Print then
	do;
		call printCmdLine;
	end;

	if b6C21 then
		call sub$4904;

	b6C21, b6B20, scanCmdLine = bZERO;
	call preStatementControls;
	primaryValid = 0;
	ctlDEBUG = ctlDEBUG and ctlOBJECT;
	ctlXREF = ctlXREF and ctlPRINT;
	ctlSYMBOLS = ctlSYMBOLS and ctlPRINT;
	ctlPAGING = ctlPAGING and ctlPRINT;
end;



sub$3DCE: procedure public;
	off6C2E = off6C2C + 1;
	b6C30 = 0;
	if b6C21 then
		call sub$4904;

	b68AD, has16bitOperand, b6B20, b689B, b687F, b6B25, b6B30, b6881, b6872, b6880,
	b6B23, b6B24, b6B32, b68AB, b6884, b6885 = bZERO;
	b689C, b6B31, b6B34, b6B35 = bTRUE;
	ctlEJECT, b6857, tokenSP, tokenSize(0), tokenType(0), b6858, b6859, b6742, b6855 = bZERO;
	asmErrCode = 20h;
	b689A = 1;
	w6A4E = w6A4E + 1;
	skipping(0) = skipping(0) > 0;
end;

end;
