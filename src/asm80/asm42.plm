asm42:
do;
$include(asm42.ipx)


physmem: procedure address public;
	declare top address at(4);

	return (top - 100h) and 0FF00h;
end;


nxtCmdCh: procedure byte public;
	declare cmdch based cmdch$p byte;
	declare ch byte;

	ch = cmdch;
	cmdch$p = cmdch$p + 1;
	if 'a' <= ch and ch <= 'z' then
		ch = ch and 5Fh;
	return ch;
end;	


ioErrChk: procedure public;
	if statusIO = 0 then
		return;
	call error(statusIO);
	call exit;
end;


flushout: procedure public;
	call write(outfd, .outbuf, out$p - .outbuf, .statusIO);
	out$p = .outbuf;
end;

outch: procedure(arg1b) public;
	declare arg1b byte;
	declare ch based out$p byte;

	if out$p = endOutBuf then
		call flushout;
	ch = arg1b;
	out$p = out$p + 1;
end;

outStrN: procedure(arg1w, arg2b) public;
	declare arg1w address, arg2b byte;
	declare ch based arg1w byte;

	do while arg2b > 0;
		call outch(ch);
		arg1w = arg1w + 1;
		arg2b = arg2b - 1;
	end;
end;

closeF: procedure(arg1w) public;
	declare arg1w address;

	call close(arg1w, .statusIO);
end;

isSpace: procedure byte public;
	return curChar = 20h;
end;

isTab: procedure byte public;
	return curChar = 9;
end;

isWhite: procedure byte public;
	return isSpace or isTab;
end;

isRParen: procedure byte public;
	return curChar = 29h;
end;

isCR: procedure byte public;
	return curChar = 0Dh;
end;

isComma: procedure byte public;
	return curChar = 2Ch;
end;

isLT: procedure byte public;
	return curChar = '<';
end;


isGT: procedure byte public;
	return curChar = '>';
end;

isPhase1: procedure byte public;
	return phase = 1;
end;

skip2EOL: procedure public;
	if not isCR then
		do while getCh <> 0Dh;
		end;
end;


chkGenObj: procedure byte public;
	return (phase = 2) and ctlOBJECT;
end;

isPhase2Print: procedure byte public;
	return phase = 2 and ctlPRINT;
end;

wrConsole: procedure(arg1w, arg2w) public;
	declare (arg1w, arg2w) address;

	call write(0, arg1w, arg2w, .statusIO);
	call ioErrChk;
end;


runtimeError: procedure(arg1b) public;
	declare arg1b byte;

	if b6BD9 then
		return;

	if isPhase1 and arg1b = 0 then
	do;
		b6B33 = TRUE;
		return;
	end;

	w6BE0 = .aError;
	if arg1b = 4 then
		w6BE0 = .aError$0;

	call wrConsole(errStrs(arg1b), errStrsLen(arg1b));
	call wrConsole(w6BE0, 8);
	if isPhase2Print then
	do;
		call outStrN(errStrs(arg1b), errStrsLen(arg1b));
		call outStrN(w6BE0, 8);
	end;

	if arg1b = 4 or arg1b = 3 then
	do;
		if tokBufIdx = 0 then
		do;
			call wrConsole(.aBadSyntax, 12);
			if not scanCmdLine then
			do;
				call skip2NextLine;
				outfd = 0;
				call printDecimal(w6A4E);
				call outch(0Ah);
			end;
		end;
		else
		do;
			call wrConsole(curFileName$p, tokBufIdx);
			call wrConsole(.ascCRLF, 2);
		end;
	end;

	if arg1b = 0 then
	do;
		b6BD9 = TRUE;
		return;
	end;

	call exit;
end;

ioError: procedure(arg1w) public;
	declare arg1w address;
	declare ch based arg1w byte;

	tokBufIdx = 0;
	curFileName$p = arg1w;

	do while ch <> ' ' and ch <> 0dh and ch <> 9;
		tokBufIdx = tokBufIdx + 1;
		arg1w = arg1w + 1;
	end;
	if b6C27 then
		call runtimeError(3);	/* eof */
	call runtimeError(4);
end;

inOpen: procedure(path$p, access) address public;
	declare (path$p, access) address;
	declare open$infd address;

	call open(.open$infd, path$p, access, 0, .openStatus);
	if openStatus <> 0 then
		call ioError(path$p);
	return open$infd;
end;


nibble2Ascii: procedure(n) byte public;
	declare n byte;
	n = (n and 0Fh) + '0';
	if n > '9' then
		n = n + 7;
	return n;
end;

put2Hex: procedure(arg1w, arg2b) public;
	declare arg1w address, arg2b byte;

	call arg1w(nibble2Ascii(ror(arg2b, 4)));
	call arg1w(nibble2Ascii(arg2b));
end;

blankAsmErrCode: procedure byte public;
	return asmErrCode = ' ';
end;

blankMorPAsmErrCode: procedure byte public;
	return blankAsmErrCode or asmErrCode = 'M' or asmErrCode = 'P';
end;


getNibble: procedure(arg1w, arg2b) byte public;
	declare arg1w address, arg2b byte;
	declare ch based arg1w byte;
	declare b6C11 byte;

	arg1w = arg1w + shr(arg2b, 1);
	b6C11 = ch;
	if not arg2b then
		b6C11 = ror(b6C11, 4);
	return b6C11 and 0Fh;
end;

sourceError: procedure(arg1b) public;
	declare arg1b byte;

	if not isSkipping or b6B2B = 22h then
	do;
		if b6749 then
			b6754 = TRUE;
		if blankAsmErrCode then
			errCnt = errCnt + 1;

		if blankMorPAsmErrCode or arg1b = 'L' or arg1b = 'U' then
			if asmErrCode <> 'L' then
				asmErrCode = arg1b;
	end;
end;

sub$3D34: procedure(arg1b) public;
	declare arg1b byte;
	declare ch based w$906A byte;

	ch = arg1b;
	if (w$906A := w$906A + 1) > w6870 then
		call runtimeError(1);	/* table error */
end;


sub$3D55: procedure(arg1b) public;
	declare arg1b byte;

	call sub$3D34(arg1b);
	if arg1b = 0Dh then
		call sub$3D34(0Ah);
end;



preStatementControls: procedure public;

	do while getCh = '$';
		if isSkipping then
		do;
			call skip2NextLine;
			b6B20$9A77 = 0FFh;
			if b$905E = 1 then
				b6897 = 0FFh;
		end;
		else
			call parseControls;
		call sub$4C1E;
	end;
	reget = 1;
end;


sub$3DA4: procedure public;
	cmdch$p = controls$p;
	scanCmdLine = 0FFh;
	call parseControls;
	if isPhase2Print then
		call printCmdLine;

	if b6C21 then
		call sub$4904;

	b6C21, b6B20$9A77, scanCmdLine = bZERO;
	call preStatementControls;
	primaryValid = 0;
	ctlDEBUG = ctlDEBUG and ctlOBJECT;
	ctlXREF = ctlXREF and ctlPRINT;
	ctlSYMBOLS = ctlSYMBOLS and ctlPRINT;
	ctlPAGING = ctlPAGING and ctlPRINT;
end;


sub$3DFB: procedure public;
	off$6C2E = off$6C2C + 1;
	b6C30 = 0;
	if b6C21 then
		call sub$4904;

	b68AD, has16bitOperand, b6B20$9A77, b689B, b687F, b6B25, b6B30, b6881, b6872, b6880,
	b6B23, b6B24, b6B32, b68AB, b6884, b$9059, b$9060, b6885 = bZERO;
	b689C, b6B31, b6B34, b6B35 = bTRUE;
	ctlEJECT, b6857, tokenSP, b$9058, argNestCnt, tokenSize(0), tokenType(0), b6858, b6859, b6742, b6855 = bZERO;
	asmErrCode = 20h;
	off$9056 = .b$8FD5;
	w$919D = w$906A;
	b$905B = b$905B > 0;
	b689A = 1;
	w6A4E = w6A4E + 1;
	off$9056 = .b$8FD5;
	skipping(0) = skipping(0) > 0;
end;

end;

/* pckToken code follows */

