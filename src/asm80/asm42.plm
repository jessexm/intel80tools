asm42:
do;

declare TRUE literally '0FFh';

declare tokenSize literally 'toksiz',
	tokStart literally 'tokst';
declare (aBadSyntax, aError, ascCRLF, aError$0, tokenSize)(1) byte external,
	(bZERO, bTRUE, b6749, b6754, tokenSP, tokenType) byte external,
	(b6855, b6857, b6858, b6859, curChar, reget, b6872) byte external,
	(b687F, b6880, b6881, b6884, b6885, asmErrCode, b6897) byte external,
	(primaryValid, b689A, b689B, b689C, b68AB, b68AD, ctlDEBUG) byte external,
	(ctlXREF, ctlSYMBOLS, ctlPAGING, ctlPRINT, ctlOBJECT, ctlEJECT, tokBufIdx) byte external,
	(scanCmdLine, b6B23, b6B24, b6B25, has16bitOperand, phase, b6B2B) byte external,
	(b6B30, b6B31, b6B32, b6B33, b6B34, b6B35, b6BD9) byte external,
	(b6C27, b6C21, b6C30) byte external,
	(b6742, skipping, b$9A77) byte external,
	(cmdch$p, endOutBuf, openStatus, outbuf, outfd, out$p) address external,
	(w6870, w6A4E, errCnt, controls$p, curFileName$p, w6BE0, statusIO) address external,
	(errStrs)(1) address external,
	(errStrsLen)(1) byte external,
	(off$6C2C, off$6C2E) address external;

isSkipping: procedure byte external; end;
getCh: procedure byte external; end;


close: procedure(w1, w2) external; declare (w1, w2) address; end;
error: procedure(w1) external; declare w1 address; end;
exit: procedure external; end;
open: procedure(w1, w2, w3, w4, w5) external; declare (w1, w2, w3, w4, w5) address; end;
skip2NextLine: procedure external; end;
sub$4904: procedure external; end;
sub$4C1E: procedure external; end;
sub$70D7: procedure external; end;
printDecimal: procedure(w1) external; declare w1 address; end;
printCmdLine: procedure external; end;
write: procedure(w1, w2, w3, w4) external; declare (w1, w2, w3, w4) address; end;


/* global data */
declare b$8FD5(127) byte external,
	w$9054 address external,
	off$9056 address external,
	b$9058 byte external,
	b$9059 byte external,
	b$905A byte external,
	b$905B byte external,
	b$905C byte external,
	b$905D byte external,
	b$905E byte external,
	b$9060 byte external,
	b$9061 byte external,
	b$9062 byte external,
	b$9063 byte external,
	b$9064 byte external,
	b$9065 byte external,
	b$9066 byte external,
	argNestCnt byte external,
	w$9068 address external,
	w$906A address external,

	(tmac$macroCondSP, tmac$ifDepth, tmac$mtype, tmac$b3) byte external,
	(tmac$w4, tmac$buf$p, tmac$blk, tmac$w10, tmac$w12, tmac$w14) address external,
	curMacroBlk address external,
	nxtMacroBlk address external,
	maxMacroBlk address external,
	w$9114 address external,
	macroBuf(129) byte external,
	w$9197 address external,
	w$9199 address external,
	w$919B address external,
	w$919D address external,
	w$919F address external,
	b$91A1 byte external,
	b$91A2 byte external,
	b$91A3 byte external,
	b$91A4(1) byte external;

	
		
	


physmem: procedure address public;
	declare top address at(4);

	return (top - 100h) and 0FF00h;
end;


nxtCmdCh: procedure byte public;
	declare cmdch based cmdch$p byte;
	declare ch byte;

	ch = cmdch;
	cmdch$p = cmdch$p + 1;
	if 'a' <= ch and ch <= 'z' then
		ch = ch and 5Fh;
	return ch;
end;	


ioErrChk: procedure public;
	if statusIO = 0 then
		return;
	call error(statusIO);
	call exit;
end;


flushout: procedure public;
	call write(outfd, .outbuf, out$p - .outbuf, .statusIO);
	out$p = .outbuf;
end;

outch: procedure(arg1b) public;
	declare arg1b byte;
	declare ch based out$p byte;

	if out$p = endOutBuf then
		call flushout;
	ch = arg1b;
	out$p = out$p + 1;
end;

outStrN: procedure(arg1w, arg2b) public;
	declare arg1w address, arg2b byte;
	declare ch based arg1w byte;

	do while arg2b > 0;
		call outch(ch);
		arg1w = arg1w + 1;
		arg2b = arg2b - 1;
	end;
end;

closeF: procedure(arg1w) public;
	declare arg1w address;

	call close(arg1w, .statusIO);
end;

isSpace: procedure byte public;
	return curChar = 20h;
end;

isTab: procedure byte public;
	return curChar = 9;
end;

isWhite: procedure byte public;
	return isSpace or isTab;
end;

isRParen: procedure byte public;
	return curChar = 29h;
end;

isCR: procedure byte public;
	return curChar = 0Dh;
end;

isComma: procedure byte public;
	return curChar = 2Ch;
end;

isLT: procedure byte public;
	return curChar = '<';
end;


isGT: procedure byte public;
	return curChar = '>';
end;

isPhase1: procedure byte public;
	return phase = 1;
end;

skip2EOL: procedure public;
	if not isCR then
		do while getCh <> 0Dh;
		end;
end;


chkGenObj: procedure byte public;
	return (phase = 2) and ctlOBJECT;
end;

isPhase2Print: procedure byte public;
	return phase = 2 and ctlPRINT;
end;

wrConsole: procedure(arg1w, arg2w) public;
	declare (arg1w, arg2w) address;

	call write(0, arg1w, arg2w, .statusIO);
	call ioErrChk;
end;


runtimeError: procedure(arg1b) public;
	declare arg1b byte;

	if b6BD9 then
		return;

	if isPhase1 and arg1b = 0 then
	do;
		b6B33 = TRUE;
		return;
	end;

	w6BE0 = .aError;
	if arg1b = 4 then
		w6BE0 = .aError$0;

	call wrConsole(errStrs(arg1b), errStrsLen(arg1b));
	call wrConsole(w6BE0, 8);
	if isPhase2Print then
	do;
		call outStrN(errStrs(arg1b), errStrsLen(arg1b));
		call outStrN(w6BE0, 8);
	end;

	if arg1b = 4 or arg1b = 3 then
	do;
		if tokBufIdx = 0 then
		do;
			call wrConsole(.aBadSyntax, 12);
			if not scanCmdLine then
			do;
				call skip2NextLine;
				outfd = 0;
				call printDecimal(w6A4E);
				call outch(0Ah);
			end;
		end;
		else
		do;
			call wrConsole(curFileName$p, tokBufIdx);
			call wrConsole(.ascCRLF, 2);
		end;
	end;

	if arg1b = 0 then
	do;
		b6BD9 = TRUE;
		return;
	end;

	call exit;
end;

ioError: procedure(arg1w) public;
	declare arg1w address;
	declare ch based arg1w byte;

	tokBufIdx = 0;
	curFileName$p = arg1w;

	do while ch <> ' ' and ch <> 0dh and ch <> 9;
		tokBufIdx = tokBufIdx + 1;
		arg1w = arg1w + 1;
	end;
	if b6C27 then
		call runtimeError(3);	/* eof */
	call runtimeError(4);
end;

inOpen: procedure(arg1w, arg2w) address public;
	declare (arg1w, arg2w) address;
	declare open$infd address;

	call open(.open$infd, arg1w, arg2w, 0, .openStatus);
	if openStatus <> 0 then
		call ioError(arg1w);
	return open$infd;
end;


nibble2Ascii: procedure(n) byte public;
	declare n byte;
	n = (n and 0Fh) + '0';
	if n > '9' then
		n = n + 7;
	return n;
end;

put2Hex: procedure(arg1w, arg2b) public;
	declare arg1w address, arg2b byte;

	call arg1w(nibble2Ascii(ror(arg2b, 4)));
	call arg1w(nibble2Ascii(arg2b));
end;

blankAsmErrCode: procedure byte public;
	return asmErrCode = 20h;
end;

blankMorPAsmErrCode: procedure byte public;
	return blankAsmErrCode or asmErrCode = 'M' or asmErrCode = 'P';
end;


getNibble: procedure(arg1w, arg2b) byte public;
	declare arg1w address, arg2b byte;
	declare ch based arg1w byte;
	declare b6C11 byte;

	arg1w = arg1w + shr(arg2b, 1);
	b6C11 = ch;
	if not arg2b then
		b6C11 = ror(b6C11, 4);
	return b6C11 and 0Fh;
end;

sourceError: procedure(arg1b) public;
	declare arg1b byte;

	if not isSkipping or b6B2B = 22h then
	do;
		if b6749 then
			b6754 = TRUE;
		if blankAsmErrCode then
			errCnt = errCnt + 1;

		if blankMorPAsmErrCode or arg1b = 'L' or arg1b = 'U' then
			if asmErrCode <> 'L' then
				asmErrCode = arg1b;
	end;
end;

sub$3D34: procedure(arg1b) public;
	declare arg1b byte;
	declare ch based w$906A byte;

	ch = arg1b;
	if (w$906A := w$906A + 1) > w6870 then
		call runtimeError(1);	/* table error */
end;


sub$3D55: procedure(arg1b) public;
	declare arg1b byte;

	call sub$3D34(arg1b);
	if arg1b = 0Dh then
		call sub$3D34(0Ah);
end;



preStatementControls: procedure public;

	do while getCh = '$';
		if isSkipping then
		do;
			call skip2NextLine;
			b$9A77 = 0FFh;
			if b$905E = 1 then
				b6897 = 0FFh;
		end;
		else
			call sub$70D7;
		call sub$4C1E;
	end;
	reget = 1;
end;


sub$3DA4: procedure public;
	cmdch$p = controls$p;
	scanCmdLine = 0FFh;
	call sub$70D7;
	if isPhase2Print then
		call printCmdLine;

	if b6C21 then
		call sub$4904;

	b6C21, b$9A77, scanCmdLine = bZERO;
	call preStatementControls;
	primaryValid = 0;
	ctlDEBUG = ctlDEBUG and ctlOBJECT;
	ctlXREF = ctlXREF and ctlPRINT;
	ctlSYMBOLS = ctlSYMBOLS and ctlPRINT;
	ctlPAGING = ctlPAGING and ctlPRINT;
end;


sub$3DFB: procedure public;
	off$6C2E = off$6C2C + 1;
	b6C30 = 0;
	if b6C21 then
		call sub$4904;

	b68AD, has16bitOperand, b$9A77, b689B, b687F, b6B25, b6B30, b6881, b6872, b6880,
	b6B23, b6B24, b6B32, b68AB, b6884, b$9059, b$9060, b6885 = bZERO;
	b689C, b6B31, b6B34, b6B35 = bTRUE;
	ctlEJECT, b6857, tokenSP, b$9058, argNestCnt, tokenSize(0), tokenType, b6858, b6859, b6742, b6855 = bZERO;
	asmErrCode = 20h;
	off$9056 = .b$8FD5;
	w$919D = w$906A;
	b$905B = b$905B > 0;
	b689A = 1;
	w6A4E = w6A4E + 1;
	off$9056 = .b$8FD5;
	skipping = skipping > 0;
end;

end;

/* pckToken code follows */

