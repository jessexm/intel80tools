asm42:
do;

declare TRUE literally '0FFh';

declare tokenSize literally 'toksiz',
	tokStart literally 'tokst';
declare (aBadSyntax, aError, asc$3699, aError$0, tokenSize)(1) byte external,
	(cZERO, c255, b6749, b6754, tokenSP, tokenType) byte external,
	(b6855, b6857, b6858, b6859, curChar, reget, b6872) byte external,
	(b687F, b6880, b6881, b6884, b6885, b6896, b6897) byte external,
	(b6898, b689A, b689B, b689C, b68AB, b68AD, optDEBUG) byte external,
	(optXREF, optSYMBOLS, optPAGING, optPRINT, optOBJECT, optEJECT, collectBufIdx) byte external,
	(scanOptions, b6B23, b6B24, b6B25, needAddrOperand, phase, b6B2B) byte external,
	(b6B30, b6B31, b6B32, b6B33, b6B34, b6B35, b6BD9) byte external,
	(b6C27, b6C21, b6C30) byte external,
	(b6742, skipping, b$9A77) byte external,
	(cmdch$p, endOutBuf, openStatus, outbuf, outfd, out$p) address external,
	(w6870, w6A4E, errCnt, options$p, curFileName$p, w6BE0, statusIO) address external,
	(errStrs)(1) address external,
	(errStrsLen)(1) byte external,
	(off$6C2C, off$6C2E) address external;

isSkipping: procedure byte external; end;
getChX: procedure byte external; end;


close: procedure(w1, w2) external; declare (w1, w2) address; end;
error: procedure(w1) external; declare w1 address; end;
exit: procedure external; end;
open: procedure(w1, w2, w3, w4, w5) external; declare (w1, w2, w3, w4, w5) address; end;
skip2NextLine: procedure external; end;
sub$4904: procedure external; end;
sub$4C1E: procedure external; end;
sub$70D7: procedure external; end;
printDecimal: procedure(w1) external; declare w1 address; end;
ovl1: procedure external; end;
write: procedure(w1, w2, w3, w4) external; declare (w1, w2, w3, w4) address; end;


/* global data */
declare b$8FD5(127) byte external,
	w$9054 address external,
	off$9056 address external,
	b$9058 byte external,
	b$9059 byte external,
	b$905A byte external,
	b$905B byte external,
	b$905C byte external,
	b$905D byte external,
	b$905E byte external,
	b$9060 byte external,
	b$9061 byte external,
	b$9062 byte external,
	b$9063 byte external,
	b$9064 byte external,
	b$9065 byte external,
	b$9066 byte external,
	b$9067 byte external,
	w$9068 address external,
	w$906A address external,
	s906C structure(macroCondSP byte, ifDepth byte, mtype byte, b3 byte,
			     w4 address, buf$p address, blk address, w10 address,
			     w12 address, w14 address) external,
	curMacroBlk address external,
	nxtMacroBlk address external,
	maxMacroBlk address external,
	w$9114 address external,
	macroBuf(129) byte external,
	w$9197 address external,
	w$9199 address external,
	w$919B address external,
	w$919D address external,
	w$919F address external,
	b$91A1 byte external,
	b$91A2 byte external,
	b$91A3 byte external,
	b$91A4(1) byte external;

	
		
	


physmem: procedure address public;
	declare top address at(4);

	return (top - 100h) and 0FF00h;
end;


nxtCmdCh: procedure byte public;
	declare cmdch based cmdch$p byte;
	declare ch byte;

	ch = cmdch;
	cmdch$p = cmdch$p + 1;
	if 'a' <= ch and ch <= 'z' then
		ch = ch and 5Fh;
	return ch;
end;	


ioErrChk: procedure public;
	if statusIO = 0 then
		return;
	call error(statusIO);
	call exit;
end;


flushout: procedure public;
	call write(outfd, .outbuf, out$p - .outbuf, .statusIO);
	out$p = .outbuf;
end;

outch: procedure(arg1b) public;
	declare arg1b byte;
	declare ch based out$p byte;

	if out$p = endOutBuf then
		call flushout;
	ch = arg1b;
	out$p = out$p + 1;
end;

outStrN: procedure(arg1w, arg2b) public;
	declare arg1w address, arg2b byte;
	declare ch based arg1w byte;

	do while arg2b > 0;
		call outch(ch);
		arg1w = arg1w + 1;
		arg2b = arg2b - 1;
	end;
end;

closeF: procedure(arg1w) public;
	declare arg1w address;

	call close(arg1w, .statusIO);
end;

isSpace: procedure byte public;
	return curChar = 20h;
end;

isTab: procedure byte public;
	return curChar = 9;
end;

isWhite: procedure byte public;
	return isSpace or isTab;
end;

isRParen: procedure byte public;
	return curChar = 29h;
end;

isCR: procedure byte public;
	return curChar = 0Dh;
end;

isComma: procedure byte public;
	return curChar = 2Ch;
end;

isLT: procedure byte public;
	return curChar = '<';
end;


isGT: procedure byte public;
	return curChar = '>';
end;

isPhase1: procedure byte public;
	return phase = 1;
end;

skip2EOL: procedure public;
	if not isCR then
		do while getChX <> 0Dh;
		end;
end;


sub$3A6A: procedure byte public;
	return (phase = 2) and optOBJECT;
end;

isPhase2Print: procedure byte public;
	return phase = 2 and optPRINT;
end;

wrConsole: procedure(arg1w, arg2w) public;
	declare (arg1w, arg2w) address;

	call write(0, arg1w, arg2w, .statusIO);
	call ioErrChk;
end;


sub$3AAB: procedure(arg1b) public;
	declare arg1b byte;

	if b6BD9 then
		return;

	if isPhase1 and arg1b = 0 then
	do;
		b6B33 = TRUE;
		return;
	end;

	w6BE0 = .aError;
	if arg1b = 4 then
		w6BE0 = .aError$0;

	call wrConsole(errStrs(arg1b), errStrsLen(arg1b));
	call wrConsole(w6BE0, 8);
	if isPhase2Print then
	do;
		call outStrN(errStrs(arg1b), errStrsLen(arg1b));
		call outStrN(w6BE0, 8);
	end;

	if arg1b = 4 or arg1b = 3 then
	do;
		if collectBufIdx = 0 then
		do;
			call wrConsole(.aBadSyntax, 12);
			if not scanOptions then
			do;
				call skip2NextLine;
				outfd = 0;
				call printDecimal(w6A4E);
				call outch(0Ah);
			end;
		end;
		else
		do;
			call wrConsole(curFileName$p, collectBufIdx);
			call wrConsole(.asc$3699, 2);
		end;
	end;

	if arg1b = 0 then
	do;
		b6BD9 = TRUE;
		return;
	end;

	call exit;
end;

fileError: procedure(arg1w) public;
	declare arg1w address;
	declare ch based arg1w byte;

	collectBufIdx = 0;
	curFileName$p = arg1w;

	do while ch <> ' ' and ch <> 0dh and ch <> 9;
		collectBufIdx = collectBufIdx + 1;
		arg1w = arg1w + 1;
	end;
	if b6C27 then
		call sub$3AAB(3);
	call sub$3AAB(4);
end;

inOpen: procedure(arg1w, arg2w) address public;
	declare (arg1w, arg2w) address;
	declare open$infd address;

	call open(.open$infd, arg1w, arg2w, 0, .openStatus);
	if openStatus <> 0 then
		call fileError(arg1w);
	return open$infd;
end;


nibble2Ascii: procedure(n) byte public;
	declare n byte;
	n = (n and 0Fh) + '0';
	if n > '9' then
		n = n + 7;
	return n;
end;

put2Hex: procedure(arg1w, arg2b) public;
	declare arg1w address, arg2b byte;

	call arg1w(nibble2Ascii(ror(arg2b, 4)));
	call arg1w(nibble2Ascii(arg2b));
end;

xisSpace: procedure byte public;
	return b6896 = 20h;
end;

sub$3C91: procedure byte public;
	return xisSpace or b6896 = 'M' or b6896 = 'P';
end;


getNibble: procedure(arg1w, arg2b) byte public;
	declare arg1w address, arg2b byte;
	declare ch based arg1w byte;
	declare b6C11 byte;

	arg1w = arg1w + shr(arg2b, 1);
	b6C11 = ch;
	if not arg2b then
		b6C11 = ror(b6C11, 4);
	return b6C11 and 0Fh;
end;

sub$3CDF: procedure(arg1b) public;
	declare arg1b byte;

	if not isSkipping or b6B2B = 22h then
	do;
		if b6749 then
			b6754 = TRUE;
		if xisSpace then
			errCnt = errCnt + 1;

		if sub$3C91 or arg1b = 'L' or arg1b = 'U' then
			if b6896 <> 'L' then
				b6896 = arg1b;
	end;
end;

sub$3D34: procedure(arg1b) public;
	declare arg1b byte;
	declare ch based w$906A byte;

	ch = arg1b;
	if (w$906A := w$906A + 1) > w6870 then
		call sub$3AAB(1);
end;


sub$3D55: procedure(arg1b) public;
	declare arg1b byte;

	call sub$3D34(arg1b);
	if arg1b = 0Dh then
		call sub$3D34(0Ah);
end;



sub$3D6E: procedure public;

	do while getChX = '$';
		if isSkipping then
		do;
			call skip2NextLine;
			b$9A77 = 0FFh;
			if b$905E = 1 then
				b6897 = 0FFh;
		end;
		else
			call sub$70D7;
		call sub$4C1E;
	end;
	reget = 1;
end;


sub$3DA4: procedure public;
	cmdch$p = options$p;
	scanOptions = 0FFh;
	call sub$70D7;
	if isPhase2Print then
		call ovl1;

	if b6C21 then
		call sub$4904;

	b6C21, b$9A77, scanOptions = cZERO;
	call sub$3D6E;
	b6898 = 0;
	optDEBUG = optDEBUG and optOBJECT;
	optXREF = optXREF and optPRINT;
	optSYMBOLS = optSYMBOLS and optPRINT;
	optPAGING = optPAGING and optPRINT;
end;


sub$3DFB: procedure public;
	off$6C2E = off$6C2C + 1;
	b6C30 = 0;
	if b6C21 then
		call sub$4904;

	b68AD, needAddrOperand, b$9A77, b689B, b687F, b6B25, b6B30, b6881, b6872, b6880,
	b6B23, b6B24, b6B32, b68AB, b6884, b$9059, b$9060, b6885 = cZERO;
	b689C, b6B31, b6B34, b6B35 = c255;
	optEJECT, b6857, tokenSP, b$9058, b$9067, tokenSize(0), tokenType, b6858, b6859, b6742, b6855 = cZERO;
	b6896 = 20h;
	off$9056 = .b$8FD5;
	w$919D = w$906A;
	b$905B = b$905B > 0;
	b689A = 1;
	w6A4E = w6A4E + 1;
	off$9056 = .b$8FD5;
	skipping = skipping > 0;
end;

end;

/* pckToken code follows */

