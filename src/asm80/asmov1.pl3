asmov1: do;

$include(global.inc)

declare	aAssemblyComple(*) byte initial(0Dh, 0Ah, 'ASSEMBLY COMPLETE,'),
	aNoErrors(*) byte initial('   NO ERRORS'),
	asc$751E(*) byte initial(' ('),
	asc$7520(*) byte initial('     )'),
	aPublicSymbols(*) byte initial(0Dh, 0Ah, 'PUBLIC SYMBOLS', 0Dh, 0Ah, 0),
	aExternalSymbol(*) byte initial(0Dh, 0Ah, 'EXTERNAL SYMBOLS', 0Dh, 0Ah, 0),
	pad754E address,

	aUserSymbols(*) byte data(0Dh, 0Ah, 'USER SYMBOLS', 0Dh, 0Ah, 0),
	aLocObjLineSour(*) byte data('  LOC  OBJ         LINE        SOURCE STATEMENT', 0Dh, 0Ah, 0Ah, 0),
	wa6DB2(*) address data(.aPublicSymbols, .aExternalSymbol, .aUserSymbols),
	asc$6DB8(*) byte data(0Dh, 0Ah, 0Ah, 0),
	asc$6DBC(*) byte data(0Dh),
	asc$6DBD(*) byte data(0Ah, 0Ah, 0Ah, 0),
	b6DC1(2) byte data(20h, 40h),
	asc$6DC3(*) byte data(' (', 0),
	asc$6DC6(*) byte data(')', 0),
	a1234(*) byte data('  1234');	



exit: procedure external; end;
flushout: procedure external; end;
ioErrChk: procedure external; end;
load: procedure(w1, w2, w3, w4, w5) external; declare (w1, w2, w3, w4, w5) address; end;
outch: procedure(b) external; declare b byte; end;
closeF: procedure(w) external; declare w address; end;
put2Hex: procedure(w1, w2) external; declare (w1, w2) address; end;
sub$546F: procedure external; end;
unpackToken: procedure(w1, w2) external; declare (w1, w2) address; end;
sub$465B: procedure byte external; end;
isPhase2Print: procedure byte external; end;
isSkipping: procedure byte external; end;
xisSpace: procedure byte external; end;
physmem: procedure address external; end;


declare (asc$3692, aIsisIi80808085, asc$3680)(1) byte external,
	(b6C21, fileIdx, b6C30) byte external,
	(off6C2C, off6C2E) address external;

out2Hex: procedure(arg1b);
	declare arg1b byte;
	call put2Hex(.outch, arg1b);
end;


print2Hex: procedure(arg1b);
	declare arg1b byte;
	call put2Hex(.printChar, arg1b);
end;



printStr: procedure(arg1w) reentrant;
	declare arg1w address;
	declare ch based arg1w byte;

	do while ch <> 0;
		call printChar(ch);
		arg1w = arg1w + 1;
	end;
end;

printNStr: procedure(arg1b, arg2w) reentrant;
	declare arg1b byte, arg2w address;
	declare ch based arg2w byte;

	do while arg1b > 0;
		call printChar(ch);
		arg2w = arg2w + 1;
		arg1b = arg1b - 1;
	end;
end;


printCRLF: procedure reentrant;
	call printChar(0Dh);
	call printChar(0Ah);
end;

declare asc$7752 byte initial(' '),
	asc$7553(*) byte initial('    ', 0);


itoa: procedure(arg1w, arg2w);
	declare (arg1w, arg2w) address;
	declare ch based arg2w byte;

	call move(5, .asc$3692 + 1, arg2w);
	arg2w = arg2w + 4;

	do while 1;
		ch = arg1w mod 10 + '0';
		arg2w = arg2w - 1;
		if (arg1w := arg1w /10) = 0 then
			return;
	end;
end;


printDecimal: procedure(arg1w) reentrant public;
	declare arg1w address;
	call itoa(arg1w, .asc$7752);
	call printStr(.asc$7553);
end;

skipToEOP: procedure public;
	do while lineCnt <= optPAGELENGTH;
		call outch(0Ah);
		lineCnt = lineCnt + 1;
	end;
end;


newPageHeader: procedure public;
	call printStr(.asc$6DBD);
	call printStr(.aIsisIi80808085);
	call printDecimal(pageCnt);
	call printCRLF;
	if optTITLE then
		call printNStr(titleLen, .optTITLESTR);

	call printCRLF;
	call printCRLF;
	if not b68AE(0) then
		call printStr(.aLocObjLineSour);
	pageCnt = pageCnt + 1;
end;


newPage: procedure public;
	if optTTY then
		call skipToEOP;
	else
		call outch(0Ch);

	lineCnt = 1;
	if not scanOptions then
		call newPageHeader;
end;


sub$6F4D: procedure public;
	if sub$465B then
	do while optEJECT > 0;
		call newPage;
		optEJECT = optEJECT - 1;
	end;
end;



printChar: procedure(arg1b) reentrant;
	declare arg1b byte;
	declare cnt byte;
	
	if arg1b = 0Ch then
	do;
		call newPage;
		return;
	end;
	if arg1b = 0Ah then
		if optPAGING then
		do;
			if (lineCnt := lineCnt + 1) >= optPAGELENGTH - 2 then
			do;
				if optTTY then
					call outch(0Ah);
				if optEJECT > 0 then
					optEJECT = optEJECT - 1;
				call newPage;
				return;
			end;
		end;
	if arg1b = 0Dh then
		curCol = 0;
	cnt = 1;
	if arg1b = 9 then
	do;
		cnt = 8 - (curCol and 7);
		arg1b = ' ';
	end;
	do while cnt <> 0;
		if curCol < 132 then
		do;
			if arg1b >= ' ' then
				curCol = curCol + 1;
			if curCol > optPAGEWIDTH then
			do;
				call printCRLF;
				call printStr(.asc$3680);
				curCol = curCol + 1;
			end;
			call outch(arg1b);
		end;
		cnt = cnt - 1;
	end;
end;

declare b755C(*) byte initial(' CDSME');

sub$7041: procedure public;
	declare b7562 byte,
		w7563 address,
		b7563 byte at(.w7563),
		b7564 byte at(.w7563 + 1),
		b7565 byte;

	sub$718C: procedure(arg1w);
		declare arg1w address;
		declare ch based curTokenSym$p byte;

		curTokenSym$p = curTokenSym$p - 1;
		call arg1w(ch and not b7565);
	end;



	b68AE(0) = 0FFh;
	if not optSYMBOLS then
		return;
	b755C(0) = 'A';
	do b7562 = 0 to 2;
		b6BDD = isPhase2Print and optSYMBOLS;
		curTokenSym$p = symTab(1) - 2;
		call printCRLF;
		call printStr(wa6DB2(b7562));

		do while (curTokenSym$p := curTokenSym$p + 8) < w6868(1);
		    w7563 = curTokenSym.w0;
		    if b7563 <> 9 then
			if b7563 <> 6 then
		    	    if b7562 <> 0 or b7563 <> 3 then
				if b7562 = 2 or (b7564 and b6DC1(b7562)) <> 0 then
				do;
				    call unpackToken(curTokenSym$p - 6, .b68AE + 1);
				    if b6BDD then
				    do;
					if optPAGEWIDTH - curCol < 11h then
						call printCRLF;
					call printStr(.b68AE + 1);
					call printChar(' ');
					if (b7565 := (b7564 and 40h) <> 0) then
						call printChar('E');
					else
						call printChar(b755C(b7564 and 7));

					call printChar(' ');
					call sub$718C(.print2Hex);
					call sub$718C(.print2Hex);
					curTokenSym$p = curTokenSym$p + 2;
					call printStr(.asc$3692 + 2);
				    end;
				end;

		end;

	end;
	if optDEBUG then
		b68AE(0) = 0;
	if b6BDD then
		call printCRLF;
end;





printCmdLine: procedure public;
	declare ch based actRead byte;

	call outch(0Ch);
	call sub$6F4D;
	ch = 0;
	call printStr(.cmdLineBuf);
	call newPageHeader;
end;


outStr: procedure(arg1w) reentrant;
	declare arg1w address;
	declare ch based arg1w byte;

	do while ch <> 0;
		call outch(ch);
		arg1w = arg1w + 1;
	end;
end;

outNStr: procedure(arg1b, arg2w) reentrant;
	declare arg1b byte, arg2w address,
		ch based arg2w byte;

	do while arg1b > 0;
		call outch(ch);
		arg2w = arg2w + 1;
		arg1b = arg1b - 1;
	end;
end;


sub$721E: procedure byte public;
	return w68A2 < w68A0;
end;



sub$7229: procedure public;
	declare ch based w68A2 byte;
	declare b7568 byte;

	if (b68AB := sub$721E or b68AB) then
	do;
		call out2Hex(high(w68A6));
		call out2Hex(low(w68A6));
	end;
	else
		call outStr(.asc$3692 + 2);

	call outch(' ');
	do  b7568 = 1 to 4;	/* may need structure access */
		if sub$721E and b6B34 then
		do;
			w68A6 = w68A6 + 1;
			call out2Hex(ch);
		end;
		else
			call outStr(.asc$3692 + 4);

		w68A2 = w68A2 + 1;
	end;

	call outch(' ');
	if shr(b6BDD := tokenAttr(b6A56), 6) then
		call outch('E');
	else if not b68AB then
		call outch(' ');
	else
		call outch(b755C(b6BDD and 7));
end;


sub$72D8: procedure public;
	if not b689B then
		return;

	call printStr(.asc$6DC3);	/* " (" */
	call printNStr(4, .b6A57);
	call printStr(.asc$6DC6);	/* ")" */
	call printCRLF;
	call move(4, .asciiLineNo, .b6A57);
end;


ovl3: procedure public;
	declare ch based off6C2C byte;
    loop:
	w68A0 = (w68A2 := tokStart(b6A56)) + tokenSize(b6A56);
	if isSkipping then
		w68A0 = w68A2;

	call outch(b6896);
	call outch(' ');
	if not xisSpace then
	do;
		b6896 = ' ';
		b689B = 0FFh;
	end;
	if b6B20 then
		call outStr(.asc$3680 + 9);
	else
		call sub$7229;
	if fileIdx > 0 then
	do;
		call outch(a1234(b6BDB := b6C21 + fileIdx));
		if b6BDB > 0 then
			call outch('=');
		else
			call outch(' ');
	end;
	else
		call outStr(.asc$3692 + 4);

	if b68AD then
	do;
		call outStr(.asc$3692 + 2);
		call printCRLF;
	end;
	else
	do;
		b68AD = 0FFh;
		call outNStr(4, .asciiLineNo);
		call outch(' ');
		curCol = 18h;
		call printNStr(b6C30, off6C2E);
		if ch <> 0Ah then
			call printChar(0Ah);
	end;
	if b6B20 then
	do;
		if optPAGING then
			call sub$6F4D;
	end;
	else
	do;
		do while sub$721E;
			call outStr(.asc$3692 + 4);
			call sub$7229;
			call printCRLF;
		end;
		if b6A56 > 0 and (b6B23 or b6B24) then
		do;
			call sub$546F;
			goto loop;
		end;
	end;
	call sub$72D8;
end;

asmComplete: procedure public;
	if errCnt > 0 then
		call itoa(errCnt, .aNoErrors);
	call printNStr((errCnt = 1) + 32, .aAssemblyComple);
	if errCnt > 0 then
	do;
		call move(4, .b6A57, .asc$7520);
		call printNStr(8, .asc$751E);
	end;
	call outch(0Dh);
	call outch(0Ah);
end;

ovl9: procedure public;
	if optPRINT then
		call closeF(outfd);
	outfd = 0;
	lineCnt = 1;
	call asmComplete;
	call flushout;
end;


ovl10: procedure public;
	declare ch based w68A6 byte;
	call closeF(infd);
	if optXREF then
	do;
		w68A6 = physmem - 1;
		ch = '0';
		if aF0Asxref$tmp(0) = ':' then
			ch = aF0Asxref$tmp(2);
		call load(.aF0Asxref, 0, 1, 0, .statusIO);
		call ioErrChk;

	end;
	call exit;
end;

end;
