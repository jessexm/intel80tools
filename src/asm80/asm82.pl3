asm80$2:
do;

$include(asm82.ipx)

declare b3E5E(*) byte data(0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			   0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0),
	b3EA0(*) byte data(36h, 0, 0, 0, 6, 0, 0, 2),
	b3EA8(*) byte data(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0, 0, 0FFh,
			   0, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0,
			   0FFh, 0, 0, 0);


skipWhite: procedure public;
	do while isWhite;
		curChar = getCh;
	end;
end;


skipWhite$2: procedure public;
	do while getCh = ' ' or isTab;
	end;
end;


skip2NextLine: procedure public;
	call skip2EOL;
	call chkLF;
end;



sub$3F19: procedure public;

	sub$416B: procedure;
		if opType = 0 then
			call expressionError;
		b6B25 = 0;
		opType = 0;
	end;

	do while 1;
		if b689C then
		do;
			call preStatementControls;
			b689C = 0;
		end;

		do case getChClass;
	/* 0 CC$BAD */	call illegalCharError;
	/* 1 CC$WS  */	;
	/* 2 CC$SEMI */	do;
				b6742 = 0FFh;
				call skip2NextLine;
				b6B29 = 1;
				return;
			end;
	/* 3 CC$COLON */do;
				if not b6872 then
				do;
					if skipping(0) then
						call popToken;
					else
					do;
						b6EC4$9C3A = 2;
						call sub5819$5CE8(segSize(activeSeg), 2);
					end;

					b6B30 = 0;
					b6872, b6B31 = bTRUE;
				end;
				else
				do;
					call syntaxError;
					call popToken;
				end;

				call sub$467F(0, .b6873);
				b6880 = 0;
				opType = 3;
			end;
	/* 4 CC$CR */	do;
				call chkLF;
				b6B29 = 1;
				return;
			end;
	/* 5 CC$PUNCT */do;
				if curChar = '+' or curChar = '-' then
					if opType <> 0  and opType <> 3 then
						curChar = curChar + 3;
				b6B29 = (curChar - 28h) + 2;
				return;
			end;
	/* 6 CC$DOLLAR */do;
				call pushToken(0Ch);
				call collectByte(low(segSize(activeSeg)));
				call collectByte(high(segSize(activeSeg)));
				if activeSeg <> 0 then
					tokenAttr(0) = tokenAttr(0) or activeSeg or 18h;
				call sub$416B;
			end;
	/* 7 CC$QUOTE */do;
				call getStr;
				if b6B31 then
					call sub$43D2;
				call sub$416B;
			end;
	/* 8 CC$DIGIT */do;
				call getNum;
				if b6B31 then
					call sub$43D2;
				call sub$416B;
			end;
	/* 9 CC$LET*/	do;
				call getId(9);
				if tokenSize(0) > 6 then
					tokenSize(0) = 6;
				if ctlXREF then
				do;
					call move(6, .b6873, .b6879);
					call move(6, .spaces24 + 18, .b6873);	/* blanks */
				end;
				call move(tokenSize(0), tokStart(0), .b6873);
				b6744 = tokenSize(0);
				call packToken;
				if b6880 then
				do;
					b687F = 0FFh;
					b6880 = 0;
				end;

				if lookup(0) = 9 then	/* not a key word */
				do;
					tokenType(0) = lookup(1);	/* look up in symbol space */
					b6880 = 0FFh;	/* not key word */
				end;

				b6B29 = tokenType(0);
				b6885 = b3EA8(tokenType(0));
				if not b3E5E(tokenType(0)) then
					call popToken;

				if b687F then
				do;
					call sub$467F((not testBit(b6B29, .b3EA0)) and 1, .b6879);
					b687F = 0;
				end;
				if b6B29 < 10 or b6B29 = 9 or 80h then
				do;
					call sub$416B;
					if b6B31 then
						call sub$43D2;
				end;
				else
				do;
					b6B31 = 0;
					return;
				end;
			end;
		end;
	end;
end;



end;
