asm80$2:
do;

$include(global.inc)

declare b3E5E(*) byte data(0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			   0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0),
	b3EA0(*) byte data(36h, 0, 0, 0, 6, 0, 0, 2),
	b3EA8(*) byte data(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0, 0, 0FFh,
			   0, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0,
			   0FFh, 0, 0, 0);

ascii2Num: procedure external; end;
packToken: procedure external; end;
popToken: procedure external; end;
pushToken: procedure(b) external; declare b byte; end;
skip2EOL: procedure external; end;
sub$3D3F: procedure external; end;
sub$43D2: procedure external; end;
sub$467F: procedure(b, w) external; declare b byte, w address; end;
sub$5819: procedure(w, b) external; declare w address, b byte; end;
chkLF: procedure external; end;
sub$5ED7: procedure external; end;
sub$5EE3: procedure external; end;
sub$5F1F: procedure external; end;
addByte2Tok: procedure(b) external; declare b byte; end;
collectIdent: procedure(b) external; declare b byte; end;
collectString: procedure external; end;

isWhite: procedure byte external; end;
isTab: procedure byte external; end;
getCh: procedure byte external; end;
getChClass: procedure byte external; end;
lookup: procedure(b) byte external; declare b byte; end;
testBit: procedure(b, w) byte external; declare b byte, w address; end;

declare b6CE4 byte external,
	c255 byte external,
	asc$3692(1) byte external;

skipWhite: procedure public;
	do while isWhite;
		curChar = getCh;
	end;
end;


skipWhite$2: procedure public;
	do while getCh = ' ' or isTab;
	end;
end;


skip2NextLine: procedure public;
	call skip2EOL;
	call chkLF;
end;



sub$3F19: procedure public;

	sub$416B: procedure;
		if opType = 0 then
			call sub$5EE3;
		b6B25 = 0;
		opType = 0;
	end;

	do while 1;
		if b689C then
		do;
			call sub$3D3F;
			b689C = 0;
		end;

		do case getChClass;
	/* 0 */		call sub$5F1F;
	/* 1 */		;
	/* 2 */		do;
				b6742 = 0FFh;
				call skip2NextLine;
				b6B29 = 1;
				return;
			end;
	/* 3 */		do;
				if not b6872 then
				do;
					if skipping(0) then
						call popToken;
					else
					do;
						b6CE4 = 2;
						call sub$5819(segSize(activeSeg), 2);
					end;

					b6B30 = 0;
					b6872, b6B31 = c255;
				end;
				else
				do;
					call sub$5ED7;
					call popToken;
				end;

				call sub$467F(0, .b6873);
				b6880 = 0;
				opType = 3;
			end;
	/* 4 */		do;
				call chkLF;
				b6B29 = 1;
				return;
			end;
	/* 5 */		do;
				if curChar = '+' or curChar = '-' then
					if opType <> 0  and opType <> 3 then
						curChar = curChar + 3;
				b6B29 = (curChar - 28h) + 2;
				return;
			end;
	/* 6 */		do;
				call pushToken(0Ch);
				call addByte2Tok(low(segSize(activeSeg)));
				call addByte2Tok(high(segSize(activeSeg)));
				if activeSeg <> 0 then
					tokenAttr(0) = tokenAttr(0) or activeSeg or 18h;
				call sub$416B;
			end;
	/* 7 */		do;
				call collectString;
				if b6B31 then
					call sub$43D2;
				call sub$416B;
			end;
	/* 8 */		do;
				call ascii2Num;
				if b6B31 then
					call sub$43D2;
				call sub$416B;
			end;
	/* 9 */		do;
				call collectIdent(9);
				if tokenSize(0) > 6 then
					tokenSize(0) = 6;
				if optXREF then
				do;
					call move(6, .b6873, .b6879);
					call move(6, .asc$3692, .b6873);	/* blanks */
				end;
				call move(tokenSize(0), tokStart(0), .b6873);
				b6744 = tokenSize(0);
				call packToken;
				if b6880 then
				do;
					b687F = 0FFh;
					b6880 = 0;
				end;

				if lookup(0) = 9 then
				do;
					tokenType(0) = lookup(1);
					b6880 = 0FFh;
				end;

				b6B29 = tokenType(0);
				b6885 = b3EA8(tokenType(0));
				if not b3E5E(tokenType(0)) then
					call popToken;

				if b687F then
				do;
					call sub$467F((not testBit(b6B29, .b3EA0)) and 1, .b6879);
					b687F = 0;
				end;
				if b6B29 < 10 or b6B29 = 9 or 80h then
				do;
					call sub$416B;
					if b6B31 then
						call sub$43D2;
				end;
				else
				do;
					b6B31 = 0;
					return;
				end;
			end;
		end;
	end;
end;



end;
