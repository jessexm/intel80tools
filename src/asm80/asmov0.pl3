asmov0: do;

$include(global.inc)

declare b6D6E(*) byte data(35h, 'DEBUG', 3Ah, 'MACRODEBUG',
			   34h, 'XREF', 37h, 'SYMBOLS',
			   36h, 'PAGING', 33h, 'TTY',
			   25h, 'MOD85', 35h, 'PRINT',
			   36h, 'OBJECT', 39h, 'MACROFILE',
			   29h, 'PAGEWIDTH', 2Ah, 'PAGELENGTH',
			   7, 'INCLUDE', 5, 'TITLE',
			   4, 'SAVE', 7, 'RESTORE',
			   5, 'EJECT', 14h, 'LIST',
			   13h, 'GEN', 14h, 'COND');

declare (b7463, b7464, b7465, b7466) byte;


skipWhite$2: procedure external; end;
skipWhite: procedure external; end;
skip2EOL: procedure external; end;
runtimeError: procedure(b) external; declare b byte; end;
chkLF: procedure external; end;
commandError: procedure external; end;
stackError: procedure external; end;
fileError: procedure external; end;
popToken: procedure external; end;
collectIdent: procedure(b) external; declare b byte; end;
ascii2Num: procedure external; end;
collectString: procedure external; end;
isCR: procedure byte external; end;
isPhase1: procedure byte external; end;
sub$43DD: procedure address external; end;
getCh: procedure byte external; end;
xisSpace: procedure byte external; end;
isWhite: procedure byte external; end;
isRParen: procedure byte external; end;

declare (b6C21, b6C22, fileIdx) byte external,
	files(6) structure(name(15) byte, blk address, byt address, b19 byte) external;

chkParen: procedure(arg1b) byte;
	declare arg1b byte;
	call skipWhite;
	reget = 0;
	return arg1b + '(' = curChar;
end;



collectBasicToken: procedure byte;
	collectBufLen = 0;
	b6ADB = 0;
	if isCR then
		return curChar;

	call skipWhite$2;
	if curChar > 40h and 5Bh > curChar or curChar >60h and 7Bh > curChar then
	do;	/* is letter */
		call collectIdent(1);
		if xisSpace and tokenSize(0) < 14 then
			call move(collectBufLen := tokenSize(0), .lineBuf, .collectBuf);
	end;
	else if curChar > 2Fh  and  3Ah > curChar then
	do;	/* is digit */
		call ascii2Num;
		if xisSpace then
		do;
			w6B1E = sub$43DD;
			b6ADB = 2;
			collectBuf(0) = 20h;
		end;
	end;
	else if curChar = 27h then
	do;	/* is string */
		call collectString;
		if xisSpace then
		do;
			collectBufLen = 40h;
			if tokenSize(0) < 40h then
				collectBufLen = tokenSize(0);
			b6ADB = 4;
			if collectBufLen > 0 then
				call move(collectBufLen, .lineBuf, .collectBuf);
		end;
	end;
	else
	do;
		collectBufLen = 1;
		collectBuf(0) = curChar;
		return curChar;
	end;

	call popToken;
	return collectBuf(0);
end;



sub$6F07: procedure(arg1w) byte;
	declare arg1w address;
	declare pad address;

	if collectBufIdx = 0 then
		return 0;

	collectBuf(collectBufIdx) = 20h;
	collectBufLen = collectBufIdx;
	if isWhite then
		return chkParen(1);
	return 0FFh;
end;

sub$6F39: procedure;
	call skipWhite$2;

    do while 1;
	if isRParen or isWhite then
	do;
		if sub$6F07(.collectBuf(0)) then
			return;
		goto done;
	end;

	collectBuf(collectBufIdx) = curChar;
	collectBufIdx = collectBufIdx + 1;
	if collectBufIdx > 14 then
		goto done;
	curChar = getCh;
    end;
done:
	curFileName$p = .collectBuf;
	call fileError;
end;


getFileParam: procedure;
	collectBufIdx = 0;
	if not chkParen(0) then		/* ( */
		call fileError;
	else
	do;
		call sub$6F39;
		call move(collectBufIdx + 1, .collectBuf, curFileName$p);
		if not chkParen(1) then	/* ) */
			call fileError;
	end;
end;


getMacroFileDrive: procedure;
	call skipWhite$2;
	collectBufIdx = 0Dh;
	b6BDB = 0;

	do while not isRParen and b6BDB < 4;
		aF0Asmac$tmp(b6BDB) = curChar;
		b6BDB = b6BDB + 1;
		curChar = getCh;
	end;

	if isRParen or isWhite then
		if sub$6F07(.aF0Asmac$tmp) then
			return;
	curFileName$p = .aF0Asmac$tmp;
	collectBufIdx = 0;
	call fileError;
end;




sub$702B: procedure byte;
	if chkParen(0) then	/* ( */
	do;
		b7463 = collectBasicToken;
		if b6ADB = 2 then
			return chkParen(1);	/* ) */
	end;
	return 0;
end;


sub$704B: procedure byte;
	declare (b746C, b746D, optionSET, b746F, b7470, b7471) byte,
		(w7472, w7474, w7476) address;
	declare twoch address at(.collectBuf);
	declare ch based w7472 byte;
	declare byt based w7476 byte;

	setOption: procedure;
		if not b7471 then
		do;
			options(optionId) = optionSET;
			if not optionSET then
				optionId = 17;
		end;
	end;

	b746F = collectBufLen;
	b746D = 0;
	optionSET = 0FFh;
	if twoch = 'ON' then	/* NO stored inverse */
	do;
		b746D = 2;
		optionSET = 0;
		b746F = collectBufLen - 2;
	end;
	w7472 = .b6D6E;
	optionId = 0;
	b746C = b746D;

	do while optionId < 20;
		w7474 = w7472 + (ch and 0Fh) + 1;
		if (ch and 0Fh) = b746F then
		do;
			b7470 = ch;
			do while b746C < collectBufLen;
				w7472 = w7472 + 1;
				if ch <> collectBuf(b746C) then
					b746C = collectBufLen + 1;
				else
					b746C = b746C + 1;
			end;
			if b746C = collectBufLen then
				goto break;
		end;
		w7472 = w7474;
		optionId = optionId + 1;
		b746C = b746D;
	end;
	return 0FFh;

break: if optionId = 1 or optionId = 12h then		/* MACRODEBUG or GEN */
	do;
		if scanOptions then
			MacroDebugOrGen = 0FFh;
		else
			return 0FFh;			/* error otherwise */
	end;

	if (b7471 := (b7470 and 10h) <> 10h) and not optionSET then
		return 0FFh;				/* NO invalid */

	if (b7470 and 20h) <> 20h then
	do;
		call setOption;
		return optionId;
	end;

	if not b6898 then
		return 0FFh;

	w7476 = .optionSeen(optionId);
	if byt then
		return 0FFh;
	byt = 0FFh;
	call setOption;
	return optionId;
end;




processCmd: procedure;
	if optionId >= 17 or optionId < 5 then
		return;

	do case optionId - 5;
/* 0 */		do;			/* TTY */
			optTTY = 0FFh;
			return;
		end;
/* 1 */		do;			/* MOD85 */
			optMOD85 = 0FFh;
			return;
		end;
/* 2 */		do;			/* PRINT */
			w6BE2 = 2;
			curFileName$p = .lstFile;
			call getFileParam;
			return;
		end;
/* 3 */		do;			/* OBJECT */
			w6BE2 = 3;
			curFileName$p = .objFile;
			call getFileParam;
			return;
		end;
/* 4 */		do;			/* MACROFILE */
			w6BE2 = 3;
			if chkParen(0) then	/* optional drive for tmp file */
				call getMacroFileDrive;
			else
				reget = 1;
			optMACROFILE = 0FFh;
			return;
		end;
/* 5 */		do;			/* PAGEWIDTH */
			if sub$702B then
			do;
				optPAGEWIDTH = w6B1E;
				if optPAGEWIDTH > 132 then
					optPAGEWIDTH = 132;
				if optPAGEWIDTH < 72 then
					optPAGEWIDTH = 72;
				return;
			end;
		end;
/* 6 */		do;			/* PAGELENGTH */
			if sub$702B then
			do;
				optPAGELENGTH = w6B1E;
				if optPAGELENGTH < 15 then
					optPAGELENGTH = 15;
				return;
			end;
		end;
/* 7 */		do;			/* INCLUDE */
			if not b6C21 then
			do;
				w6BE2 = 1;
				if fileIdx = 5 then
					call stackError;
				else
				do;
					fileIdx = fileIdx + 1;
					curFileName$p = .files(fileIdx);
					call getFileParam;
					b6C21 = 0FFh;
					if scanOptions then
						b6C22 = 0FFh;
					return;
				end;
			end;
		end;
/* 8 */		do;			/* TITLE */
			if chkParen(0) then
			do;
				b7463 = collectBasicToken;
				if b6ADB = 4 and collectBufLen <> 0 then
				do;
					if phase <> 1 or isPhase1 and b6898 then
					do;
						call move(collectBufLen, .collectBuf, .optTITLESTR);
						optTITLESTR(titleLen := collectBufLen) = 0;
						if chkParen(1) then
						do;
							optTITLE = 0FFh;
							return;
						end;
					end;
				end;
			end;
		end;
/* 9 */		do;				/* SAVE */
			if saveIdx > 7 then
				call stackError;
			else
			do;
				call move(3, .optLIST, .saveStack + saveIdx * 3);
				saveIdx = saveIdx + 1;
				return;
			end;
		end;
/* 10 */	do;				/* RESTORE */
			if saveIdx > 0 then
			do;
				call move(3, .saveStack + (saveIdx := saveIdx - 1) * 3, .optLIST);
				return;
			end;
		end;
/* 11 */	do;				/* EJECT */
			optEJECT = optEJECT + 1;
			return;
		end;
	end;
	b7466 = 0FFh;
end;


parseCmds: procedure public;
	b6B20 = 0FFh;
	b6A6F, b7464 = optLIST;
	b7466 = 0;

	do while collectBasicToken <> 0Dh and not b7466;
		if collectBuf(0) = ';' then
			call skip2EOL;
		else if sub$704B = 0FFh then
			b7466 = 0FFh;
		else
			call processCmd;
	end;

	if b7466 then
	do;
		if collectBuf(0) <> 0Dh then
		do;
			reget = 0;
			call skip2EOL;
		end;
		if scanOptions then
			call runtimeError(2);	/* command error */
		else
			call commandError;
	end;

	call chkLF;
	if optLIST <> b7464 then
		b6A6F = 0FFh;
	reget = 0;
end;

end;
