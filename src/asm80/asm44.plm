asm44:
do;

declare b4181(*) byte public data(0, 80h, 0, 0, 0Fh, 0Fh, 80h, 0Fh, 0Dh, 0Fh,
			   0Dh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Dh, 0Fh, 0Fh,
			   0Fh, 0Fh, 0Fh, 0Fh, 0Dh, 0Dh, 40h, 4Dh, 1, 1,
			   1, 1, 80h, 1, 0, 0, 47h, 7, 7, 7,
			   17h, 47h, 7, 47h, 37h, 5, 7, 0, 0, 0,
			   40h, 40h, 0, 1, 80h, 40h, 80h, 0, 40h, 80h, 80h,
			   40h, 81h, 0C0h, 80h, 0Dh),

	b41B7(*) byte data(41h, 0, 0, 0, 19h, 40h, 0, 1Ch, 0, 0),
	b41C1(*) byte data(1Ah, 5, 80h, 0, 0C0h),
	b41C6(*) byte data(57h, 71h, 0F4h, 57h, 76h, 66h, 66h, 67h, 77h, 77h, 77h, 55h),
	b41D2(*) byte data(57h, 6, 2, 20h, 0, 0, 0, 0, 0, 0, 0, 22h),
	b41DE(*) byte data(3Ah, 0FFh, 80h, 0, 0, 0Fh, 0FEh, 0, 20h),
	precedence(*) byte data(0, 0, 0, 0, 8, 7, 1, 7, 7, 8, 7, 6, 6, 6, 6, 6, 6,
			   5, 4, 3, 3, 8, 8, 8, 9, 9, 1, 1, 1, 1, 1, 1, 1, 1,
			   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			   1, 1, 1, /* extra */ 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0Ah);


flushout: procedure external; end;
outch: procedure(b) external; declare b byte; end;
outStrN: procedure(w1, w2) external; declare (w1, w2) address; end;
closeF: procedure(w) external; declare w address; end;
sourceError: procedure(b) external; declare b byte; end;
expressionError: procedure external; end;
valueError: procedure external; end;
operandError: procedure external; end;
popToken: procedure external; end;
pushToken: procedure(b) external; declare b byte; end;
nibble2Ascii: procedure(b) byte external; declare b byte; end; 
isPhase1: procedure byte external; end;
isSkipping: procedure byte external; end;

declare tokenSize literally 'toksiz',
	tokStart literally 'tokst';
declare (tokenSP, b6855, b6856, b6858) byte external,
	(tokenType, tokenSize, tokenAttr, lstFile, bp6A4E, bp6BE0)(1) byte external,
	(accum1$lb,accum1$hb,accum2$lb,accum2$hb) byte external,
	(b6859, b6881, b689A, ctlXREF, ctlPAGING, ctlPAGEWIDTH) byte external,
	(ctlPAGELENGTH, ctlLIST, ctlGEN, ctlCOND, b6A6F, has16bitOperand, b6B2B, b6B2D) byte external,
	(b6B30, b6B31, b6B32, b6B36, ii, b6BDC, jj, b$905B) byte external,
	(skipping, b$9A77) byte external,
	(curTokenSym$p, curTokStart, accum1, w685A, w685C, xreffd) address external,
	(tokenSymId)(1) address external;



testBit: procedure(arg1b, arg2w) byte public;
	declare arg1b byte, arg2w address;
	declare ch based arg2w byte;

	if ch < arg1b then
		return 0;
	
	arg2w = arg2w + shr(arg1b, 3) + 1;
	return (ch and ROR(1, (arg1b and 7) + 1)) <> 0;
end;

sub$425B: procedure(arg1b) byte public;
	declare arg1b byte;

	return arg1b = 7 or arg1b = 8;
end;

sub$4274: procedure public;
	if testBit(b6B2B, .b41B7) then
		if sub$425B(b6858) then
			call operandError;
end;

sub$4291: procedure public;
	if sub$425B(b6858) then
		call operandError;
	if (b4181(b6B2B) and 2) = 0 then
		b6856 = 0;
	else if sub$425B(b6859) then
		call operandError;

	b6858 = 0Ch;
	bp6BE0(0) = (b6855 and 18h) <> 0;
	bp6BE0(1) = (b6856 and 18h) <> 0;
	if (b6855 and 7) <> 0 then
		if (b6856 and 7) <> 0 then
			if ((b6855 xor b6856) and 1Fh) <> 0 then
				call expressionError;
	if (ii := (b6855 and 40h) <> 0) or (b6BDC := (b6856 and 40h) <> 0) then
	do;
		if b6B2B = 5 then
			if not (ii or bp6BE0(0)) then
			do;
				w685A = w685C;
				b6855 = b6856;
				return;
			end;
		if b6BDC or bp6BE0(1) or not testBit(b6B2B, .b41C1) then
			goto L4394;
		else
			return;
	end;
	jj = shl(b6B2B - 4, 2) or (bp6BE0(0) and 2) or (bp6BE0(1) and 1);
	if testBit(jj, .b41C6) then
L4394:	do;
		call expressionError;
		b6855 = 0;
		return;
	end;
	if testBit(jj, .b41D2) then
	do;
		if not bp6BE0(0) then
			b6855 = b6856;
		return;
	end;
	b6855 = 0;
end;


swapAccBytes: procedure public;
	declare b6C17 byte;
	b6C17 = accum1$lb;
	accum1$lb = accum1$hb;
	accum1$hb = b6C17;
end;



sub$43D2: procedure public;
	b6B30 = 0FFh;
	b6B31 = 0;
end;



sub$43DD: procedure address public;
	declare ch based curTokStart byte,
		s based curTokStart(1) byte,
		w$9B69 address,
		wrd based w$9B69 address;

	sub$4884: procedure(arg1b);
		declare arg1b byte;

		if tokenType(tokenSP) <> 40h then
		do;
			call sourceError(arg1b);
			return;
		end;
		if tokenSize(0) = 0 then
			tokenType(tokenSP) = 41h;
	end;



	b6855 = 0;
	accum1 = 0;
	b6858 = 9;
	if tokenType(0) = 40h then
		call pushToken(0Dh);

	if tokenSP = 0 or tokenType(0) = 0Bh and not b6B36 then
		call sub$4884('Q');
	else
	do;
		if tokenType(0) = 9 or tokenType(0) = 6 then
			call sub$4884('U');
		else
		do;
			b6858 = tokenType(0);
			if testBit(b6858, .b41DE) then
			do;
				curTokStart = curTokenSym$p + 7;
				b6855 = ch and 0DFh;
				curTokStart, w$9B69 = curTokenSym$p + 4;
				w685A = wrd;
				tokenSize(0) = 2;

			end;
			else if tokenSize(0) = 0 then
				call sub$4884('V');
			else
			do;
				if tokenSize(0) > 2 then
					call sub$4884('V');

				b6855 = (tokenAttr(0) and 0DFh);
				w685A = tokenSymId(0);
			end;

			if tokenSize(0) > 0 then
				accum1$lb = ch;
			if tokenSize(0) > 1 then
				accum1$hb = s(1) and tokenType(0) <> 7;
		end;	

		if has16bitOperand then
			if tokenSize(0) = 2 then
				if tokenType(0) = 0Ah then
					call swapAccBytes;

		if (b6855 and 40h) <> 0 then
			if tokenType(0) < 9 then
				accum1 = 0;

		call popToken;
	end;

	b6B36 = 0;
	return accum1;
end;





getPrec: procedure(arg1b) byte public;
	declare arg1b byte;
	return precedence(arg1b);
end;

sub$450F: procedure(arg1b) public;
	declare arg1b byte;

	if (arg1b and 3) <> 0 then
	do;
		if accum2$hb <> 0
		   or accum2$lb > 7
		   or arg1b and accum2$lb
		   or (arg1b and 3) = 3 and accum2$lb > 2
		   or (not sub$425B(b6859) and b6B2B <> 2Eh) then
			call operandError;
		else if sub$425B(b6859) and b6B2B = 2Eh then
			call operandError;
		if ror(arg1b, 2) then
			accum2$lb = rol(accum2$lb, 3);
		accum1$lb = accum1$lb or accum2$lb;
	end;
	else if b6B2B <> 2Dh then
		if sub$425B(b6859) then
			call operandError;

	if shr(arg1b, 3) then
	do;
		if (b6856 and 18h) = 18h then
		do;
			call valueError;
			b6856 = b6856 and 0E7h or 8;
		end;
		if accum2$hb + 1 > 1 then
			call valueError;
	end;
	if b6B2B = 28h or b6B2B = 2Ch then
	do;
		b6855 = b6856;
		w685A = w685C;
	end;
	else
		b6855 = 0;

	if b6B2B <> 2Dh then
		if accum1$lb = 76h then
			call operandError;
	if (b6B2B := shr(arg1b, 4) + 24h) = 24h then
		b6B2D = 0Bh;
end;

sub$4646: procedure byte public;
	if b689A >= tokenSP then
		return 0;
	return (b689A := b689A + 1);
end;



sub$465B: procedure byte public;
	return ((not b$9A77) and ctlLIST or b6A6F and b$9A77)
	        and (not (b$905B > 1) or ctlGEN)
		and (not(b6B32 or skipping) or ctlCOND);
end;

sub$467F: procedure(arg1b, arg2w) public;
	declare arg1b byte, arg2w address;
	declare (b6C1F, b6C20) byte;

	if not isPhase1 or not ctlXREF or isSkipping and not b6881 then
		return;

	call outch(arg1b + '0');
	if arg1b <> 2 then
	do;
		call outStrN(arg2w, 6);
		b6881 = 0;
		b6C20 = bp6A4E(1);
		b6C1F = 0;
		do while b6C1F < 4;
			b6C1F = b6C1F + 1;
			if b6C1F then
			do;
				if b6C1F = 3 then
					b6C20 = bp6A4E(0);
				call outch(nibble2Ascii(shr(b6C20, 4)));
			end;
			else
				call outch(nibble2Ascii(b6C20));
		end;
	end;
	else
	do;
		call outStrN(.lstFile, 15);
		if ctlPAGING then
			call outch('1');
		else
			call outch('0');

		call outch(nibble2Ascii(ror(ctlPAGELENGTH, 4)));
		call outch(nibble2Ascii(ctlPAGELENGTH));
		call outch(nibble2Ascii(ror(ctlPAGEWIDTH, 4)));
		call outch(nibble2Ascii(ctlPAGEWIDTH));
		call outch('3');
		call flushout;
		call closeF(xreffd);
	end;
end;

end;
