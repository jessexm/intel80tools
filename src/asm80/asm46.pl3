asm46: do;
$include(:f3:asm46.ipx)

declare    needToOpenFile bool public initial(FALSE),
    includeOnCmdLine bool public initial(FALSE),
    padb6C23 byte,
    fileIdx byte public initial(0),
    endInBuf$p address public initial(.inBuf),
    missingEnd bool public initial(FALSE),
    srcfd address public,
    rootfd address public,
    inCh$p pointer public initial(.inBuf - 1),
    startLine$p address public initial(.inBuf),
    lineChCnt byte public initial(0), 
    files(6) FILE$T public,
    seekIBlk address,
    seekIByte address,
    pad6CAD byte,  
    savInBuf$p address,
    savEndInBuf$p address,
    pad6CB2(4) address,
    readFActual address,
    pad6CBC address;


ReadF: procedure(conn, buff$p, count) public;
    declare conn byte, (buff$p, count) address;
    call Read(conn, buff$p, count, .readFActual, .statusIO);
    call IoErrChk;
end;

SeekI: procedure(seekOp) public;
    declare seekOP byte;
    call Seek(srcfd, seekOp, .seekIBlk, .seekIByte, .statusIO);
    call IoErrChk;
end;


ReadSrc: procedure(bufLoc) public;
    declare bufLoc address;
    declare pad byte;

    call ReadF(srcfd, bufLoc, .inBuf(sizeInBuf) - bufLoc);
    endInBuf$p = bufLoc + readFActual;
end;



CloseSrc: procedure public;
    call Close(srcfd, .statusIO);
    call IoErrChk;
    if fileIdx = 0 then
    do;
        missingEnd = TRUE;
        call IoError(.files(0).name);
        return;
    end;
    fileIdx = fileIdx - 1;
    /* Open the previous file */
    if fileIdx = 0 then
        srcfd = rootfd;
    else
        srcfd = InOpen(.files(fileIdx).name, 1);

    seekIByte = files(fileIdx).byt;    /* move to saved location */
    seekIBlk = files(fileIdx).blk;
    call SeekI(SEEKABS);
    endInBuf$p = .inBuf;        /* force Read */
    inCh$p = .inBuf - 1;
end;


GetSrcCh: procedure byte public;
    declare ch based inCh$p byte;
    declare insertPt address;
    loop:
    inCh$p = inCh$p + 1;

    if inCh$p = endInBuf$p then    /* buffer all used */
    do;
        savInBuf$p = startLine$p;
        savEndInBuf$p = endInBuf$p;
        /* copy the current line down to start of buffer */
        if savEndInBuf$p - savInBuf$p > 0 then
            call move(savEndInBuf$p - savInBuf$p, startLine$p, .inBuf);
        startLine$p = .inBuf;
        /* Read in  characters to rest of inBuf */
        call ReadSrc(insertPt := startLine$p + (savEndInBuf$p - savInBuf$p));
        inCh$p = insertPt;
    end;

    if readFActual = 0 then
    do;
        call CloseSrc;
        goto loop;
    end;

    lineChCnt = lineChCnt + 1;
    return ch and 7Fh;
end;


OpenSrc: procedure public;
    declare curByteLoc byte, curBlkLoc address;

    needToOpenFile = 0;
    call SeekI(SEEKTELL);
    if seekIByte = 128 then        /* adjust for 128 boundary */
    do;
        seekIBlk = seekIBlk + 1;
        seekIByte = 0;
    end;

    curBlkLoc = endInBuf$p - startLine$p;    /* un-used characters */
x:                        /* forces code alignment */
    if (curByteLoc := curBlkLoc mod 128) > seekIByte then
    do;
        seekIByte = seekIByte + 128;    /* adjust to allow for un-used chars */
        seekIBlk = seekIBlk - 1;
    end;
    /* save the current file location */
    files(fileIdx - 1).byt = seekIByte - curByteLoc;
    files(fileIdx - 1).blk = seekIBlk - curBlkLoc / 128;
    if srcfd <> rootfd then        /* close if include file */
    do;
        call Close(srcfd, .statusIO);
        call IoErrChk;
    end;

    endInBuf$p = .inBuf;            /* force Read */
    inCh$p = endInBuf$p - 1;
    startLine$p = .inBuf;
    files(fileIdx).blk = 0;            /* record at start of file */
    files(fileIdx).byt = 0;    
    srcfd = InOpen(.files(fileIdx).name, 1);    /* Open the file */
end;
end;
