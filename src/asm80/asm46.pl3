asm46: do;
$include(asm46.ipx)

declare	needToOpenFile bool public initial(FALSE),
	includeOnCmdLine bool public initial(FALSE),
	b6C23 byte public,
	fileIdx byte public initial(0),
	endInBuf$p address public initial(.inBuf),
	missingEnd bool public initial(FALSE),
	srcfd address public,
	rootfd address public,
	inCh$p address public initial(.inBuf - 1),
	startLine$p address public initial(.inBuf),
	lineChCnt byte public initial(0), 
	files(6) FILE$T public,
	seekIBlk address,
	seekIByte address,
	pad6CAD byte,  
	savInBuf$p address,
	savEndInBuf$p address,
	pad6CB2(4) address,
	readFActual address,
	pad6CBC address;


readF: procedure(conn, buff$p, count) public;
	declare conn byte, (buff$p, count) address;
	call read(conn, buff$p, count, .readFActual, .statusIO);
	call ioErrChk;
end;

seekI: procedure(seekOp) public;
	declare seekOP byte;
	call seek(srcfd, seekOp, .seekIBlk, .seekIByte, .statusIO);
	call ioErrChk;
end;


readSrc: procedure(bufLoc) public;
	declare bufLoc address;
	declare pad byte;

	call readF(srcfd, bufLoc, .inBuf(sizeInBuf) - bufLoc);
	endInBuf$p = bufLoc + readFActual;
end;



closeSrc: procedure public;
	call close(srcfd, .statusIO);
	call ioErrChk;
	if fileIdx = 0 then
	do;
		missingEnd = TRUE;
		call ioError(.files(0).name);
		return;
	end;
	fileIdx = fileIdx - 1;
	/* open the previous file */
	if fileIdx = 0 then
		srcfd = rootfd;
	else
		srcfd = inOpen(.files(fileIdx).name, 1);

	seekIByte = files(fileIdx).byt;	/* move to saved location */
	seekIBlk = files(fileIdx).blk;
	call seekI(SEEKABS);
	endInBuf$p = .inBuf;		/* force read */
	inCh$p = .inBuf - 1;
end;


getSrcCh: procedure byte public;
	declare ch based inCh$p byte;
	declare insertPt address;
    loop:
	inCh$p = inCh$p + 1;

	if inCh$p = endInBuf$p then	/* buffer all used */
	do;
		savInBuf$p = startLine$p;
		savEndInBuf$p = endInBuf$p;
		/* copy the current line down to start of buffer */
		if savEndInBuf$p - savInBuf$p > 0 then
			call move(savEndInBuf$p - savInBuf$p, startLine$p, .inBuf);
		startLine$p = .inBuf;
		/* read in  characters to rest of inBuf */
		call readSrc(insertPt := startLine$p + (savEndInBuf$p - savInBuf$p));
		inCh$p = insertPt;
	end;

	if readFActual = 0 then
	do;
		call closeSrc;
		goto loop;
	end;

	lineChCnt = lineChCnt + 1;
	return ch and 7Fh;
end;


openSrc: procedure public;
	declare curByteLoc byte, curBlkLoc address;

	needToOpenFile = 0;
	call seekI(SEEKTELL);
	if seekIByte = 128 then		/* adjust for 128 boundary */
	do;
		seekIBlk = seekIBlk + 1;
		seekIByte = 0;
	end;

	curBlkLoc = endInBuf$p - startLine$p;	/* un-used characters */
x:						/* forces code alignment */
	if (curByteLoc := curBlkLoc mod 128) > seekIByte then
	do;
		seekIByte = seekIByte + 128;	/* adjust to allow for un-used chars */
		seekIBlk = seekIBlk - 1;
	end;
	/* save the current file location */
	files(fileIdx - 1).byt = seekIByte - curByteLoc;
	files(fileIdx - 1).blk = seekIBlk - curBlkLoc / 128;
	if srcfd <> rootfd then		/* close if include file */
	do;
		call close(srcfd, .statusIO);
		call ioErrChk;
	end;

	endInBuf$p = .inBuf;			/* force read */
	inCh$p = endInBuf$p - 1;
	startLine$p = .inBuf;
	files(fileIdx).blk = 0;			/* record at start of file */
	files(fileIdx).byt = 0;	
	srcfd = inOpen(.files(fileIdx).name, 1);	/* open the file */
end;
end;
