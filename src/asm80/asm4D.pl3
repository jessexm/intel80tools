asm4D:
do;

declare
    aAssemblyComple(*) byte initial(0Dh, 0Ah, 'ASSEMBLY COMPLETE,'),
    aNoErrors(*) byte initial('   NO ERRORS'),
    asc$751E(*) byte initial(' ('),
    asc$7520(*) byte initial('     )'),
    aPublicSymbols(*) byte initial(0Dh, 0Ah, 'PUBLIC SYMBOLS', 0Dh, 0Ah, 0),
    aExternalSymbol(*) byte initial(0Dh, 0Ah, 'EXTERNAL SYMBOLS', 0Dh, 0Ah, 0),
    pad754E address,

    aUserSymbols(*) byte data(0Dh, 0Ah, 'USER SYMBOLS', 0Dh, 0Ah, 0),
    aLocObjLineSour(*) byte data('  LOC  OBJ         LINE        SOURCE STATEMENT', 0Dh, 0Ah, 0Ah, 0),
    wa6DB2(*) address data(.aPublicSymbols, .aExternalSymbol, .aUserSymbols),
    asc$6DB8(*) byte data(0Dh, 0Ah, 0Ah, 0),
    asc$6DBC(*) byte data(0Dh),
    asc$6DBD(*) byte data(0Ah, 0Ah, 0Ah, 0),
    b6DC1(2) byte data(20h, 40h),
    asc$6DC3(*) byte data(' (', 0),
    asc$6DC6(*) byte data(')', 0),
    a1234(*) byte data('  1234');    



declare rec18a structure(type byte, len address, dta(1) byte) external,
	rec16 structure(type byte, len address, seg byte, dta(1) address) external,
	rec22 structure(type byte, len address, seg byte, fixtype byte, dta(1) address) external,
	rec24 structure(type byte, len address, seg byte, fixtype byte, dta(1) address) external,
	rec20 structure(type byte, len address, fixtype byte, dta(30) address) external, 
	rec18 structure(type byte, len address, dta(1) byte) external,
	rec06 structure(type byte, len address, seg byte, addr address, dta(1) byte) external,
	rec04 structure(type byte, len address, subtype byte, seg byte, addr address, crc byte) external;



delete: procedure(w1, w2) external; declare (w1, w2) address; end;
exit: procedure external; end;
flushout: procedure external; end;
ioErrChk: procedure external; end;
load: procedure(w1, w2, w3, w4, w5) external; declare (w1, w2, w3, w4, w5) address; end;
outch: procedure(ch) external; declare ch byte; end;
closeF: procedure(w) external; declare w address; end;
put2Hex: procedure(w1, w2) external; declare (w1, w2) address; end;
sub$546F: procedure external; end;
isPhase2Print: procedure byte external; end;
sub$3FA9: procedure byte external; end;
sub$465B: procedure byte external; end;
isSkipping: procedure byte external; end;
unpackToken: procedure(w1, w2) external; declare (w1, w2) address; end;
physmem: procedure address external; end;
xisSpace: procedure byte external; end;




declare tokenSize literally 'toksiz',
	tokStart literally 'tokst';
declare (aF0Asmac$tmp, aF0Asxref, aF0Asxref$tmp, aIsisIi80808085, b3680)(1) byte external,
	(b3694, b3696, b3689, b3692, objFile, lstFile, tokenSize, tokenAttr, b68AE)(1) byte external,
	(b68B8, asciiLineNo, b6A57, optionSeen, optTITLESTR, b8FD5, cmdLineBuf)(1) byte external,
	(cZERO, c255, activeSeg, b6857, curChar, lookAhead, b6882) byte external,
	(b6896, b6898, b689B, curCol, b68AB, b68AD, b6A56, optDEBUG, optMACRODEBUG) byte external,
	(optXREF, optSYMBOLS, optPAGING, optTTY, optPRINT, optOBJECT, optPAGEWIDTH, optPAGELENGTH, optTITLE) byte external,
	(optEJECT, optLIST, optGEN, optCOND, b6A6F, titleLen, saveIdx, scanOptions, b6B23) byte external,
	(opType, b6B2C, b6B2E, b6B33, b6B34, b6BDB, b6BDD, b6C21, fileIdx) byte external,
	(b6C30, b905B, b905C, b905E, b9063, b9064, b6742, b6743) byte external,
	b674A(2) byte external,
	(b9A77, b6B24) byte external,
	(cmdch$p, actRead, off$6C25, off$6C2C, off$6C2E, outfd, statusIO) address external,
	curTokenSym$p address external,
	curTokenSym based curTokenSym$p structure(w0 address, w2 address, w4 address, type byte, b7 byte),
	(w6750, w686E, w6870, objfd) address external,
	(infd, macrofd, w68A0, w68A2, lineCnt, w68A6, pageCnt, endOutBuf) address external,
	(w6A4E,  errCnt, zero) address external,
	(options$p, includefd, rootfd, off$9056, curMacroBlk, w9114, w919B, w673F) address external,
	(w6868, w6B41, segSize, symTab, tokStart)(1) address external,
	CR literally '0Dh';




out2Hex: procedure(arg1b);
    declare arg1b byte;
    call put2Hex(.outch, arg1b);
end;


print2Hex: procedure(arg1b);
    declare arg1b byte;
    call put2Hex(.printChar, arg1b);
end;



printStr: procedure(arg1w) reentrant;
    declare arg1w address;
    declare ch based arg1w byte;

    do while ch <> 0;
        call printChar(ch);
        arg1w = arg1w + 1;
    end;
end;

printNStr: procedure(arg1b, arg2w) reentrant;
    declare arg1b byte, arg2w address;
    declare ch based arg2w byte;

    do while arg1b > 0;
        call printChar(ch);
        arg2w = arg2w + 1;
        arg1b = arg1b - 1;
    end;
end;


printCRLF: procedure reentrant;
    call printChar(0Dh);
    call printChar(0Ah);
end;

declare asc$7752 byte initial(' '),
    asc$7553(*) byte initial('    ', 0);


itoa: procedure(arg1w, arg2w);
    declare (arg1w, arg2w) address;
    declare ch based arg2w byte;

    call move(5, .b3692 + 1, arg2w);
    arg2w = arg2w + 4;

    do while 1;
        ch = arg1w mod 10 + '0';
        arg2w = arg2w - 1;
        if (arg1w := arg1w /10) = 0 then
            return;
    end;
end;


printDecimal: procedure(arg1w) reentrant public;
    declare arg1w address;
    call itoa(arg1w, .asc$7752);
    call printStr(.asc$7553);
end;

skipToEOP: procedure public;
    do while lineCnt <= optPAGELENGTH;
        call outch(0Ah);
        lineCnt = lineCnt + 1;
    end;
end;


newPageHeader: procedure public;    
    call printStr(.asc$6DBD);
    call printStr(.aIsisIi80808085);
    call printDecimal(pageCnt);
    call printCRLF;
    if optTITLE then
        call printNStr(titleLen, .optTITLESTR);

    call printCRLF;
    call printCRLF;
    if not b68AE(0) then
        call printStr(.aLocObjLineSour);
    pageCnt = pageCnt + 1;
end;


newPage: procedure public;
    if optTTY then
        call skipToEOP;
    else
        call outch(0Ch);

    lineCnt = 1;
    if not scanOptions then
        call newPageHeader;
end;


sub$6F4D: procedure public;
    if sub$465B then
    do while optEJECT > 0;
        call newPage;
        optEJECT = optEJECT - 1;
    end;
end;




printChar: procedure(arg1b) reentrant;
    declare ch byte, arg1b byte;

    if arg1b = 0Ch then
    do;
        call newPage;
        return;
    end;

    if arg1b = 0Ah then
        if optPAGING then
        do;
            if (lineCnt := lineCnt + 1) >= optPAGELENGTH - 2 then
            do;
                if optTTY then
                    call outch(0Ah);
                if optEJECT > 0 then
                    optEJECT = optEJECT - 1;
                call newPage;
                return;
            end;
        end;

    if arg1b = 0Dh then
        curCol = 0;

    ch = 1;
    if arg1b = 9 then
    do;
        ch = 8 - (curCol and 7);
        arg1b = ' ';
    end;

    do while ch <> 0;
        if curCol < 132 then
        do;
            if arg1b >= ' ' then
                curCol = curCol + 1;
            if curCol > optPAGEWIDTH then
            do;
                call printCRLF;
                call printStr(.b3680);
                curCol = curCol + 1;
            end;
            call outch(arg1b);
        end;
        ch = ch - 1;
    end;
end;

declare b755C(*) byte initial(' CDSME');

sub$8447: procedure public;
    declare b7562 byte,
        w7563 address,
        b7563 byte at(.w7563),
        b7564 byte at(.w7563 + 1),
        b7565 byte;

    sub$718C: procedure(arg1w);
        declare arg1w address;
        declare ch based curTokenSym$p byte;

        curTokenSym$p = curTokenSym$p - 1;
        call arg1w(ch and not b7565);
    end;


    b68AE(0) = 0FFh;
    if not optSYMBOLS then
        return;

    b755C(0) = 'A';
    do b7562 = 0 to 2;
        b6BDD = isPhase2Print and optSYMBOLS;
        optDEBUG = optDEBUG or optMACRODEBUG;
        curTokenSym$p = symTab(1) - 2;
        call printCRLF;
        call printStr(wa6DB2(b7562));

        do while (curTokenSym$p := curTokenSym$p + 8) < w6868(1);
            w7563 = curTokenSym.w0;
            if b7563 <> 9 then
                if b7563 <> 6 then
                    if sub$3FA9 then
                        if b7562 <> 0 or b7563 <> 3 then
                            if b7562 = 2 or (b7564 and b6DC1(b7562)) <> 0 then
                            do;
                                call unpackToken(curTokenSym$p - 6, .b68AE(1));
                                if b6BDD then
                                do;
                                    if (optPAGEWIDTH - curCol) < 11h then
                                        call printCRLF;

                                    call printStr(.b68AE(1));
                                    call printChar(20h);
                                    if b7563 = 3Ah then
                                        call printChar(2Bh);
                                    else if (b7565 := (b7564 and 40h) <> 0) then
                                        call printChar(45h);
                                    else
                                        call printChar(b755C(b7564 and 7));

                                    call printChar(20h);
                                    call sub$718C(.print2Hex);
                                    call sub$718C(.print2Hex);
                                    curTokenSym$p = curTokenSym$p + 2;
                                    call printStr(.b3694);
                                end;
                            end;
        end;
    end;

    if optDEBUG then
        b68AE(0) = 0;

    if b6BDD then
        call printCRLF;
end;

printCmdLine: procedure public;
    declare ch based actRead byte;

    call outch(0Ch);
    call sub$6F4D;
    ch = 0;
    call printStr(.cmdLineBuf);
    call newPageHeader;
end;


outStr: procedure(arg1w) reentrant public;
    declare arg1w address;
    declare ch based arg1w byte;

    do while ch <> 0;
        call outch(ch);
        arg1w = arg1w + 1;
    end;
end;

outNStr: procedure(arg1b, arg2w) reentrant;
    declare arg1b byte, arg2w address,
        ch based arg2w byte;

    do while arg1b > 0;
        call outch(ch);
        arg2w = arg2w + 1;
        arg1b = arg1b - 1;
    end;
end;


sub$721E: procedure byte public;
    return w68A2 < w68A0;
end;



sub$7229: procedure public;
    declare ch based w68A2 byte;
    declare b7568 byte;

    if (b68AB := sub$721E or b68AB) then
    do;
        call out2Hex(high(w68A6));
        call out2Hex(low(w68A6));
    end;
    else
        call outStr(.b3692 + 2);

    call outch(' ');
    do  b7568 = 1 to 4; 
        if sub$721E and b6B34 then
        do;
            w68A6 = w68A6 + 1;
            call out2Hex(ch);
        end;
        else
            call outStr(.b3692 + 4);

        w68A2 = w68A2 + 1;
    end;

    call outch(' ');
    if shr(b6BDD := tokenAttr(b6A56), 6) then
        call outch('E');
    else if not b68AB then
        call outch(' ');
    else
        call outch(b755C(b6BDD and 7));
end;


sub$72D8: procedure public;
    if not b689B then
        return;

    call printStr(.asc$6DC3);    /* " (" */
    call printNStr(4, .b6A57);
    call printStr(.asc$6DC6);    /* ")" */
    call printCRLF;
    call move(4, .asciiLineNo, .b6A57);
end;



sub$872E: procedure public;
    declare ch based off$9056 byte,
        ch1 based off$6C2C byte;
loop:

   
    w68A0 = (w68A2 := tokStart(b6A56)) + tokenSize(b6A56);
    if isSkipping then
        w68A0 = w68A2;

    call outch(b6896);
    if b$905E = 0FFh then
        call outch(2Dh);
    else
        call outch(20h);

    if not xisSpace then
    do;
        b6896 = 20h;
        b689B = 0FFh;
    end;
    if b$9A77 then
        call outStr(.b3689);
    else
        call sub$7229;

    if fileIdx > 0 then
    do;
        call outch(a1234(b6BDB := b6C21 + fileIdx));
        if b6BDB > 0 then    
            call outch(3Dh);
        else
            call outch(20h);
    end;
    else
        call outStr(.b3696);

    if b68AD then
    do;
        call outStr(.b3694);
        call printCRLF;
    end;
    else
    do;
        b68AD = 0FFh;
        call outNStr(4, .asciiLineNo);
        if b$905B > 1 then
            call outch(2Bh);
        else
            call outch(20h);

        if b$905B > 1 then
        do;
            curCol = 18h;
            ch = 0;
            call printStr(.b$8FD5);
            call printChar(0Ah);
        end;
        else
        do;
            curCol = 18h;
            call printNStr(b6C30, off$6C2E);
            if ch1 <> 0Ah then
                call printChar(0Ah);
        end;
    end;

    if b$9A77 then
    do;
        if optPAGING then
            call sub$6F4D;
    end;
    else
    do;
        do while sub$721E;
            call outStr(.b3696);
            call sub$7229;
            call printCRLF;
        end;

        if b6A56 > 0 and (b6B23 or b6B24) then
        do;
            call sub$546F;
            goto loop;
        end;
    end;

    call sub$72D8;
end;

asmComplete: procedure public;
    if errCnt > 0 then
        call itoa(errCnt, .aNoErrors);
    call printNStr((errCnt = 1) + 32, .aAssemblyComple);
    if errCnt > 0 then
    do;
        call move(4, .b6A57, .asc$7520);
        call printNStr(8, .asc$751E);
    end;
    call outch(0Dh);
    call outch(0Ah);
end;

ovl9: procedure public;
    if optPRINT then
        call closeF(outfd);
    outfd = 0;
    lineCnt = 1;
    call asmComplete;
    call flushout;
end;

sub$8915: procedure public;
    declare ch based w68A6 byte;

    call closeF(infd);
    call closeF(macrofd);
    call delete(.aF0Asmac$tmp, .statusIO);
    if optOBJECT then
        call closeF(objfd);

    if optXREF then
    do;
        w68A6 = physmem - 1;
        ch = '0';
        if aF0Asxref$tmp(0) = ':' then
            ch = aF0Asxref$tmp(2);
    
        call load(.aF0Asxref, 0, 1, 0, .statusIO);
        call ioErrChk;
    end;

    call exit;
end;
end;
