global.inc
declare lit literally 'literally',
	TRUE lit '0FFh',
	FALSE lit '0',
	CR lit '0Dh',
	LF lit '0Ah';

declare tokenSize lit 'toksiz',
	tokStart lit 'tokst',
	packToken lit 'pckTkn';

declare w651F address external,
	b6521 byte external,
	w6522 address external,
	b6524 byte external,
	b6525 byte external,
	b6526(4) byte external,
	b652A byte external,
	b652B(4) byte external,
	b652F byte external,
	rec0E(4) byte external,
	rec18a structure(type byte, len address, dta(125) byte) external,
	moduleNameLen byte external,
	rec18 structure(type byte, len address, dta(125) byte) external,
	rec06 structure(type byte, len address, seg byte, addr address, dta(122) byte, crc byte) external,
	rec16 structure(type byte, len address, seg byte, dta(62) address, crc byte) external,
	rec22 structure(type byte, len address, seg byte, fixtype byte, dta(62) address) external,
	rec24 structure(type byte, len address, seg byte, fixtype byte, dta(29) address, crc byte) external,
	rec20 structure(type byte, len address, fixtype byte, dta(30) address, crc byte) external,
	rec04 structure(type byte, len address, subtype byte, seg byte, addr address, crc byte) external,
	w673F address external,
/*	pad6741 byte initial(0ah), */
	b6742 byte external,
	b6743 byte external,
	b6744 byte external,
	b6745 byte external,
/*	padb6746 byte, */
	activeSeg byte external,
	b6748 byte external,
	b6749 byte external,
	b674A(2) byte external,
	b674C(4) byte external,
	w6750 address external,
	w6752 address external,
	b6754 byte external,
	b6755 byte external,
	startAddr address external,
	tokenSP byte external,
	b6759(128) byte external,
	tokStart(9) address external,
	curTokStart address external,
	tokenSym(9) address external,
	curTokenSym$p address external,
	curTokenSym based curTokenSym$p structure(w0 address, w2 address, w4 address, type byte, b7 byte), 
	tokenType(9) byte external,
	tokenSize(9) byte external,
	tokenAttr(9) byte external,
	tokenSymId(9) address external,
/* end */
	off682A address external,
	ifDepth byte external,
	skipping(9) byte external,
	inElse(9) byte external,
	opSP byte external,
	opStack(17) byte external,
/* ov4 compat 2CA0 */
	accum1 address external,
	accum1byt(2) byte external,
	accum2 address external,
	accum2byt(2) byte external,
	b6855 byte external,
	b6856 byte external,
	b6857 byte external,
	b6858 byte external,
	b6859 byte external,
	w685A address external,
	w685C address external,
	curChar byte external,
	reget byte external,
	lookAhead byte external,
/*	pad6861 byte initial(0), */
	symTab(2) address external,
/*	pad6866 address, */
	w6868(3) address external,
	w686E address external,
	w6870 address external,
	b6872 byte external,
	b6873(6) byte external,
	b6879(6) byte external,
	b687F byte external,
	b6880 byte external,
	b6881 byte external,
	b6882 byte external,
	b6883 byte external,
	b6884 byte external,
	b6885 byte external,
	objfd address external,
	xreffd address external,
	infd address external,
	outfd address external,
/*	pad688E address, */
	statusIO address external,
	openStatus address external,
/*	pad6894 address initial(0FFFFh), */
	b6896 byte external,
/*	pad6897 byte initial(0), */
	b6898 byte external,
/* end */
/*	pad6899 byte initial(0), */
/* ov4 compat 2C9F */
	b689A byte external,
	b689B byte external,
	b689C byte external,
/*	pad689D(2) byte, */
	curCol byte external,
	w68A0 address external,
	w68A2 address external,
	lineCnt address external,
	w68A6 address external,
	pageCnt address external,
/*	pad68AA byte, */
	b68AB byte external,
/*	pad68AC byte, */
	b68AD byte external,
	b68AE(8) byte external,
	w68B6 address external,
	b68B8(200) byte external,
	outbuf(128) byte external,
/* end */
	b6A00 byte external,
/* ov4 compat 2F57 */
	out$p address external,
	endOutBuf address external,
/*	pad6A05 address initial(.outbuf), */
/*	pad6A07 byte initial(0), */
	objFile(15) byte external,
	lstFile(15) byte external,
	aF0Asxref$tmp(1) byte external,
	aF0Asxref(1) byte external,
	aF0Asmac$tmp(1) byte external,
	w6A4E address external,
	bp6A4E(2) byte external,
/*	pad6A50(2) byte initial('  '),	*/	/* protects for very big files */
	asciiLineNo(4) byte external,
	b6A56 byte external,
	b6A57(4) byte external,
	optDEBUG byte external,
	options(1) byte external,
	optMACRODEBUG byte external,
	optXREF byte external,
	optSYMBOLS byte external,
	optPAGING byte external,
	optTTY byte external,
	optMOD85 byte external,
	optPRINT byte external,
	optOBJECT byte external,
	optMACROFILE byte external,
	optPAGEWIDTH byte external,
	optPAGELENGTH byte external,
/*	pad6A67 byte initial(0), */		/* INCLUDE */
	optTITLE byte external,
/*	pad6A69(2) byte,*/			/* SAVE, RESTORE */ 
	optEJECT byte external,
	optLIST byte external,
	optGEN byte external,
	optCOND byte external,
	b6A6F byte external,
	titleLen byte external,
	b6A71 byte external,
/*	pad6A72(3) byte initial(78h, 0FFh), */
	optionSeen(12) byte external,
	saveStack(24) byte external,
	saveIdx byte external,
	optTITLESTR(64) byte external,
	collectBufLen byte external,
	b6ADB byte external,
	optionId byte external,
	collectBuf(64) byte external,
	collectBufIdx byte external,
	w6B1E address external,
/* end */
	b6B20 byte external,
	MacroDebugOrGen byte external,
/* ov4 compat 2F56 */
	scanOptions byte external,
	b6B23 byte external,
	b6B24 byte external,
	b6B25 byte external,
	has16bitOperand byte external,
	phase byte external,
	b6B28 byte external,
	b6B29 byte external,
	opType byte external,
	b6B2B byte external,
	b6B2C byte external,
	b6B2D byte external,
	b6B2E byte external,
	b6B2F byte external,
	b6B30 byte external,
	b6B31 byte external,
	b6B32 byte external,
	b6B33 byte external,
	b6B34 byte external,
	b6B35 byte external,
	b6B36 byte external,
	segSize(4) address external,
/*	padw6B3E(2) byte initial(0, 0), */
	w6B41(3) address external,
	cmdLineBuf(129) byte external,
	actRead address external,
	errCnt address external,
/*	padw6BCB(2) byte, */
	w6BCE address external,
/*	pad6BD0(3) byte initial(0), */
	w6BD3 address external,
	cmdch$p address external,
	options$p address external,
	b6BD9 byte external,
/*	pad6BDA byte, */
	b6BDB byte external,
	b6BDC byte external,
	b6BDD byte external,
/* end */
/* ov4 compat 2F57 */
	curFileName$p address external,
	w6BE0 address external,
	bp6BE0(2) byte external,
	w6BE2 address external;
/* end */
global.cmn
declare lit literally 'literally',
	TRUE lit '0FFh',
	FALSE lit '0';
declare tokenSize lit 'toksiz',
	tokStart lit 'tokst',
$IF OVL=4
	IN$BUF$SIZE lit '512',
	OUT$BUF$SIZE lit '512',
$ELSEIF OVL=5
	IN$BUF$SIZE lit '2048',
	OUT$BUF$SIZE lit '2048',
$ELSE
	IN$BUF$SIZE lit '200',
	OUT$BUF$SIZE lit '128',
$ENDIF

$IF OVL=4
	mem(1) byte public at(0),
	b$8FD5(127) byte public,
	w$9054 address public,
	off$9056 address public initial(.b$8FD5),
	b$9058 byte public initial(0),
	b$9059 byte public,
	b$905A byte public,
	b$905B byte public,
	b$905C byte public,
	b$905D byte public initial(0),
	b$905E byte public,
	b$905F byte,
	b$9060 byte public,
	b$9061 byte public,
	b$9062 byte public,
	b$9063 byte public,
	b$9064 byte public,
	b$9065 byte public,
	b$9066 byte public,
	b$9067 byte public initial(0),
	w$9068 address public,
	w$906A address public,
	/*
		mtype has the following values
		1 -> IRP
		2 -> IRPC
		3 -> REPT
		4 -> ???
		5 -> ???
	*/
		
	s906CStk(10) structure(macroCondSP byte, ifDepth byte, mtype byte, b3 byte,
			     w4 address, buf$p address, blk address, w10 address,
			     w12 address, w14 address) public,
	s906C structure(macroCondSP byte, ifDepth byte, mtype byte, b3 byte,
			     w4 address, buf$p address, blk address, w10 address,
			     w12 address, w14 address) public at(.s906CStk(0)),
	s906C$blk address at(.s906C.blk) initial(0FFFFh),
	w$910C address,
	curMacroBlk address public initial(0FFFFh),
	nxtMacroBlk address public initial(0),
	maxMacroBlk address public initial(0),
	w$9114 address public,
	macroBuf(129) byte public,
	w$9197 address public,
	w$9199 address public,
	w$919B address public,
	w$919D address public,
	w$919F address public,
	b$91A1 byte public initial(0),
	b$91A2 byte public initial(0),

	b$91A3 byte public initial(81h),
	b$91A4(*) byte public initial(3Fh, 3Fh, 0, 0, 0, 0, 80h),
$ENDIF
/* ov4 compat 2C8C */
	w651F address public,
	b6521 byte public,
	w6522 address public,
	b6524 byte public,
	b6525 byte public,
	b6526(4) byte public initial(0, 0, 0, 0),
	b652A byte public initial(0),
	b652B(4) byte public initial(0FFh, 0FFh, 0FFh, 0FFh),
	b652F byte public initial(0FFh),
	rec0E(4) byte public initial(0Eh, 0, 0),
	rec18a structure(type byte, len address, dta(125) byte) public initial(18h, 0, 0),
	moduleNameLen byte public initial(6),
	rec18 structure(type byte, len address, dta(125) byte) public initial(18h, 0, 0),
	rec06 structure(type byte, len address, seg byte, addr address, dta(122) byte, crc byte) public at(.rec18),
	rec16 structure(type byte, len address, seg byte, dta(62) address, crc byte) public initial (16h, 1, 0, 0),
	rec22 structure(type byte, len address, seg byte, fixtype byte, dta(62) address) public at(.rec16),
	rec24 structure(type byte, len address, seg byte, fixtype byte, dta(29) address, crc byte) public,
	rec20 structure(type byte, len address, fixtype byte, dta(30) address, crc byte) public,
	rec04 structure(type byte, len address, subtype byte, seg byte, addr address, crc byte) public initial( 4, 4, 0),
	w673F address public initial(0),
	pad6741 byte initial(0ah),
	b6742 byte public initial(0),
	b6743 byte public initial(0),
	b6744 byte public,
	b6745 byte public initial(1),
	padb6746 byte,
	activeSeg byte public,
	b6748 byte public initial(0),
	b6749 byte public initial(0),
	b674A(2) byte public,
	b674C(4) byte public initial(3, 3, 3, 3),
	w6750 address public,
	w6752 address public,
	b6754 byte public initial(0),
	b6755 byte public initial(0),
	startAddr address public initial(0),
	tokenSP byte public initial(0),
	b6759(128) byte public,
	tokStart(9) address public initial(.b6759),
	curTokStart address public at(.tokStart),
	tokenSym(9) address public initial(0),
	curTokenSym$p address public at(.tokenSym(0)),
	curTokenSym based curTokenSym$p structure(w0 address, w2 address, w4 address, type byte, b7 byte),
	tokenType(9) byte public,
	tokenSize(9) byte public initial(0),
	tokenAttr(9) byte public,
	tokenSymId(9) address public,
/* end */
	off682A address public initial(.tokStart),
	ifDepth byte public initial(0),
	skipping(9) byte public,
	inElse(9) byte public,
$IF OVL=4
	macroCondSP byte public initial(0),
	macroCondStk(17) byte public,
	b$94DD(2) byte,
$ENDIF
	opSP byte public,
	opStack(17) byte public,
/* ov4 compat 2CA0 */
	accum1 address public,
	accum1byt(2) byte public at(.accum1),
	accum2 address public,
	accum2byt(2) byte public at(.accum2),
	b6855 byte public,
	b6856 byte public,
	b6857 byte public,
	b6858 byte public,
	b6859 byte public,
	w685A address public,
	w685C address public,
	curChar byte public initial(0),
	reget byte public initial(0),
	lookAhead byte public,
	pad6861 byte initial(0),
	symTab(2) address public,
	w6866 address public,
	w6868(3) address public,
	w686E address public,
	w6870 address public,
	b6872 byte public initial(0),
	b6873(6) byte public,
	b6879(6) byte public,
	b687F byte public,
	b6880 byte public,
	b6881 byte public initial(0),
	b6882 byte public initial(0),
	b6883 byte public initial(0),
	b6884 byte public initial(0),
	b6885 byte public initial(0),
	objfd address public,
	xreffd address public,
	infd address public,
	outfd address public,
	macrofd address public,
	statusIO address public,
	openStatus address public,
	pad6894 address initial(0FFFFh),
	b6896 byte public initial(20h),	
	b6897 byte public initial(0),
	b6898 byte public initial(TRUE),
/* end */
$IF OVL=0
	pad6899 byte initial(0),
$ENDIF
/* ov4 compat 2C9F */
	b689A byte public,
	b689B byte public,
	b689C byte public,
	pad689D(2) byte,
	curCol byte public initial(1),
	w68A0 address public,
	w68A2 address public,
	lineCnt address public,
	w68A6 address public,
	pageCnt address public,
	pad68AA byte,
	b68AB byte public,
	pad68AC byte,
	b68AD byte public initial(0),
	b68AE(8) byte public initial(0, 0, 0, 0, 0, 0, 0, 0),
	w68B6 address public initial(IN$BUF$SIZE),
	b68B8(IN$BUF$SIZE) byte public,
	outbuf(OUT$BUF$SIZE) byte public,
/* end */
	b6A00 byte public,
/* ov4 compat 2F57 */
	out$p address public initial(.outbuf),
	endOutBuf address public,
	pad6A05 address initial(.outbuf),
	pad6A07 byte initial(0),
	objFile(15) byte public initial('               '), /* 15 spaces */
	lstFile(15) byte public initial('               '), /* 15 spaces */
	aF0Asxref$tmp(*) byte public initial(':F0:ASXREF.TMP '),
	aF0Asxref(*) byte public initial(':F0:ASXREF '),
	aF0Asmac$tmp(*) byte public initial(':F0:ASMAC.TMP '),
	w6A4E address public initial(1),
	bp6A4E(2) byte public at(.w6A4E),
	pad6A50(2) byte initial('  '),		/* protects for very big files */
	asciiLineNo(4) byte public initial('   0'),
	b6A56 byte public,
	b6A57(4) byte public initial('   0'),
	optDEBUG byte public initial(0),	/* DEBUG */
	options(1) byte public at(.optDEBUG),
	optMACRODEBUG byte public initial(0),		/* MACRODEBUG */
	optXREF byte public initial(0),		/* XREF */
	optSYMBOLS byte public initial(0FFh),	/* SYMBOLS */
	optPAGING byte public initial(0FFh),	/* PAGING */
	optTTY byte public initial(0),		/* TTY */
	optMOD85 byte public initial(0),	/* MOD85 */
	optPRINT byte public initial(0FFh),	/* PRINT */
	optOBJECT byte public initial(0FFh),	/* OBJECT */
	optMACROFILE byte public initial(0),		/* MACROFILE */
	optPAGEWIDTH byte public initial(78h),		/* PAGEWIDTH */
	optPAGELENGTH byte public initial(42h),		/* PAGELENGTH */
	pad6A67 byte initial(0),		/* INCLUDE */
	optTITLE byte public initial(0),		/* TITLE */
	pad6A69(2) byte,			/* SAVE, RESTORE */
	optEJECT byte public initial(0),		/* EJECT */
	optLIST byte public initial(0FFh),	/* LIST */	/* SAVE/RESTORE act on next 3 opts */
	optGEN byte public initial(0FFh),	/* GEN */
	optCOND byte public initial(0FFh),	/* COND */
	b6A6F byte public initial(0FFh),
	titleLen byte public initial(0),
	b6A71 byte public,
	pad6A72(3) byte initial(78h, 0FFh),
	optionSeen(12) byte public initial(0,0,0,0,0,0,0,0,0,0,0,0),
	saveStack(24) byte public,
	saveIdx byte public initial(0),
	optTITLESTR(64) byte public,
	collectBufLen byte public,
	b6ADB byte public,
	optionId byte public,
	collectBuf(64) byte public,
	collectBufIdx byte public initial(0),
	w6B1E address public,
/* end */
$IF OVL=4
	b$9A77 byte public initial(0),
$ELSE
	b6B20 byte public initial(0),
	MacroDebugOrGen byte public initial(0),
$ENDIF
/* ov4 compat 2F56 */
	scanOptions byte public,
	b6B23 byte public,
	b6B24 byte public,
	b6B25 byte public,
	has16bitOperand byte public,
	phase byte public,
	b6B28 byte public,
	b6B29 byte public,
	opType byte public,
	b6B2B byte public,
	b6B2C byte public,
	b6B2D byte public,
	b6B2E byte public,
	b6B2F byte public,
	b6B30 byte public,
	b6B31 byte public,
	b6B32 byte public,
	b6B33 byte public,
	b6B34 byte public initial(0FFh),
	b6B35 byte public initial(0FFh),
	b6B36 byte public initial(0),
	segSize(4) address public initial(0, 0, 0, 0),	/* note treated as array */
	padw6B3E(2) byte initial(0, 0),
	w6B41(3) address public initial(0, 0, 0),
	cmdLineBuf(129) byte public,
	actRead address public,
	errCnt address public,
	padw6BCB(2) byte,
	w6BCE address public,
	pad6BD0(3) byte initial(0),
	w6BD3 address public initial(0),
	cmdch$p address public initial(.cmdLineBuf),
	options$p address public,
	b6BD9 byte public initial(0),
	b6BDA byte public,
	b6BDB byte public,
	b6BDC byte public,
	b6BDD byte public,
/* end */
$IF OVL=4
	b$9B34 byte initial(0),
$ENDIF
/* ov4 compat 2F57 */
	curFileName$p address public,
	w6BE0 address public,
	bp6BE0(2) byte public at(.w6BE0),
	w6BE2 address public;
/* end */
asm801.plm
asm80$1:
do;

$include(global.inc)

close: procedure(w1, w2) external; declare (w1, w2) address; end;
delete: procedure(w1, w2) external; declare (w1, w2) address; end;
error: procedure(w1) external; declare w1 address; end;
exit: procedure external; end;
load: procedure(w1, w2, w3, w4, w5) external; declare (w1, w2, w3, w4, w5) address; end;
open: procedure(w1, w2, w3, w4, w5) external; declare (w1, w2, w3, w4, w5) address; end;
printCmdLine: procedure external; end;
writeRec02: procedure external; end;		/* in overlay 2 */
parseCmds: procedure external; end;
asmComplete: procedure external; end;
writeRec040E: procedure external; end;
ovl9: procedure external; end;
ovl10: procedure external; end;
ovl11: procedure external; end;
skip2NextLine: procedure external; end;
sub$4904: procedure external; end;
sub$540D: procedure external; end;
sub$54FD: procedure external; end;
writeRec: procedure(w) external; declare w address; end;	/* in overlay 2 */
getAsmFileX: procedure external; end;
printDecimal: procedure(w1) external; declare w1 address; end;		/* overlay 1 */
resetData: procedure external; end;
sub$70EE: procedure external; end;
write: procedure(w1, w2, w3, w4) external; declare (w1, w2, w3, w4) address; end;

strUCequ: procedure(w1, w2) byte external; declare (w1, w2) address; end;
isSkipping: procedure byte external; end;
getCh: procedure byte external; end;



declare (b6C21, b6C27, b6C30) byte external,
	(includefd, rootfd, off6C2C, off6C2E) address external;

declare	asc$3680(*) byte public data('                  '),
	asc$3692(*) byte public data('      ', 0),
	asc$3699(*) byte public data(0Dh, 0Ah, 0),
	signonMsg(*) byte public data(0Dh, 0Ah),
	aIsisIi80808085(*) byte public data('ISIS-II 8080/8085 MACRO ASSEMBLER, V4.1', 9, 9),
	aModulePage(*) byte public data('MODULE ',9, ' PAGE ', 0),
	cZERO byte public data(0),
	c255 byte public data(0FFh),
	aC19761977197$0(*) byte data('(C) 1976,1977,1979,1980 INTEL CORP'),
	aStack(*) byte public data(0Dh, 0Ah, 'STACK', 0),
	aTable(*) byte public data(0Dh, 0Ah, 'TABLE', 0),
	aCommand(*) byte public data(0Dh, 0Ah, 'COMMAND', 0),
	aEof(*) byte public data(0Dh, 0Ah, 'EOF', 0),
	aFile(*) byte public data(0Dh, 0Ah, 'FILE', 0),
	aMemory(*) byte public data(0Dh, 0Ah, 'MEMORY', 0),
	aError(*) byte public data(' ERROR', 0Dh, 0Ah, 0),
	aError$0(*) byte public data(' ERROR, ', 0Dh,0Ah, 0),
	errStrs(*) address public data(.aStack, .aTable, .aCommand, .aEof, .aFile, .aMemory),
	errStrsLen(*) byte public data(7, 7, 9, 5, 6, 8),
	aBadSyntax(*) byte public data('BAD SYNTAX', 0Dh, 0Ah),
	aCo(*) byte public data(':CO:', 0);

declare	loadedOvl byte initial(4),
	ovlFile(*) byte public initial(':F0:ASM80.OV0 ');


physmem: procedure address public;
	declare top address at(4);

	return (top - 100h) and 0FF00h;
end;


nxtCmdCh: procedure byte public;
	declare cmdch based cmdch$p byte;
	declare ch byte;

	ch = cmdch;
	cmdch$p = cmdch$p + 1;
	if 'a' <= ch and ch <= 'z' then
		ch = ch and 5Fh;
	return ch;
end;	


ioErrChk: procedure public;
	if statusIO = 0 then
		return;
	call error(statusIO);
	call exit;
end;


flushout: procedure public;
	call write(outfd, .outbuf, out$p - .outbuf, .statusIO);
	out$p = .outbuf;
end;

outch: procedure(arg1b) public;
	declare arg1b byte;
	declare ch based out$p byte;

	if out$p = endOutBuf then
		call flushout;
	ch = arg1b;
	out$p = out$p + 1;
end;

outStrN: procedure(arg1w, arg2b) public;
	declare arg1w address, arg2b byte;
	declare ch based arg1w byte;

	do while arg2b > 0;
		call outch(ch);
		arg1w = arg1w + 1;
		arg2b = arg2b - 1;
	end;
end;

ovlMgr: procedure(ovl) public;
	declare ovl byte;
	declare w6BF9 address;

	if ovl > 4 then
	do;
		statusIO = 0Dh;
		call ioErrChk;
	end;
	if ovl <> loadedOvl then
	do;
		ovlFile(12) = ovl + '0';
		call load(.ovlFile, 0, 0, .w6BF9, .statusIO);
		call ioErrChk;
		loadedOvl = ovl;
	end;
end;

closeF: procedure(arg1w) public;
	declare arg1w address;

	call close(arg1w, .statusIO);
end;

isSpace: procedure byte public;
	return curChar = 20h;
end;

isTab: procedure byte public;
	return curChar = 9;
end;

isWhite: procedure byte public;
	return isSpace or isTab;
end;

isRParen: procedure byte public;
	return curChar = 29h;
end;

isCR: procedure byte public;
	return curChar = 0Dh;
end;

isComma: procedure byte public;
	return curChar = 2Ch;
end;

isPhase1: procedure byte public;
	return phase = 1;
end;


skip2EOL: procedure public;
	if not isCR then
		do while getCh <> 0Dh;
		end;
end;


sub$3A71: procedure byte public;
	return phase > 2 and optOBJECT;
end;


isPhase2Print: procedure byte public;
	return phase = 2 and optPRINT;
end;

wrConsole: procedure(arg1w, arg2w) public;
	declare (arg1w, arg2w) address;

	call write(0, arg1w, arg2w, .statusIO);
	call ioErrChk;
end;

wrError: procedure(arg1b) public;
	declare arg1b byte;

	if b6BD9 then
		return;
	
	if isPhase1 and arg1b = 0 then
	do;
		b6B33 = TRUE;
		return;
	end;

	w6BE0 = .aError;
	if arg1b = 4 then
		w6BE0 = .aError$0;

	call wrConsole(errStrs(arg1b), errStrsLen(arg1b));
	call wrConsole(w6BE0, 8);
	if isPhase2Print then
	do;
		call outStrN(errStrs(arg1b), errStrsLen(arg1b));
		call outStrN(w6BE0, 8);
	end;
	if arg1b = 4 or arg1b = 3 then
	do;
		if collectBufIdx = 0 then
		do;
			call wrConsole(.aBadSyntax, 12);
			if not scanOptions then
			do;
				call skip2NextLine;
				outfd = 0;
				call ovlMgr(1);
				call printDecimal(w6A4E);		/* overlay 1 */
				call outch(0Ah);
			end;
		end;
		else
		do;
			call wrConsole(curFileName$p, collectBufIdx);
			call wrConsole(.asc$3699, 2);
		end;
	end;
	if arg1b = 0 then
	do;
		b6BD9 = TRUE;
		return;
	end;
	call exit;
end;

fileError: procedure(arg1w) public;
	declare arg1w address;
	declare ch based arg1w byte;

	collectBufIdx = 0;
	curFileName$p = arg1w;

	do while ch <> ' ' and ch <> 0dh and ch <> 9;
		collectBufIdx = collectBufIdx + 1;
		arg1w = arg1w + 1;
	end;
	if b6C27 then
		call wrError(3);	/* EOF error */
	call wrError(4);		/* file error */
end;

inOpen: procedure(arg1w, arg2w) address public;
	declare (arg1w, arg2w) address;
	declare open$infd address;

	call open(.open$infd, arg1w, arg2w, 0, .openStatus);
	if openStatus <> 0 then
		call fileError(arg1w);
	return open$infd;
end;


nibble2Ascii: procedure(n) byte public;
	declare n byte;
	n = (n and 0Fh) + '0';
	if n > '9' then
		n = n + 7;
	return n;
end;

put2Hex: procedure(arg1w, arg2b) public;
	declare arg1w address, arg2b byte;

	call arg1w(nibble2Ascii(ror(arg2b, 4)));
	call arg1w(nibble2Ascii(arg2b));
end;

xisSpace: procedure byte public;
	return b6896 = 20h;
end;

sub$3C91: procedure byte public;
	return xisSpace or b6896 = 'M' or b6896 = 'P';
end;


getNibble: procedure(arg1w, arg2b) byte public;
	declare arg1w address, arg2b byte;
	declare ch based arg1w byte;
	declare b6C11 byte;

	arg1w = arg1w + shr(arg2b, 1);
	b6C11 = ch;
	if not arg2b then
		b6C11 = ror(b6C11, 4);
	return b6C11 and 0Fh;
end;

sub$3CDF: procedure(arg1b) public;
	declare arg1b byte;

	if not isSkipping or b6B2B = 22h then	/* ELSE */
	do;
		if b6749 then
			b6754 = TRUE;
		if xisSpace then
			errCnt = errCnt + 1;

		if sub$3C91 or arg1b = 'L' or arg1b = 'U' then
			if b6896 <> 'L' then
				b6896 = arg1b;
	end;
end;

parseDollarLines: procedure public;
	do while getCh = '$';
		if isSkipping then
		do;
			call skip2NextLine;
			b6B20 = 0FFh;
		end;
		else
		do;
			call ovlMgr(0);
			call parseCmds;
		end;
		call sub$54FD;
	end;
	reget = 1;
end;


sub$3D6D: procedure public;
	cmdch$p = options$p;
	scanOptions = 0FFh;
	call ovlMgr(0);
	call parseCmds;
	if isPhase2Print then
	do;
		call ovlMgr(1);
		call printCmdLine;
	end;

	if b6C21 then
		call sub$4904;

	b6C21, b6B20, scanOptions = cZERO;
	call parseDollarLines;
	b6898 = 0;
	optDEBUG = optDEBUG and optOBJECT;
	optXREF = optXREF and optPRINT;
	optSYMBOLS = optSYMBOLS and optPRINT;
	optPAGING = optPAGING and optPRINT;
end;



sub$3DCE: procedure public;
	off6C2E = off6C2C + 1;
	b6C30 = 0;
	if b6C21 then
		call sub$4904;

	b68AD, has16bitOperand, b6B20, b689B, b687F, b6B25, b6B30, b6881, b6872, b6880,
	b6B23, b6B24, b6B32, b68AB, b6884, b6885 = cZERO;
	b689C, b6B31, b6B34, b6B35 = c255;
	optEJECT, b6857, tokenSP, tokenSize(0), tokenType(0), b6858, b6859, b6742, b6855 = cZERO;
	b6896 = 20h;
	b689A = 1;
	w6A4E = w6A4E + 1;
	skipping(0) = skipping(0) > 0;
end;



start:
	call getAsmFileX;
	phase = 1;
	call resetData;
	call sub$3D6D;
	if optMACROFILE then
	do;
		if physmem < 8001h then
			call wrError(5);	 /* memory error */
		if includefd <> rootfd then
			call closeF(includefd);
		call closeF(infd);
		ovlFile(12) = '4';
		call load(.ovlFile, 0, 1, 0, .statusIO);
		call ioErrChk;
	end;
	if physmem > 8001h then
	do;
		if includefd <> rootfd then
			call closeF(includefd);
		call closeF(infd);
		ovlFile(12) = '5';
		call load(.ovlFile, 0, 1, 0, .statusIO);
		call ioErrChk;
	end;

	if MacroDebugOrGen then			/* error if no Macrofile */
		call wrError(2);		/* command error */

	if optOBJECT then
	do;
		call delete(.objFile, .statusIO);
		objfd = inOpen(.objFile, 3);
	end;

	if optXREF then
	do;
		xreffd = inOpen(.aF0Asxref$tmp, 2);
		outfd = xreffd;
	end;

	call sub$540D;
	phase = 2;
	if optOBJECT then
	do;
		call ovlMgr(2);
		if rec18a.len > 0 then
			call writeRec(.rec18a); /* in overlay 2 */
		if w6750 = 0 then
			call writeRec02;		/* in overlay 2 */
	end;
	if not optOBJECT or optPRINT then
	do;
		if optPRINT then
			outfd = inOpen(.lstFile, 2);

		call ovlMgr(3);
		call resetData;
		call sub$3D6D;
		call sub$540D;
	end;
	if optPRINT then
	do;
		call ovlMgr(1);
		call asmComplete;
		call flushout;
	end;
	if optOBJECT then
	do;
		phase = 3;
		call ovlMgr(3);
		call resetData;
		call sub$70EE;
		call sub$3D6D;
		call sub$540D;
		call ovlMgr(2);
		call ovl11;
		call writeRec040E;
	end;
	if not strUCequ(.aCo, .lstFile) then
	do;
		call ovlMgr(1);
		call ovl9;
	end;

	call ovlMgr(1);
	call ovl10;

end;
asm82.pl3
asm80$2:
do;

$include(global.inc)

declare b3E5E(*) byte data(0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			   0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0),
	b3EA0(*) byte data(36h, 0, 0, 0, 6, 0, 0, 2),
	b3EA8(*) byte data(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0, 0, 0FFh,
			   0, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0,
			   0FFh, 0, 0, 0);

ascii2Num: procedure external; end;
packToken: procedure external; end;
popToken: procedure external; end;
pushToken: procedure(b) external; declare b byte; end;
skip2EOL: procedure external; end;
parseDollarLines: procedure external; end;
sub$43D2: procedure external; end;
sub$467F: procedure(b, w) external; declare b byte, w address; end;
sub$5819: procedure(w, b) external; declare w address, b byte; end;
chkLF: procedure external; end;
sub$5ED7: procedure external; end;
sub$5EE3: procedure external; end;
sub$5F1F: procedure external; end;
addByte2Tok: procedure(b) external; declare b byte; end;
collectIdent: procedure(b) external; declare b byte; end;
collectString: procedure external; end;

isWhite: procedure byte external; end;
isTab: procedure byte external; end;
getCh: procedure byte external; end;
getChClass: procedure byte external; end;
lookup: procedure(b) byte external; declare b byte; end;
testBit: procedure(b, w) byte external; declare b byte, w address; end;

declare b6CE4 byte external,
	c255 byte external,
	asc$3692(1) byte external;

skipWhite: procedure public;
	do while isWhite;
		curChar = getCh;
	end;
end;


skipWhite$2: procedure public;
	do while getCh = ' ' or isTab;
	end;
end;


skip2NextLine: procedure public;
	call skip2EOL;
	call chkLF;
end;



sub$3F19: procedure public;

	sub$416B: procedure;
		if opType = 0 then
			call sub$5EE3;
		b6B25 = 0;
		opType = 0;
	end;

	do while 1;
		if b689C then
		do;
			call parseDollarLines;
			b689C = 0;
		end;

		do case getChClass;
	/* 0 */		call sub$5F1F;
	/* 1 */		;
	/* 2 */		do;
				b6742 = 0FFh;
				call skip2NextLine;
				b6B29 = 1;
				return;
			end;
	/* 3 */		do;
				if not b6872 then
				do;
					if skipping(0) then
						call popToken;
					else
					do;
						b6CE4 = 2;
						call sub$5819(segSize(activeSeg), 2);
					end;

					b6B30 = 0;
					b6872, b6B31 = c255;
				end;
				else
				do;
					call sub$5ED7;
					call popToken;
				end;

				call sub$467F(0, .b6873);
				b6880 = 0;
				opType = 3;
			end;
	/* 4 */		do;
				call chkLF;
				b6B29 = 1;
				return;
			end;
	/* 5 */		do;
				if curChar = '+' or curChar = '-' then
					if opType <> 0  and opType <> 3 then
						curChar = curChar + 3;
				b6B29 = (curChar - 28h) + 2;
				return;
			end;
	/* 6 */		do;
				call pushToken(0Ch);
				call addByte2Tok(low(segSize(activeSeg)));
				call addByte2Tok(high(segSize(activeSeg)));
				if activeSeg <> 0 then
					tokenAttr(0) = tokenAttr(0) or activeSeg or 18h;
				call sub$416B;
			end;
	/* 7 */		do;
				call collectString;
				if b6B31 then
					call sub$43D2;
				call sub$416B;
			end;
	/* 8 */		do;
				call ascii2Num;
				if b6B31 then
					call sub$43D2;
				call sub$416B;
			end;
	/* 9 */		do;
				call collectIdent(9);
				if tokenSize(0) > 6 then
					tokenSize(0) = 6;
				if optXREF then
				do;
					call move(6, .b6873, .b6879);
					call move(6, .asc$3692, .b6873);	/* blanks */
				end;
				call move(tokenSize(0), tokStart(0), .b6873);
				b6744 = tokenSize(0);
				call packToken;
				if b6880 then
				do;
					b687F = 0FFh;
					b6880 = 0;
				end;

				if lookup(0) = 9 then
				do;
					tokenType(0) = lookup(1);
					b6880 = 0FFh;
				end;

				b6B29 = tokenType(0);
				b6885 = b3EA8(tokenType(0));
				if not b3E5E(tokenType(0)) then
					call popToken;

				if b687F then
				do;
					call sub$467F((not testBit(b6B29, .b3EA0)) and 1, .b6879);
					b687F = 0;
				end;
				if b6B29 < 10 or b6B29 = 9 or 80h then
				do;
					call sub$416B;
					if b6B31 then
						call sub$43D2;
				end;
				else
				do;
					b6B31 = 0;
					return;
				end;
			end;
		end;
	end;
end;



end;
asm83.plm
asm80$3: do;

$include(global.inc)

declare b4181(*) byte public data(0, 80h, 0, 0, 0Fh, 0Fh, 80h, 0Fh, 0Dh, 0Fh,
			   0Dh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Dh, 0Fh, 0Fh,
			   0Fh, 0Fh, 0Fh, 0Fh, 0Dh, 0Dh, 40h, 4Dh, 1, 1,
			   1, 1, 80h, 1, 0, 0, 47h, 7, 7, 7,
			   17h, 47h, 7, 47h, 37h, 5, 7, 0, 0, 0,
			   40h, 40h, 0, 1),
	b41B7(*) byte data(41h, 0, 0, 0, 19h, 40h, 0, 1Ch, 0, 0),
	b41C1(*) byte data(1Ah, 5, 80h, 0, 0C0h),
	b41C6(*) byte data(57h, 71h, 0F4h, 57h, 76h, 66h, 66h, 67h, 77h, 77h, 77h, 55h),
	b41D2(*) byte data(57h, 6, 2, 20h, 0, 0, 0, 0, 0, 0, 0, 22h),
	b41DE(*) byte data(3Ah, 0FFh, 80h, 0, 0, 0Fh, 0FEh, 0, 20h),
	b41E7(*) byte data(0, 0, 0, 0, 8, 7, 1, 7, 7, 8, 7, 6, 6, 6, 6, 6, 6,
			   5, 4, 3, 3, 8, 8, 8, 9, 9, 1, 1, 1, 1, 1, 1, 1, 1,
			   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			   1, 1, 1);


flushout: procedure external; end;
outch: procedure(b) external; declare b byte; end;
outStrN: procedure(w1, w2) external; declare w1 address, w2 address; end;
popToken: procedure external; end;
closeF: procedure(w) external; declare w address; end;
sub$5ED7: procedure external; end;
sub$5EE3: procedure external; end;
sub$5F01: procedure external; end;
sub$5F2B: procedure external; end;
sub$5F37: procedure external; end;
nibble2Ascii: procedure(b) byte external; declare b byte; end;


isPhase1: procedure byte external; end;
isSkipping: procedure byte external; end;


testBit: procedure(arg1b, arg2w) byte public;
	declare arg1b byte, arg2w address;
	declare ch based arg2w byte;

	if ch < arg1b then
		return 0;
	
	arg2w = arg2w + shr(arg1b, 3) + 1;
	return (ch and ROR(1, (arg1b and 7) + 1)) <> 0;
end;

sub$425B: procedure(arg1b) byte public;
	declare arg1b byte;

	return arg1b = 7 or arg1b = 8;
end;

sub$4274: procedure public;
	if testBit(b6B2B, .b41B7) then
		if sub$425B(b6858) then
			call sub$5F37;
end;

sub$4291: procedure public;
	if sub$425B(b6858) then
		call sub$5F37;
	if (b4181(b6B2B) and 2) = 0 then
		b6856 = 0;
	else if sub$425B(b6859) then
		call sub$5F37;

	b6858 = 0Ch;
	bp6BE0(0) = (b6855 and 18h) <> 0;
	bp6BE0(1) = (b6856 and 18h) <> 0;
	if (b6855 and 7) <> 0 then
		if (b6856 and 7) <> 0 then
			if ((b6855 xor b6856) and 1Fh) <> 0 then
				call sub$5EE3;
	if (b6BDB := (b6855 and 40h) <> 0) or (b6BDC := (b6856 and 40h) <> 0) then
	do;
		if b6B2B = 5 then	/* +? (PAGE INPAGE)? */
			if not (b6BDB or bp6BE0(0)) then
			do;
				w685A = w685C;
				b6855 = b6856;
				return;
			end;
		if b6BDC or bp6BE0(1) or not testBit(b6B2B, .b41C1) then
			goto L4394;
		else
			return;
	end;
	b6BDD = shl(b6B2B - 4, 2) or (bp6BE0(0) and 2) or (bp6BE0(1) and 1);
	if testBit(b6BDD, .b41C6) then
L4394:	do;
		call sub$5EE3;
		b6855 = 0;
		return;
	end;
	if testBit(b6BDD, .b41D2) then
	do;
		if not bp6BE0(0) then
			b6855 = b6856;
		return;
	end;
	b6855 = 0;
end;


swapAccBytes: procedure public;
	declare b6C17 byte;
	b6C17 = accum1byt(0);
	accum1byt(0) = accum1byt(1);
	accum1byt(1) = b6C17;
end;



sub$43D2: procedure public;
	b6B30 = 0FFh;
	b6B31 = 0;
end;



sub$43DD: procedure address public;
	declare ch based curTokStart byte;
	declare cha based curTokStart(1) byte;
	declare w6C18 address;
	declare wrd based w6C18 address;

	b6855 = 0;
	accum1 = 0;
	b6858 = 9;
	if tokenSP = 0 or (tokenType(0) = 0Bh and not b6B36) then
		call sub$5ED7;
	else
	do;
		if tokenType(0) = 9 or tokenType(0) = 6 then
			call sub$5F2B;
		else
		do;
			b6858 = tokenType(0);
			if testBit(b6858, .b41DE) then
			do;
				curTokStart = curTokenSym$p + 7;
				b6855 = ch and 0DFh;
				curTokStart, w6C18 = curTokenSym$p + 4;
				w685A = wrd;
				tokenSize(0) = 2;
			end;
			else if tokenSize(0) = 0 then
				call sub$5F01;
			else
			do;
				if tokenSize(0) > 2 then
					call sub$5F01;

				b6855 = tokenAttr(0) and 0DFh;
				w685A = tokenSymId(0);
			end;

			if tokenSize(0) > 0 then
				accum1byt(0) = ch;
			if tokenSize(0) > 1 then
				accum1byt(1) = cha(1) and tokenType(0) <> 7;
		end;
		if has16bitOperand then
			if tokenSize(0) = 2 then
				if tokenType(0) = 10 then
					call swapAccBytes;

		if (b6855 and 40h) <> 0 then
			if tokenType(0) < 9 then
				accum1 = 0;

		call popToken;

	end;
	b6B36 = 0;
	return accum1;
end;


getPrec: procedure(arg1b) byte public;
	declare arg1b byte;
	return b41E7(arg1b);
end;


sub$450F: procedure(arg1b) public;
	declare arg1b byte;

	if (arg1b and 3) <> 0 then
	do;
		if accum2byt(1) <> 0
		   or accum2byt(0) > 7
		   or arg1b and accum2byt(0)
		   or (arg1b and 3) = 3 and accum2byt(0) > 2
		   or (not sub$425B(b6859) and b6B2B <> 2Eh) then	/* RST */
			call sub$5F37;
		else if sub$425B(b6859) and b6B2B = 2Eh then		/* RST */
			call sub$5F37;
		if ror(arg1b, 2) then
			accum2byt(0) = rol(accum2byt(0), 3);
		accum1byt(0) = accum1byt(0) or accum2byt(0);
	end;
	else if b6B2B <> 2Dh then					/* single byte op */
		if sub$425B(b6859) then
			call sub$5F37;

	if shr(arg1b, 3) then
	do;
		if (b6856 and 18h) = 18h then
		do;
			call sub$5F01;
			b6856 = b6856 and 0E7h or 8;
		end;
		if accum2byt(1) + 1 > 1 then
			call sub$5F01;
	end;
	if b6B2B = 28h or b6B2B = 2Ch then		/* Imm8 or imm16 */
	do;
		b6855 = b6856;
		w685A = w685C;
	end;
	else
		b6855 = 0;

	if b6B2B <> 2Dh then				/* single byte op */
		if accum1byt(0) = 76h then
			call sub$5F37;
	if (b6B2B := shr(arg1b, 4) + 24h) = 24h then	/* LXI */
		b6B2D = 0Bh;
end;

sub$4646: procedure byte public;
	if b689A >= tokenSP then
		return 0;
	return (b689A := b689A + 1);
end;


sub$465B: procedure byte public;
	return (((not b6B20) and optLIST) or (b6A6F and b6B20)) and ((not (b6B32 or skipping(0))) or optCOND);
end;


sub$467F: procedure(arg1b, arg2w) public;
	declare arg1b byte, arg2w address;
	declare (b6C1F, b6C20) byte;

	if not isPhase1 or not optXREF or isSkipping and not b6881 then
		return;

	call outch(arg1b + '0');
	if arg1b <> 2 then
	do;
		call outStrN(arg2w, 6);
		b6881 = 0;
		b6C20 = bp6A4E(1);
		b6C1F = 0;
		do while b6C1F < 4;
			b6C1F = b6C1F + 1;
			if b6C1F then
			do;
				if b6C1F = 3 then
					b6C20 = bp6A4E(0);
				call outch(nibble2Ascii(shr(b6C20, 4)));
			end;
			else
				call outch(nibble2Ascii(b6C20));
		end;
	end;
	else
	do;
		call outStrN(.lstFile, 15);
		if optPAGING then
			call outch('1');
		else
			call outch('0');

		call outch(nibble2Ascii(ror(optPAGELENGTH, 4)));
		call outch(nibble2Ascii(optPAGELENGTH));
		call outch(nibble2Ascii(ror(optPAGEWIDTH, 4)));
		call outch(nibble2Ascii(optPAGEWIDTH));
		call outch('3');
		call flushout;
		call closeF(xreffd);
	end;
end;

end;
asm84.pl3
asm80$4: do;

$include(global.inc)

declare	b6C21 byte public initial(0),
	b6C22 byte public initial(0),
	b6C23 byte public,
	fileIdx byte public initial(0),
	off6C25 address public initial(.b68B8),
	b6C27 byte public initial(0),
	includefd address public,
	rootfd address public,
	off6C2C address public initial(.b68B8 - 1),
	off6C2E address public initial(.b68B8),
	b6C30 byte public initial(0), 
	files(6) structure(name(15) byte, blk address, byt address, b19 byte) public,
	seekIBlk address,
	seekIByte address,
	pad6CAD byte,  
	w6CAE address,
	w6CB0 address,
	pad6CB2(4) address,
	readFActual address,
	pad6CBC address;


close: procedure(w1, w2) external; declare (w1, w2) address; end;
fileError: procedure(w1) external; declare w1 address; end;
ioErrChk: procedure external; end;
read: procedure(w1, w2, w3, w4, w5) external; declare (w1, w2, w3, w4, w5) address; end;
seek: procedure(w1, w2, w3, w4, w5) external; declare (w1, w2, w3, w4, w5) address; end;
inOpen: procedure(w1, w2) address external; declare (w1, w2) address; end;


readF: procedure(arg1b, arg2w, arg3w) public;
	declare arg1b byte, (arg2w, arg3w) address;
	call read(arg1b, arg2w, arg3w, .readFActual, .statusIO);
	call ioErrChk;
end;

seekI: procedure(arg1b) public;
	declare arg1b byte;
	call seek(includefd, arg1b, .seekIBlk, .seekIByte, .statusIO);
	call ioErrChk;
end;


readI: procedure(arg1w) public;
	declare arg1w address;
	declare pad byte;

	call readF(includefd, arg1w, .b68B8(w68B6) - arg1w);
	off6C25 = arg1w + readFActual;
end;



closeI: procedure public;
	call close(includefd, .statusIO);
	call ioErrChk;
	if fileIdx = 0 then
	do;
		b6C27 = 0FFh;
		call fileError(.files(0).name);
		return;
	end;
	fileIdx = fileIdx - 1;
	if fileIdx = 0 then
		includefd = rootfd;
	else
		includefd = inOpen(.files(fileIdx).name, 1);

	seekIByte = files(fileIdx).byt;
	seekIBlk = files(fileIdx).blk;
	call seekI(2);	/* SEEKABS */
	off6C25 = .b68B8;
	off6C2C = .b68B8 - 1;
end;


sub$4879: procedure byte public;
	declare ch based off6C2C byte;
	declare w6CC7 address;
    loop:
	off6C2C = off6C2C + 1;
	if off6C2C = off6C25 then
	do;
		w6CAE = off6C2E;
		w6CB0 = off6C25;
		if w6CB0 - w6CAE > 0 then
			call move(w6CB0 - w6CAE, off6C2E, .b68B8);
		off6C2E = .b68B8;
		call readI(w6CC7 := off6C2E + (w6CB0 - w6CAE));
		off6C2C = w6CC7;
	end;

	if readFActual = 0 then
	do;
		call closeI;
		goto loop;
	end;

	b6C30 = b6C30 + 1;
	return ch and 7Fh;
end;


sub$4904: procedure public;
	declare b6CC9 byte, w6CCA address;

	b6C21 = 0;
	call seekI(0);	/* SEEKTELL */
	if seekIByte = 128 then
	do;
		seekIBlk = seekIBlk + 1;
		seekIByte = 0;
	end;

	w6CCA = off6C25 - off6C2E;
x:						/* forces code alignment */
	if (b6CC9 := w6CCA mod 128) > seekIByte then
	do;
		seekIByte = seekIByte + 128;
		seekIBlk = seekIBlk - 1;
	end;

	files(fileIdx - 1).byt = seekIByte - b6CC9;
	files(fileIdx - 1).blk = seekIBlk - w6CCA / 128;
	if includefd <> rootfd then
	do;
		call close(includefd, .statusIO);
		call ioErrChk;
	end;

	off6C25 = .b68B8;
	off6C2C = off6C25 - 1;
	off6C2E = .b68B8;
	files(fileIdx).blk = 0;	
	files(fileIdx).byt = 0;	
	includefd = inOpen(.files(fileIdx).name, 1);
end;
end;
asm85.pl3
asm80$5: do;

$include(global.inc)

declare b4A26(*) byte data(0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh,
			   0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh,
			   0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh,
			   0FFh, 0FFh, 0FFh, 0FFh, 0, 0FFh, 0FFh, 0FFh),
	b4A68(*) byte data(0, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0,
			   0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh,
			   0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh);

declare pad byte;

declare	(asc$3692, aModulePage)(1) byte external,
	b6CE4 byte external,
	b4181(1) byte external;

exit: procedure external; end;
flushout: procedure external; end;
sub2$6E32: procedure external; end;
ovl2: procedure external; end;
ovl3: procedure external; end;
writeRec02: procedure external; end;
ovl8: procedure external; end;
ovlMgr: procedure(b1) external; declare b1 byte; end;
popToken: procedure external; end;
pushToken: procedure(b1) external; declare b1 byte; end;
sub$3CDF: procedure(b1) external; declare b1 byte; end;
sub$3DCE: procedure external; end;
sub$3F19: procedure external; end;
sub$4274: procedure external; end;
sub$4291: procedure external; end;
getPrec: procedure(b1) byte external; declare b1 byte; end;
sub$450F: procedure(b1) external; declare b1 byte; end;
sub$467F: procedure(b, w) external; declare b byte, w address; end;
sub$54FD: procedure external; end;
sub$5819: procedure(w, b) external; declare w address, b byte; end;
sub$5ED7: procedure external; end;
sub$5EE3: procedure external; end;
sub$5F01: procedure external; end;
sub$5F07: procedure external; end;
sub$5F13: procedure external; end;
sub$5F25: procedure external; end;
sub$5F37: procedure external; end;
nestIF: procedure(b) external; declare b byte; end;
unnestIF: procedure(b) external; declare b byte; end;
addByte2Tok: procedure(b) external; declare b byte; end;
sub$425B: procedure(b) byte external; declare b byte; end;
sub$43DD: procedure address external; end;
isPhase1: procedure byte external; end;
haveTokens: procedure byte external; end;






sub$4AAA: procedure(arg1b) public;
	declare arg1b byte;

	if b674A(arg1b) then
	do;
		if haveTokens then
		do;
			accum1 = sub$43DD;
			if b674C(arg1b) <> accum1byt(0) then
				call sub$5EE3;
		end;
		else if b674C(arg1b) <> 3 then
			call sub$5EE3;
	end;
	else
	do;
		b674A(arg1b) = TRUE;
		if haveTokens then
		do;
			accum1 = sub$43DD;
			if accum1 = 1 or accum1 = 2 then
				b674C(arg1b) = low(accum1);
			else
				call sub$5EE3;
		end;
	end;
end;


sub$4B3F: procedure(arg1b) public;
	declare arg1b byte;

	accum1 = arg1b;
	if accum1 then
		accum1 = 0FFFFh;
end;

sub$4B57: procedure(arg1b) public;
	declare arg1b byte;

	if (b6855 and 47h) <> 0 then
		b6855 = b6855 and 0E7h or arg1b;
end;

sub$4B72: procedure public;
	do case b6B2B;
/* 0 */		;
/* 1 */		call sub$54FD;			/* white space ? */
/* 2 */		goto case3;			/* ( */
/* 3 */ case3:	do;				/* : or ) */
			if not (b6B2B = 2 and opType = 3) then
				call sub$5F25;

			if tokenType(0) = 11 then
			do;
				tokenSize(0) = 1;
				tokenAttr(0) = 0;
				b6B36 = 0FFh;
			end;

			b6B35 = b6B2F;
			if opType = 3 then
				b6B2C = 0FFh;
		end;
/* 4 */		accum1 = accum1 * accum2;	/* * */
/* 5 */		accum1 = accum1 + accum2;	/* + */
/* 6 */		do;				/* , */
			call sub$5ED7;
			call popToken;
		end;
/* 7 */		accum1 = accum1 - accum2;	/* - */
/* 8 */		;				/* unary + */
/* 9 */		do;				/* / */
			if accum2 = 0 then
				call sub$5F01;

			accum1 = accum1 / accum2;
		end;
/* 10 */	accum1 = -accum1;		/* unary - */
/* 11 */	call sub$4B3F(accum1 = accum2);		/* EQ */
/* 12 */	call sub$4B3F(accum1 < accum2);		/* LT */
/* 13 */	call sub$4B3F(accum1 <= accum2);	/* LE */
/* 14 */	call sub$4B3F(accum1 > accum2);		/* GT */
/* 15 */	call sub$4B3F(accum1 >= accum2);	/* GE */
/* 16 */	call sub$4B3F(accum1 <> accum2);	/* NE */
/* 17 */	accum1 = not accum1;			/* NOT */
/* 18 */	accum1 = accum1 and accum2;		/* AND */
/* 19 */	accum1 = accum1 or accum2;		/* OR */
/* 20 */	accum1 = accum1 xor accum2;		/* XOR */
/* 21 */	do;					/* MOD */
			if accum2 = 0 then
				call sub$5F01;
			accum1 = accum1 mod accum2;
		end;
/* 22 */	do;					/* SHL */
			if accum2byt(0) <> 0 then
				accum1 = shl(accum1, accum2);
		end;
/* 23 */	do;					/* SHR */
			if accum2byt(0) <> 0 then
				accum1 = shr(accum1, accum2);
		end;
/* 24 */	do;					/* HIGH */
			accum1 = high(accum1);
			call sub$4B57(10h);
		end;
/* 25 */	do;					/* LOW */
			accum1 = low(accum1);
			call sub$4B57(8);
		end;
/* 26 */	do;					/* DB ? */
			if tokenType(0) <> 10 then
			do;
				accum1 = sub$43DD;
				if accum1byt(1) - 1 < 0FEh then
					call sub$5F01;
				b6B28 = 22h;
				if (b6855 and 18h) = 18h then
				do;
					call sub$5F01;
					b6855 = b6855 and 0E7h or 8;
				end;
			end;
			else
			do;
				b6855 = 0;
				tokenType(0) = 0Bh;
			end;

			if sub$425B(b6858) then
				call sub$5F37;
			b6B2D = 0Bh;
			b6B23 = 0FFh;
		end;
/* 27 */	do;					/* DW ? */
			b6B2D = 0Bh;
			b6B24 = 0FFh;
		end;
/* 28 */	do;					/* DS ? */
			segSize(activeSeg) = segSize(activeSeg) + accum1;
			b68AB = 0FFh;
		end;
/* 29 */ case29:					/* EQU ? */
		do;
			b68AB = 0FFh;
			if (b6855 and 40h) = 40h then
			do;
				call sub$5EE3;
				b6855 = 0;
			end;
			b6CE4 = 1;
			call sub$5819(accum1, 22h - b6B2B);	/* 4 for set, 5 for equ */
			b6B30 = 0;
		end;
/* 30 */	goto case29;				/* SET ? */
/* 31 */	do;					/* ORG ? */
			b68AB = 0FFh;
			if (b6855 and 40h) <> 40h then
			do;
				if (b6855 and 18h) <> 0 then
					if (b6855 and 7) <> activeSeg or (b6855 and 18h) <> 18h then
						call sub$5EE3;
			end;
			else
				call sub$5EE3;

			if optOBJECT then
				if segSize(activeSeg) > w6B41(activeSeg) then
					w6B41(activeSeg) = segSize(activeSeg);
			segSize(activeSeg) = accum1;
		end;
/* 32 */	do;					/* END ? */
			if tokenSP > 0 then
			do;
				startAddr = sub$43DD;
				b6755 = 1;
				b6745 = b6855 and 7;
				if (b6855 and 40h) = 40h then
					call sub$5EE3;
				if sub$425B(b6858) then
					call sub$5F37;

				b68AB = 0FFh;
			end;

			if ifDepth > 0 then
				call sub$5F07;
			if opType <> 1 then
				call sub$5ED7;
			if b6B35 then
				b6B33 = 0FFh;
			else
				call sub$5ED7;

		end;
/* 33 */	do;					/* IF ? */
			if b6B35 then
			do;
				b6B32 = 0FFh;
				call nestIF(2);
				b6881 = 0FFh;
				if skipping(0) = 0 then
					skipping(0) = not ((low(accum1) and 1) = 1);
				inElse(0) = 0;
			end;
		end;
/* 34 */	do;					/* ELSE ? */
			b6B32 = 0FFh;
			if ifDepth = 0 then
				call sub$5F07;
			else if not inElse(0) then
			do;
				if not skipping(0) then
					skipping(0) = 0FFh;
				else
					skipping(0) = skipping(ifDepth);
				inElse(0) = 0FFh;
			end;
			else
				call sub$5F07;
		end;
/* 35 */	do;					/* ENDIF ? */
			if b6B35 then
			do;
				b6B32 = 0FFh;
				call unnestIF(2);
			end;
		end;
/* 36 */	do;					/* LXI ? */
			if b6744 = 1 then
				if b6873(0) = 4Dh then
					call sub$5ED7;
			call sub$450F(85h);
		end;
/* 37 */	do;				/* POP DAD PUSH INX DCX ? */
			if b6744 = 1 then
				if b6873(0) = 4Dh then
					call sub$5ED7;
			call sub$450F(5);
		end;
/* 38 */	call sub$450F(7);		/* LDAX STAX ? */
/* 39 */	call sub$450F(2);		/* ADC ADD SUB ORA SBB XRA ANA CMP ? */
/* 40 */	call sub$450F(8);		/* ADI OUT SBI ORI IN CPI SUI XRI ANI ACI ? */
/* 41 */	call sub$450F(46h);		/* MVI ? */
/* 42 */	call sub$450F(6);		/* INR DCR ? */
/* 43 */	call sub$450F(36h);		/* MOV */
/* 44 */	call sub$450F(0);		/* CZ CNZ JZ STA JNZ JNC LHLD */
						/* CP JC SHLD CPE CPO CM LDA JP JM JPE */
						/* CALL JPO CC CNC JMP */
/* 45 */	call sub$450F(0);		/* RNZ STC DAA DI SIM SPHL RLC */
						/* RP RAL HLT RM RAR RPE RET RIM */
						/* PCHL CMA CNC RPO EI XTHL NOP */
						/* RC RNX XCHG RZ RRC */
/* 46 */	call sub$450F(6);		/* RST */
/* 47 */	activeSeg = 0;			/* ASEG ? */
/* 48 */	do;				/* CSEG ? */
			activeSeg = 1;
			call sub$4AAA(0);
		end;
/* 49 */	do;				/* DSEG ? */
			activeSeg = 2;
			call sub$4AAA(1);
		end;

/* 50 */	do;				/* PUBLIC */
			b6748 = 0FFh;
			b6CE4 = 0;
			call sub$5819(0, 6);
		end;
/* 51 */	do;				/* EXTRN ? */
			b6749 = 0FFh;
			if w6750 = 0 and isPhase1 and optOBJECT then
			do;
				call ovlMgr(2);
				call writeRec02;
			end;
			b6CE4 = 0;
			call sub$5819(w6750, 2);
			if isPhase1 and optOBJECT and not b6754 then
			do;
				call ovlMgr(2);
				call ovl2;
			end;
			if not b6754 then
				w6750 = w6750 + 1;
			b6754 = 0;
		end;
/* 52 */	do;				/* NAME */
			if tokenSP <> 0 and b6743 then
			do;
				call move(6, .asc$3692, .aModulePage);
				call move(moduleNameLen := b6744, .b6873, .aModulePage);
			end;
			else
				call sub$3CDF('R');

			call popToken;
		end;
/* 53 */	segSize(3) = accum1;		/* STKLN ? */
	end;

	if b6B2B <> 1 then
		b6743 = 0;
end;

sub$518F: procedure public;

	sub$53C0: procedure byte;
		if b6B29 > 3 then
			if b6B29 <> 6 then
				if b6B29 < 1Ah then
					return TRUE;
		return FALSE;
	end;

	sub$53DF: procedure(arg1b) byte;
		declare arg1b byte;
		return arg1b = 9 or arg1b = 64h;
	end;


	sub$53F8: procedure;
		if not b4A68(b6B2B) then
			b6B34 = 0;
	end;



	do while 1;
		if not (b6B29 = 1 or b6B29 >= 20h and b6B29 <= 23h) and skipping(0) then
		do;
			b6885 = 0;
			call popToken;
			return;
		end;
		
		if phase <> 1 then
			if b6B25 then
				if sub$53C0 then
					if getPrec(b6B29) <= getPrec(opStack(opSP)) then
						call sub$5EE3;

		if getPrec(opType := b6B29) > getPrec(b6B2B := opStack(opSP)) or opType = 2 then
		do;
			if opSP >= 10h then
			do;
				opSP = 0;
				call sub$5F13;
			end;
			else
				opStack(opSP := opSP + 1) = opType;
			if opType = 2 then
			do;
				b6B2F = b6B35;
				b6B35 = 0FFh;
			end;
			if phase > 1 then
				b6B25 = sub$53C0;
			return;
		end;

		b6B25 = 0;
		if not b6B35 and b6B2B > 3 then
			call sub$5ED7;

		if b6B2B = 0 then
			b6B2B = opType;
		else
			opSP = opSP - 1;
		

		if (b6B28 := b4181(b6B2B)) then
		do;
			accum2 = sub$43DD;
			b6856 = b6855;
			w685C = w685A;
			b6859 = b6858;
		end;

		if (b6B28 := ror(b6B28, 1)) then
			accum1 = sub$43DD;

		if not b6857 then
			b6857 = sub$53DF(b6858) or sub$53DF(b6859);

		b6B2D = 0Ch;
		if b6B2B > 3 and b6B2B < 1Ah then	/* expression op */
			call sub$4291;
		else
		do;
			call sub$53F8;
			call sub$4274;
		end;

		call sub$4B72;
		if not b4A26(b6B2B) then
			b6B35 = 0;

		if b6B2C then
		do;
			b6B2C = 0;
			return;
		end;

		if b6B2B <> 1Ch and b68AB then		/* DS */
			w68A6 = accum1;

		if (b6B28 and 1Eh) <> 0 then
			call pushToken(b6B2D);

		do b6BDB = 0 to 3;
			if (b6B28 := ror(b6B28, 1)) then
				call addByte2Tok(accum1byt(b6BDB));
		end;

		tokenAttr(0) = b6855;
		tokenSymId(0) = w685A;
		if ror(b6B28, 1) then
			if opType = 6 then
			do;
				b6B29 = b6B2B;
				b6B35 = 0FFh;
			end;
	end;
end;



sub$540D: procedure public;
	do while b6B2E = 0;
		call sub$3F19;
		call sub$518F;
	end;
end;

end;
asm851.plm
asm851: do;

$include(global.inc)

declare pad1 address data(40h);
declare pad2 address;


exit: procedure external; end;
flushout: procedure external; end;
ovl3: procedure external; end;
ovl8: procedure external; end;
ovlMgr: procedure(b) external; declare b byte; end;
popToken: procedure external; end;
sub$3DCE: procedure external; end;
sub$467F: procedure(b, w) external; declare b byte, w address; end;
sub$5ED7: procedure external; end;
sub$7041: procedure external; end;			/* in overlay 1 */
sub2$6E32: procedure external; end;
sub$4646: procedure byte external; end;
haveTokens: procedure byte external; end;
xisSpace: procedure byte external; end;
isPhase2Print: procedure byte external; end;
sub$465B: procedure byte external; end;
sub$3A71: procedure byte external; end;



strUCequ: procedure(arg1w, arg2w) byte public;
	declare (arg1w, arg2w) address;
	declare ch1 based arg1w byte,
		ch2 based arg2w byte;

	do while ch1 <> 0;
		if ch1 <> ch2 and ch1 <> (ch2 and 5Fh) then
			return FALSE;
		arg1w = arg1w + 1;
		arg2w = arg2w + 1;
	end;
	return TRUE;
end;


isSkipping: procedure byte public;
	return skipping(0);
end;


sub$546F: procedure public;
	b6A56 = sub$4646;
	if b6B30 then
		call sub$5ED7;
	if haveTokens then
		if not(tokenType(b6A56) = 0Bh or b68AD) then
			call sub$5ED7;
	if b6B23 or b6B24 then
	do;
		if tokenSP = 1 and not xisSpace and tokenSize(0) <> 1 then
			tokenSize(0) = 2;
	end;
	else if not xisSpace and haveTokens then
		if tokenSize(b6A56) > 3 then
			tokenSize(b6A56) = 3;
end;



sub$54FD: procedure public;
	declare w6CD7 address, b6CD9 byte;
	declare ch based w6CD7 byte;

	call sub$546F;
	if isPhase2Print then
	do;
		w6CD7 = .asciiLineNo(3);
		b6CD9 = TRUE;

		do while b6CD9;
			if ch = '9' then
				ch = '0';
			else
			do;
				if ch = ' ' then
					ch = '1';
				else
					ch = ch + 1;
				b6CD9 = FALSE;
			end;
			w6CD7 = w6CD7 - 1;
		end;

		if sub$465B or not xisSpace then
		do;
			call ovlMgr(1);
			call ovl3;
		end;
	end;

	if b6BD9 then
	do;
		out$p = out$p + 1;
		call flushout;
		call exit;
	end;


	if not b6B20 then
	do;
		b6BDB = 2;
		if tokenSP < 2 or b6B23 or b6B24 then
			b6BDB = 0;

		w6BCE = tokStart(b6BDB) + tokenSize(b6BDB);
		if isSkipping or not b6B34 then
			w6BCE = .b6759;

		if sub$3A71 then
		do;
			call ovlMgr(2);
			call ovl8;
		end;

		b6B2C = 0FFh;
		segSize(activeSeg), w68A6 = segSize(activeSeg) + (w6BCE - .b6759);
	end;

	if optXREF and b6880 then
		if phase = 1 then
			call sub$467F(1, .b6873);

	do while tokenSP > 0;
		call popToken;
	end;

	call sub$3DCE;
	if b6B33 then
	do;
		b6B2E = 0FFh;
		if isPhase2Print and optSYMBOLS then
		do;
			call ovlMgr(1);
			call sub$7041;			/* in overlay 1 */
		end;

		call sub$467F(2, .b6873);
		if sub$3A71 then
		do;
			call ovlMgr(2);
			call sub2$6E32;
		end;
	end;
end;
end;
asm86.pl3
asm80$6: do;

$include(global.inc)

declare	b5666(*) byte data(9, 2Dh, 80h),
	b5669(*) byte data(3Ah, 8, 80h, 0, 0, 0, 0, 0, 20h),
			/* 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
	b5672(*) byte data(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
			   0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1),
			  /* 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
	chClass(*) byte data(0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 4, 0, 0,	/* 00 */
			     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 10 */
			     1, 0, 0, 0, 6, 0, 0, 7, 5, 5, 5, 5, 5, 5, 0, 5,	/* 20 */
			     8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 3, 2, 0, 0, 0, 9,	/* 30 */
			     9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,	/* 40 */
			     9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0,	/* 50 */
			     0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,	/* 60 */
			     9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0);	/* 70 */


popToken: procedure external; end;
pushToken: procedure(b) external; declare b byte; end;
wrError: procedure(b) external; declare b byte; end;
sub$3CDF: procedure(b) external; declare b byte; end;
sub$5ED7: procedure external; end;
sub$5F31: procedure external; end;
sub$5EFB: procedure external; end;
isPhase1: procedure byte external; end;
isSkipping: procedure byte external; end;
sub$4879: procedure byte external; end;
nxtCmdCh: procedure byte external; end;
sub$5F0D: procedure external; end;
sub$5F2B: procedure external; end;
sub$5F1F: procedure external; end;
xisSpace: procedure byte external; end;
testBit: procedure(b, w) byte external; declare b byte, w address; end;


unpackToken: procedure(arg1w, arg2w) public;
	declare (arg1w, arg2w) address;
	declare wrd based arg1w address;
	declare ch based arg2w byte;
	declare w6CDE address;

	unpack1: procedure;
		ch = w6CDE mod 40;	
		if ch = 0 then
			ch = ' ';
		else if ch <= 10 then
			ch = ch + 2Fh;	/* digit */
		else 
			ch = ch + 34h;	/* ? @ and letters */
		w6CDE = w6CDE / 40;
		arg2w = arg2w - 1;
	end;


	arg1w = arg1w + 2;
	arg2w = arg2w + 5;
	w6CDE = wrd;
	call unpack1;
	call unpack1;
	call unpack1;
	arg1w = arg1w - 2;
	w6CDE = wrd;
	call unpack1;
	call unpack1;
	call unpack1;
end;




sub$57B8: procedure public;
	declare (w6CE0, w6CE2) address;
	declare ch1 based w6CE0 byte,
		ch2 based w6CE2 byte;

	w686E, w6CE0 = (w6CE2 := w686E) + 8;
	if w6CE0 > w6870 then
		call wrError(1);	/* table error */

	do while w6CE2  > curTokenSym$p;
		w6CE0 = w6CE0 - 1;
		w6CE2 = w6CE2 - 1;
		ch1 = ch2;
	end;

	call move(4, curTokStart, curTokenSym$p);
	curTokenSym.type = 0;
end;

declare b6CE4 byte public;

sub$5819: procedure(arg1w, arg2b) public;
	declare arg1w address, arg2b byte;
	declare (b6CE8, b6CE9, b6CEA, b6CEB, b6CEC) byte;

	sub$5B9A: procedure;
		tokenType(0) = arg2b;
		if (b6858 = 7 or b6858 = 8) and b6CEB then
			tokenType(0) = 12 - arg2b;
	end;


	b6CEC = tokenType(0);
	b6CEB = arg2b = 5 or arg2b = 4;
	b6CE9 = 0;
	b6CE8 = curTokenSym.b7;
	b6CEA = 0;
	if curTokenSym$p > w6868(1) or curTokenSym$p < symTab(1) then
	do;
		call sub$5ED7;
		return;
	end;

	if tokenSP > 1 then
		call sub$5ED7;

	if isPhase1 then
		if tokenType(0) = 9 then
		do;
			if b6883 then
			do;
				if curTokenSym.type >= 80h then
				do;
					call sub$5F31;
					b6CE9 = 80h;
				end;
			end;
			else
			do;
				call sub$57B8;
				w6868(1) = w6868(1) + 8;
				b6CE8 = 0;
			end;

			b6CE8 = (activeSeg <> 0 and 18h) or b6748 and 20h or b6749 and 58h;
			if b6CE4 = 1 then
				b6CE8 = b6855;

			if b6CE4 = 2 then
				b6CE8 = b6CE8 or activeSeg;
			if b6857 and b6CEB then
				tokenType(0) = 64h;
			else
				call sub$5B9A;
			goto L5A9B;
		end;

	if b6882 = 2 then
		if tokenType(0) = 9 then
			if b6858 <> 9 then
				if b6CEB then
				do;
					call sub$5B9A;
					if curTokenSym.type < 128 then
					do;
						curTokenSym.type = tokenType(0);
						curTokenSym.w4 = arg1w;
						b6CE8 = b6855;
						b6CEA = 0FFh;
					end;
					goto L5A9B;
				end;

	if isPhase1 then
		if tokenType(0) = 6 then
			if testBit(arg2b, .b5666) then
			do;
				if b6749 then
					tokenType(0) = 3;
				else
				do;
					tokenType(0) = arg2b;
					b6CE8 = b6CE8 and 0E0h;
					if b6CE4 = 1 then
						b6CE8 = b6855 or 20h;
					if b6CE4 = 2 then
						if activeSeg <> 0 then
							b6CE8 = b6CE8 or activeSeg or 38h;
				end;
				goto L5A9B;
			end;

	if isPhase1 then
		if arg2b = 6 then
			if testBit(tokenType(0), .b5666) then
			do;
				if (b6CE8 and 60h) <> 0 then
					tokenType(0) = 3;
				else
					b6CE8 = b6CE8 or 20h;
				goto L5A9B;
			end;

	if isPhase1 then
		if tokenType(0) <> arg2b and tokenType(0) <> 8 or arg2b = 5 then
			tokenType(0) = 3;

	if not b6748 and testBit(tokenType(0), .b5669) then
		b6CE8 = (b6CE8 and 20h) and tokenType(0) <> 3Ah or b6855;
	else
	do;
		if isPhase1 then
			tokenType(0) = 3;

		if not(b6748 or b6749) then
			if curTokenSym.w4 <> arg1w then
				call sub$5F0D;
	end;

L5A9B:
	b6CE9 = curTokenSym.type and 80h or b6CE9;
	if isPhase1 and (arg2b = 9 or arg2b = 6 or b6CEC <> tokenType(0)) then
		curTokenSym.type = tokenType(0) or b6CE9;

	b6BDD = curTokenSym.type;
	if tokenType(0) = 3 or b6BDD = 3 then
		call sub$5EFB;

	if b6BDD >= 80h then
		call sub$5F31;

	if isPhase1 and (tokenType(0) = arg2b or arg2b = 5 and tokenType(0) = 7) or arg2b = 4 and xisSpace or b6CEA then
		curTokenSym.w4 = arg1w;
	curTokenSym.b7 = b6CE8;
	b6748 = 0;
	b6749 = 0;
	if curTokenSym.type = 6 then
		call sub$5F2B;

	b6857 = 0;
	if b6883 then
		call popToken;
end;



lookup: procedure(arg1b) byte public;
	declare arg1b byte;
	declare (w6CEE, w6CF0, w6CF2, w6CF4, s6CF6$p, s6CF8$p) address,
		x structure(b6CFA byte), b6CFB byte;
	declare s6CF6 based s6CF6$p structure(w0 address, w2 address, b4 byte, b5 byte, type byte, b7 byte),
		s6CF8 based s6CF8$p structure(w0 address, w2 address, b4 byte, b5 byte, type byte, b7 byte);
	declare addr based w6BE0 address,
		addrAlt based w6BE0 address;


	s6CF8$p = curTokStart;
	if arg1b = 0 then
	do;
		s6CF6$p = 0;
		w6CF4 = symTab(0) + ((s6CF8.w0 + s6CF8.w2) mod 151) * 8;

		do while w6CF4 <> 0;
			s6CF6$p = s6CF6$p + w6CF4;
			if s6CF6.w0 = s6CF8.w0 then
				if s6CF6.w2 = s6CF8.w2 then
				do;
					curTokenSym$p = s6CF6$p;
					tokenType(0) = curTokenSym.type;
					if tokenType(0) < 2Dh then
						if b5672(tokenType(0)) then
							has16bitOperand = 0FFh;

					if curTokenSym.b7 = 2 and not optMOD85 then
						call sub$3CDF(4Fh);

					if tokenType(0) = 8 then		/* SP */
					do;
						if not(opType = 24h or opType = 25h) then /* lxi or push/pop */
							call sub$3CDF(58h);
						tokenType(0) = 7;		/* reg */
					end;
					return tokenType(0) and 7Fh;
				end;
			w6CF4 = s6CF6.b5;
		end;
		return 9;
	end;

	w6CEE = symTab(arg1b);
	w6CF0, s6CF6$p = w6868(arg1b);

	do while (w6CF2 := w6CEE + shr((w6CF0 - w6CEE) and 0FFF0h, 1)) <> s6CF6$p;
		s6CF6$p = w6CF2;
		if s6CF8.w0 = s6CF6.w0 then
		do;
			if s6CF8.w2 = s6CF6.w2 then
			do;
				curTokenSym$p = s6CF6$p;
				tokenType(0) = curTokenSym.type;
				if tokenType(0) = 64h then
					tokenType(0) = 9;
				if (b6884 := (b6BDD := tokenType(0) and 7Fh) = 9) then
					if b6885 then
						curTokenSym.type = 89h;
				return b6BDD;
			end;
			else
				b6CFB = s6CF6.w2 > s6CF8.w2;
		end;
		else
			b6CFB = s6CF6.w0 > s6CF8.w0;

		s6CF6$p = w6CF2;
		if b6CFB then
			w6CF0 = s6CF6$p;
		else
			w6CEE = s6CF6$p;
	end;

	curTokenSym$p = w6CF0;
	if arg1b = 1 and not isSkipping then
	do;
		b6883 = 0;
		b6CE4 = 0;
		call sub$5819(w6A4E, b6885 and 80h or 9);
		w6BE0 = .tokenSym;
		do x.b6CFA = 1 to tokenSP;
			w6BE0 = w6BE0 + 2;
			if addr >= curTokenSym$p then
				addrAlt = addr + 8;
		end;
		b6883 = 0FFh;
	end;
	return 9;
end;

getCh: procedure byte public;
	declare (b6CFC, b6CFD) byte;

	if not reget then
	do;
		b6CFD = b6CFC;
	L5E54:
		b6CFC = lookAhead;
		if scanOptions then
			lookAhead = nxtCmdCh;
		else
			lookAhead = sub$4879;

		if chClass(b6CFC) = 0 then
			if b6CFC = 0 or b6CFC = 7Fh or b6CFC = 0Ch then
				goto L5E54;
	end;
	reget = 0;
	return (curChar := b6CFC);
end;

getChClass: procedure byte public;
	curChar = getCh;
	return chClass(curChar);
end;


chkLF: procedure public;
	if lookAhead = 0Ah then
		lookAhead = 0;
	else
		call sub$5F1F;
end;
end;
asm861.plm
asm861: do;

$include(global.inc)

declare cZERO byte external;

sub$3CDF: procedure(b) external; declare b byte; end;
wrError: procedure(b) external; declare b byte; end;
getChClass: procedure byte external; end;
getCh: procedure byte external; end;



sub$5ED7: procedure public;
	call sub$3CDF('Q');	/* questionable */
end;

sub$5EDD: procedure public;
	call sub$3CDF('D');	/* double defined symbol */
end;

sub$5EE3: procedure public;
	call sub$3CDF('E');	/* external error */
end;

sub$5EE9: procedure public;
	call sub$3CDF('C');	/* command error */
end;

sub$5EEF: procedure public;
	call sub$3CDF('O');
end;

sub$5EF5: procedure public;
	call sub$3CDF('R');
end;

sub$5EFB: procedure public;
	call sub$3CDF('M');	/* multiply defined symbol */
end;

sub$5F01: procedure public;
	call sub$3CDF('V');	/* value error */
end;

sub$5F07: procedure public;
	call sub$3CDF('N');	/* nesting error */
end;

sub$5F0D: procedure public;
	call sub$3CDF('P');	/* phase error */
end;

sub$5F13: procedure public;
	call wrError(0);	/* stack error */
end;

sub$5F19: procedure public;
	call wrError(4);	/* file error */
end;

sub$5F1F: procedure public;
	call sub$3CDF('I');
end;

sub$5F25: procedure public;
	call sub$3CDF('B');
end;

sub$5F2B: procedure public;
	call sub$3CDF('U');	/* undefined symbol */
end;

sub$5F31: procedure public;
	call sub$3CDF('L');
end;

sub$5F37: procedure public;
	call sub$3CDF('X');
end;

haveTokens: procedure byte public;
	return tokenSP <> 0;
end;


popToken: procedure public;
	tokStart(0) = tokStart(tokenSP);
	tokenSym(0) = tokenSym(tokenSP);
	tokenType(0) = tokenType(tokenSP);
	tokenAttr(0) = tokenAttr(tokenSP);
	tokenSize(0) = tokenSize(tokenSP);
	tokenSymId(0) = tokenSymId(tokenSP);
	if haveTokens then
		tokenSP = tokenSP - 1;
end;


nestIF: procedure(arg1b) public;
	declare arg1b byte;
	
	if (ifDepth := ifDepth + 1) > 8 then
	do;
		call sub$5F13;
		ifDepth = 0;
	end;
	else
	do;
		skipping(ifDepth) = skipping(0);
		inElse(ifDepth) = inElse(0);
	end;
end;

unnestIF: procedure(arg1b) public;
	declare arg1b byte;

	if ifDepth = 0 then
		call sub$5F07;
	else
	do;
		skipping(0) = skipping(ifDepth);
		inElse(0) = inElse(ifDepth);
		ifDepth = ifDepth - 1;
	end;
end;

pushToken: procedure(arg1b) public;
	declare arg1b byte;
	if tokenSP >= 8 then
		call sub$5F13;
	else
	do;
		tokenSP = tokenSP + 1;
		tokStart(tokenSP) = tokStart(0);
		tokenSym(tokenSP) = tokenSym(0);
		tokenType(tokenSP) = tokenType(0);
		tokenAttr(tokenSP) = tokenAttr(0);
		tokenSize(tokenSP) = tokenSize(0);
		tokenSymId(tokenSP) = tokenSymId(0);
		tokStart(0) = tokStart(0) + tokenSize(0);
		tokenType(0) = arg1b;
		tokenAttr(0), tokenSize(0) = cZERO;
		tokenSym(0) = w673F;
		tokenSymId(0) = tokenSym(0);
	end;
end;

addByte2Tok: procedure(arg1b) public;
	declare arg1b byte, w6D02 address;
	declare ch based w6D02 byte;

	if (w6D02 := tokStart(0) + tokenSize(0)) < off682A then
	do;
		ch = arg1b;
		tokenSize(0) = tokenSize(0) + 1;
	end;
	else
		call sub$5F13;
end;

collectIdent: procedure(arg1b) public;
	declare arg1b byte;

	call pushToken(arg1b);
	reget = 1;

	do while (arg1b := getChClass) = 8 or arg1b = 9;	/* digit or letter */
		if curChar > 60h then
			curChar = curChar and 0DFh;
		call addByte2Tok(curChar);
	end;
	reget = 1;
end;


ascii2Num: procedure public;
	declare accum address, (radix, digit, i) byte;
	declare chrs based curTokStart(1) byte;

	call collectIdent(0Ch);
	

	radix = chrs(tokenSize(0) := tokenSize(0) - 1);
	if radix = 'H' then
		radix = 10h;

	if radix = 'D' then
		radix = 0Ah;

	if radix = 'O' or radix = 'Q' then
		radix = 8;

	if radix = 'B' then
		radix = 2;

	if radix > 10h then
		radix = 10;
	else
		tokenSize(0) = tokenSize(0) - 1;

	accum = 0;
	do i = 0 to tokenSize(0);
		if chrs(i) = '?' or chrs(i) = '@' then
		do;
			call sub$5F1F;
			digit = 0;
		end;
		else
		do;
			digit = chrs(i) - '0';
			if digit > 9 then
				digit = digit - 7;
			if digit >= radix then
				if tokenType(2) <> 40h then
				do;
					call sub$5F1F;
					digit = 0;
				end;
		end;

		accum = accum * radix + digit;
	end;

	/* replace with packed number */
	tokenSize(0) = 0;
	call addByte2Tok(low(accum));
	call addByte2Tok(high(accum));
end;


collectString: procedure public;
	call pushToken(0Ah);

	do while getCh <> 0Dh;
		if curChar = 27h then
			if getCh <> 27h then
				goto L6268;
		call addByte2Tok(curChar);
	end;

	call sub$5F25;

L6268:
	reget = 1;
end;

end;
asmov0.pl3
asmov0: do;

$include(global.inc)

declare b6D6E(*) byte data(35h, 'DEBUG', 3Ah, 'MACRODEBUG',
			   34h, 'XREF', 37h, 'SYMBOLS',
			   36h, 'PAGING', 33h, 'TTY',
			   25h, 'MOD85', 35h, 'PRINT',
			   36h, 'OBJECT', 39h, 'MACROFILE',
			   29h, 'PAGEWIDTH', 2Ah, 'PAGELENGTH',
			   7, 'INCLUDE', 5, 'TITLE',
			   4, 'SAVE', 7, 'RESTORE',
			   5, 'EJECT', 14h, 'LIST',
			   13h, 'GEN', 14h, 'COND');

declare (b7463, b7464, b7465, b7466) byte;


skipWhite$2: procedure external; end;
skipWhite: procedure external; end;
skip2EOL: procedure external; end;
wrError: procedure(b) external; declare b byte; end;
chkLF: procedure external; end;
sub$5EE9: procedure external; end;
sub$5F13: procedure external; end;
sub$5F19: procedure external; end;
popToken: procedure external; end;
collectIdent: procedure(b) external; declare b byte; end;
ascii2Num: procedure external; end;
collectString: procedure external; end;
isCR: procedure byte external; end;
isPhase1: procedure byte external; end;
sub$43DD: procedure address external; end;
getCh: procedure byte external; end;
xisSpace: procedure byte external; end;
isWhite: procedure byte external; end;
isRParen: procedure byte external; end;

declare (b6C21, b6C22, fileIdx) byte external,
	files(6) structure(name(15) byte, blk address, byt address, b19 byte) external;

chkParen: procedure(arg1b) byte;
	declare arg1b byte;
	call skipWhite;
	reget = 0;
	return arg1b + 28h = curChar;
end;



collectBasicToken: procedure byte;
	collectBufLen = 0;
	b6ADB = 0;
	if isCR then
		return curChar;

	call skipWhite$2;
	if curChar > 40h and 5Bh > curChar or curChar >60h and 7Bh > curChar then
	do;	/* is letter */
		call collectIdent(1);
		if xisSpace and tokenSize(0) < 14 then
			call move(collectBufLen := tokenSize(0), .b6759, .collectBuf);
	end;
	else if curChar > 2Fh  and  3Ah > curChar then
	do;	/* is digit */
		call ascii2Num;
		if xisSpace then
		do;
			w6B1E = sub$43DD;
			b6ADB = 2;
			collectBuf(0) = 20h;
		end;
	end;
	else if curChar = 27h then
	do;	/* is string */
		call collectString;
		if xisSpace then
		do;
			collectBufLen = 40h;
			if tokenSize(0) < 40h then
				collectBufLen = tokenSize(0);
			b6ADB = 4;
			if collectBufLen > 0 then
				call move(collectBufLen, .b6759, .collectBuf);
		end;
	end;
	else
	do;
		collectBufLen = 1;
		collectBuf(0) = curChar;
		return curChar;
	end;

	call popToken;
	return collectBuf(0);
end;



sub$6F07: procedure(arg1w) byte;
	declare arg1w address;
	declare pad address;

	if collectBufIdx = 0 then
		return 0;

	collectBuf(collectBufIdx) = 20h;
	collectBufLen = collectBufIdx;
	if isWhite then
		return chkParen(1);
	return 0FFh;
end;

sub$6F39: procedure;
	call skipWhite$2;

    do while 1;
	if isRParen or isWhite then
	do;
		if sub$6F07(.collectBuf(0)) then
			return;
		goto done;
	end;

	collectBuf(collectBufIdx) = curChar;
	collectBufIdx = collectBufIdx + 1;
	if collectBufIdx > 14 then
		goto done;
	curChar = getCh;
    end;
done:
	curFileName$p = .collectBuf;
	call sub$5F19;
end;


getFileParam: procedure;
	collectBufIdx = 0;
	if not chkParen(0) then		/* ( */
		call sub$5F19;
	else
	do;
		call sub$6F39;
		call move(collectBufIdx + 1, .collectBuf, curFileName$p);
		if not chkParen(1) then	/* ) */
			call sub$5F19;
	end;
end;


getMacroFileDrive: procedure;
	call skipWhite$2;
	collectBufIdx = 0Dh;
	b6BDB = 0;

	do while not isRParen and b6BDB < 4;
		aF0Asmac$tmp(b6BDB) = curChar;
		b6BDB = b6BDB + 1;
		curChar = getCh;
	end;

	if isRParen or isWhite then
		if sub$6F07(.aF0Asmac$tmp) then
			return;
	curFileName$p = .aF0Asmac$tmp;
	collectBufIdx = 0;
	call sub$5F19;
end;




sub$702B: procedure byte;
	if chkParen(0) then	/* ( */
	do;
		b7463 = collectBasicToken;
		if b6ADB = 2 then
			return chkParen(1);	/* ) */
	end;
	return 0;
end;


sub$704B: procedure byte;
	declare (b746C, b746D, optionSET, b746F, b7470, b7471) byte,
		(w7472, w7474, w7476) address;
	declare twoch address at(.collectBuf);
	declare ch based w7472 byte;
	declare byt based w7476 byte;

	setOption: procedure;
		if not b7471 then
		do;
			options(optionId) = optionSET;
			if not optionSET then
				optionId = 17;
		end;
	end;

	b746F = collectBufLen;
	b746D = 0;
	optionSET = 0FFh;
	if twoch = 'ON' then	/* NO stored inverse */
	do;
		b746D = 2;
		optionSET = 0;
		b746F = collectBufLen - 2;
	end;
	w7472 = .b6D6E;
	optionId = 0;
	b746C = b746D;

	do while optionId < 20;
		w7474 = w7472 + (ch and 0Fh) + 1;
		if (ch and 0Fh) = b746F then
		do;
			b7470 = ch;
			do while b746C < collectBufLen;
				w7472 = w7472 + 1;
				if ch <> collectBuf(b746C) then
					b746C = collectBufLen + 1;
				else
					b746C = b746C + 1;
			end;
			if b746C = collectBufLen then
				goto break;
		end;
		w7472 = w7474;
		optionId = optionId + 1;
		b746C = b746D;
	end;
	return 0FFh;

break: if optionId = 1 or optionId = 12h then		/* MACRODEBUG or GEN */
	do;
		if scanOptions then
			MacroDebugOrGen = 0FFh;
		else
			return 0FFh;			/* error otherwise */
	end;

	if (b7471 := (b7470 and 10h) <> 10h) and not optionSET then
		return 0FFh;				/* NO invalid */

	if (b7470 and 20h) <> 20h then
	do;
		call setOption;
		return optionId;
	end;

	if not b6898 then
		return 0FFh;

	w7476 = .optionSeen(optionId);
	if byt then
		return 0FFh;
	byt = 0FFh;
	call setOption;
	return optionId;
end;




processCmd: procedure;
	if optionId >= 17 or optionId < 5 then
		return;

	do case optionId - 5;
/* 0 */		do;			/* TTY */
			optTTY = 0FFh;
			return;
		end;
/* 1 */		do;			/* MOD85 */
			optMOD85 = 0FFh;
			return;
		end;
/* 2 */		do;			/* PRINT */
			w6BE2 = 2;
			curFileName$p = .lstFile;
			call getFileParam;
			return;
		end;
/* 3 */		do;			/* OBJECT */
			w6BE2 = 3;
			curFileName$p = .objFile;
			call getFileParam;
			return;
		end;
/* 4 */		do;			/* MACROFILE */
			w6BE2 = 3;
			if chkParen(0) then	/* optional drive for tmp file */
				call getMacroFileDrive;
			else
				reget = 1;
			optMACROFILE = 0FFh;
			return;
		end;
/* 5 */		do;			/* PAGEWIDTH */
			if sub$702B then
			do;
				optPAGEWIDTH = w6B1E;
				if optPAGEWIDTH > 132 then
					optPAGEWIDTH = 132;
				if optPAGEWIDTH < 72 then
					optPAGEWIDTH = 72;
				return;
			end;
		end;
/* 6 */		do;			/* PAGELENGTH */
			if sub$702B then
			do;
				optPAGELENGTH = w6B1E;
				if optPAGELENGTH < 15 then
					optPAGELENGTH = 15;
				return;
			end;
		end;
/* 7 */		do;			/* INCLUDE */
			if not b6C21 then
			do;
				w6BE2 = 1;
				if fileIdx = 5 then
					call sub$5F13;
				else
				do;
					fileIdx = fileIdx + 1;
					curFileName$p = .files(fileIdx);
					call getFileParam;
					b6C21 = 0FFh;
					if scanOptions then
						b6C22 = 0FFh;
					return;
				end;
			end;
		end;
/* 8 */		do;			/* TITLE */
			if chkParen(0) then
			do;
				b7463 = collectBasicToken;
				if b6ADB = 4 and collectBufLen <> 0 then
				do;
					if phase <> 1 or isPhase1 and b6898 then
					do;
						call move(collectBufLen, .collectBuf, .optTITLESTR);
						optTITLESTR(titleLen := collectBufLen) = 0;
						if chkParen(1) then
						do;
							optTITLE = 0FFh;
							return;
						end;
					end;
				end;
			end;
		end;
/* 9 */		do;				/* SAVE */
			if saveIdx > 7 then
				call sub$5F13;
			else
			do;
				call move(3, .optLIST, .saveStack + saveIdx * 3);
				saveIdx = saveIdx + 1;
				return;
			end;
		end;
/* 10 */	do;				/* RESTORE */
			if saveIdx > 0 then
			do;
				call move(3, .saveStack + (saveIdx := saveIdx - 1) * 3, .optLIST);
				return;
			end;
		end;
/* 11 */	do;				/* EJECT */
			optEJECT = optEJECT + 1;
			return;
		end;
	end;
	b7466 = 0FFh;
end;


parseCmds: procedure public;
	b6B20 = 0FFh;
	b6A6F, b7464 = optLIST;
	b7466 = 0;

	do while collectBasicToken <> 0Dh and not b7466;
		if collectBuf(0) = ';' then
			call skip2EOL;
		else if sub$704B = 0FFh then
			b7466 = 0FFh;
		else
			call processCmd;
	end;

	if b7466 then
	do;
		if collectBuf(0) <> 0Dh then
		do;
			reget = 0;
			call skip2EOL;
		end;
		if scanOptions then
			call wrError(2);	/* command error */
		else
			call sub$5EE9;
	end;

	call chkLF;
	if optLIST <> b7464 then
		b6A6F = 0FFh;
	reget = 0;
end;

end;
asmov1.pl3
asmov1: do;

$include(global.inc)

declare	aAssemblyComple(*) byte initial(0Dh, 0Ah, 'ASSEMBLY COMPLETE,'),
	aNoErrors(*) byte initial('   NO ERRORS'),
	asc$751E(*) byte initial(' ('),
	asc$7520(*) byte initial('     )'),
	aPublicSymbols(*) byte initial(0Dh, 0Ah, 'PUBLIC SYMBOLS', 0Dh, 0Ah, 0),
	aExternalSymbol(*) byte initial(0Dh, 0Ah, 'EXTERNAL SYMBOLS', 0Dh, 0Ah, 0),
	pad754E address,

	aUserSymbols(*) byte data(0Dh, 0Ah, 'USER SYMBOLS', 0Dh, 0Ah, 0),
	aLocObjLineSour(*) byte data('  LOC  OBJ         LINE        SOURCE STATEMENT', 0Dh, 0Ah, 0Ah, 0),
	wa6DB2(*) address data(.aPublicSymbols, .aExternalSymbol, .aUserSymbols),
	asc$6DB8(*) byte data(0Dh, 0Ah, 0Ah, 0),
	asc$6DBC(*) byte data(0Dh),
	asc$6DBD(*) byte data(0Ah, 0Ah, 0Ah, 0),
	b6DC1(2) byte data(20h, 40h),
	asc$6DC3(*) byte data(' (', 0),
	asc$6DC6(*) byte data(')', 0),
	a1234(*) byte data('  1234');	



exit: procedure external; end;
flushout: procedure external; end;
ioErrChk: procedure external; end;
load: procedure(w1, w2, w3, w4, w5) external; declare (w1, w2, w3, w4, w5) address; end;
outch: procedure(b) external; declare b byte; end;
closeF: procedure(w) external; declare w address; end;
put2Hex: procedure(w1, w2) external; declare (w1, w2) address; end;
sub$546F: procedure external; end;
unpackToken: procedure(w1, w2) external; declare (w1, w2) address; end;
sub$465B: procedure byte external; end;
isPhase2Print: procedure byte external; end;
isSkipping: procedure byte external; end;
xisSpace: procedure byte external; end;
physmem: procedure address external; end;


declare (asc$3692, aIsisIi80808085, asc$3680)(1) byte external,
	(b6C21, fileIdx, b6C30) byte external,
	(off6C2C, off6C2E) address external;

out2Hex: procedure(arg1b);
	declare arg1b byte;
	call put2Hex(.outch, arg1b);
end;


print2Hex: procedure(arg1b);
	declare arg1b byte;
	call put2Hex(.printChar, arg1b);
end;



printStr: procedure(arg1w) reentrant;
	declare arg1w address;
	declare ch based arg1w byte;

	do while ch <> 0;
		call printChar(ch);
		arg1w = arg1w + 1;
	end;
end;

printNStr: procedure(arg1b, arg2w) reentrant;
	declare arg1b byte, arg2w address;
	declare ch based arg2w byte;

	do while arg1b > 0;
		call printChar(ch);
		arg2w = arg2w + 1;
		arg1b = arg1b - 1;
	end;
end;


printCRLF: procedure reentrant;
	call printChar(0Dh);
	call printChar(0Ah);
end;

declare asc$7752 byte initial(' '),
	asc$7553(*) byte initial('    ', 0);


itoa: procedure(arg1w, arg2w);
	declare (arg1w, arg2w) address;
	declare ch based arg2w byte;

	call move(5, .asc$3692 + 1, arg2w);
	arg2w = arg2w + 4;

	do while 1;
		ch = arg1w mod 10 + '0';
		arg2w = arg2w - 1;
		if (arg1w := arg1w /10) = 0 then
			return;
	end;
end;


printDecimal: procedure(arg1w) reentrant public;
	declare arg1w address;
	call itoa(arg1w, .asc$7752);
	call printStr(.asc$7553);
end;

skipToEOP: procedure public;
	do while lineCnt <= optPAGELENGTH;
		call outch(0Ah);
		lineCnt = lineCnt + 1;
	end;
end;


newPageHeader: procedure public;
	call printStr(.asc$6DBD);
	call printStr(.aIsisIi80808085);
	call printDecimal(pageCnt);
	call printCRLF;
	if optTITLE then
		call printNStr(titleLen, .optTITLESTR);

	call printCRLF;
	call printCRLF;
	if not b68AE(0) then
		call printStr(.aLocObjLineSour);
	pageCnt = pageCnt + 1;
end;


newPage: procedure public;
	if optTTY then
		call skipToEOP;
	else
		call outch(0Ch);

	lineCnt = 1;
	if not scanOptions then
		call newPageHeader;
end;


sub$6F4D: procedure public;
	if sub$465B then
	do while optEJECT > 0;
		call newPage;
		optEJECT = optEJECT - 1;
	end;
end;



printChar: procedure(arg1b) reentrant;
	declare arg1b byte;
	declare cnt byte;
	
	if arg1b = 0Ch then
	do;
		call newPage;
		return;
	end;
	if arg1b = 0Ah then
		if optPAGING then
		do;
			if (lineCnt := lineCnt + 1) >= optPAGELENGTH - 2 then
			do;
				if optTTY then
					call outch(0Ah);
				if optEJECT > 0 then
					optEJECT = optEJECT - 1;
				call newPage;
				return;
			end;
		end;
	if arg1b = 0Dh then
		curCol = 0;
	cnt = 1;
	if arg1b = 9 then
	do;
		cnt = 8 - (curCol and 7);
		arg1b = ' ';
	end;
	do while cnt <> 0;
		if curCol < 132 then
		do;
			if arg1b >= ' ' then
				curCol = curCol + 1;
			if curCol > optPAGEWIDTH then
			do;
				call printCRLF;
				call printStr(.asc$3680);
				curCol = curCol + 1;
			end;
			call outch(arg1b);
		end;
		cnt = cnt - 1;
	end;
end;

declare b755C(*) byte initial(' CDSME');

sub$7041: procedure public;
	declare b7562 byte,
		w7563 address,
		b7563 byte at(.w7563),
		b7564 byte at(.w7563 + 1),
		b7565 byte;

	sub$718C: procedure(arg1w);
		declare arg1w address;
		declare ch based curTokenSym$p byte;

		curTokenSym$p = curTokenSym$p - 1;
		call arg1w(ch and not b7565);
	end;



	b68AE(0) = 0FFh;
	if not optSYMBOLS then
		return;
	b755C(0) = 'A';
	do b7562 = 0 to 2;
		b6BDD = isPhase2Print and optSYMBOLS;
		curTokenSym$p = symTab(1) - 2;
		call printCRLF;
		call printStr(wa6DB2(b7562));

		do while (curTokenSym$p := curTokenSym$p + 8) < w6868(1);
		    w7563 = curTokenSym.w0;
		    if b7563 <> 9 then
			if b7563 <> 6 then
		    	    if b7562 <> 0 or b7563 <> 3 then
				if b7562 = 2 or (b7564 and b6DC1(b7562)) <> 0 then
				do;
				    call unpackToken(curTokenSym$p - 6, .b68AE + 1);
				    if b6BDD then
				    do;
					if optPAGEWIDTH - curCol < 11h then
						call printCRLF;
					call printStr(.b68AE + 1);
					call printChar(' ');
					if (b7565 := (b7564 and 40h) <> 0) then
						call printChar('E');
					else
						call printChar(b755C(b7564 and 7));

					call printChar(' ');
					call sub$718C(.print2Hex);
					call sub$718C(.print2Hex);
					curTokenSym$p = curTokenSym$p + 2;
					call printStr(.asc$3692 + 2);
				    end;
				end;

		end;

	end;
	if optDEBUG then
		b68AE(0) = 0;
	if b6BDD then
		call printCRLF;
end;





printCmdLine: procedure public;
	declare ch based actRead byte;

	call outch(0Ch);
	call sub$6F4D;
	ch = 0;
	call printStr(.cmdLineBuf);
	call newPageHeader;
end;


outStr: procedure(arg1w) reentrant;
	declare arg1w address;
	declare ch based arg1w byte;

	do while ch <> 0;
		call outch(ch);
		arg1w = arg1w + 1;
	end;
end;

outNStr: procedure(arg1b, arg2w) reentrant;
	declare arg1b byte, arg2w address,
		ch based arg2w byte;

	do while arg1b > 0;
		call outch(ch);
		arg2w = arg2w + 1;
		arg1b = arg1b - 1;
	end;
end;


sub$721E: procedure byte public;
	return w68A2 < w68A0;
end;



sub$7229: procedure public;
	declare ch based w68A2 byte;
	declare b7568 byte;

	if (b68AB := sub$721E or b68AB) then
	do;
		call out2Hex(high(w68A6));
		call out2Hex(low(w68A6));
	end;
	else
		call outStr(.asc$3692 + 2);

	call outch(' ');
	do  b7568 = 1 to 4;	/* may need structure access */
		if sub$721E and b6B34 then
		do;
			w68A6 = w68A6 + 1;
			call out2Hex(ch);
		end;
		else
			call outStr(.asc$3692 + 4);

		w68A2 = w68A2 + 1;
	end;

	call outch(' ');
	if shr(b6BDD := tokenAttr(b6A56), 6) then
		call outch('E');
	else if not b68AB then
		call outch(' ');
	else
		call outch(b755C(b6BDD and 7));
end;


sub$72D8: procedure public;
	if not b689B then
		return;

	call printStr(.asc$6DC3);	/* " (" */
	call printNStr(4, .b6A57);
	call printStr(.asc$6DC6);	/* ")" */
	call printCRLF;
	call move(4, .asciiLineNo, .b6A57);
end;


ovl3: procedure public;
	declare ch based off6C2C byte;
    loop:
	w68A0 = (w68A2 := tokStart(b6A56)) + tokenSize(b6A56);
	if isSkipping then
		w68A0 = w68A2;

	call outch(b6896);
	call outch(' ');
	if not xisSpace then
	do;
		b6896 = ' ';
		b689B = 0FFh;
	end;
	if b6B20 then
		call outStr(.asc$3680 + 9);
	else
		call sub$7229;
	if fileIdx > 0 then
	do;
		call outch(a1234(b6BDB := b6C21 + fileIdx));
		if b6BDB > 0 then
			call outch('=');
		else
			call outch(' ');
	end;
	else
		call outStr(.asc$3692 + 4);

	if b68AD then
	do;
		call outStr(.asc$3692 + 2);
		call printCRLF;
	end;
	else
	do;
		b68AD = 0FFh;
		call outNStr(4, .asciiLineNo);
		call outch(' ');
		curCol = 18h;
		call printNStr(b6C30, off6C2E);
		if ch <> 0Ah then
			call printChar(0Ah);
	end;
	if b6B20 then
	do;
		if optPAGING then
			call sub$6F4D;
	end;
	else
	do;
		do while sub$721E;
			call outStr(.asc$3692 + 4);
			call sub$7229;
			call printCRLF;
		end;
		if b6A56 > 0 and (b6B23 or b6B24) then
		do;
			call sub$546F;
			goto loop;
		end;
	end;
	call sub$72D8;
end;

asmComplete: procedure public;
	if errCnt > 0 then
		call itoa(errCnt, .aNoErrors);
	call printNStr((errCnt = 1) + 32, .aAssemblyComple);
	if errCnt > 0 then
	do;
		call move(4, .b6A57, .asc$7520);
		call printNStr(8, .asc$751E);
	end;
	call outch(0Dh);
	call outch(0Ah);
end;

ovl9: procedure public;
	if optPRINT then
		call closeF(outfd);
	outfd = 0;
	lineCnt = 1;
	call asmComplete;
	call flushout;
end;


ovl10: procedure public;
	declare ch based w68A6 byte;
	call closeF(infd);
	if optXREF then
	do;
		w68A6 = physmem - 1;
		ch = '0';
		if aF0Asxref$tmp(0) = ':' then
			ch = aF0Asxref$tmp(2);
		call load(.aF0Asxref, 0, 1, 0, .statusIO);
		call ioErrChk;

	end;
	call exit;
end;

end;
asmov2.pl3
asmov2: do;

$include(global.inc)
declare (aModulePage)(1) byte external;


declare	b6D6E(*) byte data(1, 2, 1, 3),
	off$6D72(*) address data(.rec16.len, .rec24.len, .rec20.len, .rec06.len),
	b6D7A(*) byte data(7Bh, 3Ah, 39h, 7Ch),
	b6D7E(*) byte data(0Ah, 12h, 40h);


declare	rec02 structure(type byte, len address, b0 byte, dta(25) byte) initial(2),
	(w758B$p, w758D$p) address;




ioErrChk: procedure external; end;
seek: procedure(w1, w2, w3, w4, w5) external; declare (w1, w2, w3, w4, w5) address; end;
unpackToken: procedure(w1, w2) external; declare (w1, w2) address; end;
write: procedure(w1, w2, w3, w4) external; declare (w1, w2, w3, w4) address; end;
testBit: procedure(b, w) byte external; declare b byte, w address; end;
sub$4646: procedure byte external; end;
isSkipping: procedure byte external; end;


writeRec: procedure(arg1w) public;
	declare arg1w address,
		w7591 address, w7593 address,
		b7595 byte, b7596 byte;
	declare wrd based w7591 address;
	declare ch based w7591 byte;

	w7591 = arg1w + 1;
	w7593 = (wrd := wrd + 1) + 3;	/* include crc byte + type + len word */
	b7596 = 0;			/* crc */
	w7591 = w7591 - 1;
	do b7595 = 2 to w7593;
		b7596 = b7596 - ch;
		w7591 = w7591 + 1;
	end;
	ch = b7596;			/* insert crc byte */
	call write(objfd, arg1w, w7593, .statusIO);
	call ioErrChk;
end;


sub$6DF1: procedure byte;
	declare b7597 byte;
	if ((b7597 := tokenAttr(b6A56)) and 5Fh) = 0 then
		return 3;
	if (b7597 and 40h) <> 0 then
		return 2;
	if (b6521 := b7597 and 7) = 0 then
		return 3;
	return (b6521 <> activeSeg) and 1;
end;


sub2$6E32: procedure public;
	declare b7598 byte;
	declare wrd based w758B$p address;
	do b7598 = 0 to 3;
		b6BDB = (b7598 - 1) and 3;
		w758B$p = off$6D72(b6BDB);
		if wrd > b6D6E(b6BDB) then
			call writeRec(w758B$p - 1);

		wrd = b6D6E(b6BDB);
		b6526(b6BDB) = 0;
		if b6525 <>  b6BDB then
			b652B(b6BDB) = 0FFh;
	end;
	rec06.addr = w6752 + segSize(rec06.seg := activeSeg);
	rec16.seg = b6524;
	rec24.seg = tokenAttr(b6A56) and 7;
	rec24.fixtype, rec20.fixtype = b6524;
end;



sub$6EE1: procedure;
	declare w7599 address;

	declare wrd based w758B$p address;

	w758B$p = off$6D72(b6525 := sub$6DF1);
	if wrd > b6D7A(b6525) or rec06.len + tokenSize(b6A56) > 7Ch then
		call sub2$6E32;

	if b652F then
	do;
		b652F = 0;
		rec06.addr = segSize(rec06.seg := activeSeg) + w6752;
	end;
	else if rec06.seg <> activeSeg or (w7599 := rec06.addr + b6526(3)) <> segSize(activeSeg) + w6752
	  or w7599 < rec06.addr then
		call sub2$6E32;


	do case b6525;
/* 0 */		do;
			if b652B(0) then
			do;
				b652B(0) = 0;
				rec16.seg = b6524;
			end;
			else if rec16.seg <> b6524 then
				call sub2$6E32;
		end;
/* 1 */		do;
			if b652B(1) then
			do;
				b652B(1) = 0;
				rec24.seg = tokenAttr(b6A56) and 7;
				rec24.fixtype = b6524;
			end;
			else if rec24.fixtype <> b6524 or (tokenAttr(b6A56) and 7) <> rec24.seg then
				call sub2$6E32;
		end;
/* 2 */		do;
			if b652B(2) then
			do;
				b652B(2) = 0;
				rec20.fixtype = b6524;
			end;
			else if rec20.fixtype <> b6524 then
				call sub2$6E32;

		end;
/* 4 */		;
	end;
end;


sub$704D: procedure;
	declare b759B byte;

	declare ch based w651F byte;
	do b759B = 1 to tokenSize(b6A56);
		rec06.dta(b6526(3)) = ch;
		b6526(3) = b6526(3) + 1;
		w651F = w651F + 1;
	end;
	rec06.len = rec06.len + tokenSize(b6A56);
end;



sub$709D: procedure;
	rec16.len = rec16.len + 2;
	rec16.dta(b6526(0)) = w6522;
	b6526(0) = b6526(0) + 1;
end;


sub$70C1: procedure;
	rec24.len = rec24.len + 2;
	rec24.dta(b6526(1)) = w6522;
	b6526(1) = b6526(1) + 1;
end;

sub$70E5: procedure;
	rec20.dta(b6526(2)) = tokenSymId(b6A56);
	rec20.dta(b6526(2) + 1) = w6522;
	rec20.len = rec20.len + 4;
	b6526(2) = b6526(2) + 2;
end;

sub$7131: procedure;
	b6524 = shr(tokenAttr(b6A56) and 18h, 3);
	w6522 = segSize(activeSeg) + w6752;
	if not (b6B23 or b6B24) and (tokenSize(b6A56) = 2 or tokenSize(b6A56) = 3) then
		w6522 = w6522 + 1;
	call sub$6EE1;
	w651F = w68A2;
	call sub$704D;
	do case sub$6DF1;
/* 0 */ 	call sub$709D;
/* 1 */		call sub$70C1;
/* 2 */		call sub$70E5;
/* 3 */		;
	end;
end;


ovl2: procedure public;
	declare b759C byte;

	if rec18a.len + 9 > 7Dh then
	do;
		call writeRec(.rec18a);
		rec18a.type = 18h;
		rec18a.len = 0;
		b652A = 0;
	end;
	rec18a.len = rec18a.len + b6744 + 2;
	rec18a.dta(b652A) = b6744;
	b652A = b652A + 1;
	do b759C = 0 to b6744;
		rec18a.dta(b652A + b759C) = b6873(b759C);
	end;

	rec18a.dta(b652A + b6744) = 0;
	b652A = b652A + b6744 + 1;
end;

sub$725E: procedure(arg1b);
	declare arg1b byte;
	declare b759E byte,
	b67EB based curTokenSym$p(1) byte;	/* TO CLEANUP */

	sub$72EC: procedure;
		declare w759F address;
		declare b758B based w758B$p(6) byte;
		declare b758D based w758D$p(1) byte;
		declare w758D based w758D$p address;
		declare wrd based w759F address;
		declare ch based w758D$p byte;
		if (b67EB(1) and 40h) <> 0 then
			return;
		w759F = curTokenSym$p - 2;
		w758D = wrd; 
		call unpackToken(curTokenSym$p - 6, (w758B$p := (w758D$p := w758D$p + 2) + 1));
		b758B(6) = ' ';
		ch = 0;

		do while b758B(0) <> ' ';
			b758D(0) = b758D(0) + 1;
			w758B$p = w758B$p + 1;
		end;
		b758B(0) = 0;
		w758D$p = w758B$p + 1;
	end;

	sub$7359: procedure;
		if (rec16.len := w758D$p - .rec16.seg) > 1 then
			call writeRec(.rec16);
		rec16.type = (arg1b and 4) or 12h;
		rec16.seg = b759E;
		w758D$p = .rec16.dta;
	end;

	w758D$p = .rec16.dta;
	do b759E = 0 to 4;
		call sub$7359;
		curTokenSym$p = symTab(1) - 2;

		do while (curTokenSym$p := curTokenSym$p + 8) < w6868(1);
			if w758D$p > .rec16.dta(57) then
				call sub$7359;

			if (b67EB(1) and 7) = b759E and not testBit(b67EB(0), .b6D7E) and
			  (not arg1b or (b67EB(1) and 20h) <> 0) then
				call sub$72EC;
		end;
		call sub$7359;
	end;
end;








writeRec02: procedure public;
	declare wrd based w758B$p address;
	declare ch based w758B$p byte;
	declare b75A1 byte;


	call move((rec02.b0 := moduleNameLen), .aModulePage, .rec02.dta);
	w758B$p = .rec02 + moduleNameLen + 4;
	wrd = 0;
	w758B$p = w758B$p + 1;
	if segSize(1) < w6B41(1) then
		segSize(1) = w6B41(1);
	if segSize(2) < w6B41(2) then
		segSize(2) = w6B41(2);

	do b75A1 = 1 to 4;
		w758B$p = w758B$p + 1;
		ch = b75A1;
		w758B$p = w758B$p + 1;
		wrd = segSize(b75A1);
		w758B$p = w758B$p + 2;
		ch = b674C(b75A1 - 1);
	end;
	rec02.len = moduleNameLen + 13h;
	call writeRec(.rec02);
end;

writeRec040E: procedure public;
	rec04.subtype = b6755;
	rec04.seg = b6745;
	rec04.addr = startAddr;
	call writeRec(.rec04);
	rec0E(1) = 0;
	call writeRec(.rec0E);
end;

ovl8: procedure public;
	w6752 = 0;
	b689A = 1;
	b6A56 = 1;
	if b6B33 then
		;
	else
	do while b6A56 <> 0;
		b6A56 = sub$4646;
		w68A0 = tokStart(b6A56) + tokenSize(b6A56);
		w68A2 = tokStart(b6A56);
		if isSkipping or not b6B34 then
			w68A0 = w68A2;
		if w68A0 > w68A2 then
		do;
			call sub$7131;
			w6752 = w6752 + tokenSize(b6A56);
		end;
		if not(b6B23 or b6B24) then
			b6A56 = 0;
	end;
end;


ovl11: procedure public;
	declare myrec16 structure(type byte, len address, seg byte, b1 byte) at (.rec16);
	if w6750 <> 0 then
	do;
		call seek(objfd, 2, .w6BD3, .w6BD3, .statusIO);		/* SEEKABS */
		call writeRec02;
		call seek(objfd, 4, .w6BD3, .w6BD3, .statusIO);		/* SEEKEND */
	end;
	rec22.type = 16h;
	rec22.len = 1;
	rec22.seg = 0;
	rec22.fixtype = 0;
	call sub$725E(0FFh);
	if optDEBUG then
		call sub$725E(0);
end;
end;
asmov3.plm
asm88: do;

$include(global.inc)

declare	(signonMsg, ovlFile)(1) byte external,
	(cZERO, c255, b6C21, fileIdx) byte external,
	(off6C25, off6C2C, off6C2E, w75C4, rootfd, includefd) address external,
	files(6) structure(name(15) byte, blk address, byt address, b19 byte) external;

rescan: procedure(w1, w2) external; declare (w1, w2) address; end;
isPhase1: procedure byte external; end;
physmem: procedure address external; end;
ioErrChk: procedure external; end;
sub$3DCE: procedure external; end;
wrError: procedure(b) external; declare b byte; end;
closeF: procedure(w) external; declare w address; end;
read: procedure(w1, w2, w3, w4, w5) external; declare (w1, w2, w3, w4, w5) address; end;
seek: procedure(w1, w2, w3, w4, w5) external; declare (w1, w2, w3, w4, w5) address; end;
write: procedure(w1, w2, w3, w4) external; declare (w1, w2, w3, w4) address; end;
inOpen: procedure(w1, w2) address external; declare (w1, w2) address; end;


declare aExtents(*) byte public initial(' LSTOBJ'),
	aDebug(*) byte public initial('DEBUG');

declare EDATA byte external;


/* overlay 3 appears to repair the code that starts here */

cmdSkipWhite: procedure public;
	declare cmdch based cmdch$p byte;
	
	do while (cmdch = ' ' or cmdch = 9) and cmdch$p <> actRead;
		cmdch$p = cmdch$p + 1;
	end;
end;

getDrive: procedure byte public;
	declare cmdch based cmdch$p byte;

	if cmdch = ':' then
	do;
		cmdch$p = cmdch$p + 2;
		return cmdch;
	end;
	else
		do b6BDB = 0 to 4;
		if cmdch <> aDebug(b6BDB) and aDebug(b6BDB) + 20h <> cmdch then
				return '0';
			cmdch$p = cmdch$p + 1;
		end;
	call cmdSkipWhite;
	if cmdch <> ':' then
		return '0';
	cmdch$p = cmdch$p + 2;
	return cmdch;
end;

addExtents: procedure public;
	do b6BDB = 1 to 3;
		lstFile(b6BDD + b6BDB) = aExtents(b6BDB);
		objFile(b6BDD + b6BDB) = aExtents(b6BDB+3);
	end;
end;

getAsmFileX: procedure public;		/* extended to include overlay file initialisation */
	declare cmdch based cmdch$p byte;

	cmdIsWhite: procedure byte;
		declare cmdch based cmdch$p byte;
		return cmdch = ' ' or cmdch = 9 or cmdch = CR;
	end;

	symTab(0) = .w75C4;
	w686E, w6868(0), symTab(1), w6868(1) = .EDATA;
	call rescan(1, .statusIO);
	call ioErrChk;
	call read(1, .cmdLineBuf, 128, .actRead, .statusIO);
	call ioErrChk;
	actRead = actRead + .cmdLineBuf;
	scanOptions = 0FFh;
	call write(0, .signonMsg, 29h, .statusIO);
	call write(0, .signonMsg, 2, .statusIO);
	call ioErrChk;
	call cmdSkipWhite;
	ovlFile(2), aF0Asxref(2) = getDrive; 

	do while not cmdIsWhite;
		cmdch$p = cmdch$p + 1;
	end;

	call cmdSkipWhite;
	if cmdch = CR then
		call wrError(4);	/* file error */

	infd = inOpen(cmdch$p, 1);
	rootfd, includefd = infd;
	b6BDB = TRUE;
	b6BDD = 0;

	do while not cmdIsWhite;
		files(0).name(b6BDD) = cmdch;
		if b6BDB then
			lstFile(b6BDD), objFile(b6BDD) = cmdch;
		if cmdch = '.' then
		do;
			b6BDB = FALSE;
			call addExtents;
		end;
		b6BDD = b6BDD + 1;
		cmdch$p = cmdch$p + 1;
	end;
	options$p = cmdch$p;
	if b6BDB then
	do;
		lstFile(b6BDD) = '.';
		objFile(b6BDD) = '.';
		call addExtents;
	end;

	files(0).name(b6BDD) = ' ';
	if lstFile(0) = ':' and lstFile(2) <> '0' then
		aF0Asxref$tmp(2) = lstFile(2);
end;




resetData: procedure public;
	call sub$3DCE;
	b6B33, scanOptions, skipping(0), b6B2C, inElse(0), b6B2E, b674A(0), b674A(1), b6742, b6857, b6C21 = cZERO;
	b6743, b6898, optLIST, b6A6F, optCOND = c255;
	saveIdx, lookAhead, activeSeg, ifDepth, opSP, opStack(0) = cZERO;
	segSize(0), segSize(1), segSize(2), w6B41(0), w6B41(1), w6B41(2), w68A6, w6750, errCnt = w673F;
	b6882 = b6882 + 1;
	w6A4E, opType, pageCnt, lineCnt = 1;
	b68AE(0) = 0;
	curChar = 20h;
	do b6BDB = 0 to 11;
		optionSeen(b6BDB) = 0;
	end;
	if not isPhase1 then
	do;
		if fileIdx <> 0 then
		do;
			call closeF(includefd);
			call ioErrChk;
			includefd = rootfd;
		end;
		fileIdx = cZERO;
		off6C25 = .b68B8;
		off6C2C = off6C25 - 1;
		off6C2E = .b68B8;
		call seek(infd, 2, .w6BD3, .w6BD3, .statusIO);	/* SEEKABS */
		call ioErrChk;
	end;
	w6870 = physmem + 0BFh;
	endOutBuf = .b6A00;
end;


sub$70EE: procedure public;
	rec06.type = 6;
	rec06.len = 3;
	rec16.type = 22h;
	rec16.len = 1;
	rec24.type = 24h;
	rec24.len = 2;
	rec20.type = 20h;
	rec20.len = 1;
end;

end;
keywrd.plm
keywords: do;
declare copyright(*) byte data('(C) 1976,1977,1979,1980 INTEL CORP');

declare w75C4(*) address public initial(
	0A528h,	0,	0,	10h,	/* NE */
	63B0h,	0,	0CCh,	2Ch,	/* CZ */
	0,	0,	0,	0,	/* */
	0BFB6h,	0,	0C0h,	2Dh,	/* RNZ */
	0B354h,	0,	0C1h,	25h,	/* POP */
	6EE9h,	0,	0,	1Dh,	/* EQU */
	0AD70h,	0,	0E800h,	13h,	/* OR */
	0A1A5h,	0,	0E806h,	29h,	/* MVI */
	0C6CFh,	0,	37h,	2Dh,	/* STC */
	0C6CDh,	6158h,	0,	1B05h,	/* STACK */
	6615h,	0,	27h,	2Dh,	/* DAA */
	988Dh,	0E100h,	0Ah,	26h,	/* LDAX */
	61F6h,	0,	0C4h,	2Ch,	/* CNZ */
	53CFh,	0,	0D888h,	27h,	/* ADC */
	53D0h,	0,	80h,	27h,	/* ADD */
	6748h,	0,	0D0F3h,	2Dh,	/* DI */
	0,	0,	0,	0,	/* */
	0,	0,	0,	0,	/* */
	0,	0,	0,	0,	/* */
	53D5h,	0,	0C8C6h,	28h,	/* ADI */
	6A40h,	0,	0F003h,	7,	/* E */
	0,	0,	0,	0,	/* */
	0,	0,	0,	0,	/* */
	0,	0,	0,	0,	/* */
	0A088h,	0,	0,	15h,	/* MOD */
	0AD83h,	0,	0,	1Fh,	/* ORG */
	0,	0,	0,	0,	/* */
	8F70h,	0,	0E8CAh,	2Ch,	/* JZ */
	68E9h,	76C0h,	0,	31h,	/* DSEG */
	0C488h,	0,	0,	1Eh,	/* SET */
	0,	0,	0,	0,	/* */
	0C521h,	0,	30h,	22Dh,	/* SIM */
	0,	0,	0,	0,	/* */
	0,	0,	0,	0,	/* */
	0A4A1h,	6A40h,	0,	34h,	/* NAME */
	0C6CDh,	0,	32h,	2Ch,	/* STA */
	0AE08h,	0,	0D3h,	28h,	/* OUT */
	6630h,	0,	0,	1Ah,	/* DB */
	8DB6h,	0,	0C2h,	2Ch,	/* JNZ */
	0,	0,	0,	0,	/* */
	6618h,	0,	0C009h,	25h,	/* DAD */
	8D9Fh,	0,	0D2h,	2Ch,	/* JNC */
	0A09Ah,	0,	0C040h,	2Bh,	/* MOV */
	8610h,	0,	0C000h,	21h,	/* IF */
	6E60h,	0,	0A800h,	20h,	/* END */
	9938h,	6400h,	0B82Ah,	2Ch,	/* LHLD */
	9600h,	0,	0C005h,	7,	/* L */
	0C6F6h,	0,	90h,	27h,	/* SUB */
	0C634h,	9600h,	0F9h,	2Dh,	/* SPHL */
	0C405h,	0,	0DEh,	28h,	/* SBI */
	0B3FBh,	0,	6,	7,	/* PSW */
	0BF4Fh,	0,	7,	2Dh,	/* RLC */
	5780h,	0,	0,	7,	/* B */
	0,	0,	0,	0,	/* */
	6220h,	0,	0F0F4h,	2Ch,	/* CP */
	0,	0,	0,	0,	/* */
	0AD85h,	0,	0F6h,	28h,	/* ORI */
	0B11Bh,	6A40h,	2,	5,	/* PAGE */
	0,	0,	0,	0,	/* */
	0,	0,	0,	0,	/* */
	5629h,	76C0h,	0,	2Fh,	/* ASEG */
	8750h,	0,	0DBh,	28h,	/* IN */
	6E60h,	8610h,	0D000h,	23h,	/* ENDIF */
	0,	0,	0,	0,	/* */
	8BD8h,	0,	0F0DAh,	2Ch,	/* JC */
	0AD7Dh,	0,	0B0h,	27h,	/* ORA */
	0C3FEh,	0,	98h,	27h,	/* SBB */
	0C6D7h,	9A10h,	0,	35h,	/* STKLN */
	0BFE0h,	0,	0F0h,	2Dh,	/* RP */
	0C4F8h,	6400h,	22h,	2Ch,	/* SHLD */
	0C078h,	0,	0C7h,	2Eh,	/* RST */
	6231h,	0,	0ECh,	2Ch,	/* CPE */
	0B436h,	9957h,	0E800h,	32h,	/* PUBLIC */
	0BDA0h,	0,	0E817h,	2Dh,	/* RAL */
	80E0h,	0,	0E876h,	2Dh,	/* HLT */
	6235h,	0,	0FEh,	28h,	/* CPI */
	0BF68h,	0,	0F8h,	2Dh,	/* RM */
	0,	0,	0,	0,	/* */
	0,	0,	0,	0,	/* */
	0BDA6h,	0,	1Fh,	2Dh,	/* RAR */
	805Bh,	7D00h,	0D000h,	18h,	/* HIGH */
	623Bh,	0,	0D8E4h,	2Ch,	/* CPO */
	0B447h,	7D00h,	0E0C5h,	25h,	/* PUSH */
	0,	0,	0,	0,	/* */
	0C6FDh,	0,	0F0D6h,	28h,	/* SUI */
	61A8h,	0,	0FCh,	2Ch,	/* CM */
	0,	0,	0,	0,	/* */
	0,	0,	0,	0,	/* */
	0BFF1h,	0,	0E8h,	2Dh,	/* RPE */
	62A9h,	76C0h,	0,	30h,	/* CSEG */
	0BE48h,	0,	0C9h,	2Dh,	/* RET */
	876Eh,	0,	4,	2Ah,	/* INR */
	0BEE1h,	0,	20h,	22Dh,	/* RIM */
	0,	0,	0,	0,	/* */
	0B16Ch,	9600h,	0E9h,	2Dh,	/* PCHL */
	988Dh,	0,	3Ah,	2Ch,	/* LDA */
	7000h,	0BF90h,	0,	33h,	/* EXTRN */
	8774h,	0,	0B003h,	25h,	/* INX */
	61B5h,	0,	2Fh,	2Dh,	/* CMA */
	0,	0,	0,	0,	/* */
	61B7h,	0,	3Fh,	2Dh,	/* CNC */
	0BFFBh,	0,	0E0h,	2Dh,	/* RPO */
	0C6CDh,	0E100h,	7002h,	26h,	/* STAX */
	0E5BDh,	0,	0A8h,	27h,	/* XRA */
	9A5Bh,	0,	0,	19h,	/* LOW */
	6D88h,	0,	0FBh,	2Dh,	/* EI */
	8DE0h,	0,	0F2h,	2Ch,	/* JP */
	6676h,	0,	0D005h,	2Ah,	/* DCR */
	6400h,	0,	2,	7,	/* D */
	555Dh,	0,	0A0h,	27h,	/* ANA */
	0E5C5h,	0,	0EEh,	28h,	/* XRI */
	8D68h,	0,	0FAh,	2Ch,	/* JM */
	5560h,	0,	0,	12h,	/* AND */
	5140h,	0,	3807h,	7,	/* A */
	0E614h,	9600h,	0E3h,	2Dh,	/* XTHL */
	0,	0,	0,	0,	/* */
	876Ch,	5449h,	1,	5,	/* INPAGE */
	5565h,	0,	0E6h,	28h,	/* ANI */
	9B00h,	0,	0,	0Ch,	/* LT */
	8DF1h,	0,	0EAh,	2Ch,	/* JPE */
	61C4h,	0,	20B8h,	27h,	/* CMP */
	7BC0h,	0,	0,	0Eh,	/* GT */
	6978h,	0,	7800h,	1Bh,	/* DW */
	6EC8h,	0,	0,	0Bh,	/* EQ */
	667Ch,	0,	500Bh,	25h,	/* DCX */
	6E1Fh,	6A40h,	0A000h,	22h,	/* ELSE */
	0A6D4h,	0,	0,	2Dh,	/* NOP */
	9F01h,	0AD95h,	0,	1C05h,	/* MEMORY */
	5FE0h,	9600h,	0CDh,	2Ch,	/* CALL */
	0BDD8h,	0,	0D8h,	2Dh,	/* RC */
	53ADh,	0,	80CEh,	28h,	/* ACI */
	0BF9Fh,	0,	0D0h,	2Dh,	/* RNC */
	0E36Ch,	76C0h,	0EBh,	2Dh,	/* XCHG */
	8DFBh,	0,	0E2h,	2Ch,	/* JPO */
	68D8h,	0,	0,	1Ch,	/* DS */
	0C620h,	0,	6,	8,	/* SP */
	9C40h,	0,	6,	7,	/* M */
	98A8h,	0,	3800h,	0Dh,	/* LE */
	6018h,	0,	0DCh,	2Ch,	/* CC */
	7D00h,	0,	5004h,	7,	/* H */
	61DFh,	0,	50D4h,	2Ch,	/* CNC */
	0C4F8h,	0,	0,	16h,	/* SHL */
	5DC0h,	0,	1,	7,	/* C */
	0C170h,	0,	0C8h,	2Dh,	/* RZ */
	0E556h,	0,	0,	14h,	/* XOR */
	7968h,	0,	0,	0Fh,	/* GE */
	0A6D8h,	0,	0,	11h,	/* NOT */
	0C4FEh,	0,	0,	17h,	/* SHR */
	9BB5h,	0,	1,	24h,	/* LXI */
	8D84h,	0,	0C3h,	2Ch,	/* JMP */
	0C03Fh,	0,	0Fh,	2Dh	/* RRC */
);


end;
asm51.plm
asm51: do;

declare	asc$3680(*) byte public data('                  '),
	asc$3692(*) byte public data('      ', 0),
	asc$3699(*) byte public data(0Dh, 0Ah, 0),
	signonMsg(*) byte public data(0Dh, 0Ah),
	aIsisIi80808085(*) byte public data('ISIS-II 8080/8085 MACRO ASSEMBLER, V4.1', 9, 9),
	aModulePage(*) byte public data('MODULE ',9, ' PAGE ', 0),
	cZERO byte public data(0),
	c255 byte public data(0FFh),
	aC19761977197$0(*) byte data('(C) 1976,1977,1979,1980 INTEL CORP'),
	aStack(*) byte public data(0Dh, 0Ah, 'STACK', 0),
	aTable(*) byte public data(0Dh, 0Ah, 'TABLE', 0),
	aCommand(*) byte public data(0Dh, 0Ah, 'COMMAND', 0),
	aEof(*) byte public data(0Dh, 0Ah, 'EOF', 0),
	aFile(*) byte public data(0Dh, 0Ah, 'FILE', 0),
	aMemory(*) byte public data(0Dh, 0Ah, 'MEMORY', 0),
	aError(*) byte public data(' ERROR', 0Dh, 0Ah, 0),
	aError$0(*) byte public data(' ERROR, ', 0Dh,0Ah, 0),
	errStrs(*) address public data(.aStack, .aTable, .aCommand, .aEof, .aFile, .aMemory),
	errStrsLen(*) byte public data(7, 7, 9, 5, 6, 8),
	aBadSyntax(*) byte public data('BAD SYNTAX', 0Dh, 0Ah),
	aCo(*) byte public data(':CO:', 0);



delete: procedure(w1, w2) external; declare (w1, w2) address; end;
flushout: procedure external; end;
writeRec: procedure(w) external; declare w address; end;	/* in overlay 2 */
ovl10: procedure external; end;
ovl11: procedure external; end;
writeRec02: procedure external; end;		/* in overlay 2 */
asmComplete: procedure external; end;
writeRec040E: procedure external; end;
ovl9: procedure external; end;
sub$540D: procedure external; end;
getAsmFile: procedure external; end;
resetData: procedure external; end;
sub$70EE: procedure external; end;
sub$3D6D: procedure external; end;

inOpen: procedure(w1, w2) address external; declare (w1, w2) address; end;
strUCequ: procedure(w1, w2) byte external; declare (w1, w2) address; end;


declare	(objFile, optXREF, optPRINT, optOBJECT, optMACROFILE, MacroDebugOrGen, phase) byte external,
	(w6750, objfd, xreffd, includefd, rootfd, statusIO, infd, outfd) address external,
	rec18a structure(type byte, len address, dta(1) byte) external,
	lstFile(1) byte external,
	aF0Asxref$tmp(1) byte external;;

	
start:
	call getAsmFile;
	phase = 1;
	call resetData;
	call sub$3D6D;
	if optOBJECT then
	do;
		call delete(.objFile, .statusIO);
		objfd = inOpen(.objFile, 3);
	end;

	if optXREF then
	do;
		xreffd = inOpen(.aF0Asxref$tmp, 2);
		outfd = xreffd;
	end;

	call sub$540D;
	phase = 2;
	if optOBJECT then
	do;
		if rec18a.len > 0 then
			call writeRec(.rec18a);
		if w6750 = 0 then
			call writeRec02;
		call sub$70EE;
	end;
	
	if optPRINT then
		outfd = inOpen(.lstFile, 2);

	call resetData;
	call sub$3D6D;
	call sub$540D;
	if optPRINT then
	do;
		call asmComplete;
		call flushout;
	end;

	if optOBJECT then
	do;
		call ovl11;
		call writeRec040E;
	end;

	if not strUCequ(.aCo, .lstFile) then
		call ovl9;
	call ovl10;


end;
asm52.plm
asm52: do;

declare TRUE literally '0FFh',
	FALSE literally '0';

close: procedure(w1, w2) external; declare (w1, w2) address; end;
error: procedure(w1) external; declare w1 address; end;
exit: procedure external; end;
load: procedure(w1, w2, w3, w4, w5) external; declare (w1, w2, w3, w4, w5) address; end;
open: procedure(w1, w2, w3, w4, w5) external; declare (w1, w2, w3, w4, w5) address; end;
printCmdLine: procedure external; end;
parseCmds: procedure external; end;
skip2NextLine: procedure external; end;
sub$4904: procedure external; end;
sub$54FD: procedure external; end;
printDecimal: procedure(w1) external; declare w1 address; end;		/* overlay 1 */
write: procedure(w1, w2, w3, w4) external; declare (w1, w2, w3, w4) address; end;

getCh: procedure byte external; end;
isSkipping: procedure byte external; end;

declare tokenSize literally 'toksiz',
	tokStart literally 'tokst';

declare (w6A4E, curFileName$p, w6BE0, cmdch$p, statusIO, outfd, out$p, endOutBuf) address external,
	(openStatus, errCnt, options$p, off6C2C, off6C2E) address external,
	(outbuf, aError, aError$0, errStrsLen)(1) byte external,
	(aBadSyntax, asc$3699)(1) byte external,
	errStrs(1) address external,
	(phase, optPRINT, optOBJECT, collectBufIdx, scanOptions, b6B33, b6BD9) byte external,
	(b6C27, b6896, b6B2B, b6749, b6754, curChar, b6B20, reget) byte external,
	(b6C21, cZERO, c255, b6898, optDEBUG, optXREF, optSYMBOLS, optPAGING, b6C30) byte external,
	(b6742, b6855, b6857, b6858, b6859, b6872) byte external,
	(b687F, b6880, b6881, b6884, b6885, b689A, b689B, b689C, b68AB) byte external,
	(b68AD, optEJECT, b6B23, b6B24, b6B25, has16bitOperand, b6B30, b6B31, b6B32) byte external,
	(b6B34, b6B35, tokenSP) byte external,
	(tokenSize, skipping, tokenType)(1) byte external;

physmem: procedure address public;
	declare top address at(4);

	return (top - 100h) and 0FF00h;
end;


nxtCmdCh: procedure byte public;
	declare cmdch based cmdch$p byte;
	declare ch byte;

	ch = cmdch;
	cmdch$p = cmdch$p + 1;
	if 'a' <= ch and ch <= 'z' then
		ch = ch and 5Fh;
	return ch;
end;


ioErrChk: procedure public;
	if statusIO = 0 then
		return;
	call error(statusIO);
	call exit;
end;


flushout: procedure public;
	call write(outfd, .outbuf, out$p - .outbuf, .statusIO);
	out$p = .outbuf;
end;

outch: procedure(arg1b) public;
	declare arg1b byte;
	declare ch based out$p byte;

	if out$p = endOutBuf then
		call flushout;
	ch = arg1b;
	out$p = out$p + 1;
end;

outStrN: procedure(arg1w, arg2b) public;
	declare arg1w address, arg2b byte;
	declare ch based arg1w byte;

	do while arg2b > 0;
		call outch(ch);
		arg1w = arg1w + 1;
		arg2b = arg2b - 1;
	end;
end;


closeF: procedure(arg1w) public;
	declare arg1w address;

	call close(arg1w, .statusIO);
end;

isSpace: procedure byte public;
	return curChar = 20h;
end;

isTab: procedure byte public;
	return curChar = 9;
end;

isWhite: procedure byte public;
	return isSpace or isTab;
end;

isRParen: procedure byte public;
	return curChar = 29h;
end;

isCR: procedure byte public;
	return curChar = 0Dh;
end;

isComma: procedure byte public;
	return curChar = 2Ch;
end;

isPhase1: procedure byte public;
	return phase = 1;
end;


skip2EOL: procedure public;
	if not isCR then
		do while getCh <> 0Dh;
		end;
end;

sub4$3A6A: procedure byte public;
	return (phase = 2) and optOBJECT;
end;


isPhase2Print: procedure byte public;
	return phase = 2 and optPRINT;
end;

wrConsole: procedure(arg1w, arg2w) public;
	declare (arg1w, arg2w) address;

	call write(0, arg1w, arg2w, .statusIO);
	call ioErrChk;
end;

wrError: procedure(arg1b) public;
	declare arg1b byte;

	if b6BD9 then
		return;

	if isPhase1 and arg1b = 0 then
	do;
		b6B33 = TRUE;
		return;
	end;

	w6BE0 = .aError;
	if arg1b = 4 then
		w6BE0 = .aError$0;

	call wrConsole(errStrs(arg1b), errStrsLen(arg1b));
	call wrConsole(w6BE0, 8);
	if isPhase2Print then
	do;
		call outStrN(errStrs(arg1b), errStrsLen(arg1b));
		call outStrN(w6BE0, 8);
	end;
	if arg1b = 4 or arg1b = 3 then
	do;
		if collectBufIdx = 0 then
		do;
			call wrConsole(.aBadSyntax, 12);
			if not scanOptions then
			do;
				call skip2NextLine;
				outfd = 0;
				call printDecimal(w6A4E);		/* overlay 1 */
				call outch(0Ah);
			end;
		end;
		else
		do;
			call wrConsole(curFileName$p, collectBufIdx);
			call wrConsole(.asc$3699, 2);
		end;
	end;
	if arg1b = 0 then
	do;
		b6BD9 = TRUE;
		return;
	end;
	call exit;
end;

fileError: procedure(arg1w) public;
	declare arg1w address;
	declare ch based arg1w byte;

	collectBufIdx = 0;
	curFileName$p = arg1w;

	do while ch <> ' ' and ch <> 0dh and ch <> 9;
		collectBufIdx = collectBufIdx + 1;
		arg1w = arg1w + 1;
	end;
	if b6C27 then
		call wrError(3);
	call wrError(4);
end;

inOpen: procedure(arg1w, arg2w) address public;
	declare (arg1w, arg2w) address;
	declare open$infd address;

	call open(.open$infd, arg1w, arg2w, 0, .openStatus);
	if openStatus <> 0 then
		call fileError(arg1w);
	return open$infd;
end;


nibble2Ascii: procedure(n) byte public;
	declare n byte;
	n = (n and 0Fh) + '0';
	if n > '9' then
		n = n + 7;
	return n;
end;

put2Hex: procedure(arg1w, arg2b) public;
	declare arg1w address, arg2b byte;

	call arg1w(nibble2Ascii(ror(arg2b, 4)));
	call arg1w(nibble2Ascii(arg2b));
end;

xisSpace: procedure byte public;
	return b6896 = 20h;
end;

sub$3C91: procedure byte public;
	return xisSpace or b6896 = 'M' or b6896 = 'P';
end;


getNibble: procedure(arg1w, arg2b) byte public;
	declare arg1w address, arg2b byte;
	declare ch based arg1w byte;
	declare b6C11 byte;

	arg1w = arg1w + shr(arg2b, 1);
	b6C11 = ch;
	if not arg2b then
		b6C11 = ror(b6C11, 4);
	return b6C11 and 0Fh;
end;

sub$3CDF: procedure(arg1b) public;
	declare arg1b byte;

	if not isSkipping or b6B2B = 22h then		/* ELSE */
	do;
		if b6749 then
			b6754 = TRUE;
		if xisSpace then
			errCnt = errCnt + 1;

		if sub$3C91 or arg1b = 'L' or arg1b = 'U' then
			if b6896 <> 'L' then
				b6896 = arg1b;
	end;
end;

parseDollarLines: procedure public;
	do while getCh = '$';
		if isSkipping then
		do;
			call skip2NextLine;
			b6B20 = 0FFh;
		end;
		else
		do;
			call parseCmds;
		end;
		call sub$54FD;
	end;
	reget = 1;
end;


sub$3D6D: procedure public;
	cmdch$p = options$p;
	scanOptions = TRUE;
	call parseCmds;
	if isPhase2Print then
	do;
		call printCmdLine;
	end;

	if b6C21 then
		call sub$4904;

	b6C21, b6B20, scanOptions = cZERO;
	call parseDollarLines;
	b6898 = 0;
	optDEBUG = optDEBUG and optOBJECT;
	optXREF = optXREF and optPRINT;
	optSYMBOLS = optSYMBOLS and optPRINT;
	optPAGING = optPAGING and optPRINT;
end;



sub$3DCE: procedure public;
	off6C2E = off6C2C + 1;
	b6C30 = 0;
	if b6C21 then
		call sub$4904;

	b68AD, has16bitOperand, b6B20, b689B, b687F, b6B25, b6B30, b6881, b6872, b6880,
	b6B23, b6B24, b6B32, b68AB, b6884, b6885 = cZERO;
	b689C, b6B31, b6B34, b6B35 = c255;
	optEJECT, b6857, tokenSP, tokenSize(0), tokenType(0), b6858, b6859, b6742, b6855 = cZERO;
	b6896 = 20h;
	b689A = 1;
	w6A4E = w6A4E + 1;
	skipping(0) = skipping(0) > 0;
end;

end;
asm55.plm
asm851: do;

declare TRUE literally '0FFh',
	FALSE literally '0';

declare pad1 address data(40h);
declare pad2 address;

declare tokenSize literally 'toksiz',
	tokStart literally 'tokst';
declare (skipping, tokenType, tokenSize, b6759, asciiLineNo)(1) byte external,
	(b6A56, b6B30, b68AD, b6B23, b6B24, tokenSP, b6BD9) byte external,
	(b6B20, b6BDB, b6B34, b6B2C, activeSeg, b6880, optXREF, phase, b6873) byte external,
	(b6B33, b6B2E, optSYMBOLS) byte external,
	(out$p, w6BCE, w68A6) address external,
	(tokStart, segSize)(1) address external;

exit: procedure external; end;
flushout: procedure external; end;
ovl3: procedure external; end;
ovl8: procedure external; end;
popToken: procedure external; end;
sub$3DCE: procedure external; end;
sub$467F: procedure(b, w) external; declare b byte, w address; end;
sub$5ED7: procedure external; end;
sub$7041: procedure external; end;			/* in overlay 1 */
sub2$6E32: procedure external; end;
sub$4646: procedure byte external; end;
haveTokens: procedure byte external; end;
xisSpace: procedure byte external; end;
isPhase2Print: procedure byte external; end;
sub$465B: procedure byte external; end;
sub4$3A6A: procedure byte external; end;



strUCequ: procedure(arg1w, arg2w) byte public;
	declare (arg1w, arg2w) address;
	declare ch1 based arg1w byte,
		ch2 based arg2w byte;

	do while ch1 <> 0;
		if ch1 <> ch2 and ch1 <> (ch2 and 5Fh) then
			return FALSE;
		arg1w = arg1w + 1;
		arg2w = arg2w + 1;
	end;
	return TRUE;
end;


isSkipping: procedure byte public;
	return skipping(0);
end;


sub$546F: procedure public;
	b6A56 = sub$4646;
	if b6B30 then
		call sub$5ED7;
	if haveTokens then
		if not(tokenType(b6A56) = 0Bh or b68AD) then
			call sub$5ED7;
	if b6B23 or b6B24 then
	do;
		if tokenSP = 1 and not xisSpace and tokenSize(0) <> 1 then
			tokenSize(0) = 2;
	end;
	else if not xisSpace and haveTokens then
		if tokenSize(b6A56) > 3 then
			tokenSize(b6A56) = 3;
end;



sub$54FD: procedure public;
	declare w6CD7 address, b6CD9 byte;
	declare ch based w6CD7 byte;

	call sub$546F;
	if isPhase2Print then
	do;
		w6CD7 = .asciiLineNo(3);
		b6CD9 = TRUE;

		do while b6CD9;
			if ch = '9' then
				ch = '0';
			else
			do;
				if ch = ' ' then
					ch = '1';
				else
					ch = ch + 1;
				b6CD9 = FALSE;
			end;
			w6CD7 = w6CD7 - 1;
		end;

		if sub$465B or not xisSpace then
		do;
			call ovl3;
		end;
	end;

	if b6BD9 then
	do;
		out$p = out$p + 1;
		call flushout;
		call exit;
	end;


	if not b6B20 then
	do;
		b6BDB = 2;
		if tokenSP < 2 or b6B23 or b6B24 then
			b6BDB = 0;

		w6BCE = tokStart(b6BDB) + tokenSize(b6BDB);
		if isSkipping or not b6B34 then
			w6BCE = .b6759;

		if sub4$3A6A then
		do;
			call ovl8;
		end;

		b6B2C = 0FFh;
		segSize(activeSeg), w68A6 = segSize(activeSeg) + (w6BCE - .b6759);
	end;

	if optXREF and b6880 then
		if phase = 1 then
			call sub$467F(1, .b6873);

	do while tokenSP > 0;
		call popToken;
	end;

	call sub$3DCE;
	if b6B33 then
	do;
		b6B2E = 0FFh;
		if isPhase2Print and optSYMBOLS then
		do;
			call sub$7041;			/* in overlay 1 */
		end;

		call sub$467F(2, .b6873);
		if sub4$3A6A then
		do;
			call sub2$6E32;
		end;
	end;
end;
end;
asm57.pl3
asm57: do;

declare lit literally 'literally',
	TRUE lit '0FFh',
	FALSE lit '0';

declare b4A26(*) byte data(0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh,
			   0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh,
			   0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh,
			   0FFh, 0FFh, 0FFh, 0FFh, 0, 0FFh, 0FFh, 0FFh),
	b4A68(*) byte data(0, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0,
			   0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh,
			   0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh);

declare pad byte;

declare tokenSize literally 'toksiz',
	tokStart literally 'tokst';
declare (b674A, b674C, tokenSize, tokenAttr, skipping, inElse, b6873, asc$3692, aModulePage)(1) byte external,
	(tokenType, opStack, b4181, accum1byt, accum2byt)(1) byte external,
	(b6855, opType, b6B2B, b6B2C, b6B2F, b6B35, b6B36) byte external,
	(activeSeg, b6B28, b6858, b68AB, b6B23, b6B24, b6B2D, b6B30, b6CE4) byte external,
	(tokenSP, b6745, b6755, ifDepth, b6B32, b6B33, b6881, b6748, b6749) byte external,
	(b6754, b6743, moduleNameLen, b6B29, b6885, b6B25, phase, b6B34, opSP, b6856, b6859) byte external,
	(b6857, b6BDB, b6B2E, optOBJECT, b6744) byte external,
	(accum1, accum2, startAddr, w6750, w685A, w685C, w68A6) address external,
	(segSize, tokenSymId, w6B41)(1) address external;

exit: procedure external; end;
flushout: procedure external; end;
sub2$6E32: procedure external; end;
ovl2: procedure external; end;
ovl3: procedure external; end;
writeRec02: procedure external; end;
ovl8: procedure external; end;
popToken: procedure external; end;
pushToken: procedure(b1) external; declare b1 byte; end;
sub$3CDF: procedure(b1) external; declare b1 byte; end;
sub$3DCE: procedure external; end;
sub$3F19: procedure external; end;
sub$4274: procedure external; end;
sub$4291: procedure external; end;
getPrec: procedure(b1) byte external; declare b1 byte; end;
sub$450F: procedure(b1) external; declare b1 byte; end;
sub$467F: procedure(b, w) external; declare b byte, w address; end;
sub$54FD: procedure external; end;
sub$5819: procedure(w, b) external; declare w address, b byte; end;
sub$5ED7: procedure external; end;
sub$5EE3: procedure external; end;
sub$5F01: procedure external; end;
sub$5F07: procedure external; end;
sub$5F13: procedure external; end;
sub$5F25: procedure external; end;
sub$5F37: procedure external; end;
nestIF: procedure(b) external; declare b byte; end;
unnestIF: procedure(b) external; declare b byte; end;
addByte2Tok: procedure(b) external; declare b byte; end;
sub$425B: procedure(b) byte external; declare b byte; end;
sub$43DD: procedure address external; end;
isPhase1: procedure byte external; end;
haveTokens: procedure byte external; end;






sub$4AAA: procedure(arg1b) public;
	declare arg1b byte;

	if b674A(arg1b) then
	do;
		if haveTokens then
		do;
			accum1 = sub$43DD;
			if b674C(arg1b) <> accum1byt(0) then
				call sub$5EE3;
		end;
		else if b674C(arg1b) <> 3 then
			call sub$5EE3;
	end;
	else
	do;
		b674A(arg1b) = TRUE;
		if haveTokens then
		do;
			accum1 = sub$43DD;
			if accum1 = 1 or accum1 = 2 then
				b674C(arg1b) = low(accum1);
			else
				call sub$5EE3;
		end;
	end;
end;


sub$4B3F: procedure(arg1b) public;
	declare arg1b byte;

	accum1 = arg1b;
	if accum1 then
		accum1 = 0FFFFh;
end;

sub$4B57: procedure(arg1b) public;
	declare arg1b byte;

	if (b6855 and 47h) <> 0 then
		b6855 = b6855 and 0E7h or arg1b;
end;

sub$4B72: procedure public;
	do case b6B2B;
/* 0 */		;
/* 1 */		call sub$54FD;
/* 2 */		goto case3;
/* 3 */ case3:	do;
			if not (b6B2B = 2 and opType = 3) then
				call sub$5F25;

			if tokenType(0) = 11 then
			do;
				tokenSize(0) = 1;
				tokenAttr(0) = 0;
				b6B36 = 0FFh;
			end;

			b6B35 = b6B2F;
			if opType = 3 then
				b6B2C = 0FFh;
		end;
/* 4 */		accum1 = accum1 * accum2;
/* 5 */		accum1 = accum1 + accum2;
/* 6 */		do;
			call sub$5ED7;
			call popToken;
		end;
/* 7 */		accum1 = accum1 - accum2;
/* 8 */		;
/* 9 */		do;
			if accum2 = 0 then
				call sub$5F01;

			accum1 = accum1 / accum2;
		end;
/* 10 */	accum1 = -accum1;
/* 11 */	call sub$4B3F(accum1 = accum2);
/* 12 */	call sub$4B3F(accum1 < accum2);
/* 13 */	call sub$4B3F(accum1 <= accum2);
/* 14 */	call sub$4B3F(accum1 > accum2);
/* 15 */	call sub$4B3F(accum1 >= accum2);
/* 16 */	call sub$4B3F(accum1 <> accum2);
/* 17 */	accum1 = not accum1;
/* 18 */	accum1 = accum1 and accum2;
/* 19 */	accum1 = accum1 or accum2;
/* 20 */	accum1 = accum1 xor accum2;
/* 21 */	do;
			if accum2 = 0 then
				call sub$5F01;
			accum1 = accum1 mod accum2;
		end;
/* 22 */	do;
			if accum2byt(0) <> 0 then
				accum1 = shl(accum1, accum2);
		end;
/* 23 */	do;
			if accum2byt(0) <> 0 then
				accum1 = shr(accum1, accum2);
		end;
/* 24 */	do;
			accum1 = high(accum1);
			call sub$4B57(10h);
		end;
/* 25 */	do;
			accum1 = low(accum1);
			call sub$4B57(8);
		end;
/* 26 */	do;
			if tokenType(0) <> 10 then
			do;
				accum1 = sub$43DD;
				if accum1byt(1) - 1 < 0FEh then
					call sub$5F01;
				b6B28 = 22h;
				if (b6855 and 18h) = 18h then
				do;
					call sub$5F01;
					b6855 = b6855 and 0E7h or 8;
				end;
			end;
			else
			do;
				b6855 = 0;
				tokenType(0) = 0Bh;
			end;

			if sub$425B(b6858) then
				call sub$5F37;
			b6B2D = 0Bh;
			b6B23 = 0FFh;
		end;
/* 27 */	do;
			b6B2D = 0Bh;
			b6B24 = 0FFh;
		end;
/* 28 */	do;
			segSize(activeSeg) = segSize(activeSeg) + accum1;
			b68AB = 0FFh;
		end;
/* 29 */ case29:
		do;
			b68AB = 0FFh;
			if (b6855 and 40h) = 40h then
			do;
				call sub$5EE3;
				b6855 = 0;
			end;
			b6CE4 = 1;
			call sub$5819(accum1, 22h - b6B2B);
			b6B30 = 0;
		end;
/* 30 */	goto case29;
/* 31 */	do;
			b68AB = 0FFh;
			if (b6855 and 40h) <> 40h then
			do;
				if (b6855 and 18h) <> 0 then
					if (b6855 and 7) <> activeSeg or (b6855 and 18h) <> 18h then
						call sub$5EE3;
			end;
			else
				call sub$5EE3;

			if optOBJECT then
				if segSize(activeSeg) > w6B41(activeSeg) then
					w6B41(activeSeg) = segSize(activeSeg);
			segSize(activeSeg) = accum1;
		end;
/* 32 */	do;
			if tokenSP > 0 then
			do;
				startAddr = sub$43DD;
				b6755 = 1;
				b6745 = b6855 and 7;
				if (b6855 and 40h) = 40h then
					call sub$5EE3;
				if sub$425B(b6858) then
					call sub$5F37;

				b68AB = 0FFh;
			end;

			if ifDepth > 0 then
				call sub$5F07;
			if opType <> 1 then
				call sub$5ED7;
			if b6B35 then
				b6B33 = 0FFh;
			else
				call sub$5ED7;

		end;
/* 33 */	do;
			if b6B35 then
			do;
				b6B32 = 0FFh;
				call nestIF(2);
				b6881 = 0FFh;
				if skipping(0) = 0 then
					skipping(0) = not ((low(accum1) and 1) = 1);
				inElse(0) = 0;
			end;
		end;
/* 34 */	do;
			b6B32 = 0FFh;
			if ifDepth = 0 then
				call sub$5F07;
			else if not inElse(0) then
			do;
				if not skipping(0) then
					skipping(0) = 0FFh;
				else
					skipping(0) = skipping(ifDepth);
				inElse(0) = 0FFh;
			end;
			else
				call sub$5F07;
		end;
/* 35 */	do;
			if b6B35 then
			do;
				b6B32 = 0FFh;
				call unnestIF(2);
			end;
		end;
/* 36 */	do;
			if b6744 = 1 then
				if b6873(0) = 4Dh then
					call sub$5ED7;
			call sub$450F(85h);
		end;
/* 37 */	do;
			if b6744 = 1 then
				if b6873(0) = 4Dh then
					call sub$5ED7;
			call sub$450F(5);
		end;
/* 38 */	call sub$450F(7);
/* 39 */	call sub$450F(2);
/* 40 */	call sub$450F(8);
/* 41 */	call sub$450F(46h);
/* 42 */	call sub$450F(6);
/* 43 */	call sub$450F(36h);
/* 44 */	call sub$450F(0);
/* 45 */	call sub$450F(0);
/* 46 */	call sub$450F(6);
/* 47 */	activeSeg = 0;
/* 48 */	do;
			activeSeg = 1;
			call sub$4AAA(0);
		end;
/* 49 */	do;
			activeSeg = 2;
			call sub$4AAA(1);
		end;

/* 50 */	do;
			b6748 = 0FFh;
			b6CE4 = 0;
			call sub$5819(0, 6);
		end;
/* 51 */	do;
			b6749 = 0FFh;
			if w6750 = 0 and isPhase1 and optOBJECT then
			do;
				call writeRec02;
			end;
			b6CE4 = 0;
			call sub$5819(w6750, 2);
			if isPhase1 and optOBJECT and not b6754 then
			do;
				call ovl2;
			end;
			if not b6754 then
				w6750 = w6750 + 1;
			b6754 = 0;
		end;
/* 52 */	do;
			if tokenSP <> 0 and b6743 then
			do;
				call move(6, .asc$3692, .aModulePage);
				call move(moduleNameLen := b6744, .b6873, .aModulePage);
			end;
			else
				call sub$3CDF('R');

			call popToken;
		end;
/* 53 */	segSize(3) = accum1;
	end;

	if b6B2B <> 1 then
		b6743 = 0;
end;


sub$518F: procedure public;

	sub$53C0: procedure byte;
		if b6B29 > 3 then
			if b6B29 <> 6 then
				if b6B29 < 1Ah then
					return TRUE;
		return FALSE;
	end;

	sub$53DF: procedure(arg1b) byte;
		declare arg1b byte;
		return arg1b = 9 or arg1b = 64h;
	end;


	sub$53F8: procedure;
		if not b4A68(b6B2B) then
			b6B34 = 0;
	end;



	do while 1;
		if not (b6B29 = 1 or b6B29 >= 20h and b6B29 <= 23h) and skipping(0) then
		do;
			b6885 = 0;
			call popToken;
			return;
		end;
		
		if phase <> 1 then
			if b6B25 then
				if sub$53C0 then
					if getPrec(b6B29) <= getPrec(opStack(opSP)) then
						call sub$5EE3;

		if getPrec(opType := b6B29) > getPrec(b6B2B := opStack(opSP)) or opType = 2 then
		do;
			if opSP >= 10h then
			do;
				opSP = 0;
				call sub$5F13;
			end;
			else
				opStack(opSP := opSP + 1) = opType;
			if opType = 2 then
			do;
				b6B2F = b6B35;
				b6B35 = 0FFh;
			end;
			if phase > 1 then
				b6B25 = sub$53C0;
			return;
		end;

		b6B25 = 0;
		if not b6B35 and b6B2B > 3 then
			call sub$5ED7;

		if b6B2B = 0 then
			b6B2B = opType;
		else
			opSP = opSP - 1;
		

		if (b6B28 := b4181(b6B2B)) then
		do;
			accum2 = sub$43DD;
			b6856 = b6855;
			w685C = w685A;
			b6859 = b6858;
		end;

		if (b6B28 := ror(b6B28, 1)) then
			accum1 = sub$43DD;

		if not b6857 then
			b6857 = sub$53DF(b6858) or sub$53DF(b6859);

		b6B2D = 0Ch;
		if b6B2B > 3 and b6B2B < 1Ah then
			call sub$4291;
		else
		do;
			call sub$53F8;
			call sub$4274;
		end;

		call sub$4B72;
		if not b4A26(b6B2B) then
			b6B35 = 0;

		if b6B2C then
		do;
			b6B2C = 0;
			return;
		end;

		if b6B2B <> 1Ch and b68AB then
			w68A6 = accum1;

		if (b6B28 and 1Eh) <> 0 then
			call pushToken(b6B2D);

		do b6BDB = 0 to 3;
			if (b6B28 := ror(b6B28, 1)) then
				call addByte2Tok(accum1byt(b6BDB));
		end;

		tokenAttr(0) = b6855;
		tokenSymId(0) = w685A;
		if ror(b6B28, 1) then
			if opType = 6 then
			do;
				b6B29 = b6B2B;
				b6B35 = 0FFh;
			end;
	end;
end;



sub$540D: procedure public;
	do while b6B2E = 0;
		call sub$3F19;
		call sub$518F;
	end;
end;

end;
asm5D.plm
asm5D: do;
declare lit literally 'literally',
	TRUE lit '0FFh',
	FALSE lit '0',
	CR lit '0Dh';


declare (cmdch$p, actRead) address external,
	(b6BDB, b6BDD) byte external,
	(lstFile, objFile, cmdLineBuf, signonMsg, b674A, b68AE)(1) byte external,
	(inElse, opStack, aF0Asxref, aF0Asxref$tmp, skipping, optionSeen)(1) byte external,
	(cZERO, c255, b6742, b6743, activeSeg, ifDepth) byte external,
	(opSP, b6857, curChar, lookAhead, b6882, b6898) byte external,
	(b68B8, b6A00, optLIST, optCOND, b6A6F, saveIdx, scanOptions) byte external,
	(opType, b6B2C, b6B2E, b6B33, b6C21, fileIdx) byte external,
	(w673F, w6750, w686E, w6870) address external,
	(lineCnt, w68A6, pageCnt, w6A4E) address external,
	(errCnt, options$p, includefd, rootfd, w75C4, statusIO, infd, off6C25) address external,
	(off6C2C, off6C2E, w6BD3, endOutBuf) address external,
	(w6868, w6B41, segSize, symTab)(1) address external,
	files(6) structure(name(15) byte, blk address, byt address, b19 byte) external,
	rec06 structure(type byte, len address, dta(125) byte) external,
	rec16 structure(type byte, len address, seg byte, dta(125) byte) external,
	rec24 structure(type byte, len address, dta(61) byte) external,
	rec20 structure(type byte, len address, dta(70) byte) external;

rescan: procedure(w1, w2) external; declare (w1, w2) address; end;
isPhase1: procedure byte external; end;
physmem: procedure address external; end;
ioErrChk: procedure external; end;
sub$3DCE: procedure external; end;
wrError: procedure(b) external; declare b byte; end;
closeF: procedure(w) external; declare w address; end;
read: procedure(w1, w2, w3, w4, w5) external; declare (w1, w2, w3, w4, w5) address; end;
seek: procedure(w1, w2, w3, w4, w5) external; declare (w1, w2, w3, w4, w5) address; end;
write: procedure(w1, w2, w3, w4) external; declare (w1, w2, w3, w4) address; end;
inOpen: procedure(w1, w2) address external; declare (w1, w2) address; end;


declare aExtents(*) byte public initial(' LSTOBJ'),
	aDebug(*) byte public initial('DEBUG');



/* overlay 3 appears to repair the code that starts here */

cmdSkipWhite: procedure public;
	declare cmdch based cmdch$p byte;
	
	do while (cmdch = ' ' or cmdch = 9) and cmdch$p <> actRead;
		cmdch$p = cmdch$p + 1;
	end;
end;

getDrive: procedure byte public;
	declare cmdch based cmdch$p byte;

	if cmdch = ':' then
	do;
		cmdch$p = cmdch$p + 2;
		return cmdch;
	end;
	else
		do b6BDB = 0 to 4;
		if cmdch <> aDebug(b6BDB) and aDebug(b6BDB) + 20h <> cmdch then
				return '0';
			cmdch$p = cmdch$p + 1;
		end;
	call cmdSkipWhite;
	if cmdch <> ':' then
		return '0';
	cmdch$p = cmdch$p + 2;
	return cmdch;
end;

addExtents: procedure public;
	do b6BDB = 1 to 3;
		lstFile(b6BDD + b6BDB) = aExtents(b6BDB);
		objFile(b6BDD + b6BDB) = aExtents(b6BDB+3);
	end;
end;

getAsmFile: procedure public;
	declare cmdch based cmdch$p byte;

	cmdIsWhite: procedure byte;
		declare cmdch based cmdch$p byte;
		return cmdch = ' ' or cmdch = 9 or cmdch = CR;
	end;

	symTab(0) = .w75C4;
	w686E, w6868(0), symTab(1), w6868(1) = .MEMORY;
	call rescan(1, .statusIO);
	call ioErrChk;
	call read(1, .cmdLineBuf, 128, .actRead, .statusIO);
	call ioErrChk;
	actRead = actRead + .cmdLineBuf;
	scanOptions = 0FFh;
	call cmdSkipWhite;
	aF0Asxref(2) = getDrive; 

	do while not cmdIsWhite;
		cmdch$p = cmdch$p + 1;
	end;

	call cmdSkipWhite;
	if cmdch = CR then
		call wrError(4);

	infd = inOpen(cmdch$p, 1);
	rootfd, includefd = infd;
	b6BDB = TRUE;
	b6BDD = 0;

	do while not cmdIsWhite;
		files(0).name(b6BDD) = cmdch;
		if b6BDB then
			lstFile(b6BDD), objFile(b6BDD) = cmdch;
		if cmdch = '.' then
		do;
			b6BDB = FALSE;
			call addExtents;
		end;
		b6BDD = b6BDD + 1;
		cmdch$p = cmdch$p + 1;
	end;
	options$p = cmdch$p;
	if b6BDB then
	do;
		lstFile(b6BDD) = '.';
		objFile(b6BDD) = '.';
		call addExtents;
	end;

	files(0).name(b6BDD) = ' ';
	if lstFile(0) = ':' and lstFile(2) <> '0' then
		aF0Asxref$tmp(2) = lstFile(2);
end;




resetData: procedure public;
	call sub$3DCE;
	b6B33, scanOptions, skipping(0), b6B2C, inElse(0), b6B2E, b674A(0), b674A(1), b6742, b6857, b6C21 = cZERO;
	b6743, b6898, optLIST, b6A6F, optCOND = c255;
	saveIdx, lookAhead, activeSeg, ifDepth, opSP, opStack(0) = cZERO;
	segSize(0), segSize(1), segSize(2), w6B41(0), w6B41(1), w6B41(2), w68A6, w6750, errCnt = w673F;
	b6882 = b6882 + 1;
	w6A4E, opType, pageCnt, lineCnt = 1;
	b68AE(0) = 0;
	curChar = 20h;
	do b6BDB = 0 to 11;
		optionSeen(b6BDB) = 0;
	end;
	if not isPhase1 then
	do;
		if fileIdx <> 0 then
		do;
			call closeF(includefd);
			call ioErrChk;
			includefd = rootfd;
		end;
		fileIdx = cZERO;
		off6C25 = .b68B8;
		off6C2C = off6C25 - 1;
		off6C2E = .b68B8;
		call seek(infd, 2, .w6BD3, .w6BD3, .statusIO);	/* SEEKABS */
		call ioErrChk;
	end;
	w6870 = physmem + 0BFh;
	endOutBuf = .b6A00;
end;


sub$70EE: procedure public;
	rec06.type = 6;
	rec06.len = 3;
	rec16.type = 22h;
	rec16.len = 1;
	rec24.type = 24h;
	rec24.len = 2;
	rec20.type = 20h;
	rec20.len = 1;
end;

end;
asm41.plm
asmov4:
do;

declare w$3780 address public data(0),
	b$3782 byte public data(80h),
	b$3783 byte public data(81h),
	b3680(*) byte public data('         '),
	b3689(*) byte public data('         '),
	b3692(*) byte public data(' '),
	b3693(*) byte public data(' '),
	b3694(*) byte public data('  '),
	b3696(*) byte public data('  ', 0),
	asc$3699(*) byte public data(0Dh, 0Ah, 0),
	signonMsg(*) byte data(0Dh, 0Ah),
	aIsisIi80808085(*) byte public data('ISIS-II 8080/8085 MACRO ASSEMBLER, V4.1', 9, 9),
	aModulePage(*) byte public data('MODULE ', 9, ' PAGE ', 0),
	cZERO byte public data(0),
	c255 byte public data(0FFh),
	copyright(*) byte data('(C) 1976,1977,1979,1980 INTEL CORP'),
	aStack(*) byte public data(0Dh, 0Ah, 'STACK', 0),
	aTable(*) byte public data(0Dh, 0Ah, 'TABLE', 0),
	aCommand(*) byte public data(0Dh, 0Ah, 'COMMAND', 0),
	aEof(*) byte public data(0Dh, 0Ah, 'EOF', 0),
	aFile(*) byte public data(0Dh, 0Ah, 'FILE', 0),
	aMemory(*) byte public data(0Dh, 0Ah, 'MEMORY', 0),
	aError(*) byte public data(' ERROR', 0Dh, 0Ah, 0),
	aError$0(*) byte public data(' ERROR, ', 0Dh,0Ah, 0),
	errStrs(*) address public data(.aStack, .aTable, .aCommand, .aEof, .aFile, .aMemory),
	errStrsLen(*) byte public data(7, 7, 9, 5, 6, 8),
	aBadSyntax(*) byte public data('BAD SYNTAX', 0Dh, 0Ah),
	aCo(*) byte public data(':CO:', 0);

declare (aF0Asmac$tmp, aF0Asxref$tmp, objFile, lstFile)(1) byte external,
	(optXREF, optPRINT, optOBJECT, phase) byte external,
	(outfd, statusIO, w6750, objfd, xreffd, macrofd) address external,
	rec18a structure(type byte, len address, dta(1) byte) external;


delete: procedure(w1, w2) external; declare (w1, w2) address; end;
flushout: procedure external; end;
sub$3DA4: procedure external; end;
sub$540D: procedure external; end;
sub$70EE: procedure external; end;
sub$8915: procedure external; end;
getAsmFile: procedure external; end;
resetDataX: procedure external; end;
asmComplete: procedure external; end;
ovl9: procedure external; end;
writeRec: procedure(arg1w) external; declare arg1w address; end;
writeRec02: procedure external; end;
writeRec040E: procedure external; end;
ovl11: procedure external; end;
inOpen: procedure(w1, w2) address external; declare (w1, w2) address; end;
strUCequ: procedure(w1, w2) byte external; declare (w1, w2) address; end;


mainov4:
	call getAsmFile;
	phase = 1;
	call resetDataX;
	call sub$3DA4;
	macrofd = inOpen(.aF0Asmac$tmp, 3);
	if optOBJECT then
	do;
		call delete(.objFile, .statusIO);
		objfd = inOpen(.objFile, 3);
	end;

	if optXREF then
	do;
		xreffd = inOpen(.aF0Asxref$tmp, 2);
		outfd = xreffd;
	end;

	call sub$540D;
	phase = 2;
	if optOBJECT then
	do;
		if rec18a.len > 0 then
			call writeRec(.rec18a);

		if w6750 = 0 then
			call writeRec02;

		call sub$70EE;
	end;

	if optPRINT then
		outfd = inOpen(.lstFile, 2);

	call resetDataX;
	call sub$3DA4;
	call sub$540D;
	if optPRINT then
	do;
		call asmComplete;
		call flushout;
	end;

	if optOBJECT then
	do;
		call ovl11;
		call writeRec040E;
	end;

	if not strUCequ(.aCo, .lstFile) then
		call ovl9;

	call sub$8915;
end;
asm42.plm
asm42:
do;

declare TRUE literally '0FFh';

declare tokenSize literally 'toksiz',
	tokStart literally 'tokst';
declare (aBadSyntax, aError, asc$3699, aError$0, tokenSize)(1) byte external,
	(cZERO, c255, b6749, b6754, tokenSP, tokenType) byte external,
	(b6855, b6857, b6858, b6859, curChar, reget, b6872) byte external,
	(b687F, b6880, b6881, b6884, b6885, b6896, b6897) byte external,
	(b6898, b689A, b689B, b689C, b68AB, b68AD, optDEBUG) byte external,
	(optXREF, optSYMBOLS, optPAGING, optPRINT, optOBJECT, optEJECT, collectBufIdx) byte external,
	(scanOptions, b6B23, b6B24, b6B25, has16bitOperand, phase, b6B2B) byte external,
	(b6B30, b6B31, b6B32, b6B33, b6B34, b6B35, b6BD9) byte external,
	(b6C27, b6C21, b6C30) byte external,
	(b6742, skipping, b$9A77) byte external,
	(cmdch$p, endOutBuf, openStatus, outbuf, outfd, out$p) address external,
	(w6870, w6A4E, errCnt, options$p, curFileName$p, w6BE0, statusIO) address external,
	(errStrs)(1) address external,
	(errStrsLen)(1) byte external,
	(off$6C2C, off$6C2E) address external;

isSkipping: procedure byte external; end;
getChX: procedure byte external; end;


close: procedure(w1, w2) external; declare (w1, w2) address; end;
error: procedure(w1) external; declare w1 address; end;
exit: procedure external; end;
open: procedure(w1, w2, w3, w4, w5) external; declare (w1, w2, w3, w4, w5) address; end;
skip2NextLine: procedure external; end;
sub$4904: procedure external; end;
sub$4C1E: procedure external; end;
sub$70D7: procedure external; end;
printDecimal: procedure(w1) external; declare w1 address; end;
printCmdLine: procedure external; end;
write: procedure(w1, w2, w3, w4) external; declare (w1, w2, w3, w4) address; end;


/* global data */
declare b$8FD5(127) byte external,
	w$9054 address external,
	off$9056 address external,
	b$9058 byte external,
	b$9059 byte external,
	b$905A byte external,
	b$905B byte external,
	b$905C byte external,
	b$905D byte external,
	b$905E byte external,
	b$9060 byte external,
	b$9061 byte external,
	b$9062 byte external,
	b$9063 byte external,
	b$9064 byte external,
	b$9065 byte external,
	b$9066 byte external,
	b$9067 byte external,
	w$9068 address external,
	w$906A address external,
	s906C structure(macroCondSP byte, ifDepth byte, mtype byte, b3 byte,
			     w4 address, buf$p address, blk address, w10 address,
			     w12 address, w14 address) external,
	curMacroBlk address external,
	nxtMacroBlk address external,
	maxMacroBlk address external,
	w$9114 address external,
	macroBuf(129) byte external,
	w$9197 address external,
	w$9199 address external,
	w$919B address external,
	w$919D address external,
	w$919F address external,
	b$91A1 byte external,
	b$91A2 byte external,
	b$91A3 byte external,
	b$91A4(1) byte external;

	
		
	


physmem: procedure address public;
	declare top address at(4);

	return (top - 100h) and 0FF00h;
end;


nxtCmdCh: procedure byte public;
	declare cmdch based cmdch$p byte;
	declare ch byte;

	ch = cmdch;
	cmdch$p = cmdch$p + 1;
	if 'a' <= ch and ch <= 'z' then
		ch = ch and 5Fh;
	return ch;
end;	


ioErrChk: procedure public;
	if statusIO = 0 then
		return;
	call error(statusIO);
	call exit;
end;


flushout: procedure public;
	call write(outfd, .outbuf, out$p - .outbuf, .statusIO);
	out$p = .outbuf;
end;

outch: procedure(arg1b) public;
	declare arg1b byte;
	declare ch based out$p byte;

	if out$p = endOutBuf then
		call flushout;
	ch = arg1b;
	out$p = out$p + 1;
end;

outStrN: procedure(arg1w, arg2b) public;
	declare arg1w address, arg2b byte;
	declare ch based arg1w byte;

	do while arg2b > 0;
		call outch(ch);
		arg1w = arg1w + 1;
		arg2b = arg2b - 1;
	end;
end;

closeF: procedure(arg1w) public;
	declare arg1w address;

	call close(arg1w, .statusIO);
end;

isSpace: procedure byte public;
	return curChar = 20h;
end;

isTab: procedure byte public;
	return curChar = 9;
end;

isWhite: procedure byte public;
	return isSpace or isTab;
end;

isRParen: procedure byte public;
	return curChar = 29h;
end;

isCR: procedure byte public;
	return curChar = 0Dh;
end;

isComma: procedure byte public;
	return curChar = 2Ch;
end;

isLT: procedure byte public;
	return curChar = '<';
end;


isGT: procedure byte public;
	return curChar = '>';
end;

isPhase1: procedure byte public;
	return phase = 1;
end;

skip2EOL: procedure public;
	if not isCR then
		do while getChX <> 0Dh;
		end;
end;


sub$3A6A: procedure byte public;
	return (phase = 2) and optOBJECT;
end;

isPhase2Print: procedure byte public;
	return phase = 2 and optPRINT;
end;

wrConsole: procedure(arg1w, arg2w) public;
	declare (arg1w, arg2w) address;

	call write(0, arg1w, arg2w, .statusIO);
	call ioErrChk;
end;


wrError: procedure(arg1b) public;
	declare arg1b byte;

	if b6BD9 then
		return;

	if isPhase1 and arg1b = 0 then
	do;
		b6B33 = TRUE;
		return;
	end;

	w6BE0 = .aError;
	if arg1b = 4 then
		w6BE0 = .aError$0;

	call wrConsole(errStrs(arg1b), errStrsLen(arg1b));
	call wrConsole(w6BE0, 8);
	if isPhase2Print then
	do;
		call outStrN(errStrs(arg1b), errStrsLen(arg1b));
		call outStrN(w6BE0, 8);
	end;

	if arg1b = 4 or arg1b = 3 then
	do;
		if collectBufIdx = 0 then
		do;
			call wrConsole(.aBadSyntax, 12);
			if not scanOptions then
			do;
				call skip2NextLine;
				outfd = 0;
				call printDecimal(w6A4E);
				call outch(0Ah);
			end;
		end;
		else
		do;
			call wrConsole(curFileName$p, collectBufIdx);
			call wrConsole(.asc$3699, 2);
		end;
	end;

	if arg1b = 0 then
	do;
		b6BD9 = TRUE;
		return;
	end;

	call exit;
end;

fileError: procedure(arg1w) public;
	declare arg1w address;
	declare ch based arg1w byte;

	collectBufIdx = 0;
	curFileName$p = arg1w;

	do while ch <> ' ' and ch <> 0dh and ch <> 9;
		collectBufIdx = collectBufIdx + 1;
		arg1w = arg1w + 1;
	end;
	if b6C27 then
		call wrError(3);
	call wrError(4);
end;

inOpen: procedure(arg1w, arg2w) address public;
	declare (arg1w, arg2w) address;
	declare open$infd address;

	call open(.open$infd, arg1w, arg2w, 0, .openStatus);
	if openStatus <> 0 then
		call fileError(arg1w);
	return open$infd;
end;


nibble2Ascii: procedure(n) byte public;
	declare n byte;
	n = (n and 0Fh) + '0';
	if n > '9' then
		n = n + 7;
	return n;
end;

put2Hex: procedure(arg1w, arg2b) public;
	declare arg1w address, arg2b byte;

	call arg1w(nibble2Ascii(ror(arg2b, 4)));
	call arg1w(nibble2Ascii(arg2b));
end;

xisSpace: procedure byte public;
	return b6896 = 20h;
end;

sub$3C91: procedure byte public;
	return xisSpace or b6896 = 'M' or b6896 = 'P';
end;


getNibble: procedure(arg1w, arg2b) byte public;
	declare arg1w address, arg2b byte;
	declare ch based arg1w byte;
	declare b6C11 byte;

	arg1w = arg1w + shr(arg2b, 1);
	b6C11 = ch;
	if not arg2b then
		b6C11 = ror(b6C11, 4);
	return b6C11 and 0Fh;
end;

sub$3CDF: procedure(arg1b) public;
	declare arg1b byte;

	if not isSkipping or b6B2B = 22h then
	do;
		if b6749 then
			b6754 = TRUE;
		if xisSpace then
			errCnt = errCnt + 1;

		if sub$3C91 or arg1b = 'L' or arg1b = 'U' then
			if b6896 <> 'L' then
				b6896 = arg1b;
	end;
end;

sub$3D34: procedure(arg1b) public;
	declare arg1b byte;
	declare ch based w$906A byte;

	ch = arg1b;
	if (w$906A := w$906A + 1) > w6870 then
		call wrError(1);
end;


sub$3D55: procedure(arg1b) public;
	declare arg1b byte;

	call sub$3D34(arg1b);
	if arg1b = 0Dh then
		call sub$3D34(0Ah);
end;



sub$3D6E: procedure public;

	do while getChX = '$';
		if isSkipping then
		do;
			call skip2NextLine;
			b$9A77 = 0FFh;
			if b$905E = 1 then
				b6897 = 0FFh;
		end;
		else
			call sub$70D7;
		call sub$4C1E;
	end;
	reget = 1;
end;


sub$3DA4: procedure public;
	cmdch$p = options$p;
	scanOptions = 0FFh;
	call sub$70D7;
	if isPhase2Print then
		call printCmdLine;

	if b6C21 then
		call sub$4904;

	b6C21, b$9A77, scanOptions = cZERO;
	call sub$3D6E;
	b6898 = 0;
	optDEBUG = optDEBUG and optOBJECT;
	optXREF = optXREF and optPRINT;
	optSYMBOLS = optSYMBOLS and optPRINT;
	optPAGING = optPAGING and optPRINT;
end;


sub$3DFB: procedure public;
	off$6C2E = off$6C2C + 1;
	b6C30 = 0;
	if b6C21 then
		call sub$4904;

	b68AD, has16bitOperand, b$9A77, b689B, b687F, b6B25, b6B30, b6881, b6872, b6880,
	b6B23, b6B24, b6B32, b68AB, b6884, b$9059, b$9060, b6885 = cZERO;
	b689C, b6B31, b6B34, b6B35 = c255;
	optEJECT, b6857, tokenSP, b$9058, b$9067, tokenSize(0), tokenType, b6858, b6859, b6742, b6855 = cZERO;
	b6896 = 20h;
	off$9056 = .b$8FD5;
	w$919D = w$906A;
	b$905B = b$905B > 0;
	b689A = 1;
	w6A4E = w6A4E + 1;
	off$9056 = .b$8FD5;
	skipping = skipping > 0;
end;

end;

/* pckToken code follows */

asm43.pl3
asm43:
do;
declare packToken literally 'pckTkn';

declare b3E5E(*) byte data(0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			   0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0),
	b3EA0(*) byte data(36h, 0, 0, 0, 6, 0, 0, 2),
	b3EA8(*) byte data(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0, 0, 0FFh,
			   0, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0,
			   0FFh, 0, 0, 0),
	b$3F88(*) byte data(41h, 90h, 0, 0, 0, 0, 0, 0, 0, 40h);


ioErrChk: procedure external; end;
packToken: procedure external; end;
read: procedure(w1, w2, w3, w4, w5) external; declare (w1, w2, w3, w4, w5) address; end;
seek: procedure(w1, w2, w3, w4, w5) external; declare (w1, w2, w3, w4, w5) address; end;
skip2EOL: procedure external; end;
sub$3D34: procedure(b1) external; declare b1 byte; end;
sub$3D55: procedure(b1) external; declare b1 byte; end;
sub$3D6E: procedure external; end;
sub$43D2: procedure external; end;
sub$467F: procedure(b1, w2) external; declare b1 byte, w2 address; end;
sub$5CE8: procedure(w1, b2) external; declare w1 address, b2 byte; end;
sub$5ED7: procedure external; end;
sub$5EE3: procedure external; end;
sub$5F1F: procedure external; end;
popToken: procedure external; end;
collectIdent: procedure(b1) external; declare b1 byte; end;
collectString: procedure external; end;
sub$65D9: procedure external; end;
pushToken: procedure(b1) external; declare b1 byte; end;
collectByte: procedure(b1) external; declare b1 byte; end;
ascii2Num: procedure external; end;
sub$73AD: procedure external; end;
write: procedure(w1, w2, w3, w4) external; declare (w1, w2, w3, w4) address; end;
testBit: procedure(b1, w2) byte external; declare b1 byte, w2 address; end;
sub$43DD: procedure address external; end;
getChX: procedure byte external; end;
lookup: procedure(b1) byte external; declare b1 byte; end;
sub$65BE: procedure byte external; end;
isTab: procedure byte external; end;
isWhite: procedure byte external; end;

declare tokenSize literally 'toksiz',
	tokStart literally 'tokst';
declare (b3692, tokenSize, tokenAttr, mem, macroBuf)(1) byte external,
	(c255, b6742, b6744, activeSeg, tokenType, curChar, b6872, b6873, b6879, b687F) byte external,
	(b6880, b6885, b6897, b689C, optMACRODEBUG, optXREF, b6B25, phase) byte external,
	(b6B29, opType, b6B30, b6B31, b6BDA, b6BDD) byte external,
	(b$9058, b$9059, b$905B, b$905E, skipping, b$9C3A) byte external,
	(curTokenSym$p, statusIO, w$3780, w686E) address external,
	(w6868, curTokStart, segSize)(1) address external,
	(macrofd, w6BE0, w$906A, curMacroBlk, nxtMacroBlk) address external,
	(maxMacroBlk, w$9114, w$919F) address external,
	s906C structure(macroCondSP byte, ifDepth byte, mtype byte, b3 byte,
			     w4 address, buf$p address, blk address, w10 address,
			     w12 address, w14 address) external;




skipWhite$2: procedure public;
	do while getChX = ' ' or isTab;
	end;
end;


sub$3FA9: procedure byte public;
	declare w$9B5A address,
		wrd based w$9B5A address;

	w$9B5A = curTokenSym$p - 6;
	return (wrd < 4679h) or optMACRODEBUG or (4682h < wrd);
end;



seekM: procedure(arg1w);
	declare arg1w address;

	if (w6BE0 := arg1w - nxtMacroBlk) <> 0 then
	do;
		b6BDD = 3;			/* SEEKFWD */
		if arg1w < nxtMacroBlk then
		do;
			w6BE0 = - w6BE0;
			b6BDD = 1;		/* SEEKBACK */
		end;

		call seek(macrofd, b6BDD, .w6BE0, .w$3780, .statusIO);
		call ioErrChk;
	end;
	nxtMacroBlk = arg1w + 1;
end;



readM: procedure(arg1w) public;
	declare arg1w address;
	declare w$9B60 address;

	if arg1w >= maxMacroBlk then
		w$9B60 = 0;
	else if arg1w = curMacroBlk then
		return;
	else
	do;
		call seekM(arg1w);
		call read(macrofd, .macroBuf, 128, .w$9B60, .statusIO);
		call ioErrChk;
	end;

	s906C.blk, curMacroBlk = arg1w;
	macroBuf(w$9B60) = 0FEh;	/* flag end of macro buffer */
end;


writeM: procedure public;
	if phase = 1 then
	do;
		call seekM(maxMacroBlk);
		maxMacroBlk = maxMacroBlk + 1;
		call write(macrofd, w686E, 128, .statusIO);
		call ioErrChk;
	end;
	w$9114 = w$9114 + 1;
end;



sub$40B9: procedure public;
	declare w$9B62 address;

	if b$905E then
	do;
		do while (w$9B62 := w$906A - w686E) >= 128;
			call writeM;
			w686E = w686E + 128;
		end;
		if w$9B62 <> 0 then
			call move(w$9B62, w686E, w6868(2));
		w$906A = (w686E := w6868(2)) + w$9B62;
	end;
end;

skipWhite: procedure public;
	do while isWhite;
		curChar = getChX;
	end;
end;

skip2NextLine: procedure public;
	call skip2EOL;
	call sub$65D9;
end;



sub$3F19: procedure public;

	sub$416B: procedure;
		if opType = 0 then
			call sub$5EE3;
		b6B25 = 0;
		opType = 0;
	end;


    do while 1;
	if b689C then
	do;
		call sub$3D6E;
		b689C = 0;
	end;

	do case sub$65BE;
/* 0 */ case0:	call sub$5F1F;
/* 1 */		;
/* 2 */		do;
			if not b$9058 then
			do;
				b6742 = 0FFh;
				if sub$65BE = 2 and b$905E then
				do;
					b$9059 = 0FFh;
					w$906A = w$906A - 2;
				end;
				call skip2NextLine;
				b6B29 = 1;
				return;
			end;
		end;
/* 3 */		do;
			if not b6872 then
			do;
				if skipping or b$905E then
					call popToken;
				else
				do;
					b$9C3A = 2;
					call sub$5CE8(segSize(activeSeg), 2);
				end;

				b6B30 = 0;
				b6872, b6B31 = c255;
			end;
			else
			do;
				call sub$5ED7;
				call popToken;
			end;

			call sub$467F(0, .b6873);
			b6880 = 0;
			opType = 3;
		end;
/* 4 */		do;
			call sub$65D9;
			b6B29 = 1;
			b$9058 = 0;
			return;
		end;
/* 5 */		do;
			if curChar = 2Bh or curChar = 2Dh then
				if not testBit(opType, .b$3F88) then
					curChar = curChar + 3;
			b6B29 = curChar - 28h + 2;
			return;
		end;
/* 6 */		do;
			call pushToken(0Ch);
			call collectByte(low(segSize(activeSeg)));
			call collectByte(high(segSize(activeSeg)));
			if activeSeg <> 0 then
				tokenAttr(0) = tokenAttr(0) or activeSeg or 18h;
			call sub$416B;
		end;
/* 7 */		do;
			if b6B29 = 37h then
			do;
				call sub$5F1F;
				return;
			end;
			if b$905E then
				b$9058 = not b$9058;
			else
			do;
				call collectString;
				if b6B31 then
					call sub$43D2;
				call sub$416B;
			end;
		end;
/* 8 */		do;
			call ascii2Num;
			if b6B31 then
				call sub$43D2;
			call sub$416B;
		end;
/* 9 */		do;
			w$919F = w$906A - 1;
			call collectIdent(9);
			if tokenSize(0) > 6 then
				tokenSize(0) = 6;

			if optXREF then
			do;
				call move(6, .b6873, .b6879);
				call move(6, .b3692, .b6873);
			end;

			call move(tokenSize(0), curTokStart(0), .b6873);
			b6744 = tokenSize(0);
			call packToken;
			if b6880 then
			do;
				b687F = 0FFh;
				b6880 = 0;
			end;

			if lookup(2) <> 9 and b$905E then
			do;
				if not b$9058 or (b6BDD := tokenType = 0) and (curChar = 26h or mem(w$919F-1) = 26h) then
				do;
					w$906A = w$919F;
					call sub$3D55(b6BDD + 81h);
					call sub$3D34(sub$43DD);
					call sub$3D55(curChar);
					b6B29 = 9;
				end;
			end;
			else if b6B29 <> 37h and not b$905E = 2 then
			do;
				if lookup(0) = 9 then
				do;
					tokenType = lookup(1);
					b6880 = 0FFh;
				end;

				b6B29 = tokenType;
				b6885 = b3EA8(tokenType);
				if not b3E5E(tokenType) then
					call popToken;

				if b687F then
				do;
					call sub$467F((not testBit(b6B29, .b3EA0)) and 1, .b6879);
					b687F = 0;
				end;
			end;

			if b$905E = 1 then
			do;
				if b6B29 = 3Fh then
				do;
					b$905E = 2;
					if b6897 then
						call sub$5ED7;
					b6897 = 0;
				end;
				else
				do;
					b6897 = 0;
					b$905E = 0FFh;
				end;
			end;

			if b6B29 = 41h then
				call pushToken(40h);
			if b6B29 < 0Ah or b6B29 = 9 or 80h then
			do;
				call sub$416B;
				if b6B31 then
					call sub$43D2;
			end;
			else
			do;
				b6B31 = 0;
				return;
			end;
		end;
/* 10 */	do;
			b6BDA = 0;
			call sub$73AD;
			if b6BDA then
				return;
		end;
/* 11 */	do;
			if b$905B then
			do;
				skipping = 0;
				b6B29 = 40h;
				return;
			end;
			else
				goto case0;
		end;
	end;
    end;
end;

end;
asm44.plm
asm44:
do;

declare b4181(*) byte public data(0, 80h, 0, 0, 0Fh, 0Fh, 80h, 0Fh, 0Dh, 0Fh,
			   0Dh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Dh, 0Fh, 0Fh,
			   0Fh, 0Fh, 0Fh, 0Fh, 0Dh, 0Dh, 40h, 4Dh, 1, 1,
			   1, 1, 80h, 1, 0, 0, 47h, 7, 7, 7,
			   17h, 47h, 7, 47h, 37h, 5, 7, 0, 0, 0,
			   40h, 40h, 0, 1, 80h, 40h, 80h, 0, 40h, 80h, 80h,
			   40h, 81h, 0C0h, 80h, 0Dh),

	b41B7(*) byte data(41h, 0, 0, 0, 19h, 40h, 0, 1Ch, 0, 0),
	b41C1(*) byte data(1Ah, 5, 80h, 0, 0C0h),
	b41C6(*) byte data(57h, 71h, 0F4h, 57h, 76h, 66h, 66h, 67h, 77h, 77h, 77h, 55h),
	b41D2(*) byte data(57h, 6, 2, 20h, 0, 0, 0, 0, 0, 0, 0, 22h),
	b41DE(*) byte data(3Ah, 0FFh, 80h, 0, 0, 0Fh, 0FEh, 0, 20h),
	b41E7(*) byte data(0, 0, 0, 0, 8, 7, 1, 7, 7, 8, 7, 6, 6, 6, 6, 6, 6,
			   5, 4, 3, 3, 8, 8, 8, 9, 9, 1, 1, 1, 1, 1, 1, 1, 1,
			   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			   1, 1, 1, /* extra */ 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0Ah);


flushout: procedure external; end;
outch: procedure(b) external; declare b byte; end;
outStrN: procedure(w1, w2) external; declare (w1, w2) address; end;
closeF: procedure(w) external; declare w address; end;
sub$3CDF: procedure(b) external; declare b byte; end;
sub$5EE3: procedure external; end;
sub$5F01: procedure external; end;
sub$5F37: procedure external; end;
popToken: procedure external; end;
pushToken: procedure(b) external; declare b byte; end;
nibble2Ascii: procedure(b) byte external; declare b byte; end; 
isPhase1: procedure byte external; end;
isSkipping: procedure byte external; end;

declare tokenSize literally 'toksiz',
	tokStart literally 'tokst';
declare (tokenSP, b6855, b6856, b6858) byte external,
	(tokenType, tokenSize, tokenAttr, accum1byt, accum2byt, lstFile, bp6A4E, bp6BE0)(1) byte external,
	(b6859, b6881, b689A, optXREF, optPAGING, optPAGEWIDTH) byte external,
	(optPAGELENGTH, optLIST, optGEN, optCOND, b6A6F, has16bitOperand, b6B2B, b6B2D) byte external,
	(b6B30, b6B31, b6B32, b6B36, b6BDB, b6BDC, b6BDD, b$905B) byte external,
	(skipping, b$9A77) byte external,
	(curTokenSym$p, curTokStart, accum1, w685A, w685C, xreffd) address external,
	(tokenSymId)(1) address external;



testBit: procedure(arg1b, arg2w) byte public;
	declare arg1b byte, arg2w address;
	declare ch based arg2w byte;

	if ch < arg1b then
		return 0;
	
	arg2w = arg2w + shr(arg1b, 3) + 1;
	return (ch and ROR(1, (arg1b and 7) + 1)) <> 0;
end;

sub$425B: procedure(arg1b) byte public;
	declare arg1b byte;

	return arg1b = 7 or arg1b = 8;
end;

sub$4274: procedure public;
	if testBit(b6B2B, .b41B7) then
		if sub$425B(b6858) then
			call sub$5F37;
end;

sub$4291: procedure public;
	if sub$425B(b6858) then
		call sub$5F37;
	if (b4181(b6B2B) and 2) = 0 then
		b6856 = 0;
	else if sub$425B(b6859) then
		call sub$5F37;

	b6858 = 0Ch;
	bp6BE0(0) = (b6855 and 18h) <> 0;
	bp6BE0(1) = (b6856 and 18h) <> 0;
	if (b6855 and 7) <> 0 then
		if (b6856 and 7) <> 0 then
			if ((b6855 xor b6856) and 1Fh) <> 0 then
				call sub$5EE3;
	if (b6BDB := (b6855 and 40h) <> 0) or (b6BDC := (b6856 and 40h) <> 0) then
	do;
		if b6B2B = 5 then
			if not (b6BDB or bp6BE0(0)) then
			do;
				w685A = w685C;
				b6855 = b6856;
				return;
			end;
		if b6BDC or bp6BE0(1) or not testBit(b6B2B, .b41C1) then
			goto L4394;
		else
			return;
	end;
	b6BDD = shl(b6B2B - 4, 2) or (bp6BE0(0) and 2) or (bp6BE0(1) and 1);
	if testBit(b6BDD, .b41C6) then
L4394:	do;
		call sub$5EE3;
		b6855 = 0;
		return;
	end;
	if testBit(b6BDD, .b41D2) then
	do;
		if not bp6BE0(0) then
			b6855 = b6856;
		return;
	end;
	b6855 = 0;
end;


swapAccBytes: procedure public;
	declare b6C17 byte;
	b6C17 = accum1byt(0);
	accum1byt(0) = accum1byt(1);
	accum1byt(1) = b6C17;
end;



sub$43D2: procedure public;
	b6B30 = 0FFh;
	b6B31 = 0;
end;



sub$43DD: procedure address public;
	declare ch based curTokStart byte,
		s based curTokStart(1) byte,
		w$9B69 address,
		wrd based w$9B69 address;

	sub$4884: procedure(arg1b);
		declare arg1b byte;

		if tokenType(tokenSP) <> 40h then
		do;
			call sub$3CDF(arg1b);
			return;
		end;
		if tokenSize(0) = 0 then
			tokenType(tokenSP) = 41h;
	end;



	b6855 = 0;
	accum1 = 0;
	b6858 = 9;
	if tokenType(0) = 40h then
		call pushToken(0Dh);

	if tokenSP = 0 or tokenType(0) = 0Bh and not b6B36 then
		call sub$4884(51h);
	else
	do;
		if tokenType(0) = 9 or tokenType(0) = 6 then
			call sub$4884(55h);
		else
		do;
			b6858 = tokenType(0);
			if testBit(b6858, .b41DE) then
			do;
				curTokStart = curTokenSym$p + 7;
				b6855 = ch and 0DFh;
				curTokStart, w$9B69 = curTokenSym$p + 4;
				w685A = wrd;
				tokenSize(0) = 2;

			end;
			else if tokenSize(0) = 0 then
				call sub$4884(56h);
			else
			do;
				if tokenSize(0) > 2 then
					call sub$4884(56h);

				b6855 = (tokenAttr(0) and 0DFh);
				w685A = tokenSymId(0);
			end;

			if tokenSize(0) > 0 then
				accum1byt(0) = ch;
			if tokenSize(0) > 1 then
				accum1byt(1) = s(1) and tokenType(0) <> 7;
		end;	

		if has16bitOperand then
			if tokenSize(0) = 2 then
				if tokenType(0) = 0Ah then
					call swapAccBytes;

		if (b6855 and 40h) <> 0 then
			if tokenType(0) < 9 then
				accum1 = 0;

		call popToken;
	end;

	b6B36 = 0;
	return accum1;
end;





getPrec: procedure(arg1b) byte public;
	declare arg1b byte;
	return b41E7(arg1b);
end;

sub$450F: procedure(arg1b) public;
	declare arg1b byte;

	if (arg1b and 3) <> 0 then
	do;
		if accum2byt(1) <> 0
		   or accum2byt(0) > 7
		   or arg1b and accum2byt(0)
		   or (arg1b and 3) = 3 and accum2byt(0) > 2
		   or (not sub$425B(b6859) and b6B2B <> 2Eh) then
			call sub$5F37;
		else if sub$425B(b6859) and b6B2B = 2Eh then
			call sub$5F37;
		if ror(arg1b, 2) then
			accum2byt(0) = rol(accum2byt(0), 3);
		accum1byt(0) = accum1byt(0) or accum2byt(0);
	end;
	else if b6B2B <> 2Dh then
		if sub$425B(b6859) then
			call sub$5F37;

	if shr(arg1b, 3) then
	do;
		if (b6856 and 18h) = 18h then
		do;
			call sub$5F01;
			b6856 = b6856 and 0E7h or 8;
		end;
		if accum2byt(1) + 1 > 1 then
			call sub$5F01;
	end;
	if b6B2B = 28h or b6B2B = 2Ch then
	do;
		b6855 = b6856;
		w685A = w685C;
	end;
	else
		b6855 = 0;

	if b6B2B <> 2Dh then
		if accum1byt(0) = 76h then
			call sub$5F37;
	if (b6B2B := shr(arg1b, 4) + 24h) = 24h then
		b6B2D = 0Bh;
end;

sub$4646: procedure byte public;
	if b689A >= tokenSP then
		return 0;
	return (b689A := b689A + 1);
end;



sub$465B: procedure byte public;
	return ((not b$9A77) and optLIST or b6A6F and b$9A77)
	        and (not (b$905B > 1) or optGEN)
		and (not(b6B32 or skipping) or optCOND);
end;

sub$467F: procedure(arg1b, arg2w) public;
	declare arg1b byte, arg2w address;
	declare (b6C1F, b6C20) byte;

	if not isPhase1 or not optXREF or isSkipping and not b6881 then
		return;

	call outch(arg1b + '0');
	if arg1b <> 2 then
	do;
		call outStrN(arg2w, 6);
		b6881 = 0;
		b6C20 = bp6A4E(1);
		b6C1F = 0;
		do while b6C1F < 4;
			b6C1F = b6C1F + 1;
			if b6C1F then
			do;
				if b6C1F = 3 then
					b6C20 = bp6A4E(0);
				call outch(nibble2Ascii(shr(b6C20, 4)));
			end;
			else
				call outch(nibble2Ascii(b6C20));
		end;
	end;
	else
	do;
		call outStrN(.lstFile, 15);
		if optPAGING then
			call outch('1');
		else
			call outch('0');

		call outch(nibble2Ascii(ror(optPAGELENGTH, 4)));
		call outch(nibble2Ascii(optPAGELENGTH));
		call outch(nibble2Ascii(ror(optPAGEWIDTH, 4)));
		call outch(nibble2Ascii(optPAGEWIDTH));
		call outch('3');
		call flushout;
		call closeF(xreffd);
	end;
end;

end;
asm45.plm
asm45:
do;

declare pad4B3C address data(40h),
	pad9B73 address public;

declare	TRUE literally '0FFh',
	FALSE literally '0';

exit: procedure external; end;
flushout: procedure external; end;
sub$3DFB: procedure external; end;
sub$40B9: procedure external; end;
sub$467F: procedure(b, w) external; declare b byte, w address; end;
sub$5ED7: procedure external; end;
popToken: procedure external; end;
sub$8447: procedure external; end;
sub$872E: procedure external; end;
sub$6E32: procedure external; end;
ovl8: procedure external; end;
haveTokens: procedure byte external; end;
xisSpace: procedure byte external; end;
sub$3A6A: procedure byte external; end;
isPhase2Print: procedure byte external; end;
sub$4646: procedure byte external; end;
sub$465B: procedure byte external; end;

declare tokenSize literally 'toksiz',
	tokStart literally 'tokst';

declare (activeSeg, tokenSP, b6880, b68AD) byte external,
	(b6A56, optXREF, optSYMBOLS, b6B23, b6B24, phase, b6B2C, b6B2E, b6B30) byte external,
	(b6759, tokenType, tokenSize, b6873, asciiLineNo)(1) byte external,
	(b6B33, b6B34, b6BD9, b6BDB, b905E, skipping, b9A77) byte external,
	(out$p, w68A6, w6BCE) address external,
	(tokStart, segSize)(1) address external;



strUCequ: procedure(arg1w, arg2w) byte public;
	declare (arg1w, arg2w) address;
	declare ch1 based arg1w byte,
		ch2 based arg2w byte;

	do while ch1 <> 0;
		if ch1 <> ch2 and ch1 <> (ch2 and 5Fh) then
			return FALSE;
		arg1w = arg1w + 1;
		arg2w = arg2w + 1;
	end;
	return TRUE;
end;


isSkipping: procedure byte public;
	return b$905E or skipping;
end;

sub$546F: procedure public;
	b6A56 = sub$4646;
	if b6B30 then
		call sub$5ED7;
	if haveTokens then
		if not(tokenType(b6A56) = 0Bh or b68AD) then
			call sub$5ED7;
	if b6B23 or b6B24 then
	do;
		if tokenSP = 1 and not xisSpace and tokenSize(0) <> 1 then
			tokenSize(0) = 2;
	end;
	else if not xisSpace and haveTokens then
		if tokenSize(b6A56) > 3 then
			tokenSize(b6A56) = 3;
end;


sub$4C1E: procedure public;
	declare w$9B79 address,
		b$9B7B byte,
		ch based w$9B79 byte;

	call sub$546F;
	if isPhase2Print then
	do;
		w$9B79 = .asciiLineNo(3);
		b$9B7B = 0FFh;

		do while b$9B7B;
			if ch = '9' then
				ch = '0';
			else
			do;
				if ch = ' ' then
					ch = '1';
				else
					ch = ch + 1;
				b$9B7B = 0;
			end;
			w$9B79 = w$9B79 - 1;
		end;
		if sub$465B or not xisSpace then
			call sub$872E;
	end;

	if b6BD9 then
	do;
		out$p = out$p + 1;
		call flushout;
		call exit;
	end;

	if not b$9A77 then
	do;
		b6BDB = 2;
		if tokenSP < 2 or b6B23 or b6B24 then
			b6BDB = 0;

		w6BCE = tokStart(b6BDB) + tokenSize(b6BDB);
		if isSkipping or not b6B34 then
			w6BCE = .b6759;

		if sub$3A6A then
			call ovl8;

		b6B2C = 0FFh;
		segSize(activeSeg), w68A6 = segSize(activeSeg) + (w6BCE - .b6759);
	end;

	if optXREF and b6880 then
		if phase = 1 then
			call sub$467F(1, .b6873);

	call sub$40B9;

	do while tokenSP > 0;
		call popToken;
	end;

	call sub$3DFB;
	if b6B33 then
	do;
		b6B2E = 0FFh;
		if isPhase2Print and optSYMBOLS then
			call sub$8447;

		call sub$467F(2, .b6873);
		if sub$3A6A then
			call sub$6E32;
	end;
end;

end;
asm46.pl3
asm46: do;

declare (b68B8)(1) byte external,
	(statusIO) address external,
	w68B6 address external;

declare	b6C21 byte public initial(0),
	b6C22 byte public initial(0),
	b6C23 byte public,
	fileIdx byte public initial(0),
	off6C25 address public initial(.b68B8),
	b6C27 byte public initial(0),
	includefd address public,
	rootfd address public,
	off6C2C address public initial(.b68B8 - 1),
	off6C2E address public initial(.b68B8),
	b6C30 byte public initial(0), 
	files(6) structure(name(15) byte, blk address, byt address, b19 byte) public,
	seekIBlk address,
	seekIByte address,
	pad6CAD byte,  
	w6CAE address,
	w6CB0 address,
	pad6CB2(4) address,
	readFActual address,
	pad6CBC address;


close: procedure(w1, w2) external; declare (w1, w2) address; end;
fileError: procedure(w1) external; declare w1 address; end;
ioErrChk: procedure external; end;
read: procedure(w1, w2, w3, w4, w5) external; declare (w1, w2, w3, w4, w5) address; end;
seek: procedure(w1, w2, w3, w4, w5) external; declare (w1, w2, w3, w4, w5) address; end;
inOpen: procedure(w1, w2) address external; declare (w1, w2) address; end;


readF: procedure(arg1b, arg2w, arg3w) public;
	declare arg1b byte, (arg2w, arg3w) address;
	call read(arg1b, arg2w, arg3w, .readFActual, .statusIO);
	call ioErrChk;
end;

seekI: procedure(arg1b) public;
	declare arg1b byte;
	call seek(includefd, arg1b, .seekIBlk, .seekIByte, .statusIO);
	call ioErrChk;
end;


readI: procedure(arg1w) public;
	declare arg1w address;
	declare pad byte;

	call readF(includefd, arg1w, .b68B8(w68B6) - arg1w);
	off6C25 = arg1w + readFActual;
end;



closeI: procedure public;
	call close(includefd, .statusIO);
	call ioErrChk;
	if fileIdx = 0 then
	do;
		b6C27 = 0FFh;
		call fileError(.files(0).name);
		return;
	end;
	fileIdx = fileIdx - 1;
	if fileIdx = 0 then
		includefd = rootfd;
	else
		includefd = inOpen(.files(fileIdx).name, 1);

	seekIByte = files(fileIdx).byt;
	seekIBlk = files(fileIdx).blk;
	call seekI(2);			/* SEEKABS */
	off6C25 = .b68B8;
	off6C2C = .b68B8 - 1;
end;


sub$4879: procedure byte public;
	declare ch based off6C2C byte;
	declare w6CC7 address;
    loop:
	off6C2C = off6C2C + 1;
	if off6C2C = off6C25 then
	do;
		w6CAE = off6C2E;
		w6CB0 = off6C25;
		if w6CB0 - w6CAE > 0 then
			call move(w6CB0 - w6CAE, off6C2E, .b68B8);
		off6C2E = .b68B8;
		call readI(w6CC7 := off6C2E + (w6CB0 - w6CAE));
		off6C2C = w6CC7;
	end;

	if readFActual = 0 then
	do;
		call closeI;
		goto loop;
	end;

	b6C30 = b6C30 + 1;
	return ch and 7Fh;
end;


sub$4904: procedure public;
	declare b6CC9 byte, w6CCA address;

	b6C21 = 0;
	call seekI(0);
	if seekIByte = 128 then
	do;
		seekIBlk = seekIBlk + 1;
		seekIByte = 0;
	end;

	w6CCA = off6C25 - off6C2E;
x:						/* forces code alignment */
/*	b6CC9 = w6CCA mod 128; */
	if (b6CC9 := w6CCA mod 128) > seekIByte then
	do;
		seekIByte = seekIByte + 128;
		seekIBlk = seekIBlk - 1;
	end;

	files(fileIdx - 1).byt = seekIByte - b6CC9;
	files(fileIdx - 1).blk = seekIBlk - w6CCA / 128;
	if includefd <> rootfd then
	do;
		call close(includefd, .statusIO);
		call ioErrChk;
	end;

	off6C25 = .b68B8;
	off6C2C = off6C25 - 1;
	off6C2E = .b68B8;
	files(fileIdx).blk = 0;	
	files(fileIdx).byt = 0;	
	includefd = inOpen(.files(fileIdx).name, 1);
end;
end;
asm47.pl3
asm47:
do;

declare b4A26(*) byte data(0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh,
			   0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh,
			   0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh,
			   0FFh, 0FFh, 0FFh, 0FFh, 0, 0FFh, 0FFh, 0FFh),
	b4A68(*) byte data(0, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0,
			   0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh,
			   0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh);



sub$3CDF: procedure(b) external; declare b byte; end;
sub$3F19: procedure external; end;
sub$4274: procedure external; end;
sub$4291: procedure external; end;
sub$450F: procedure(b) external; declare b byte; end;
sub$4C1E: procedure external; end;
sub$5CE8: procedure(w, b) external; declare w address, b byte; end;
sub$5ED7: procedure external; end;
sub$5EE3: procedure external; end;
sub$5F01: procedure external; end;
sub$5F07: procedure external; end;
sub$5F13: procedure external; end;
sub$5F25: procedure external; end;
sub$5F37: procedure external; end;
popToken: procedure external; end;
nestIFX: procedure(b) external; declare b byte; end;
sub$676D: procedure(b) external; declare b byte; end;
pushToken: procedure(b) external; declare b byte; end;
collectByte: procedure(b) external; declare b byte; end;
sub$72A4: procedure(b) external; declare b byte; end;
sub$7327: procedure external; end;
sub$7517: procedure external; end;
sub$753E: procedure external; end;
sub$75FF: procedure external; end;
sub$76CE: procedure external; end;
sub$770B: procedure external; end;
sub$7844: procedure external; end;
sub$787A: procedure external; end;
sub$78CE: procedure external; end;
ovl2: procedure external; end;
writeRec02: procedure external; end;
haveTokens: procedure byte external; end;
isPhase1: procedure byte external; end;
sub$425B: procedure(b) byte external; declare b byte; end;
getPrec: procedure(b) byte external; declare b byte; end;
sub$43DD: procedure address external; end;

declare	FALSE literally '0',
	TRUE literally '0FFh';


declare tokenSize literally 'toksiz',
	tokStart literally 'tokst';
declare (moduleNameLen, b6745, activeSeg, b6754) byte external,
	(b6755, tokenSP, b6855, b6856) byte external,
	(b6857, b6858, b6859, b6881, b6885, b68AB, optOBJECT, b6B23) byte external,
	(b6B24, b6B25, phase, b6B28, b6B29, opType, b6B2B, b6B2C, b6B2D) byte external,
	(b6B2E, b6B2F, b6B30, b6B32, b6B33, b6B34, b6B35, b6B36, b6BDB) byte external,
	(b6BDD, b9058, b905E, b6743, b6744, b6748, b6749, ifDepth) byte external,
	(inElse, macroCondSP, opSP, b9C3A) byte external,
	(b3692, aModulePage, b4181, tokenSize, b674C, tokenType, tokenAttr, accum1byt, accum2byt)(1) byte external,
	(macroCondStk, b6873, b674A, skipping, opStack)(1) byte external,
	(w6750, startAddr, accum1, accum2, w685A, w685C, w68A6) address external,
	(tokenSymId, segSize, w6B41)(1) address external,
	s906C structure(macroCondSP byte, ifDepth byte, mtype byte, b3 byte,
			     w4 address, buf$p address, blk address, w10 address,
			     w12 address, w14 address) external;


declare pad9C27 byte;



sub$4AAA: procedure(arg1b) public;
	declare arg1b byte;

	if b674A(arg1b) then
	do;
		if haveTokens then
		do;
			accum1 = sub$43DD;
			if b674C(arg1b) <> accum1byt(0) then
				call sub$5EE3;
		end;
		else if b674C(arg1b) <> 3 then
			call sub$5EE3;
	end;
	else
	do;
		b674A(arg1b) = TRUE;
		if haveTokens then
		do;
			accum1 = sub$43DD;
			if accum1 = 1 or accum1 = 2 then
				b674C(arg1b) = low(accum1);
			else
				call sub$5EE3;
		end;
	end;
end;


sub$4B3F: procedure(arg1b) public;
	declare arg1b byte;

	accum1 = arg1b;
	if accum1 then
		accum1 = 0FFFFh;
end;

sub$4B57: procedure(arg1b) public;
	declare arg1b byte;

	if (b6855 and 47h) <> 0 then
		b6855 = b6855 and 0E7h or arg1b;
end;




sub$516F: procedure;
	do case b6B2B;
/* 0 */		;
/* 1 */		call sub$4C1E;
/* 2 */		goto case3;
/* 3 */	case3:	do;
			if not (b6B2B = 2 and opType = 3) then
				call sub$5F25;

			if tokenType(0) = 11 then
			do;
				tokenSize(0) = 1;
				tokenAttr(0) = 0;
				b6B36 = 0FFh;
			end;
			b6B35 = b6B2F;
			if opType = 3 then
				b6B2C = 0FFh;
		end;
/* 4 */		accum1 = accum1 * accum2;
/* 5 */		accum1 = accum1 + accum2;
/* 6 */		do;
			call sub$5ED7;
			call popToken;
		end;
/* 7 */		accum1 = accum1 - accum2;
/* 8 */		;
/* 9 */		do;
			if accum2 = 0 then
				call sub$5F01;
			accum1 = accum1 / accum2;
		end;
/* 10 */	accum1 = -accum1;
/* 11 */	call sub$4B3F(accum1 = accum2);
/* 12 */	call sub$4B3F(accum1 < accum2);
/* 13 */	call sub$4B3F(accum1 <= accum2);
/* 14 */	call sub$4B3F(accum1 > accum2);
/* 15 */	call sub$4B3F(accum1 >= accum2);
/* 16 */	call sub$4B3F(accum1 <> accum2);
/* 17 */	accum1 = not accum1;
/* 18 */	accum1 = accum1 and accum2;
/* 19 */	accum1 = accum1 or accum2;
/* 20 */	accum1 = accum1 xor accum2;
/* 21 */	do;
			if accum2 = 0 then
				call sub$5F01;
			accum1 = accum1 mod accum2;
		end;
/* 22 */	do;
			if accum2byt(0) <> 0 then
				accum1 = shl(accum1, accum2);
		end;
/* 23 */	do;
			if accum2byt(0) <> 0 then
				accum1 = shr(accum1, accum2);
		end;
/* 24 */	do;
			accum1 = high(accum1);
			call sub$4B57(10h);
		end;
/* 25 */	do;
			accum1 = low(accum1);
			call sub$4B57(8);
		end;
/* 26 */	do;
			if tokenType(0) <> 10 then
			do;
				accum1 = sub$43DD;
				if accum1byt(1) - 1 < 0FEh then
					call sub$5F01;
				b6B28 = 22h;
				if (b6855 and 18h) = 18h then
				do;
					call sub$5F01;
					b6855 = b6855 and 0E7h or 8;
				end;
			end;
			else
			do;
				b6855 = 0;
				tokenType(0) = 0Bh;
			end;

			if sub$425B(b6858) then
				call sub$5F37;
			b6B2D = 0Bh;
			b6B23 = 0FFh;
		end;
/* 27 */	do;
			b6B2D = 0Bh;
			b6B24 = 0FFh;
		end;
/* 28 */	do;
			segSize(activeSeg) = segSize(activeSeg) + accum1;
			b68AB = 0FFh;
		end;
/* 29 */ case29:
		do;
			b68AB = 0FFh;
			if (b6855 and 40h) = 40h then
			do;
				call sub$5EE3;
				b6855 = 0;
			end;
			b$9C3A = 1;
			call sub$5CE8(accum1, 22h - b6B2B);
			b6B30 = 0;
		end;
/* 30 */	goto case29;
/* 31 */	do;
			b68AB = 0FFh;
			if (b6855 and 40h) <> 40h then
			do;
				if (b6855 and 18h) <> 0 then
					if (b6855 and 7) <> activeSeg or (b6855 and 18h) <> 18h then
						call sub$5EE3;
			end;
			else
				call sub$5EE3;

			if optOBJECT then
				if segSize(activeSeg) > w6B41(activeSeg) then
					w6B41(activeSeg) = segSize(activeSeg);

			segSize(activeSeg) = accum1;
		end;
/* 32 */	do;
			if tokenSP > 0 then
			do;
				startAddr = sub$43DD;
				b6755 = 1;
				b6745 = (b6855 and 7);

				if (b6855 and 40h) = 40h then
					call sub$5EE3;

				if sub$425B(b6858) then
					call sub$5F37;

				b68AB = 0FFh;
			end;

			b6BDD = b$905E;		/* code diff */
			b$905E = 0;			/* code diff */

			if macroCondSP > 0 or b6BDD then	/* code diff */
				call sub$5F07;

			if opType <> 1 then
				call sub$5ED7;

			if b6B35 then
				b6B33 = 0FFh;
			else
				call sub$5ED7;
		end;
/* 33 */	do;
			if b6B35 then
			do;
				b6B32 = 0FFh;
				call nestIFX(2);
				b6881 = 0FFh;
				if skipping(0) = 0 then
					skipping(0) = not ((low(accum1) and 1) = 1);

				inElse = 0;

			end;
		end;
/* 34 */	do;
			b6B32 = 0FFh;
			if macroCondStk(0) <> 2 then
				call sub$5F07;
			else if not inElse then
			do;
				if not skipping(0) then
					skipping(0) = 0FFh;
				else
					skipping(0) = skipping(ifDepth);
				inElse = 0FFh;
			end;
			else
				call sub$5F07;
		end;
/* 35 */	do;
			if b6B35 then
			do;
				b6B32 = 0FFh;
				call sub$676D(2);
			end;
		end;
/* 36 */	do;
			if b6744 = 1 then
				if b6873(0) = 4Dh then
					call sub$5ED7;
			call sub$450F(85h);
		end;
/* 37 */	do;
			if b6744 = 1 then
				if b6873(0) = 4Dh then
					call sub$5ED7;
			call sub$450F(5);
		end;
/* 38 */	call sub$450F(7);
/* 39 */	call sub$450F(2);
/* 40 */	call sub$450F(8);
/* 41 */	call sub$450F(46h);
/* 42 */	call sub$450F(6);
/* 43 */	call sub$450F(36h);
/* 44 */	call sub$450F(0);
/* 45 */	call sub$450F(0);
/* 46 */	call sub$450F(6);
/* 47 */	activeSeg = 0;
/* 48 */	do;
			activeSeg = 1;
			call sub$4AAA(0);
		end;
/* 49 */	do;
			activeSeg = 2;
			call sub$4AAA(1);
		end;

/* 50 */	do;
			b6748 = 0FFh;
			b$9C3A = 0;
			call sub$5CE8(0, 6);
		end;
/* 51 */	do;
			b6749 = 0FFh;
			if w6750 = 0 and isPhase1 and optOBJECT then
				call writeRec02;
			b$9C3A = 0;
			call sub$5CE8(w6750, 2);
			if isPhase1 and optOBJECT and not b6754 then
				call ovl2;
			
			if not b6754 then
				w6750 = w6750 + 1;
			b6754 = 0;
		end;
/* 52 */	do;
			if tokenSP <> 0 and b6743 then
			do;
				call move(6, .b3692, .aModulePage);
				call move(moduleNameLen := b6744, .b6873, .aModulePage);
			end;
			else
				call sub$3CDF(52h);
			call popToken;
		end;
/* 53 */	segSize(3) = accum1;
/* 54 */	call sub$7517;			/* MACRO ? */
/* 55 */	call sub$753E;
/* 56 */	call sub$75FF;			/* ENDM */
/* 57 */	call sub$76CE;			/* EXITM */
/* 58 */	do;
			s906C.mtype = 4;
			call sub$7327;
		end;
/* 59 */	call sub$72A4(1);		/* IRP ? */
/* 60 */	call sub$72A4(2);		/* IRPC */
/* 61 */	call sub$770B;
/* 62 */	call sub$7844;			/* REPT ? */
/* 63 */	call sub$787A;			/* LOCAL */
/* 64 */	call sub$78CE;
/* 65 */	do;				/* NUL */
			call sub$4B3F(tokenType(0) = 41h);
			call popToken;
			b6855 = 0;
		end;
	end;

	if b6B2B <> 1 then
		b6743 = 0;
end;


sub$518F: procedure;

	sub$53C0: procedure byte;
		if b6B29 > 3 then
			if b6B29 <> 6 then
				if b6B29 < 1Ah then
					return TRUE;
		return FALSE;
	end;

	sub$53DF: procedure(arg1b) byte;
		declare arg1b byte;
		return arg1b = 9 or arg1b = 64h;
	end;


	sub$53F8: procedure;
		if not b4A68(b6B2B) then
			b6B34 = 0;
	end;

    do while 1;
	if not (b6B29 = 1 or not (b6B29 < 20h)
	  and not (b6B29 > 23h)) and skipping(0)
	  or (b4181(b6B29) < 128 or b$9058) and b$905E then
		do;
			b6885 = 0;
			call popToken;
			return;
		end;

	if phase <> 1 then
		if b6B25 then
			if sub$53C0 then
				if getPrec(b6B29) <= getPrec(opStack(opSP)) then
					call sub$5EE3;

	if getPrec(opType := b6B29) > getPrec(b6B2B := opStack(opSP)) or opType = 2 then
	do;
		if opSP >= 10h then
		do;
			opSP = 0;
			call sub$5F13;
		end;
		else
			opStack(opSP := opSP + 1) = opType;

		if opType = 2 then
		do;
			b6B2F = b6B35;
			b6B35 = 0FFh;
		end;

		if phase > 1 then
			b6B25 = sub$53C0;

		return;
	end;

	b6B25 = 0;
	if not b6B35 and b6B2B > 3 then
		call sub$5ED7;

	if b6B2B = 0 then
		b6B2B = opType;
	else
		opSP = opSP - 1;

	if (b6B28 := b4181(b6B2B)) then
	do;
		accum2 = sub$43DD;
		b6856 = b6855;
		w685C = w685A;
		b6859 = b6858;
	end;

	if (b6B28 := ror(b6B28, 1)) then
		accum1 = sub$43DD;

	if not b6857 then
		b6857 = sub$53DF(b6858) or sub$53DF(b6859);

	b6B2D = 0Ch;
	if b6B2B > 3 and 1Ah > b6B2B then
		call sub$4291;
	else
	do;
		call sub$53F8;
		call sub$4274;
	end;

	call sub$516F;
	if not b4A26(b6B2B) then
		b6B35 = 0;

	if b6B2C then
	do;
		b6B2C = 0;
		return;
	end;

	if (b6B2B <> 1Ch) and b68AB then
		w68A6 = accum1;

	if (b6B28 and 1Eh) <> 0 then
		call pushToken(b6B2D);

	do b6BDB = 0 to 3;
		if (b6B28 := ror(b6B28, 1)) then
			call collectByte(accum1byt(b6BDB));
	end;

	tokenAttr(0) = b6855;
	tokenSymId(0) = w685A;
	if ror(b6B28,1) then
		if opType = 6 then
		do;
			b6B29 = b6B2B;
			b6B35 = 0FFh;
		end;
    end;
end;

sub$540D: procedure public;
	do while b6B2E = 0;
		call sub$3F19;
		call sub$518F;
	end;
end;
end;
asm48.pl3
asm48:
do;
declare	b5666(*) byte data(9, 2Dh, 80h),
	b5669(*) byte data(3Ah, 8, 80h, 0, 0, 0, 0, 0, 20h),
	b5672(*) byte data(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0,
			   0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1),
			   /* 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
	chClassX(*) byte data(0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 4, 0, 0,
			      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0Bh, 0, 0, 0, 0,	/* ESC maps to 0Bh */
			      1, 0, 0, 0, 6, 0, 0, 7, 5, 5, 5, 5, 5, 5, 0, 5,
			      8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 3, 2, 0, 0, 0, 9,
			      9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
			      9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0,
			      0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
			      9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0);


wrError: procedure(b) external; declare b byte; end;
sub$3CDF: procedure(b) external; declare b byte; end;
sub$3D55: procedure(b) external; declare b byte; end;
readM: procedure(w) external; declare w address; end;
sub$5ED7: procedure external; end;
sub$5EFB: procedure external; end;
sub$5F0D: procedure external; end;
sub$5F1F: procedure external; end;
sub$5F2B: procedure external; end;
sub$5F31: procedure external; end;
popToken: procedure external; end;
nxtCmdCh: procedure byte external; end;
xisSpace: procedure byte external; end;
isPhase1: procedure byte external; end;
isPhase2Print: procedure byte external; end;
testBit: procedure(b, w) byte external; declare b byte, w address; end;
sub$4879: procedure byte external; end;
isSkipping: procedure byte external; end;

declare (activeSeg, tokenSP, b6855, b6857, b6858) byte external,
	(curChar, reget, lookAhead, b6882, b6883, b6884, b6885, optMOD85, scanOptions) byte external,
	(has16bitOperand, opType, b6BDB, b6BDD, b$9059, b$905B, b$905C, b$905D) byte external,
	(b$905E, b$9062, b$9067, b$91A1, b$91A2) byte external,
	(b6742, b6748, b6749) byte external,
	(tokenType, b$91A4, mem, macroBuf)(1) byte external,
	curTokenSym$p address external,
	curTokenSym based curTokenSym$p structure(w0 address, w2 address, w4 address, type byte, b7 byte),
	(w$9054, off$9056, curTokStart, w6866) address external,
	(w686E, w6870, w6A4E, w6BE0, w$906A) address external,
	(curMacroBlk, w$9197, w$919D) address external,
	(symTab, w6868, tokenSym)(1) address external,
	s906C structure(macroCondSP byte, ifDepth byte, mtype byte, b3 byte,
			     w4 address, buf$p address, blk address, w10 address,
			     w12 address, w14 address) external;






unpackToken: procedure(arg1w, arg2w) public;
	declare (arg1w, arg2w) address;
	declare wrd based arg1w address;
	declare ch based arg2w byte;
	declare w6CDE address;

	unpack1: procedure;
		ch = w6CDE mod 40;	
		if ch = 0 then
			ch = ' ';
		else if ch <= 10 then
			ch = ch + 2Fh;	/* digit */
		else 
			ch = ch + 34h;	/* ? @ and letters */
		w6CDE = w6CDE / 40;
		arg2w = arg2w - 1;
	end;


	arg1w = arg1w + 2;
	arg2w = arg2w + 5;
	w6CDE = wrd;
	call unpack1;
	call unpack1;
	call unpack1;
	arg1w = arg1w - 2;
	w6CDE = wrd;
	call unpack1;
	call unpack1;
	call unpack1;
end;


sub$5C08: procedure;
	declare (w$9C32, w$9C34) address;
	declare ch1 based w$9C32 byte;
	declare ch2 based w$9C34 byte;

	w686E, w$9C32 = (w$9C34 := w686E) + 8;
	if w6870 < w$9C32 then
		call wrError(1);

	do while w$9C34 > curTokenSym$p;
		w$9C32 = w$9C32 - 1;
		w$9C34 = w$9C34 - 1;
		ch1 = ch2;
	end;

	call move(4, curTokStart, curTokenSym$p);
	w6868(2) = w6868(2) + 8;
	curTokenSym.type = 0;
end;


sub$5C73: procedure(arg1b) byte;
	declare arg1b byte;

	if w6868(arg1b) >= curTokenSym$p and curTokenSym$p >= symTab(arg1b) then
		return 0;

	call sub$5ED7;
	return 0FFh;
end;


sub$5CAD: procedure(arg1w, arg2b) public;
	declare arg1w address, arg2b byte;

	if sub$5C73(2) then
		return;
	call sub$5C08;
	curTokenSym.w4 = arg1w;
	curTokenSym.type = arg2b;
	curTokenSym.b7 = 0;
	call popToken;
end;

declare b$9C3A byte public;

sub$5CE8: procedure(arg1w, arg2b) public;
	declare arg1w address, arg2b byte;
	declare (b6CE8, b6CE9, b6CEA, b6CEB, b6CEC) byte;

	sub$5B9A: procedure;
		tokenType(0) = arg2b;
		if (b6858 = 7 or b6858 = 8) and b6CEB then
			tokenType(0) = 12 - arg2b;
	end;

	b6CEC = tokenType(0);
	b6CEB = arg2b = 5 or arg2b = 4;
	b6CE9 = 0;
	b6CE8 = curTokenSym.b7;
	b6CEA = 0;
	if sub$5C73(1) then
		return;

	if tokenSP > 1 then
		call sub$5ED7;

	if isPhase1 then
		if tokenType(0) = 9 then
		do;
			if b6883 then
			do;
				if curTokenSym.type >= 80h or arg2b = 3Ah and curTokenSym.w4 <> w6A4E then
				do;
					call sub$5F31;
					b6CE9 = 80h;
				end;
			end;
			else
			do;
				call sub$5C08;
				w6866 = w6866 + 8;
				w6868(1) = w6868(1) + 8;
				b6CE8 = 0;
			end;

			b6CE8 = ((activeSeg <> 0) and 18h) or (b6748 and 20h) or (b6749 and 58h);
			if b$9C3A = 1 then
				b6CE8 = b6855;

			if b$9C3A = 2 then
				b6CE8 = b6CE8 or activeSeg;

			if b6857 and b6CEB then
				tokenType(0) = 64h;
			else
				call sub$5B9A;

			goto L5F82;
		end;

	if b6882 = 2 then
		if tokenType(0) = 9 then
			if b6858 <> 9 then
				if b6CEB then
				do;
					call sub$5B9A;
					if curTokenSym.type < 80h then
					do;
						curTokenSym.type = tokenType(0);
						curTokenSym.w4 = arg1w;
						b6CE8 = b6855;
						b6CEA = 0FFh;
					end;
					goto L5F82;
				end;

	if isPhase1 then
		if tokenType(0) = 6 then
			if testBit(arg2b, .b5666) then
			do;
				if b6749 then
					tokenType(0) = 3;
				else
				do;
					tokenType(0) = arg2b;
					b6CE8 = (b6CE8 and 0E0h);
					if b$9C3A = 1 then
						b6CE8 = b6855 or 20h;

					if b$9C3A = 2 then
						if activeSeg <> 0 then
							b6CE8 = b6CE8 or activeSeg or 38h;
				end;
				goto L5F82;
			end;

	if isPhase1 then
		if arg2b = 6 then
			if testBit(tokenType(0), .b5666) then
			do;
				if (b6CE8 and 60h) <> 0 then
					tokenType(0) = 3;
				else
					b6CE8 = b6CE8 or 20h;
				goto L5F82;
			end;

	if isPhase1 then
		if tokenType(0) <> arg2b and  8 <> tokenType(0) or arg2b = 5 then
			tokenType(0) = 3;

	if not b6748 and testBit(tokenType(0), .b5669) then
		b6CE8 = (b6CE8 and 20h) and tokenType(0) <> 3Ah or b6855;
	else
	do;
		if isPhase1 then
			tokenType(0) = 3;

		if not (b6748 or b6749) then
			if curTokenSym.w4 <> arg1w then
				call sub$5F0D;
	end;

L5F82:
	b6CE9 = b6CE9 or (curTokenSym.type and 80h);

	if isPhase1 and (arg2b = 9 or arg2b = 6 or b6CEC <> tokenType(0)) then
		curTokenSym.type = tokenType(0) or b6CE9;

	b6BDD = curTokenSym.type;
	if tokenType(0) = 3 or b6BDD = 3 then
		call sub$5EFB;

	if b6BDD >= 80h then
		call sub$5F31;

	if isPhase1 and (tokenType(0) = arg2b or arg2b = 5 and tokenType(0) = 7) or arg2b = 4 and xisSpace
	   or b6CEA or arg2b = 3Ah then
		curTokenSym.w4 = arg1w;

	curTokenSym.b7 = b6CE8;
	b6748 = 0;
	b6749 = 0;
	if curTokenSym.type = 6 then
		call sub$5F2B;

	b6857 = 0;
	if b6883 then
		call popToken;

end;



lookup: procedure(arg1b) byte public;
	declare arg1b byte;
	declare (w6CEE, w6CF0, s6CF2$p, w6CF4, s6CF6$p, s6CF8$p) address,
		(b6CFA, b6CFB) byte;
	declare s6CF6 based s6CF6$p structure(w0 address, w2 address, b4 byte, b5 byte, type byte, b7 byte),
		s6CF8 based s6CF8$p structure(w0 address, w2 address, b4 byte, b5 byte, type byte, b7 byte);
	declare wrd based w6BE0 address;

	s6CF8$p = curTokStart;
	if arg1b = 0 then
	do;
		s6CF6$p = 0;
		w6CF4 = symTab(0) + (s6CF8.w0 + s6CF8.w2) mod 97h * 8;

		do while w6CF4 <> 0;
			s6CF6$p = s6CF6$p + w6CF4;
			if s6CF6.w0 = s6CF8.w0 then
				if s6CF6.w2 = s6CF8.w2 then
				do;
					curTokenSym$p = s6CF6$p;
					tokenType(0) = curTokenSym.type;
					if tokenType(0) < 2Dh then
						if b5672(tokenType(0)) then
							has16bitOperand = 0FFh;
					if curTokenSym.b7 = 2 and not optMOD85 then
						call sub$3CDF(4Fh);

					if tokenType(0) = 8 then	/* SP */
					do;
						if not (opType = 24h or opType = 25h) then /* lxi or push/pop */
							call sub$3CDF(58h);
						tokenType(0) = 7;	/* reg */
					end;
					return (tokenType(0) and 7Fh);
				end;
			w6CF4 = s6CF6.b5;
		end;
		return 9;
	end;

	w6CEE = symTab(arg1b);
	w6CF0, s6CF6$p = w6868(arg1b);

	do while (s6CF2$p := w6CEE + shr((w6CF0 - w6CEE) and 0FFF0h, 1)) <> s6CF6$p;
		s6CF6$p = s6CF2$p;
		if s6CF8.w0 = s6CF6.w0 then
		do;
			if s6CF8.w2 = s6CF6.w2 then
			do;
				curTokenSym$p = s6CF6$p;
				tokenType(0) = curTokenSym.type;
				if tokenType(0) = 64h then
					tokenType(0) = 9;

				if (b6884 := (b6BDD := (tokenType(0) and 7Fh)) = 9) then
					if b6885 then
						curTokenSym.type = 89h;
				return b6BDD;
			end;
			else
				b6CFB = s6CF6.w2 > s6CF8.w2;
		end;
		else
			b6CFB = s6CF6.w0 > s6CF8.w0;

		s6CF6$p = s6CF2$p;
		if b6CFB then
			w6CF0 = s6CF6$p;
		else
			w6CEE = s6CF6$p;
	end;

	curTokenSym$p = w6CF0;
	if arg1b = 1 and not isSkipping then
	do;
		b6883 = 0;
		b$9C3A = 0;
		call sub$5CE8(w6A4E, (b6885 and 80h) or 9);
		w6BE0 = .tokenSym;
		do b6CFA = 1 to tokenSP;
			w6BE0 = w6BE0 + 2;
			if wrd >= curTokenSym$p then
				wrd = wrd + 8;
		end;

		b6883 = 0FFh;
	end;
	return 9;
end;



getChX: procedure byte public;
	declare (b6CFC, b6CFD) byte;
	declare ch based s906C.buf$p byte;
	declare ch1 based off$9056 byte;

L6339:
	if not reget then
	do;
		b6CFD = b6CFC;

	L6347:
		b6CFC = lookAhead;
		if b$905B then
		do;
			do while (lookAhead := ch) = 0FEh;
				call readM(curMacroBlk + 1);
				s906C.buf$p = .macroBuf;
			end;

			s906C.buf$p = s906C.buf$p + 1;
		end;
		else if scanOptions then
			lookAhead = nxtCmdCh;
		else
			lookAhead = sub$4879;

		if chClassX(b6CFC) = 0 then
			if b6CFC = 0 or b6CFC = 7Fh or b6CFC = 0Ch then
				goto L6347;

		if b$905B then
		do;
			if b6CFC = 1Bh then
			do;
				goto L65B2;
			end;
			else if b6CFC = 26h then
			do;
				if not b6CFD < 80h or lookAhead = 80h then
					goto L6339;
			end;
			else if b6CFC = 21h and b6CFD <> 0 then
			do;
				if not (b$905D or b$905E) and b$905C then
				do;
					b6CFC = 0;
					goto L6339;
				end;
			end;
			else if b6CFC >= 128 then
			do;
				if not (b$905C := not b$905C) then
					s906C.buf$p = w$9197;
				else
				do;
					w$9197 = s906C.buf$p;
					if b6CFC = 80h then
					do;
						s906C.buf$p = s906C.w12;
						if b$9062 = 2 then
						do;
							b$91A2 = ch;
							s906C.buf$p = .b$91A2;
							if ch = 21h then
							do;
								b$91A1 = 21h;
								b$91A2 = mem(s906C.w12 + 1);
								s906C.buf$p = s906C.buf$p - 1;
							end;
						end;
						else
						do;
							do while (lookAhead := lookAhead - 1) <> 0FFh;
								s906C.buf$p = s906C.buf$p - (ch and 7Fh);
							end;

							s906C.buf$p = s906C.buf$p + 1;
						end;
					end;
					else
					do;
						s906C.buf$p = .b$91A4;
						w6BE0 = lookAhead + s906C.w4;
						do b6BDB = 1 to 4;
							b$91A4(6 - b6BDB) = w6BE0 mod 10 + '0';
							w6BE0 = w6BE0 / 10;
						end;
					end;
				end;

				lookAhead = 0;
				goto L6339;
			end;
		end;

		if b$905B > 1 then
			if isPhase2Print then
				if off$9056 < .w$9054 then
				do;
					ch1 = b6CFC;	
					off$9056 = off$9056 + 1;
				end;

		if b$905E then
			if w$919D <> w$906A and b6CFC = 0Dh or not b$9059 then
			call sub$3D55(b6CFC);

		if not(b6CFD = 21h or b6742) then
		do;
			if b6CFC = 3Eh then
				b$9067 = b$9067 - 1;

			if b6CFC = 3Ch then
				b$9067 = b$9067 + 1;
		end;
	end;
L65B2:
	reget = 0;
	return (curChar := b6CFC);
end;

sub$65BE: procedure byte public;
	curChar = getChX;
	if b$905D then
		return 0Ah;

	return chClassX(curChar);
end;



sub$65D9: procedure public;
	if lookAhead = 0Ah then
		lookAhead = 0;
	else
	do;
		b$905E = b$905E and 0FEh;
		call sub$5F1F;
		b$905E = b$905E > 0;
	end;
end;

end;

asm49.pl3
asm49:
do;


sub$3CDF: procedure(b) external; declare b byte; end;
wrError: procedure(b) external; declare b byte; end;
readM: procedure(w) external; declare w address; end;
physmem: procedure address external; end;
getChX: procedure byte external; end;
sub$65BE: procedure byte external; end;

declare tokenSize literally 'toksiz',
	tokStart literally 'tokst';
declare (cZERO, tokenSP, macroCondSP, curChar, reget, ifDepth, b905B, b9061) byte external,
	(b9062, b9063) byte external,
	(tokenType, tokenSize, tokenAttr, skipping, inElse, macroCondStk)(1) byte external,
	(off$682A, curTokStart, w6870, w673F) address external,
	(tokenSymId, tokenSym, tokStart)(1) address external,
	s906CStk(10) structure(macroCondSP byte, ifDepth byte, mtype byte, b3 byte,
			     w4 address, buf$p address, blk address, w10 address,
			     w12 address, w14 address) external,
	s906C structure(macroCondSP byte, ifDepth byte, mtype byte, b3 byte,
			     w4 address, buf$p address, blk address, w10 address,
			     w12 address, w14 address) external;


sub$5ED7: procedure public;
	call sub$3CDF('Q');
end;

sub$5EDD: procedure public;
	call sub$3CDF('D');
end;

sub$5EE3: procedure public;
	call sub$3CDF('E');
end;

sub$5EE9: procedure public;
	call sub$3CDF('C');
end;

sub$5EEF: procedure public;
	call sub$3CDF('O');
end;

sub$5EF5: procedure public;
	call sub$3CDF('R');
end;

sub$5EFB: procedure public;
	call sub$3CDF('M');
end;

sub$5F01: procedure public;
	call sub$3CDF('V');
end;

sub$5F07: procedure public;
	call sub$3CDF('N');
end;

sub$5F0D: procedure public;
	call sub$3CDF('P');
end;

sub$5F13: procedure public;
	call wrError(0);
end;

sub$5F19: procedure public;
	call wrError(4);
end;

sub$5F1F: procedure public;
	call sub$3CDF('I');
end;

sub$5F25: procedure public;
	call sub$3CDF('B');
end;

sub$5F2B: procedure public;
	call sub$3CDF('U');
end;

sub$5F31: procedure public;
	call sub$3CDF('L');
end;

sub$5F37: procedure public;
	call sub$3CDF('X');
end;

haveTokens: procedure byte public;
	return tokenSP <> 0;
end;


popToken: procedure public;
	tokStart(0) = tokStart(tokenSP);
	tokenSym(0) = tokenSym(tokenSP);
	tokenType(0) = tokenType(tokenSP);
	tokenAttr(0) = tokenAttr(tokenSP);
	tokenSize(0) = tokenSize(tokenSP);
	tokenSymId(0) = tokenSymId(tokenSP);
	if haveTokens then
		tokenSP = tokenSP - 1;
end;



nestIFX: procedure(arg1b) public;
	declare arg1b byte;

	macroCondStk(macroCondSP := macroCondSP + 1) = macroCondStk(0);
	if (macroCondStk(0) := arg1b) = 1 then
	do;
		if (b$9063 := b$9063 + 1) > 9 then
		do;
			call sub$5F13;
			b$9063 = 0;
		end;
		else
		do;
			call move(16, .s906CStk(0), .s906CStk(b$9063));
			s906C.macroCondSP = macroCondSP;
			s906C.ifDepth = ifDepth;
			b$9061 = 0FFh;
		end;
	end;
	else
	do;
		if (ifDepth := ifDepth + 1) > 8 then
		do;
			call sub$5F13;
			ifDepth = 0;
		end;
		else
		do;
			skipping(ifDepth) = skipping(0);
			inElse(ifDepth) = inElse(0);
		end;
	end;
end;


sub$676D: procedure(arg1b) public;
	declare arg1b byte;

	if arg1b <> macroCondStk(0) then
	do;
		call sub$5F07;
		if arg1b = 2 then
			return;
		macroCondSP = s906C.macroCondSP;
		ifDepth = s906C.ifDepth;
	end;

	macroCondStk(0) = macroCondStk(macroCondSP);
	macroCondSP = macroCondSP - 1;
	if arg1b = 1 then
	do;
		call move(16, .s906CStk(b$9063), .s906CStk(0));
		call readM(s906C.blk);
		b$9062 = s906C.mtype;
		if (b$9063 := b$9063 - 1) = 0 then
		do;
			b$905B = 0;
			w6870 = physmem + 0BFh;
		end;
	end;
	else
	do;
		skipping(0) = skipping(ifDepth);
		inElse(0) = inElse(ifDepth);
		ifDepth = ifDepth - 1;
	end;
end;

pushToken: procedure(arg1b) public;
	declare arg1b byte;

	if tokenSP >= 8 then
		call sub$5F13;
	else
	do;
		tokenSP = tokenSP + 1;
		tokStart(tokenSP) = tokStart(0);
		tokenSym(tokenSP) = tokenSym(0);
		tokenType(tokenSP) = tokenType(0);
		tokenAttr(tokenSP) = tokenAttr(0);
		tokenSize(tokenSP) = tokenSize(0);
		tokenSymId(tokenSP) = tokenSymId(0);	
		tokStart(0) = tokStart(0) + tokenSize(0);
		tokenType(0) = arg1b;
		tokenAttr(0), tokenSize(0) = cZERO;
		tokenSym(0) = w673F;
		tokenSymId(0) = w673F;
	end;
end;

collectByte: procedure(arg1b) public;
	declare arg1b byte;
	declare w6D02 address;
	declare ch based w6D02 byte;


	if (w6D02 := curTokStart + tokenSize(0)) < off$682A then
	do;
		ch = arg1b;
		tokenSize(0)= tokenSize(0)+ 1;
	end;
	else
		call sub$5F13;
end;

collectIdent: procedure(arg1b) public;
	declare arg1b byte;

	call pushToken(arg1b);
	reget = 1;

	do while (arg1b := sub$65BE) = 8 or arg1b = 9;
		if curChar > 60h then
			curChar = curChar and 0DFh;
		call collectByte(curChar);
	end;
	reget = 1;
end;


ascii2Num: procedure public;
	declare w$9C5B address,
		(b$9C5D, b$9C5E, b$9C5F) byte;
	declare cha based curTokStart(1) byte;

	call collectIdent(0Ch);
	b$9C5D = cha(tokenSize(0):= tokenSize(0)- 1);
	if b$9C5D = 48h then
		b$9C5D = 10h;

	if b$9C5D = 44h then
		b$9C5D = 0Ah;

	if b$9C5D = 4Fh or b$9C5D = 51h then
		b$9C5D = 8;

	if b$9C5D = 42h then
		b$9C5D = 2;

	if b$9C5D > 10h then
		b$9C5D = 0Ah;
	else
		tokenSize(0)= tokenSize(0)- 1;

	w$9C5B = 0;
	do b$9C5F = 0 to tokenSize(0);
		if cha(b$9C5F) = 3Fh or cha(b$9C5F) = 40h then
		do;
			call sub$5F1F;
			b$9C5E = 0;
		end;
		else
		do;
			if (b$9C5E := cha(b$9C5F) - '0') > 9 then
				b$9C5E = b$9C5E - 7;
			if b$9C5E >= b$9C5D then
				if not (tokenType(2) = 40h) then
				do;
					call sub$5F1F;
					b$9C5E = 0;
				end;
		end;

		w$9C5B = w$9C5B * b$9C5D + b$9C5E;
	end;
	tokenSize(0)= 0;
	call collectByte(low(w$9C5B));
	call collectByte(high(w$9C5B));
end;

collectString: procedure public;
	call pushToken(0Ah);

	do while getChX <> 0Dh;
		if curChar = 27h then
			if getChX <> 27h then
				goto L6268;
		call collectByte(curChar);
	end;

	call sub$5F25;

L6268:
	reget = 1;
end;

end;
asm4A.pl3
asm4A: do;
declare b6D6E(*) byte data(35h, 'DEBUG', 3Ah, 'MACRODEBUG',
			   34h, 'XREF', 37h, 'SYMBOLS',
			   36h, 'PAGING', 33h, 'TTY',
			   25h, 'MOD85', 35h, 'PRINT',
			   36h, 'OBJECT', 39h, 'MACROFILE',
			   29h, 'PAGEWIDTH', 2Ah, 'PAGELENGTH',
			   7, 'INCLUDE', 5, 'TITLE',
			   4, 'SAVE', 7, 'RESTORE',
			   5, 'EJECT', 14h, 'LIST',
			   13h, 'GEN', 14h, 'COND');

declare (b7463, b7464, b7465, b7466) byte;

declare TRUE literally '0FFh',
	FALSE literally '0';

skipWhite$2: procedure external; end;
skipWhite: procedure external; end;
skip2EOL: procedure external; end;
wrError: procedure(b) external; declare b byte; end;
sub$5EE9: procedure external; end;
sub$5F13: procedure external; end;
sub$5F19: procedure external; end;
popToken: procedure external; end;
collectIdent: procedure(b) external; declare b byte; end;
ascii2Num: procedure external; end;
collectString: procedure external; end;
isCR: procedure byte external; end;
isPhase1: procedure byte external; end;
sub$43DD: procedure address external; end;
getChX: procedure byte external; end;
xisSpace: procedure byte external; end;
isWhite: procedure byte external; end;
isRParen: procedure byte external; end;
sub$65D9: procedure external; end;


declare tokenSize literally 'toksiz',
	tokStart literally 'tokst';
declare (b6759, curChar, reget, b6898, objFile, lstFile, optTTY, optMOD85, optMACROFILE,
	 optPAGEWIDTH, optPAGELENGTH, optTITLE, optEJECT, optGEN, b6A6F, optLIST, titleLen, saveStack,
	 saveIdx, collectBufLen, b6ADB, b$905B, b$9A77, optDEBUG) byte external,
	 (optionId, collectBufIdx, scanOptions, phase, b6BDB, b6C21, b6C22, fileIdx) byte external,
	(tokenSize, aF0Asmac$tmp, options, optionSeen, optTITLESTR, collectBuf)(1) byte external,
	(w6B1E, curFileName$p, w6BE2) address external,
	files(6) structure(name(15) byte, blk address, byt address, b19 byte) external;

chkParen: procedure(arg1b) byte;
	declare arg1b byte;
	call skipWhite;
	reget = 0;
	return arg1b + '(' = curChar;
end;



collectBasicToken: procedure byte;
	collectBufLen = 0;
	b6ADB = 0;
	if isCR then
		return curChar;

	call skipWhite$2;
	if curChar > 40h and 5Bh > curChar or curChar >60h and 7Bh > curChar then
	do;
		call collectIdent(1);
		if xisSpace and tokenSize(0) < 14 then
			call move(collectBufLen := tokenSize(0), .b6759, .collectBuf);
	end;
	else if curChar > 2Fh  and  3Ah > curChar then
	do;
		call ascii2Num;
		if xisSpace then
		do;
			w6B1E = sub$43DD;
			b6ADB = 2;
			collectBuf(0) = 20h;
		end;
	end;
	else if curChar = 27h then
	do;
		call collectString;
		if xisSpace then
		do;
			collectBufLen = 40h;
			if tokenSize(0) < 40h then
				collectBufLen = tokenSize(0);
			b6ADB = 4;
			if collectBufLen > 0 then
				call move(collectBufLen, .b6759, .collectBuf);
		end;
	end;
	else
	do;
		collectBufLen = 1;
		collectBuf(0) = curChar;
		return curChar;
	end;

	call popToken;
	return collectBuf(0);
end;



sub$6F07: procedure(arg1w) byte;
	declare arg1w address;
	declare pad address;

	if collectBufIdx = 0 then
		return 0;

	collectBuf(collectBufIdx) = 20h;
	collectBufLen = collectBufIdx;
	if isWhite then
		return chkParen(1);
	return 0FFh;
end;

sub$6F39: procedure;
	call skipWhite$2;

    do while 1;
	if isRParen or isWhite then
	do;
		if sub$6F07(.collectBuf(0)) then
			return;
		goto done;
	end;

	collectBuf(collectBufIdx) = curChar;
	collectBufIdx = collectBufIdx + 1;
	if collectBufIdx > 14 then
		goto done;
	curChar = getChX;
    end;
done:
	curFileName$p = .collectBuf;
	call sub$5F19;
end;


getFileParam: procedure;
	collectBufIdx = 0;
	if not chkParen(0) then
		call sub$5F19;
	else
	do;
		call sub$6F39;
		call move(collectBufIdx + 1, .collectBuf, curFileName$p);
		if not chkParen(1) then
			call sub$5F19;
	end;
end;


getMacroFileDrive: procedure;
	call skipWhite$2;
	collectBufIdx = 0Dh;
	b6BDB = 0;

	do while not isRParen and b6BDB < 4;
		aF0Asmac$tmp(b6BDB) = curChar;
		b6BDB = b6BDB + 1;
		curChar = getChX;
	end;

	if isRParen or isWhite then
		if sub$6F07(.aF0Asmac$tmp) then
			return;
	curFileName$p = .aF0Asmac$tmp;
	collectBufIdx = 0;
	call sub$5F19;
end;




sub$702B: procedure byte;
	if chkParen(0) then
	do;
		b7463 = collectBasicToken;
		if b6ADB = 2 then
			return chkParen(1);
	end;
	return 0;
end;


lookupCmd: procedure byte;
	declare (b746C, b746D, optionSET, b746F, b7470, b7471) byte,
		(w7472, w7474, w7476) address;
	declare twoch address at(.collectBuf);
	declare ch based w7472 byte;
	declare byt based w7476 byte;

	setOption: procedure;
		if not b7471 then
		do;
			options(optionId) = optionSET;
			if not optionSET then
				optionId = 17;
		end;
	end;


	b746F = collectBufLen;
	b746D = 0;
	optionSET = 0FFh;
	if twoch = 4F4Eh then
	do;
		b746D = 2;
		optionSET = 0;
		b746F = collectBufLen - 2;
	end;

	w7472 = .b6D6E;
	optionId = 0;
	b746C = b746D;

	do while optionId < 20;
		w7474 = w7472 + (ch and 0Fh) + 1;
		if (ch and 0Fh) = b746F then
		do;
			b7470 = ch;

			do while b746C < collectBufLen;
				w7472 = w7472 + 1;
				if ch <> collectBuf(b746C) then
					b746C = collectBufLen + 1;
				else
					b746C = b746C + 1;
			end;

			if b746C = collectBufLen then
				goto L6E3C;
		end;
		w7472 = w7474;
		optionId = optionId + 1;
		b746C = b746D;
	end;
	return TRUE;

L6E3C:
	if (b7471 := (b7470 and 10h) <> 10h) and not optionSET then
		return TRUE;

	if (b7470 and 20h) <> 20h then
	do;
		call setOption;
		return optionId;
	end;

	if not b6898 then
		return TRUE;

	w7476 = .optionSeen(optionId);
	if byt then
		return TRUE;
	byt = TRUE;
	call setOption;
	return optionId;
end;

processCmd: procedure;
	if optionId >= 17 or optionId < 5 then
		return;

	do case optionId - 5;
/* 0 */		do;
			optTTY = 0FFh;	/* TTY */
			return;
		end;
/* 1 */		do;			/* MOD85 */
			optMOD85 = 0FFh;
			return;
		end;
/* 2 */		do;			/* PRINT */
			w6BE2 = 2;
			curFileName$p = .lstFile;
			call getFileParam;
			return;
		end;
/* 3 */		do;			/* OBJECT */
			w6BE2 = 3;
			curFileName$p = .objFile;
			call getFileParam;
			return;
		end;
/* 4 */		do;			/* MACROFILE */
			w6BE2 = 3;
			if chkParen(0) then
				call getMacroFileDrive;
			else
				reget = 1;
			optMACROFILE = 0FFh;
			return;
		end;
/* 5 */		do;			/* PAGEWIDTH */
			if sub$702B then
			do;
				optPAGEWIDTH = w6B1E;
				if optPAGEWIDTH > 132 then
					optPAGEWIDTH = 132;
				if optPAGEWIDTH < 72 then
					optPAGEWIDTH = 72;
				return;
			end;
		end;
/* 6 */		do;			/* PAGELENGTH */
			if sub$702B then
			do;
				optPAGELENGTH = w6B1E;
				if optPAGELENGTH < 15 then
					optPAGELENGTH = 15;
				return;
			end;
		end;
/* 7 */		do;			/* INCLUDE */
			if not b6C21 then
			do;
				w6BE2 = 1;
				if fileIdx = 5 then
					call sub$5F13;
				else
				do;
					fileIdx = fileIdx + 1;
					curFileName$p = .files(fileIdx);
					call getFileParam;
					b6C21 = 0FFh;
					if scanOptions then
						b6C22 = 0FFh;
					return;
				end;
			end;
		end;
/* 8 */		do;			/* TITLE */
			if chkParen(0) then
			do;
				b7463 = collectBasicToken;
				if b6ADB = 4 and collectBufLen <> 0 then
				do;
					if phase <> 1 or isPhase1 and b6898 then
					do;
						call move(collectBufLen, .collectBuf, .optTITLESTR);
						optTITLESTR(titleLen := collectBufLen) = 0;
						if chkParen(1) then
						do;
							optTITLE = 0FFh;
							return;
						end;
					end;
				end;
			end;
		end;
/* 9 */		do;			/* SAVE */
			if saveIdx > 7 then
				call sub$5F13;
			else
			do;
				call move(3, .optLIST, .saveStack + saveIdx * 3);
				saveIdx = saveIdx + 1;
				return;
			end;
		end;
/* 10 */	do;			/* RESTORE */
			if saveIdx > 0 then
			do;
				call move(3, .saveStack + (saveIdx := saveIdx - 1) * 3, .optLIST);
				return;
			end;
		end;
/* 11 */	do;			/* EJECT */
			optEJECT = optEJECT + 1;
			return;
		end;
	end;
	b7466 = 0FFh;
end;

sub$70D7: procedure public;

	b$9A77 = 0FFh;
	b6A6F, b7464 = optLIST;
	b7465 = optGEN;
	b7466 = 0;

	do while collectBasicToken <> 0Dh and not b7466;
		if collectBuf(0) = ';' then
			call skip2EOL;
		else if lookupCmd = 0FFh then
			b7466 = 0FFh;
		else
			call processCmd;
	end;

	if b7466 then
	do;
		if collectBuf(0) <> 0Dh then
		do;
			reget = 0;
			call skip2EOL;
		end;

		if scanOptions then
			call wrError(2);
		else
			call sub$5EE9;
	end;

	call sub$65D9;
	if optLIST <> b7464 then
		b6A6F = 0FFh;
	else if optGEN <> b7465 and b$905B then
		b6A6F = 0;

	reget = 0;
end;

end;
asm4B.pl3
asm4B:
do;

declare b$7183(*) byte data(3Fh, 0, 4, 0, 0, 0, 8, 0, 10h),
	aMacro(*) byte data('MACRO', 0);

declare w$9C75 address,
	b$9C77 byte public;


popToken: procedure external; end;
skip2EOL: procedure external; end;
skipWhite: procedure external; end;
wrError: procedure(b) external; declare b byte; end;
readM: procedure(w) external; declare w address; end;
writeM: procedure external; end;
sub$40B9: procedure external; end;
sub$467F: procedure(b, w) external; declare b byte, w address; end;
sub$5CAD: procedure(w1, b2) external; declare w1 address, b2 byte; end;
sub$5CE8: procedure(w1, b2) external; declare w1 address, b2 byte; end;
sub$5ED7: procedure external; end;
sub$5EFB: procedure external; end;
sub$5F07: procedure external; end;
sub$5F13: procedure external; end;
sub$5F1F: procedure external; end;
sub$5F25: procedure external; end;
sub$5F31: procedure external; end;
nestIFX: procedure(b) external; declare b byte; end;
sub$676D: procedure(b) external; declare b byte; end;
pushToken: procedure(b) external; declare b byte; end;
collectByte: procedure(b) external; declare b byte; end;
isCR: procedure byte external; end;
isLT: procedure byte external; end;
isWhite: procedure byte external; end;
isComma: procedure byte external; end;
isGT: procedure byte external; end;
getChX: procedure byte external; end;
sub$3C91: procedure byte external; end;
testBit: procedure(b, w) byte external; declare b byte, w address; end;
sub$43DD: procedure address external; end;
strUCequ: procedure(w1, w2) byte external; declare (w1, w2) address; end;
haveTokens: procedure byte external; end;


declare TRUE literally '0FFh',
	FALSE literally '0';

declare tokenSize literally 'toksiz',
	tokStart literally 'tokst';
declare (cZERO, c255, b$3782, b$3783, tokenSP, curChar, reget, lookAhead) byte external,
	(b6880, b6884, b6896, b689C, b6B29, opType, b6B2B, b6B2C, b6B30) byte external,
	(b6B32, b6BDA, b6BDD, b905A, b905B, b905D, b905E, b9060, b9061) byte external,
	(b9062, b9063, b9064, b9065, b9066, b9067) byte external,
	(ifDepth, macroCondSP, opSP) byte external,
	(macroBuf, tokenType, tokenSize, b6873, macroCondStk, bp6BE0, mem)(1) byte external,
	curTokenSym$p address external,
	curTokenSym based curTokenSym$p structure(w0 address, w2 address, w4 address, type byte, b7 byte),
	(curTokStart, accum1, w6866, w686E, w6870, w6BE0) address external,
	(w$9068, w906A, w9114) address external,
	(w9199, w919B, w919D, w919F) address external,
	w6868(3) address external,
	s906CStk(10) structure(macroCondSP byte, ifDepth byte, mtype byte, b3 byte,
			     w4 address, buf$p address, blk address, w10 address,
			     w12 address, w14 address) external,
	s906C structure(macroCondSP byte, ifDepth byte, mtype byte, b3 byte,
			     w4 address, buf$p address, blk address, w10 address,
			     w12 address, w14 address) external;




sub$7192: procedure byte;
	if isCR then
	do;
		b$905A = 0;
		return TRUE;
	end;

	if b$905A then
		return b$9067 = b$9066;

	if isLT or (not (s906C.mtype = 1) and isGT) then
	do;
		call sub$5F1F;
		return TRUE;
	end;

	return isWhite or isComma or isGT or curChar = 3Bh;
end;



sub$71F2: procedure;
	w6866, w6868(2) = w686E;
	b$9065, s906C.b3 = cZERO;
	b6B29 = 37h;
end;


sub$720A: procedure;

	b$9062 = s906C.mtype;
	if not b$905B then
		b$905B = 1;

	if b$9063 = 0 then
		b$905B = 0FFh;

	if b$9061 then
		call move(4, .s906CStk(0).buf$p, .s906CStk(b$9063).buf$p);

	b$9061 = 0;
	s906C.w12 = w$9199;
	s906C.w4 = w$919B;
	w$919B = w$919B + s906C.b3;
	call readM(s906C.w10);
	s906C.buf$p = .macroBuf;
end;


sub$727F: procedure byte;
	if not b$905E then
		return TRUE;
	b$9064 = b$9064 + 1;
	b6B2C = b6B2B <> 3Eh;
	b6B29 = 37h;
	return FALSE;
end;


sub$72A4: procedure(arg1b) public;	/* 1 -> IRP, 2 -> IRPC */
	declare arg1b byte;

	if sub$727F then
	do;
		call sub$71F2;
		call nestIFX(1);
		s906C.w14 = 0;
		s906C.mtype = arg1b;
	end;
end;

sub$72C4: procedure;
	declare b$9C79(6) byte;

	call pushToken(0Dh);
	b6BDD = 0;

L72CE:
	b$9C79(b6BDD := b6BDD + 1) = accum1 mod 10 + '0';
	if (accum1 := accum1 / 10) > 0 then
		goto L72CE;

	do while b6BDD > 0;
		call collectByte(b$9C79(b6BDD));
		b6BDD = b6BDD - 1;
	end;
end;


sub$7327: procedure public;
	w$9199 = w6870;
	b6B29 = 3Dh;
	b$905D = 0FFh;
	b$9060 = 0;
end;


sub$733D: procedure(arg1w, arg2w) address;
	declare (arg1w, arg2w) address;
	declare ch1 based w6870 byte,
		ch2 based arg2w byte;

	do while arg1w <= arg2w;
		if w6870 <= w686E then
			call wrError(1);
		ch1 = ch2;
		w6870 = w6870 - 1;
		arg2w = arg2w - 1;
	end;
	return w6870;
end;


sub$7383: procedure;
	b$9064 = 1;
	w$906A = w686E;
	b$905E = 1;
	w$9C75 = w$9114;
end;



sub$739A: procedure;
	if b6884 then
		if b6896 <> 55h then
			call sub$5F31;
end;


sub$73AD: procedure public;
	declare b$9C83 byte;

	b$9C77 = tokenSP;
	call skipWhite;
	if not (b$9C83 := curChar = 25h) then
	do;
		b$9066 = b$9067 - 1;
		if (b$905A := isLT) then
			curChar = getChX;

		call pushToken(0Dh);

	L73E2:	do while not sub$7192;
			if curChar = 27h then
			do;
				if (curChar := getChX) = 27h then
				do;
					curChar = getChX;
					call skipWhite;
					if sub$7192 then
						goto L7463;
					else
					do;
						call collectByte(27h);
						call collectByte(27h);
					end;
				end;
				else
				do;
					call collectByte(27h);
					goto L73E2;
				end;
			end;
			call collectByte(curChar);
			if s906C.mtype = 2 then
				s906C.w14 = s906C.w14 + 1;

			if curChar = 21h and getChX <> 0Dh then
			do;
				call collectByte(curChar);
				curChar = getChX;
			end;
		end;

	L7463:	if b$905A then
			curChar = getChX;

		call skipWhite;
		if isGT then
		do;
			curChar = getChX;
			call skipWhite;
		end;

		reget = 1;
	end;

	b$905D = 0;
	if s906C.mtype = 4 then
	do;
		if not b$905A and tokenSize(0) = 5 then
			if strUCequ(.aMacro, curTokStart) then
			do;
				b6B29 = 36h;
				call popToken;
				w$9199 = s906C.w12;
				opSP = opSP - 1;
				reget = 1;
				call sub$467F(0, .b6873);
				b6880 = 0;
				b6BDA = 0FFh;
				return;
			end;
		s906C.mtype = b$9062;
		call nestIFX(1);
		s906C.mtype = 0;
	end;

	if not b$9C83 then
		if not testBit(curChar, .b$7183) then
		do;
			call skip2EOL;
			call sub$5ED7;
			reget = 1;
		end;
end;



sub$7517: procedure public;
	if sub$727F then
	do;
		b6B30 = 0;
		w$9068 = curTokenSym$p + 4;
		call sub$5CE8(0, 3Ah);
		s906C.mtype = 0;
		call sub$71F2;
	end;
end;

sub$753E: procedure public;
	declare ch based w$9068 byte;

	if haveTokens then
	do;
		if tokenType(0) = 0 then
			call sub$5EFB;

		call sub$5CAD((b$9065 := b$9065 + 1), 0);
	end;
	else if not (s906C.mtype = 0) then
		call sub$5ED7;

	if not s906C.mtype = 0 then
	do;
		call skipWhite;
		if isComma then
		do;
			reget = 0;
			opType = 0;
			call sub$7327;
			if s906C.mtype = 1 then
			do;
				curChar = getChX;
				call skipWhite;
				if not isLT then
				do;
					call sub$5ED7;
					reget = 1;
				end;
			end;
		end;
		else
		do;
			call sub$5ED7;
			call sub$7383;
		end;
	end;
	else if opType = 1 then
	do;
		if not sub$3C91 then
		do;
			s906C.mtype = 5;
			w$9068 = w$9068 + 2;
			if (ch and 7Fh) = 3Ah then
				ch = (b6896 = 4Ch) and 80h or 9;
		end;
		call sub$7383;
	end;
end;

sub$75FF: procedure public;
	declare ch based w$906A byte;
	declare ch2 based w$9068 byte;
	declare wrd based w$9068 address;

	if b$905E then
	do;
		if (b$9064 := b$9064 - 1) = 0 then
		do;
			b$905E = 0;
			if not (s906C.mtype = 5) then
			do;
				if s906C.mtype = 2 then
					w$9199 = w6870 + 3;

				do w6BE0 = w$919D to w$919F - 1;
					curChar = mem(w6BE0);
					if not isWhite then
						call sub$5ED7;
				end;

				w$906A = w$919D;
				ch = 1Bh;
				call sub$40B9;
				call writeM;
				w686E, w6868(2) = w6866;
				if s906C.mtype = 0 then
				do;
					wrd = w$9C75;
					w$9068 = w$9068 + 3;
					ch2 = s906C.b3;
				end;
				else
				do;
					s906C.w10 = w$9C75;
					call sub$720A;
					if s906C.w14 = 0 then
						call sub$676D(1);
				end;
			end;
		end;
	end;
	else
		call sub$5F07;
end;


sub$76CE: procedure public;
	if b$905B then
	do;
		if opType = 1 then
		do;
			b6B32 = 0FFh;
			macroCondSP = s906C.macroCondSP;
			ifDepth = s906C.ifDepth;
			s906C.w14 = 1;
			lookAhead = 1Bh;
			macroCondStk(0) = 1;
		end;
		else
			call sub$5ED7;
	end;
	else
		call sub$5F07;
end;


sub$770B: procedure public;
	if b$9C77 + 1 <> tokenSP then
		call sub$5ED7;
	else if not b$9060 then
	do;
		if tokenType(0) <> 0Dh then
		do;
			accum1 = sub$43DD;
			call sub$72C4;
		end;

		if s906C.mtype = 2 then
			s906C.w14 = tokenSize(0) - (tokenSize(0) = 0);

		call collectByte((tokenSize(0) + 1) or 80h);
		w6870 = sub$733D(curTokStart, curTokStart + tokenSize(0) - 1);
		call popToken;

		if s906C.mtype = 0 or s906C.mtype = 1 and b$9067 > 0 then
			b$905D = 0FFh;
		else
			b$9060 = 0FFh;

		if s906C.mtype = 1 then
			s906C.w14 = s906C.w14 + 1;
	end;
	else
		call sub$5ED7;

	if opType = 1 then
	do;
		b$905D = 0;
		if b$9067 > 0 then
			call sub$5F25;

		if not sub$3C91 then
		do;
			call sub$739A;
			if s906C.mtype = 0 then
			do;
				call sub$720A;
				call sub$676D(1);
				return;
			end;
			else
				s906C.w14 = 0;
		end;
		else
		do;
			w6870 = sub$733D(.b$3782, .b$3783);
			if s906C.mtype = 0 then
			do;
				s906C.b3 = curTokenSym.b7;
				s906C.w10 = sub$43DD;
				call sub$720A;
			end;
			else if s906C.w14 = 0 then
				call sub$5ED7;
		end;

		if not (s906C.mtype = 0) then
			call sub$7383;
	end;
end;



sub$7844: procedure public;
	call sub$72A4(3);
	if (b6B29 := opType) <> 1 then
		call sub$5ED7;

	if not b$905E then
	do;
		s906C.w14 = accum1;
		if not sub$3C91 then
		do;
			call sub$739A;
			s906C.w14 = 0;
		end;

		call sub$7383;
	end;
end;


sub$787A: procedure public;
	if b$905E = 2 then
	do;
		if haveTokens then
		do;
			if (s906C.b3 := s906C.b3 + 1) = 0 then
				call sub$5F13;

			if tokenType(0) <> 9 then
				call sub$5EFB;

			call sub$5CAD(s906C.b3, 1);
			w$906A = w686E;
		end;
		if opType = 1 then
		do;
			b$905E = 1;
			w$906A = w686E;
		end;
	end;
	else
		call sub$5ED7;
end;



sub$78CE: procedure public;
	b6BDD = mem(s906C.w12);
	bp6BE0(0) = 1 - (b6BDD = 21h and b$9062 = 2);
	if b$9062 = 0 or (s906C.w14 := s906C.w14 - bp6BE0(0)) = 0 then
		call sub$676D(1);
	else
	do;
		if b$9062 = 1 then
			w$9199 = s906C.w12 - (b6BDD and 7Fh);
		else
			w$9199 = s906C.w12 + bp6BE0(0);

		s906C.mtype = b$9062;
		call sub$720A;
	end;
	lookAhead = 0;
	b6B2C, b689C = c255;
end;

end;
asm4C.pl3
asm4C:
do;

declare rec18a structure(type byte, len address, dta(1) byte) external,
	rec16 structure(type byte, len address, seg byte, dta(1) address) external,
	rec22 structure(type byte, len address, seg byte, fixtype byte, dta(1) address) external,
	rec24 structure(type byte, len address, seg byte, fixtype byte, dta(1) address) external,
	rec20 structure(type byte, len address, fixtype byte, dta(1) address) external, 
	rec18 structure(type byte, len address, dta(1) byte) external,
	rec06 structure(type byte, len address, seg byte, addr address, dta(1) byte) external,
	rec04 structure(type byte, len address, subtype byte, seg byte, addr address, crc byte) external;

declare	b6D6E(*) byte data(1, 2, 1, 3),
	off$6D72(*) address data(.rec16.len, .rec24.len, .rec20.len, .rec06.len),
	b6D7A(*) byte data(7Bh, 3Ah, 39h, 7Ch),
	b6D7E(*) byte data(0Ah, 12h, 40h);


declare	rec02 structure(type byte, len address, b0 byte, dta(25) byte) initial(2),
	(w758B$p, w758D$p) address;




ioErrChk: procedure external; end;
seek: procedure(w1, w2, w3, w4, w5) external; declare (w1, w2, w3, w4, w5) address; end;
write: procedure(w1, w2, w3, w4) external; declare (w1, w2, w3, w4) address; end;
unpackToken: procedure(w1, w2) external; declare (w1, w2) address; end;
sub$3FA9: procedure byte external; end;
testBit: procedure(b, w) byte external; declare b byte, w address; end;
sub$4646: procedure byte external; end;
isSkipping: procedure byte external; end;

declare tokenSize literally 'toksiz',
	tokStart literally 'tokst';
declare	(b6521, b6524, b6525, b652A, b652F) byte external,
	(moduleNameLen, b6744, b6745, activeSeg, b6755, b689A, b6A56, optDEBUG) byte external,
	(b6B23, b6B24, b6B33, b6B34, b6BDB) byte external,
	curTokenSym$p address external,
	curTokenSym based curTokenSym$p structure(w0 address, w2 address, w4 address, type byte, b7 byte),
	symb based curTokenSym$p(1) byte,
	(statusIO, w651F, w6522, w6750, w6752, startAddr, objfd) address external,
	(w68A0, w68A2, w6BD3) address external,
	(rec0E, b6526, b652B, b674C, aModulePage, tokenSize, tokenAttr, b6873)(1) byte external,
	(w6868, w6B41, symTab, tokStart, tokenSymId, segSize)(1) address external;



writeRec: procedure(arg1w) public;
	declare arg1w address,
		w7591 address, w7593 address,
		b7595 byte, b7596 byte;
	declare wrd based w7591 address;
	declare ch based w7591 byte;

	w7591 = arg1w + 1;
	w7593 = (wrd := wrd + 1) + 3;	
	b7596 = 0;
	w7591 = w7591 - 1;
	do b7595 = 2 to w7593;
		b7596 = b7596 - ch;
		w7591 = w7591 + 1;
	end;
	ch = b7596;
	call write(objfd, arg1w, w7593, .statusIO);
	call ioErrChk;
end;


sub$6DF1: procedure byte;
	declare b7597 byte;
	if ((b7597 := tokenAttr(b6A56)) and 5Fh) = 0 then
		return 3;
	if (b7597 and 40h) <> 0 then
		return 2;
	if (b6521 := b7597 and 7) = 0 then
		return 3;
	return (b6521 <> activeSeg) and 1;
end;


sub$6E32: procedure public;
	declare b7598 byte;
	declare wrd based w758B$p address;
	do b7598 = 0 to 3;
		b6BDB = (b7598 - 1) and 3;
		w758B$p = off$6D72(b6BDB);
		if wrd > b6D6E(b6BDB) then
			call writeRec(w758B$p - 1);

		wrd = b6D6E(b6BDB);
		b6526(b6BDB) = 0;
		if b6525 <>  b6BDB then
			b652B(b6BDB) = 0FFh;
	end;
	rec06.addr = w6752 + segSize(rec06.seg := activeSeg);
	rec16.seg = b6524;
	rec24.seg = tokenAttr(b6A56) and 7;
	rec24.fixtype, rec20.fixtype = b6524;
end;



sub$6EE1: procedure;
	declare w7599 address;

	declare wrd based w758B$p address;

	w758B$p = off$6D72(b6525 := sub$6DF1);
	if wrd > b6D7A(b6525) or rec06.len + tokenSize(b6A56) > 7Ch then
		call sub$6E32;

	if b652F then
	do;
		b652F = 0;
		rec06.addr = segSize(rec06.seg := activeSeg) + w6752;
	end;
	else if rec06.seg <> activeSeg or (w7599 := rec06.addr + b6526(3)) <> segSize(activeSeg) + w6752
	  or w7599 < rec06.addr then
		call sub$6E32;


	do case b6525;
/* 0 */		do;
			if b652B(0) then
			do;
				b652B(0) = 0;
				rec16.seg = b6524;
			end;
			else if rec16.seg <> b6524 then
				call sub$6E32;
		end;
/* 1 */		do;
			if b652B(1) then
			do;
				b652B(1) = 0;
				rec24.seg = tokenAttr(b6A56) and 7;
				rec24.fixtype = b6524;
			end;
			else if rec24.fixtype <> b6524 or (tokenAttr(b6A56) and 7) <> rec24.seg then
				call sub$6E32;
		end;
/* 2 */		do;
			if b652B(2) then
			do;
				b652B(2) = 0;
				rec20.fixtype = b6524;
			end;
			else if rec20.fixtype <> b6524 then
				call sub$6E32;

		end;
/* 4 */		;
	end;
end;


sub$704D: procedure;
	declare b759B byte;

	declare ch based w651F byte;
	do b759B = 1 to tokenSize(b6A56);
		rec06.dta(b6526(3)) = ch;
		b6526(3) = b6526(3) + 1;
		w651F = w651F + 1;
	end;
	rec06.len = rec06.len + tokenSize(b6A56);
end;



sub$709D: procedure;
	rec16.len = rec16.len + 2;
	rec16.dta(b6526(0)) = w6522;
	b6526(0) = b6526(0) + 1;
end;


sub$70C1: procedure;
	rec24.len = rec24.len + 2;
	rec24.dta(b6526(1)) = w6522;
	b6526(1) = b6526(1) + 1;
end;

sub$70E5: procedure;
	rec20.dta(b6526(2)) = tokenSymId(b6A56);
	rec20.dta(b6526(2) + 1) = w6522;
	rec20.len = rec20.len + 4;
	b6526(2) = b6526(2) + 2;
end;

sub$7131: procedure;
	b6524 = shr(tokenAttr(b6A56) and 18h, 3);
	w6522 = segSize(activeSeg) + w6752;
	if not (b6B23 or b6B24) and (tokenSize(b6A56) = 2 or tokenSize(b6A56) = 3) then
		w6522 = w6522 + 1;
	call sub$6EE1;
	w651F = w68A2;
	call sub$704D;
	do case sub$6DF1;
/* 0 */ 	call sub$709D;
/* 1 */		call sub$70C1;
/* 2 */		call sub$70E5;
/* 3 */		;
	end;
end;


ovl2: procedure public;
	declare b759C byte;

	if rec18a.len + 9 > 7Dh then
	do;
		call writeRec(.rec18a);
		rec18a.type = 18h;
		rec18a.len = 0;
		b652A = 0;
	end;
	rec18a.len = rec18a.len + b6744 + 2;
	rec18a.dta(b652A) = b6744;
	b652A = b652A + 1;
	do b759C = 0 to b6744;
		rec18a.dta(b652A + b759C) = b6873(b759C);
	end;

	rec18a.dta(b652A + b6744) = 0;
	b652A = b652A + b6744 + 1;
end;


sub$725E: procedure(arg1b);
	declare arg1b byte;
	declare b759E byte;

	sub$72EC: procedure;
		declare w759F address;
		declare b758B based w758B$p(6) byte;
		declare b758D based w758D$p(1) byte;
		declare w758D based w758D$p address;
		declare wrd based w759F address;
		declare ch based w758D$p byte;

		if (symb(1) and 40h) <> 0 then
			return;
		w759F = curTokenSym$p - 2;
		w758D = wrd; 
		call unpackToken(curTokenSym$p - 6, (w758B$p := (w758D$p := w758D$p + 2) + 1));
		b758B(6) = ' ';
		ch = 0;

		do while b758B(0) <> ' ';
			b758D(0) = b758D(0) + 1;
			w758B$p = w758B$p + 1;
		end;
		b758B(0) = 0;
		w758D$p = w758B$p + 1;
	end;

	sub$7359: procedure;
		if (rec16.len := w758D$p - .rec16.seg) > 1 then
			call writeRec(.rec16);
		rec16.type = (arg1b and 4) or 12h;
		rec16.seg = b759E;
		w758D$p = .rec16.dta;
	end;

	w758D$p = .rec16.dta;
	do b759E = 0 to 4;
		call sub$7359;
		curTokenSym$p = symTab(1) - 2;
	
		do while (curTokenSym$p := curTokenSym$p + 8) < w6868(1);
			if w758D$p > .rec16.dta(57) then
				call sub$7359;

			if (symb(1) and 7) = b759E and symb(0) <> 3Ah and sub$3FA9
			  and not testBit(symb(0), .b6D7E) and (not arg1b or (symb(1) and 20h) <> 0) then
				call sub$72EC;
		end;
		call sub$7359;
	end;
end;

writeRec02: procedure public;
	declare wrd based w758B$p address;
	declare ch based w758B$p byte;
	declare b75A1 byte;

	call move((rec02.b0 := moduleNameLen), .aModulePage, .rec02.dta);
	w758B$p = .rec02 + moduleNameLen + 4;
	wrd = 0;
	w758B$p = w758B$p + 1;
	if segSize(1) < w6B41(1) then
		segSize(1) = w6B41(1);
	if segSize(2) < w6B41(2) then
		segSize(2) = w6B41(2);

	do b75A1 = 1 to 4;
		w758B$p = w758B$p + 1;
		ch = b75A1;
		w758B$p = w758B$p + 1;
		wrd = segSize(b75A1);
		w758B$p = w758B$p + 2;
		ch = b674C(b75A1 - 1);
	end;
	rec02.len = moduleNameLen + 13h;
	call writeRec(.rec02);
end;


writeRec040E: procedure public;
	rec04.subtype = b6755;
	rec04.seg = b6745;
	rec04.addr = startAddr;
	call writeRec(.rec04);
	rec0E(1) = 0;
	call writeRec(.rec0E);
end;

ovl8: procedure public;
	w6752 = 0;
	b689A = 1;
	b6A56 = 1;
	if b6B33 then
		;
	else
	do while b6A56 <> 0;
		b6A56 = sub$4646;
		w68A0 = tokStart(b6A56) + tokenSize(b6A56);
		w68A2 = tokStart(b6A56);
		if isSkipping or not b6B34 then
			w68A0 = w68A2;
		if w68A0 > w68A2 then
		do;
			call sub$7131;
			w6752 = w6752 + tokenSize(b6A56);
		end;
		if not(b6B23 or b6B24) then
			b6A56 = 0;
	end;
end;


ovl11: procedure public;
	declare myrec16 structure(type byte, len address, seg byte, b1 byte) at (.rec16);
	if w6750 <> 0 then
	do;
		call seek(objfd, 2, .w6BD3, .w6BD3, .statusIO);		/* SEEKABS */
		call writeRec02;
		call seek(objfd, 4, .w6BD3, .w6BD3, .statusIO);		/* SEEKEND */
	end;
	rec22.type = 16h;
	rec22.len = 1;
	rec22.seg = 0;
	rec22.fixtype = 0;
	call sub$725E(0FFh);
	if optDEBUG then
		call sub$725E(0);
end;

end;
asm4D.pl3
asm4D:
do;

declare
    aAssemblyComple(*) byte initial(0Dh, 0Ah, 'ASSEMBLY COMPLETE,'),
    aNoErrors(*) byte initial('   NO ERRORS'),
    asc$751E(*) byte initial(' ('),
    asc$7520(*) byte initial('     )'),
    aPublicSymbols(*) byte initial(0Dh, 0Ah, 'PUBLIC SYMBOLS', 0Dh, 0Ah, 0),
    aExternalSymbol(*) byte initial(0Dh, 0Ah, 'EXTERNAL SYMBOLS', 0Dh, 0Ah, 0),
    pad754E address,

    aUserSymbols(*) byte data(0Dh, 0Ah, 'USER SYMBOLS', 0Dh, 0Ah, 0),
    aLocObjLineSour(*) byte data('  LOC  OBJ         LINE        SOURCE STATEMENT', 0Dh, 0Ah, 0Ah, 0),
    wa6DB2(*) address data(.aPublicSymbols, .aExternalSymbol, .aUserSymbols),
    asc$6DB8(*) byte data(0Dh, 0Ah, 0Ah, 0),
    asc$6DBC(*) byte data(0Dh),
    asc$6DBD(*) byte data(0Ah, 0Ah, 0Ah, 0),
    b6DC1(2) byte data(20h, 40h),
    asc$6DC3(*) byte data(' (', 0),
    asc$6DC6(*) byte data(')', 0),
    a1234(*) byte data('  1234');    



declare rec18a structure(type byte, len address, dta(1) byte) external,
	rec16 structure(type byte, len address, seg byte, dta(1) address) external,
	rec22 structure(type byte, len address, seg byte, fixtype byte, dta(1) address) external,
	rec24 structure(type byte, len address, seg byte, fixtype byte, dta(1) address) external,
	rec20 structure(type byte, len address, fixtype byte, dta(1) address) external, 
	rec18 structure(type byte, len address, dta(1) byte) external,
	rec06 structure(type byte, len address, seg byte, addr address, dta(1) byte) external,
	rec04 structure(type byte, len address, subtype byte, seg byte, addr address, crc byte) external;



delete: procedure(w1, w2) external; declare (w1, w2) address; end;
exit: procedure external; end;
flushout: procedure external; end;
ioErrChk: procedure external; end;
load: procedure(w1, w2, w3, w4, w5) external; declare (w1, w2, w3, w4, w5) address; end;
outch: procedure(ch) external; declare ch byte; end;
closeF: procedure(w) external; declare w address; end;
put2Hex: procedure(w1, w2) external; declare (w1, w2) address; end;
sub$546F: procedure external; end;
isPhase2Print: procedure byte external; end;
sub$3FA9: procedure byte external; end;
sub$465B: procedure byte external; end;
isSkipping: procedure byte external; end;
unpackToken: procedure(w1, w2) external; declare (w1, w2) address; end;
physmem: procedure address external; end;
xisSpace: procedure byte external; end;




declare tokenSize literally 'toksiz',
	tokStart literally 'tokst';
declare (aF0Asmac$tmp, aF0Asxref, aF0Asxref$tmp, aIsisIi80808085, b3680)(1) byte external,
	(b3694, b3696, b3689, b3692, objFile, lstFile, tokenSize, tokenAttr, b68AE)(1) byte external,
	(b68B8, asciiLineNo, b6A57, optionSeen, optTITLESTR, b8FD5, cmdLineBuf)(1) byte external,
	(cZERO, c255, activeSeg, b6857, curChar, lookAhead, b6882) byte external,
	(b6896, b6898, b689B, curCol, b68AB, b68AD, b6A56, optDEBUG, optMACRODEBUG) byte external,
	(optXREF, optSYMBOLS, optPAGING, optTTY, optPRINT, optOBJECT, optPAGEWIDTH, optPAGELENGTH, optTITLE) byte external,
	(optEJECT, optLIST, optGEN, optCOND, b6A6F, titleLen, saveIdx, scanOptions, b6B23) byte external,
	(opType, b6B2C, b6B2E, b6B33, b6B34, b6BDB, b6BDD, b6C21, fileIdx) byte external,
	(b6C30, b905B, b905C, b905E, b9063, b9064, b6742, b6743) byte external,
	b674A(2) byte external,
	(b9A77, b6B24) byte external,
	(cmdch$p, actRead, off$6C25, off$6C2C, off$6C2E, outfd, statusIO) address external,
	curTokenSym$p address external,
	curTokenSym based curTokenSym$p structure(w0 address, w2 address, w4 address, type byte, b7 byte),
	(w6750, w686E, w6870, objfd) address external,
	(infd, macrofd, w68A0, w68A2, lineCnt, w68A6, pageCnt, endOutBuf) address external,
	(w6A4E,  errCnt, w6BD3) address external,
	(options$p, includefd, rootfd, off$9056, curMacroBlk, w9114, w919B, w673F) address external,
	(w6868, w6B41, segSize, symTab, tokStart)(1) address external,
	CR literally '0Dh';




out2Hex: procedure(arg1b);
    declare arg1b byte;
    call put2Hex(.outch, arg1b);
end;


print2Hex: procedure(arg1b);
    declare arg1b byte;
    call put2Hex(.printChar, arg1b);
end;



printStr: procedure(arg1w) reentrant;
    declare arg1w address;
    declare ch based arg1w byte;

    do while ch <> 0;
        call printChar(ch);
        arg1w = arg1w + 1;
    end;
end;

printNStr: procedure(arg1b, arg2w) reentrant;
    declare arg1b byte, arg2w address;
    declare ch based arg2w byte;

    do while arg1b > 0;
        call printChar(ch);
        arg2w = arg2w + 1;
        arg1b = arg1b - 1;
    end;
end;


printCRLF: procedure reentrant;
    call printChar(0Dh);
    call printChar(0Ah);
end;

declare asc$7752 byte initial(' '),
    asc$7553(*) byte initial('    ', 0);


itoa: procedure(arg1w, arg2w);
    declare (arg1w, arg2w) address;
    declare ch based arg2w byte;

    call move(5, .b3692 + 1, arg2w);
    arg2w = arg2w + 4;

    do while 1;
        ch = arg1w mod 10 + '0';
        arg2w = arg2w - 1;
        if (arg1w := arg1w /10) = 0 then
            return;
    end;
end;


printDecimal: procedure(arg1w) reentrant public;
    declare arg1w address;
    call itoa(arg1w, .asc$7752);
    call printStr(.asc$7553);
end;

skipToEOP: procedure public;
    do while lineCnt <= optPAGELENGTH;
        call outch(0Ah);
        lineCnt = lineCnt + 1;
    end;
end;


newPageHeader: procedure public;    
    call printStr(.asc$6DBD);
    call printStr(.aIsisIi80808085);
    call printDecimal(pageCnt);
    call printCRLF;
    if optTITLE then
        call printNStr(titleLen, .optTITLESTR);

    call printCRLF;
    call printCRLF;
    if not b68AE(0) then
        call printStr(.aLocObjLineSour);
    pageCnt = pageCnt + 1;
end;


newPage: procedure public;
    if optTTY then
        call skipToEOP;
    else
        call outch(0Ch);

    lineCnt = 1;
    if not scanOptions then
        call newPageHeader;
end;


sub$6F4D: procedure public;
    if sub$465B then
    do while optEJECT > 0;
        call newPage;
        optEJECT = optEJECT - 1;
    end;
end;




printChar: procedure(arg1b) reentrant;
    declare ch byte, arg1b byte;

    if arg1b = 0Ch then
    do;
        call newPage;
        return;
    end;

    if arg1b = 0Ah then
        if optPAGING then
        do;
            if (lineCnt := lineCnt + 1) >= optPAGELENGTH - 2 then
            do;
                if optTTY then
                    call outch(0Ah);
                if optEJECT > 0 then
                    optEJECT = optEJECT - 1;
                call newPage;
                return;
            end;
        end;

    if arg1b = 0Dh then
        curCol = 0;

    ch = 1;
    if arg1b = 9 then
    do;
        ch = 8 - (curCol and 7);
        arg1b = ' ';
    end;

    do while ch <> 0;
        if curCol < 132 then
        do;
            if arg1b >= ' ' then
                curCol = curCol + 1;
            if curCol > optPAGEWIDTH then
            do;
                call printCRLF;
                call printStr(.b3680);
                curCol = curCol + 1;
            end;
            call outch(arg1b);
        end;
        ch = ch - 1;
    end;
end;

declare b755C(*) byte initial(' CDSME');

sub$8447: procedure public;
    declare b7562 byte,
        w7563 address,
        b7563 byte at(.w7563),
        b7564 byte at(.w7563 + 1),
        b7565 byte;

    sub$718C: procedure(arg1w);
        declare arg1w address;
        declare ch based curTokenSym$p byte;

        curTokenSym$p = curTokenSym$p - 1;
        call arg1w(ch and not b7565);
    end;


    b68AE(0) = 0FFh;
    if not optSYMBOLS then
        return;

    b755C(0) = 'A';
    do b7562 = 0 to 2;
        b6BDD = isPhase2Print and optSYMBOLS;
        optDEBUG = optDEBUG or optMACRODEBUG;
        curTokenSym$p = symTab(1) - 2;
        call printCRLF;
        call printStr(wa6DB2(b7562));

        do while (curTokenSym$p := curTokenSym$p + 8) < w6868(1);
            w7563 = curTokenSym.w0;
            if b7563 <> 9 then
                if b7563 <> 6 then
                    if sub$3FA9 then
                        if b7562 <> 0 or b7563 <> 3 then
                            if b7562 = 2 or (b7564 and b6DC1(b7562)) <> 0 then
                            do;
                                call unpackToken(curTokenSym$p - 6, .b68AE(1));
                                if b6BDD then
                                do;
                                    if (optPAGEWIDTH - curCol) < 11h then
                                        call printCRLF;

                                    call printStr(.b68AE(1));
                                    call printChar(20h);
                                    if b7563 = 3Ah then
                                        call printChar(2Bh);
                                    else if (b7565 := (b7564 and 40h) <> 0) then
                                        call printChar(45h);
                                    else
                                        call printChar(b755C(b7564 and 7));

                                    call printChar(20h);
                                    call sub$718C(.print2Hex);
                                    call sub$718C(.print2Hex);
                                    curTokenSym$p = curTokenSym$p + 2;
                                    call printStr(.b3694);
                                end;
                            end;
        end;
    end;

    if optDEBUG then
        b68AE(0) = 0;

    if b6BDD then
        call printCRLF;
end;

printCmdLine: procedure public;
    declare ch based actRead byte;

    call outch(0Ch);
    call sub$6F4D;
    ch = 0;
    call printStr(.cmdLineBuf);
    call newPageHeader;
end;


outStr: procedure(arg1w) reentrant public;
    declare arg1w address;
    declare ch based arg1w byte;

    do while ch <> 0;
        call outch(ch);
        arg1w = arg1w + 1;
    end;
end;

outNStr: procedure(arg1b, arg2w) reentrant;
    declare arg1b byte, arg2w address,
        ch based arg2w byte;

    do while arg1b > 0;
        call outch(ch);
        arg2w = arg2w + 1;
        arg1b = arg1b - 1;
    end;
end;


sub$721E: procedure byte public;
    return w68A2 < w68A0;
end;



sub$7229: procedure public;
    declare ch based w68A2 byte;
    declare b7568 byte;

    if (b68AB := sub$721E or b68AB) then
    do;
        call out2Hex(high(w68A6));
        call out2Hex(low(w68A6));
    end;
    else
        call outStr(.b3692 + 2);

    call outch(' ');
    do  b7568 = 1 to 4; 
        if sub$721E and b6B34 then
        do;
            w68A6 = w68A6 + 1;
            call out2Hex(ch);
        end;
        else
            call outStr(.b3692 + 4);

        w68A2 = w68A2 + 1;
    end;

    call outch(' ');
    if shr(b6BDD := tokenAttr(b6A56), 6) then
        call outch('E');
    else if not b68AB then
        call outch(' ');
    else
        call outch(b755C(b6BDD and 7));
end;


sub$72D8: procedure public;
    if not b689B then
        return;

    call printStr(.asc$6DC3);    /* " (" */
    call printNStr(4, .b6A57);
    call printStr(.asc$6DC6);    /* ")" */
    call printCRLF;
    call move(4, .asciiLineNo, .b6A57);
end;



sub$872E: procedure public;
    declare ch based off$9056 byte,
        ch1 based off$6C2C byte;
loop:

   
    w68A0 = (w68A2 := tokStart(b6A56)) + tokenSize(b6A56);
    if isSkipping then
        w68A0 = w68A2;

    call outch(b6896);
    if b$905E = 0FFh then
        call outch(2Dh);
    else
        call outch(20h);

    if not xisSpace then
    do;
        b6896 = 20h;
        b689B = 0FFh;
    end;
    if b$9A77 then
        call outStr(.b3689);
    else
        call sub$7229;

    if fileIdx > 0 then
    do;
        call outch(a1234(b6BDB := b6C21 + fileIdx));
        if b6BDB > 0 then    
            call outch(3Dh);
        else
            call outch(20h);
    end;
    else
        call outStr(.b3696);

    if b68AD then
    do;
        call outStr(.b3694);
        call printCRLF;
    end;
    else
    do;
        b68AD = 0FFh;
        call outNStr(4, .asciiLineNo);
        if b$905B > 1 then
            call outch(2Bh);
        else
            call outch(20h);

        if b$905B > 1 then
        do;
            curCol = 18h;
            ch = 0;
            call printStr(.b$8FD5);
            call printChar(0Ah);
        end;
        else
        do;
            curCol = 18h;
            call printNStr(b6C30, off$6C2E);
            if ch1 <> 0Ah then
                call printChar(0Ah);
        end;
    end;

    if b$9A77 then
    do;
        if optPAGING then
            call sub$6F4D;
    end;
    else
    do;
        do while sub$721E;
            call outStr(.b3696);
            call sub$7229;
            call printCRLF;
        end;

        if b6A56 > 0 and (b6B23 or b6B24) then
        do;
            call sub$546F;
            goto loop;
        end;
    end;

    call sub$72D8;
end;

asmComplete: procedure public;
    if errCnt > 0 then
        call itoa(errCnt, .aNoErrors);
    call printNStr((errCnt = 1) + 32, .aAssemblyComple);
    if errCnt > 0 then
    do;
        call move(4, .b6A57, .asc$7520);
        call printNStr(8, .asc$751E);
    end;
    call outch(0Dh);
    call outch(0Ah);
end;

ovl9: procedure public;
    if optPRINT then
        call closeF(outfd);
    outfd = 0;
    lineCnt = 1;
    call asmComplete;
    call flushout;
end;

sub$8915: procedure public;
    declare ch based w68A6 byte;

    call closeF(infd);
    call closeF(macrofd);
    call delete(.aF0Asmac$tmp, .statusIO);
    if optOBJECT then
        call closeF(objfd);

    if optXREF then
    do;
        w68A6 = physmem - 1;
        ch = '0';
        if aF0Asxref$tmp(0) = ':' then
            ch = aF0Asxref$tmp(2);
    
        call load(.aF0Asxref, 0, 1, 0, .statusIO);
        call ioErrChk;
    end;

    call exit;
end;
end;
asm4E.plm
asm4E:
do;

declare rec18a structure(type byte, len address, dta(1) byte) external,
	rec16 structure(type byte, len address, seg byte, dta(1) address) external,
	rec22 structure(type byte, len address, seg byte, fixtype byte, dta(1) address) external,
	rec24 structure(type byte, len address, seg byte, fixtype byte, dta(1) address) external,
	rec20 structure(type byte, len address, fixtype byte, dta(1) address) external, 
	rec18 structure(type byte, len address, dta(1) byte) external,
	rec06 structure(type byte, len address, seg byte, addr address, dta(1) byte) external,
	rec04 structure(type byte, len address, subtype byte, seg byte, addr address, crc byte) external;


declare tokenSize literally 'toksiz',
	tokStart literally 'tokst';
declare (aF0Asmac$tmp, aF0Asxref, aF0Asxref$tmp, aIsisIi80808085, b3680)(1) byte external,
	(b3694, b3696, b3689, b3692, objFile, lstFile, tokenSize, tokenAttr, b68AE)(1) byte external,
	(b68B8, asciiLineNo, b6A57, optionSeen, optTITLESTR, b8FD5, cmdLineBuf,
	 macroCondStk, opStack, b674A)(1) byte external,
	(cZERO, c255, activeSeg, b6857, curChar, lookAhead, b6882) byte external,
	(b6896, b6898, b689B, curCol, b68AB, b68AD, b6A56, optDEBUG, optMACRODEBUG) byte external,
	(optXREF, optSYMBOLS, optPAGING, optTTY, optPRINT, optOBJECT, optPAGEWIDTH, optPAGELENGTH, optTITLE) byte external,
	(optEJECT, optLIST, optGEN, optCOND, b6A6F, titleLen, saveIdx, scanOptions, b6B23) byte external,
	(opType, b6B2C, b6B2E, b6B33, b6B34, b6BDB, b6BDD, b6C21, fileIdx) byte external,
	(b6C30, b905B, b905C, b905E, b9063, b9064, b6742, b6743) byte external,
	(ifDepth, skipping, inElse, macroCondSP, opSP, b6A00) byte external,
	(b9A77, b6B24) byte external,
	(cmdch$p, actRead, off$6C25, off$6C2C, off$6C2E, outfd, statusIO) address external,
	curTokenSym$p address external,
	curTokenSym based curTokenSym$p structure(w0 address, w2 address, w4 address, type byte, b7 byte),
	(w6750, w686E, w6870, objfd) address external,
	(infd, macrofd, w68A0, w68A2, lineCnt, w68A6, pageCnt, endOutBuf) address external,
	(w6A4E, errCnt, w6BD3) address external,
	w6868(3) address external,
	(options$p, includefd, rootfd, off$9056, curMacroBlk, w9114, w919B, w673F) address external,
	(w6B41, segSize, symTab, tokStart, w9D71)(1) address external,
	files(6) structure(name(15) byte, blk address, byt address, b19 byte) external,
	CR literally '0Dh';



ioErrChk: procedure external; end;
closeF: procedure(w) external; declare w address; end;
physmem: procedure address external; end;

read: procedure(w1, w2, w3, w4, w5) external; declare (w1, w2, w3, w4, w5) address; end;
rescan: procedure(w1, w2) external; declare (w1, w2) address; end;
seek: procedure(w1, w2, w3, w4, w5) external; declare (w1, w2, w3, w4, w5) address; end;
isPhase1: procedure byte external; end;
wrError: procedure(b) external; declare b byte; end;
sub$3DFB: procedure external; end;
inOpen: procedure(w1, w2) address external; declare (w1, w2) address; end;

declare aExtents(*) byte public initial(' LSTOBJ'),
    aDebug(*) byte public initial('DEBUG');


cmdSkipWhite: procedure public;
    declare cmdch based cmdch$p byte;
    
    do while (cmdch = ' ' or cmdch = 9) and cmdch$p <> actRead;
        cmdch$p = cmdch$p + 1;
    end;
end;

getDrive: procedure byte public;
    declare cmdch based cmdch$p byte;

    if cmdch = ':' then
    do;
        cmdch$p = cmdch$p + 2;
        return cmdch;
    end;
    else
        do b6BDB = 0 to 4;
        if cmdch <> aDebug(b6BDB) and aDebug(b6BDB) + 20h <> cmdch then
                return '0';
            cmdch$p = cmdch$p + 1;
        end;
    call cmdSkipWhite;
    if cmdch <> ':' then
        return '0';
    cmdch$p = cmdch$p + 2;
    return cmdch;
end;

addExtents: procedure public;
    do b6BDB = 1 to 3;
        lstFile(b6BDD + b6BDB) = aExtents(b6BDB);
        objFile(b6BDD + b6BDB) = aExtents(b6BDB+3);
    end;
end;


getAsmFile: procedure public;
    declare cmdch based cmdch$p byte;

    cmdIsWhite: procedure byte;
        declare cmdch based cmdch$p byte;
        return cmdch = ' ' or cmdch = 9 or cmdch = CR;
    end;


    symTab(0) = .w9D71;
    w686E, w6868(0), symTab(1), w6868(1) = .MEMORY;
    call rescan(1, .statusIO);
    call ioErrChk;
    call read(1, .cmdLineBuf, 128, .actRead, .statusIO);
    call ioErrChk;
    actRead = actRead + .cmdLineBuf;
    scanOptions = 0FFh;
    call cmdSkipWhite;
    aF0Asxref(2) = getDrive;

    do while not cmdIsWhite;
        cmdch$p = cmdch$p + 1;
    end;

    call cmdSkipWhite;
    if cmdch = 0Dh then
        call wrError(4);

    infd = inOpen(cmdch$p, 1);
    rootfd, includefd = infd;
    b6BDB = 0FFh;

    b6BDD = 0;

    do while not cmdIsWhite;
        files(0).name(b6BDD) = cmdch;
        if b6BDB then
            lstFile(b6BDD), objFile(b6BDD) = cmdch;

        if cmdch = 2Eh then
        do;
            b6BDB = 0;
            call addExtents;
        end;

        b6BDD = b6BDD + 1;
        cmdch$p = cmdch$p + 1;
    end;

    options$p = cmdch$p;
    if b6BDB then
    do;
        lstFile(b6BDD) = '.';
        objFile(b6BDD) = '.';
        call addExtents;
    end;

    files(0).name(b6BDD) = ' ';
    if lstFile(0) = ':' and lstFile(2) <> '0' then
        aF0Asmac$tmp(2), aF0Asxref$tmp(2) = lstFile(2);
end;


resetDataX: procedure public;	/* extended initialisation */

    call sub$3DFB;

    b6B33, scanOptions, skipping, b6B2C, inElse, b6B2E, b674A(0), b674A(1), b6742,
    b$905B, b$905C, b$905E, b6857, b6C21 = cZERO;
    b6743, b6898, optLIST, b6A6F, optGEN, optCOND = c255;
    b$9063, b$9064, macroCondStk(0), macroCondSP, saveIdx, lookAhead, activeSeg, ifDepth, opSP, opStack(0) = cZERO;
    w$9114, segSize(0), segSize(1), segSize(2), w6B41(0), w6B41(1), w6B41(2), w68A6, w$919B, w6750, errCnt = w673F;
    b6882 = b6882 + 1;
    w6A4E, opType, pageCnt, lineCnt = 1;
    b68AE(0) = 0;
    curChar = 20h;
    do b6BDB = 0 to 11;
        optionSeen(b6BDB) = 0;
    end;

    curMacroBlk = 0FFFFh;
    if not isPhase1 then
    do;
        if fileIdx <> 0 then
        do;
            call closeF(includefd);
            call ioErrChk;
            includefd = rootfd;
        end;

        fileIdx = cZERO;
        off$6C25 = .b68B8;
        off$6C2C = off$6C25 - 1;
        off$6C2E = .b68B8;
        call seek(infd, 2, .w6BD3, .w6BD3, .statusIO);	/* SEEKABS */
        call ioErrChk;
    end;

    w6870 = physmem + 0BFh;
    endOutBuf = .b6A00;
end;

sub$70EE: procedure public;
    rec06.type = 6;
    rec06.len = 3;
    rec16.type = 22h;
    rec16.len = 1;
    rec24.type = 24h;
    rec24.len = 2;
    rec20.type = 20h;
    rec20.len = 1;
end;

end;
key4.plm
keywords: do;
declare copyright(*) byte data('(C) 1976,1977,1979,1980 INTEL CORP');

declare w9D71(*) address public initial(
	0A528h,	00000h,	00h,	010h,	/* NE */
	063B0h,	00000h,	0CCh,	02Ch,	/* CZ */
	06E60h,	09C40h,	00h,	038h,	/* ENDM */
	0BFB6h,	00000h,	0C0h,	02Dh,	/* RNZ */
	0B354h,	00000h,	0C1h,	025h,	/* POP */
	06EE9h,	00000h,	00h,	01Dh,	/* EQU */
	0C6CDh,	00000h,	08032h,	02Ch,	/* STA */
	0A1A5h,	00000h,	08006h,	029h,	/* MVI */
	0C6CFh,	00000h,	037h,	02Dh,	/* STC */
	0C6CDh,	06158h,	00h,	01B05h,	/* STACK */
	06615h,	00000h,	027h,	02Dh,	/* DAA */
	0988Dh,	0E100h,	0Ah,	026h,	/* LDAX */
	061F6h,	00000h,	0C4h,	02Ch,	/* CNZ */
	053CFh,	00000h,	08888h,	027h,	/* ADC */
	053D0h,	00000h,	080h,	027h,	/* ADD */
	08D9Fh,	00000h,	0A0D2h,	02Ch,	/* JNC */
	00000h,	00000h,	00h,	00h,	/*  */
	00000h,	00000h,	00h,	00h,	/*  */
	00000h,	00000h,	00h,	00h,	/*  */
	06E60h,	00000h,	08800h,	020h,	/* END */
	06A40h,	00000h,	0A003h,	07h,	/* E */
	00000h,	00000h,	00h,	00h,	/*  */
	0AD70h,	00000h,	00h,	013h,	/* OR */
	0AE08h,	00000h,	0D3h,	028h,	/* OUT */
	0A088h,	00000h,	00h,	015h,	/* MOD */
	0AD83h,	00000h,	00h,	01Fh,	/* ORG */
	00000h,	00000h,	00h,	00h,	/*  */
	08F70h,	00000h,	070CAh,	02Ch,	/* JZ */
	068E9h,	076C0h,	00h,	031h,	/* DSEG */
	0C488h,	00000h,	00h,	01Eh,	/* SET */
	08BD8h,	00000h,	010DAh,	02Ch,	/* JC */
	0C521h,	00000h,	030h,	022Dh,	/* SIM */
	06618h,	00000h,	0809h,	025h,	/* DAD */
	0B16Ch,	09600h,	0E9h,	02Dh,	/* PCHL */
	0A4A1h,	06A40h,	00h,	034h,	/* NAME */
	06748h,	00000h,	0F3h,	02Dh,	/* DI */
	053D5h,	00000h,	018C6h,	028h,	/* ADI */
	06630h,	00000h,	00h,	01Ah,	/* DB */
	08DB6h,	00000h,	0C2h,	02Ch,	/* JNZ */
	0AD7Dh,	00000h,	0B0h,	027h,	/* ORA */
	0B3FBh,	00000h,	06h,	07h,	/* PSW */
	0AD85h,	00000h,	0F6h,	028h,	/* ORI */
	0A09Ah,	00000h,	0B840h,	02Bh,	/* MOV */
	08610h,	00000h,	0B800h,	021h,	/* IF */
	00000h,	00000h,	00h,	00h,	/*  */
	09938h,	06400h,	0B02Ah,	02Ch,	/* LHLD */
	09600h,	00000h,	0B005h,	07h,	/* L */
	0C6F6h,	00000h,	090h,	027h,	/* SUB */
	0C634h,	09600h,	0F9h,	02Dh,	/* SPHL */
	0C405h,	00000h,	0DEh,	028h,	/* SBI */
	00000h,	00000h,	00h,	00h,	/*  */
	0BF4Fh,	00000h,	07h,	02Dh,	/* RLC */
	05780h,	00000h,	00h,	07h,	/* B */
	00000h,	00000h,	00h,	00h,	/*  */
	0E614h,	09600h,	0E8E3h,	02Dh,	/* XTHL */
	00000h,	00000h,	00h,	00h,	/*  */
	00000h,	00000h,	00h,	00h,	/*  */
	0B11Bh,	06A40h,	02h,	05h,	/* PAGE */
	00000h,	00000h,	00h,	00h,	/*  */
	00000h,	00000h,	00h,	00h,	/*  */
	0A7C0h,	00000h,	0D800h,	041h,	/* NUL */
	08750h,	00000h,	0DBh,	028h,	/* IN */
	06E60h,	08610h,	0D000h,	023h,	/* ENDIF */
	00000h,	00000h,	00h,	00h,	/*  */
	00000h,	00000h,	00h,	00h,	/*  */
	0C3FEh,	00000h,	098h,	027h,	/* SBB */
	0C6D7h,	09A10h,	00h,	035h,	/* STKLN */
	0BFE0h,	00000h,	0F0h,	02Dh,	/* RP */
	0C078h,	00000h,	0C7h,	02Eh,	/* RST */
	0C4F8h,	06400h,	022h,	02Ch,	/* SHLD */
	09E57h,	0BFB8h,	00h,	036h,	/* MACRO */
	06231h,	00000h,	0ECh,	02Ch,	/* CPE */
	0B436h,	09957h,	0A800h,	032h,	/* PUBLIC */
	0BDA0h,	00000h,	0A817h,	02Dh,	/* RAL */
	06FF5h,	0CBE8h,	0D800h,	039h,	/* EXITM */
	06235h,	00000h,	0FEh,	028h,	/* CPI */
	0BF68h,	00000h,	0F8h,	02Dh,	/* RM */
	00000h,	00000h,	00h,	00h,	/*  */
	00000h,	00000h,	00h,	00h,	/*  */
	0BDA6h,	00000h,	01Fh,	02Dh,	/* RAR */
	0805Bh,	07D00h,	0B800h,	018h,	/* HIGH */
	06400h,	00000h,	0C802h,	07h,	/* D */
	0B447h,	07D00h,	0D0C5h,	025h,	/* PUSH */
	0C6FDh,	00000h,	08D6h,	028h,	/* SUI */
	06220h,	00000h,	0F4h,	02Ch,	/* CP */
	061A8h,	00000h,	0FCh,	02Ch,	/* CM */
	00000h,	00000h,	00h,	00h,	/*  */
	05629h,	076C0h,	00h,	02Fh,	/* ASEG */
	0BFF1h,	00000h,	0E8h,	02Dh,	/* RPE */
	0880Ch,	05DC0h,	0A800h,	03Ch,	/* IRPC */
	0BE48h,	00000h,	0C9h,	02Dh,	/* RET */
	0876Eh,	00000h,	04h,	02Ah,	/* INR */
	0BEE1h,	00000h,	020h,	022Dh,	/* RIM */
	0BFFBh,	00000h,	0E0h,	02Dh,	/* RPO */
	0C6CDh,	0E100h,	02802h,	026h,	/* STAX */
	0988Dh,	00000h,	0983Ah,	02Ch,	/* LDA */
	07000h,	0BF90h,	00h,	033h,	/* EXTRN */
	08774h,	00000h,	09003h,	025h,	/* INX */
	061B5h,	00000h,	0902Fh,	02Dh,	/* CMA */
	0876Ch,	05449h,	01h,	05h,	/* INPAGE */
	09A47h,	05500h,	09800h,	03Fh,	/* LOCAL */
	0E5BDh,	00000h,	08A8h,	027h,	/* XRA */
	080E0h,	00000h,	076h,	02Dh,	/* HLT */
	08DE0h,	00000h,	0F2h,	02Ch,	/* JP */
	09A5Bh,	00000h,	00h,	019h,	/* LOW */
	06D88h,	00000h,	0FBh,	02Dh,	/* EI */
	0623Bh,	00000h,	0E4h,	02Ch,	/* CPO */
	06676h,	00000h,	06805h,	02Ah,	/* DCR */
	0E5C5h,	00000h,	0EEh,	028h,	/* XRI */
	0555Dh,	00000h,	0A0h,	027h,	/* ANA */
	062A9h,	076C0h,	00h,	030h,	/* CSEG */
	08D68h,	00000h,	0FAh,	02Ch,	/* JM */
	05560h,	00000h,	00h,	012h,	/* AND */
	05140h,	00000h,	05807h,	07h,	/* A */
	0BE44h,	0C800h,	00h,	03Eh,	/* REPT */
	08DF1h,	00000h,	0EAh,	02Ch,	/* JPE */
	0880Ch,	00000h,	00h,	03Bh,	/* IRP */
	05565h,	00000h,	0E6h,	028h,	/* ANI */
	09B00h,	00000h,	00h,	0Ch,	/* LT */
	061B7h,	00000h,	03Fh,	02Dh,	/* CMC */
	08DFBh,	00000h,	0E2h,	02Ch,	/* JPO */
	07BC0h,	00000h,	00h,	0Eh,	/* GT */
	06978h,	00000h,	07800h,	01Bh,	/* DW */
	06EC8h,	00000h,	00h,	0Bh,	/* EQ */
	068D8h,	00000h,	04800h,	01Ch,	/* DS */
	07968h,	00000h,	0A000h,	0Fh,	/* GE */
	0A6D4h,	00000h,	00h,	02Dh,	/* NOP */
	09F01h,	0AD95h,	00h,	01C05h,	/* MEMORY */
	05FE0h,	09600h,	0CDh,	02Ch,	/* CALL */
	0BDD8h,	00000h,	0D8h,	02Dh,	/* RC */
	053ADh,	00000h,	080CEh,	028h,	/* ACI */
	0BF9Fh,	00000h,	0D0h,	02Dh,	/* RNC */
	0E36Ch,	076C0h,	0EBh,	02Dh,	/* XCHG */
	061C4h,	00000h,	08B8h,	027h,	/* CMP */
	0667Ch,	00000h,	0Bh,	025h,	/* DCX */
	0C620h,	00000h,	06h,	08h,	/* SP */
	09C40h,	00000h,	06h,	07h,	/* M */
	098A8h,	00000h,	03800h,	0Dh,	/* LE */
	06018h,	00000h,	0DCh,	02Ch,	/* CC */
	07D00h,	00000h,	05004h,	07h,	/* H */
	0C03Fh,	00000h,	0500Fh,	02Dh,	/* RRC */
	0C4F8h,	00000h,	00h,	016h,	/* SHL */
	05DC0h,	00000h,	01h,	07h,	/* C */
	0C170h,	00000h,	0C8h,	02Dh,	/* RZ */
	0E556h,	00000h,	00h,	014h,	/* XOR */
	06E1Fh,	06A40h,	00h,	022h,	/* ELSE */
	0A6D8h,	00000h,	00h,	011h,	/* NOT */
	0C4FEh,	00000h,	00h,	017h,	/* SHR */
	09BB5h,	00000h,	01h,	024h,	/* LXI */
	08D84h,	00000h,	0C3h,	02Ch,	/* JMP */
	061DFh,	00000h,	0D4h,	02Ch	/* CNC */
);


end;
glb.plm
glb: do;
$SET(OVL=0)
$include(global.cmn)
end;
glb4.plm
glb4: do;
$SET(OVL=4)
$include(global.cmn)
end;
glb5.plm
glb5: do;
$SET(OVL=5)
$include(global.cmn)
end;
makefile
ISIS=..\..\isis
PLMDIR=..\..\plm80v4
ASMDIR=..\..\plm80v4
OLDPLMDIR=..\..\plm80v3
OVERLAY=6D4Ch
#
# compilation and assembly rules
.SUFFIXES: .plm .pl3
.plm.obj:
	@SET :F0:=.
	@SET :F1:=$(PLMDIR)
	$(ISIS) :F1:PLM80 $< code
	@if not exist $*.obj exit /b 1

.pl3.obj:
	@SET :F0:=.
	@SET :F1:=$(OLDPLMDIR)
	$(ISIS) :F1:PLM80 $< code
	@find $*.lst "     0 PROGRAM ERROR(S)" >nul || (del $*.obj & exit /b 1)

.asm.obj:
	@SET :F0:=.
	@SET :F1:=$(ASMDIR)
	$(ISIS) :F1:ASM80 $< 
	@find $*.lst "ASSEMBLY COMPLETE,   NO ERRORS" >nul || (del $*.obj & exit /b 1)

all: asm80 asm80.ov0 asm80.ov1 asm80.ov2 asm80.ov3 asm80.ov4 asm80.ov5

asm80: base.abs asmov0.abs asmov1.abs asmov2.abs asmov3.abs keywrd.abs 
	@SET :F0:=.
	@SET :F1:=$(PLMDIR)
	$(ISIS) < <<	
:F1:link base.abs,publics(asmov0.abs,asmov1.abs,asmov2.abs),&
asmov3.abs,keywrd.abs to $*.rel &
map print($*.lin)
:F1:locate $*.rel to $@ SYMBOLS MAP PUBLICS print($*.map)&
STACKSIZE(0) PURGE NAME(ASM80)
exit
<<NOKEEP
	del $*.rel
	@find $*.lin "LINK MAP" >nul || (del $@ & exit /b 1)
	@(find $*.map "UNSATISFIED EXTERNAL" >nul && (del $@ & exit /b 1)) || exit /b 0)



asm80.ov0: asmov0.abs 
	@SET :F0:=.
	@SET :F1:=$(PLMDIR)
	$(ISIS) < <<	
:F1:locate $** to $@ SYMBOLS MAP PUBLICS print($*.mo0) &
STACKSIZE(0) PURGE NAME(A80O0)
exit
<<NOKEEP
	@(find $*.mo0 "UNSATISFIED EXTERNAL" >nul && (del $@ & exit /b 1)) || exit /b 0)

asm80.ov1: asmov1.abs 
	@SET :F0:=.
	@SET :F1:=$(PLMDIR)
	$(ISIS) < <<	
:F1:locate $** to $@ SYMBOLS MAP PUBLICS print($*.mo1) &
STACKSIZE(0) PURGE NAME(A80O1)
exit
<<NOKEEP	
	@(find $*.mo1 "UNSATISFIED EXTERNAL" >nul && (del $@ & exit /b 1)) || exit /b 0)


asm80.ov2: asmov2.abs 
	@SET :F0:=.
	@SET :F1:=$(PLMDIR)
	$(ISIS) < <<	
:F1:locate $** to $@ SYMBOLS MAP PUBLICS print($*.mo2) &
STACKSIZE(0) PURGE NAME(A80O2)
exit
<<NOKEEP	
	@(find $*.mo2 "UNSATISFIED EXTERNAL" >nul && (del $@ & exit /b 1)) || exit /b 0)

asm80.ov3: asmov3.abs
	@SET :F0:=.
	@SET :F1:=$(PLMDIR)
	$(ISIS) < <<	
:F1:locate $** to $@ SYMBOLS MAP PUBLICS print($*.mo3) &
STACKSIZE(0) PURGE NAME(A80O3)
exit
<<NOKEEP
	@(find $*.mo3 "UNSATISFIED EXTERNAL" >nul && (del $@ & exit /b 1)) || exit /b 0)




OBJS1 =	glb.obj asm801.obj asm82.obj asm83.obj asm84.obj asm85.obj\
	asm851.obj asm86.obj asm861.obj asm87.obj close.obj delete.obj error.obj\
       	exit.obj load.obj open.obj read.obj rescan.obj seek.obj write.obj

base.abs: $(OBJS1)
	@SET :F0:=.
	@SET :F1:=$(PLMDIR)
	$(ISIS) < <<
:F1:link $(OBJS1: =,&
),:f1:plm80.lib to $*.rel print($*.lin)
:F1:locate $*.rel to $@ SYMBOLS MAP PUBLICS STACKSIZE(120) print($*.map)
exit
<<NOKEEP	
	del $*.rel
	@find $*.lin "UNRESOLVED EXTERNAL" >nul || (del $@ & exit /b 1)


keywrd.abs: keywrd.obj memory.obj
	@SET :F0:=.
	@SET :F1:=$(PLMDIR)
	$(ISIS) < <<
:F1:link $(**: =,) to $*.rel map print($*.lin)
:F1:locate $*.rel to $@ SYMBOLS MAP PUBLICS CODE(075A2h) STACKSIZE(0) print($*.map)
exit
<<NOKEEP
	del $*.rel
	@find $*.lin "LINK MAP" >nul || (del $@ & exit /b 1)
	@(find $*.map "UNSATISFIED EXTERNAL" >nul && (del $@ & exit /b 1)) || exit /b 0)

asmov0.abs: base.abs cprite.obj asmov0.obj
	@SET :F0:=.
	@SET :F1:=$(PLMDIR)
	$(ISIS) < <<
:F1:link publics(base.abs),cprite.obj,asmov0.obj to $*.rel map print($*.la0)
:F1:locate $*.rel to $@ SYMBOLS MAP PUBLICS CODE($(OVERLAY)) STACKSIZE(0) print($*.ma0)
exit
<<NOKEEP
	del $*.rel
	@find $*.la0 "LINK MAP" >nul || (del $@ & exit /b 1)


asmov1.abs: base.abs cprite.obj asmov1.obj
	@SET :F0:=.
	@SET :F1:=$(PLMDIR)
	$(ISIS) < <<
:F1:link publics(base.abs),cprite.obj,asmov1.obj,:F1:plm80.lib &
to $*.rel map print($*.la1)
:F1:locate $*.rel to $@ SYMBOLS MAP PUBLICS CODE($(OVERLAY)) STACKSIZE(0) print($*.ma1)
exit
<<NOKEEP
	del $*.rel
	@find $*.la1 "LINK MAP" >nul || (del $@ & exit /b 1)



asmov2.abs: base.abs cprite.obj asmov2.obj
	@SET :F0:=.
	@SET :F1:=$(PLMDIR)
	$(ISIS) < <<
:F1:link publics(base.abs),cprite.obj,asmov2.obj to $*.rel map print($*.la2)
:F1:locate $*.rel to $@ SYMBOLS MAP PUBLICS CODE($(OVERLAY)) STACKSIZE(0) print($*.ma2)
exit
<<NOKEEP
	del $*.rel
	@find $*.la2 "LINK MAP" >nul || (del $@ & exit /b 1)


asmov3.abs: base.abs cprite.obj asmov3.obj keywrd.abs
	@SET :F0:=.
	@SET :F1:=$(PLMDIR)
	$(ISIS) < <<
:F1:link publics(base.abs),cprite.obj,asmov3.obj,publics(keywrd.abs) &
to $*.rel map print($*.la3)
:F1:locate $*.rel to $@ SYMBOLS MAP PUBLICS CODE($(OVERLAY)) STACKSIZE(0) print($*.ma3)
exit
<<NOKEEP
	del $*.rel
	@find $*.la3 "LINK MAP" >nul || (del $@ & exit /b 1)



clean:
	del *.obj *lst *.map *.abs *.rel *.lin *.*~ *.la? *.ma? *.lo? *.mo? makefile~

vclean: clean
	del asm80 asm80.ov?

verify: asm80 asm80.ov0 asm80.ov1 asm80.ov2 asm80.ov3 asm80.ov4 asm80.ov5
	for %i in ($**) do ..\..\diffbin %i $(PLMDIR)\%i

compare: asm80 asm80.ov0 asm80.ov1 asm80.ov2 asm80.ov3 asm80.ov4 asm80.ov5
	for %i in ($**) do fc /b %i $(PLMDIR)\%i


OBJS4 =	glb4.obj asm41.obj asm42.obj asm87.obj asm43.obj asm44.obj asm45.obj asm46.obj\
	asm47.obj asm48.obj asm49.obj asm4A.obj asm4B.obj asm4C.obj asm4D.obj asm4E.obj\
	close.obj delete.obj error.obj exit.obj\
	load.obj open.obj read.obj rescan.obj\
	seek.obj write.obj

asm80.ov4: $(OBJS4) key4.obj
	@SET :F0:=.
	@SET :F1:=$(PLMDIR)
	$(ISIS) < <<	
:F1:link $(OBJS4: =,&
),:f1:plm80.lib,key4.obj to asmov4.rel map print(asmov4.lin)
:F1:locate asmov4.rel to $@ SYMBOLS NAME(A80O4) PURGE &
MAP PUBLICS code(3780h) STACKSIZE(144) print(asmov4.map)
exit
<<NOKEEP
	@find asmov4.lin "LINK MAP" >nul || (del $@ & exit /b 1)
	@(find asmov4.map "UNSATISFIED EXTERNAL" >nul && (del $@ & exit /b 1)) || exit /b 0)



OBJS5 =	glb5.obj asm51.obj asm52.obj asm87.obj asm82.obj asm83.obj asm55.obj asm84.obj\
	asm57.obj asm86.obj asm861.obj asmov0.obj asmov2.obj asmov1.obj asm5D.obj\
	close.obj delete.obj error.obj exit.obj\
	load.obj open.obj read.obj rescan.obj\
	seek.obj write.obj

asm80.ov5: $(OBJS5) keywrd.obj
	@SET :F0:=.
	@SET :F1:=$(PLMDIR)
	$(ISIS) < <<	
:F1:link $(OBJS5: =,&
),:f1:plm80.lib,keywrd.obj to asmov5.rel map print(asmov5.lin)
:F1:locate asmov5.rel to $@ SYMBOLS NAME(A80O5) PURGE &
MAP PUBLICS code(3780h) STACKSIZE(144) print(asmov5.map)
exit
<<NOKEEP
	@find asmov5.lin "LINK MAP" >nul || (del $@ & exit /b 1)
	@(find asmov5.map "UNSATISFIED EXTERNAL" >nul && (del $@ & exit /b 1)) || exit /b 0)


glb5.obj: glb5.plm global.cmn
	@SET :F0:=.
	@SET :F1:=$(PLMDIR)
	$(ISIS) :F1:PLM80 glb5.plm code
	@if not exist $*.obj exit /b 1

glb.obj: glb.plm global.cmn
	@SET :F0:=.
	@SET :F1:=$(PLMDIR)
	$(ISIS) :F1:PLM80 glb.plm code
	@if not exist $*.obj exit /b 1

glb4.obj: glb4.plm global.cmn
	@SET :F0:=.
	@SET :F1:=$(PLMDIR)
	$(ISIS) :F1:PLM80 glb4.plm code
	@if not exist $*.obj exit /b 1
close.plm
close: DO;
DECLARE IOPEN LITERALLY '0',
 ICLOSE LITERALLY '1',
 IDELETE LITERALLY '2',
 IREAD LITERALLY '3',
 IWRITE LITERALLY '4',
 ISEEK LITERALLY '5',
 ILOAD LITERALLY '6',
 IRENAME LITERALLY '7',
 ICONSOL LITERALLY '8',
 IEXIT LITERALLY '9',
 IATTRIB LITERALLY '10',
 IRESCAN LITERALLY '11',
 IERROR LITERALLY '12',
 IWHOCON LITERALLY '13',
 ISPATH LITERALLY '14';

ISIS: procedure(b, w) external; declare b byte, w address; end;

close: PROCEDURE(conn, status$p) public;
    declare (conn, status$p) address;
    CALL ISIS(ICLOSE, .conn);
end close;
end;
delete.plm
delete: DO;

DECLARE IOPEN LITERALLY '0',
 ICLOSE LITERALLY '1',
 IDELETE LITERALLY '2',
 IREAD LITERALLY '3',
 IWRITE LITERALLY '4',
 ISEEK LITERALLY '5',
 ILOAD LITERALLY '6',
 IRENAME LITERALLY '7',
 ICONSOL LITERALLY '8',
 IEXIT LITERALLY '9',
 IATTRIB LITERALLY '10',
 IRESCAN LITERALLY '11',
 IERROR LITERALLY '12',
 IWHOCON LITERALLY '13',
 ISPATH LITERALLY '14';

ISIS: procedure(b, w) external; declare b byte, w address; end;

delete: procedure (path$p, status$p) public;
    declare (path$p, status$p) address;
    call ISIS(IDELETE, .path$p);
end delete;
end;
error.plm
error: DO;
DECLARE IOPEN LITERALLY '0',
 ICLOSE LITERALLY '1',
 IDELETE LITERALLY '2',
 IREAD LITERALLY '3',
 IWRITE LITERALLY '4',
 ISEEK LITERALLY '5',
 ILOAD LITERALLY '6',
 IRENAME LITERALLY '7',
 ICONSOL LITERALLY '8',
 IEXIT LITERALLY '9',
 IATTRIB LITERALLY '10',
 IRESCAN LITERALLY '11',
 IERROR LITERALLY '12',
 IWHOCON LITERALLY '13',
 ISPATH LITERALLY '14';

ISIS: procedure(b, w) external; declare b byte, w address; end;

error: procedure (error$num) public;
    declare (error$num) address;
    declare status address;
    status = .status;
    call ISIS(IERROR, .error$num);
end error;
end;
exit.plm
exit: DO;
DECLARE IOPEN LITERALLY '0',
 ICLOSE LITERALLY '1',
 IDELETE LITERALLY '2',
 IREAD LITERALLY '3',
 IWRITE LITERALLY '4',
 ISEEK LITERALLY '5',
 ILOAD LITERALLY '6',
 IRENAME LITERALLY '7',
 ICONSOL LITERALLY '8',
 IEXIT LITERALLY '9',
 IATTRIB LITERALLY '10',
 IRESCAN LITERALLY '11',
 IERROR LITERALLY '12',
 IWHOCON LITERALLY '13',
 ISPATH LITERALLY '14';

ISIS: procedure(b, w) external; declare b byte, w address; end;

exit: procedure public;
    declare tmp address;
    tmp = .tmp;
    call ISIS(IEXIT, .tmp);
end exit;
end;
load.plm
load: DO;

DECLARE IOPEN LITERALLY '0',
 ICLOSE LITERALLY '1',
 IDELETE LITERALLY '2',
 IREAD LITERALLY '3',
 IWRITE LITERALLY '4',
 ISEEK LITERALLY '5',
 ILOAD LITERALLY '6',
 IRENAME LITERALLY '7',
 ICONSOL LITERALLY '8',
 IEXIT LITERALLY '9',
 IATTRIB LITERALLY '10',
 IRESCAN LITERALLY '11',
 IERROR LITERALLY '12',
 IWHOCON LITERALLY '13',
 ISPATH LITERALLY '14';

ISIS: procedure(b, w) external; declare b byte, w address; end;

load: procedure (path$p, load$offset, switch, entry$p, status$p) public;
    declare (path$p, load$offset, switch, entry$p, status$p) address;
    CALL ISIS(ILOAD, .path$p);
end load;
end;
open.plm
open: DO;

DECLARE IOPEN LITERALLY '0',
 ICLOSE LITERALLY '1',
 IDELETE LITERALLY '2',
 IREAD LITERALLY '3',
 IWRITE LITERALLY '4',
 ISEEK LITERALLY '5',
 ILOAD LITERALLY '6',
 IRENAME LITERALLY '7',
 ICONSOL LITERALLY '8',
 IEXIT LITERALLY '9',
 IATTRIB LITERALLY '10',
 IRESCAN LITERALLY '11',
 IERROR LITERALLY '12',
 IWHOCON LITERALLY '13',
 ISPATH LITERALLY '14';

ISIS: procedure(b, w) external; declare b byte, w address; end;

open: procedure (conn$p, path$p, access, echo, status$p) public;
    declare (conn$p, path$p, access, echo, status$p) address;
    CALL ISIS(IOPEN, .conn$p);
end open;
end;
read.plm
read: DO;

DECLARE IOPEN LITERALLY '0',
 ICLOSE LITERALLY '1',
 IDELETE LITERALLY '2',
 IREAD LITERALLY '3',
 IWRITE LITERALLY '4',
 ISEEK LITERALLY '5',
 ILOAD LITERALLY '6',
 IRENAME LITERALLY '7',
 ICONSOL LITERALLY '8',
 IEXIT LITERALLY '9',
 IATTRIB LITERALLY '10',
 IRESCAN LITERALLY '11',
 IERROR LITERALLY '12',
 IWHOCON LITERALLY '13',
 ISPATH LITERALLY '14';

ISIS: procedure(b, w) external; declare b byte, w address; end;

read: procedure (conn, buff$p, count, actual$p, status$p) public;
    declare (conn, buff$p, count, actual$p, status$p) address;
    call ISIS(IREAD, .conn);
end read;
end;
rescan.plm
rescan: DO;

DECLARE IOPEN LITERALLY '0',
 ICLOSE LITERALLY '1',
 IDELETE LITERALLY '2',
 IREAD LITERALLY '3',
 IWRITE LITERALLY '4',
 ISEEK LITERALLY '5',
 ILOAD LITERALLY '6',
 IRENAME LITERALLY '7',
 ICONSOL LITERALLY '8',
 IEXIT LITERALLY '9',
 IATTRIB LITERALLY '10',
 IRESCAN LITERALLY '11',
 IERROR LITERALLY '12',
 IWHOCON LITERALLY '13',
 ISPATH LITERALLY '14';

ISIS: procedure(b, w) external; declare b byte, w address; end;

rescan: procedure (conn, status$p) public;
    declare (conn, status$p) address;
    call ISIS(IRESCAN, .conn);
end rescan;
end;
seek.plm
seek: DO;

DECLARE IOPEN LITERALLY '0',
 ICLOSE LITERALLY '1',
 IDELETE LITERALLY '2',
 IREAD LITERALLY '3',
 IWRITE LITERALLY '4',
 ISEEK LITERALLY '5',
 ILOAD LITERALLY '6',
 IRENAME LITERALLY '7',
 ICONSOL LITERALLY '8',
 IEXIT LITERALLY '9',
 IATTRIB LITERALLY '10',
 IRESCAN LITERALLY '11',
 IERROR LITERALLY '12',
 IWHOCON LITERALLY '13',
 ISPATH LITERALLY '14';

ISIS: procedure(b, w) external; declare b byte, w address; end;

seek: procedure (conn, mode, block$p, byte$p, status$p) public;
    declare (conn, mode, block$p, byte$p, status$p) address;
    CALL ISIS(ISEEK, .conn);
end seek;
end;
write.plm
write: DO;

DECLARE IOPEN LITERALLY '0',
 ICLOSE LITERALLY '1',
 IDELETE LITERALLY '2',
 IREAD LITERALLY '3',
 IWRITE LITERALLY '4',
 ISEEK LITERALLY '5',
 ILOAD LITERALLY '6',
 IRENAME LITERALLY '7',
 ICONSOL LITERALLY '8',
 IEXIT LITERALLY '9',
 IATTRIB LITERALLY '10',
 IRESCAN LITERALLY '11',
 IERROR LITERALLY '12',
 IWHOCON LITERALLY '13',
 ISPATH LITERALLY '14';

ISIS: procedure(b, w) external; declare b byte, w address; end;

write: procedure (conn, buff$p, count, status$p) public;
    declare (conn, buff$p, count, status$p) address;
    call ISIS(IWRITE, .conn);
end write;
end;
asm87.asm
	public pckTkn
	public ISIS
	extrn toksiz
	extrn tokst;

	aseg
ISIS	equ	40h

	CSEG
pckTkn: lhld	tokst
	xchg
	lxi	h, toksiz
	mov	c, m
	mvi	m, 4
	call pack3
	push	h
	call pack3
	pop	b
	xchg
	dcx	h
	dcx	h
	dcx	h
	mov	m, d
	dcx	h
	mov	m, e
	dcx	h
	mov	m, b
	dcx	h
	mov	m, c
	ret
pack3:
	lxi	h, 0	
	mvi	b, 3

L6291:
	push	d
	mov	d, h	; x 40
	mov	e, l
	dad	h
	dad	h
	dad	d
	dad	h
	dad	h
	dad	h
	pop	d
	call pack1
	add	l
	mov	l, a
	mvi	a, 0
	adc	h
	mov	h, a
	dcr	b
	jnz	L6291
	ret

pack1:	ldax	d
	inx	d
	dcr	c
	jm	L62B7
	sui	2Fh		;  012345678  (0-9)
				; 9?@ABCDEFG  (10-19)
				; HIJKLMNOPQ  (20-29)
				; RSTUVWXYZ[  (30-39)
	cpi	10h
	rc
	sui	5
	ret

L62B7:
	sub	a
	ret

	end
cprite.asm
	CSEG
cprite:	db '(C) 1976,1977,1979,1980 INTEL CORP'
	end;
memory.asm
	public EDATA
	DSEG
EDATA	equ	$
	end
