asm851: do;

$include(global.inc)

declare pad1 address data(40h);
declare pad2 address;


exit: procedure external; end;
flushout: procedure external; end;
ovl3: procedure external; end;
ovl8: procedure external; end;
ovlMgr: procedure(b) external; declare b byte; end;
popToken: procedure external; end;
sub$3DCE: procedure external; end;
sub$467F: procedure(b, w) external; declare b byte, w address; end;
syntaxError: procedure external; end;
sub$7041: procedure external; end;			/* in overlay 1 */
sub$6E32: procedure external; end;
sub$4646: procedure byte external; end;
haveTokens: procedure byte external; end;
xisSpace: procedure byte external; end;
isPhase2Print: procedure byte external; end;
sub$465B: procedure byte external; end;
sub$3A71: procedure byte external; end;



strUCequ: procedure(arg1w, arg2w) byte public;
	declare (arg1w, arg2w) address;
	declare ch1 based arg1w byte,
		ch2 based arg2w byte;

	do while ch1 <> 0;
		if ch1 <> ch2 and ch1 <> (ch2 and 5Fh) then
			return FALSE;
		arg1w = arg1w + 1;
		arg2w = arg2w + 1;
	end;
	return TRUE;
end;


isSkipping: procedure byte public;
	return skipping(0);
end;


sub$546F: procedure public;
	b6A56 = sub$4646;
	if b6B30 then
		call syntaxError;
	if haveTokens then
		if not(tokenType(b6A56) = 0Bh or b68AD) then
			call syntaxError;
	if b6B23 or b6B24 then
	do;
		if tokenSP = 1 and not xisSpace and tokenSize(0) <> 1 then
			tokenSize(0) = 2;
	end;
	else if not xisSpace and haveTokens then
		if tokenSize(b6A56) > 3 then
			tokenSize(b6A56) = 3;
end;



sub$54FD: procedure public;
	declare w6CD7 address, b6CD9 byte;
	declare ch based w6CD7 byte;

	call sub$546F;
	if isPhase2Print then
	do;
		w6CD7 = .asciiLineNo(3);
		b6CD9 = TRUE;

		do while b6CD9;
			if ch = '9' then
				ch = '0';
			else
			do;
				if ch = ' ' then
					ch = '1';
				else
					ch = ch + 1;
				b6CD9 = FALSE;
			end;
			w6CD7 = w6CD7 - 1;
		end;

		if sub$465B or not xisSpace then
		do;
			call ovlMgr(1);
			call ovl3;
		end;
	end;

	if b6BD9 then
	do;
		out$p = out$p + 1;
		call flushout;
		call exit;
	end;


	if not b6B20 then
	do;
		b6BDB = 2;
		if tokenSP < 2 or b6B23 or b6B24 then
			b6BDB = 0;

		w6BCE = tokStart(b6BDB) + tokenSize(b6BDB);
		if isSkipping or not b6B34 then
			w6BCE = .lineBuf;

		if sub$3A71 then
		do;
			call ovlMgr(2);
			call ovl8;
		end;

		b6B2C = 0FFh;
		segSize(activeSeg), w68A6 = segSize(activeSeg) + (w6BCE - .lineBuf);
	end;

	if optXREF and b6880 then
		if phase = 1 then
			call sub$467F(1, .b6873);

	do while tokenSP > 0;
		call popToken;
	end;

	call sub$3DCE;
	if b6B33 then
	do;
		b6B2E = 0FFh;
		if isPhase2Print and optSYMBOLS then
		do;
			call ovlMgr(1);
			call sub$7041;			/* in overlay 1 */
		end;

		call sub$467F(2, .b6873);
		if sub$3A71 then
		do;
			call ovlMgr(2);
			call sub$6E32;
		end;
	end;
end;
end;
