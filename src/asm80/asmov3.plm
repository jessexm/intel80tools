asm88: do;

$include(asmov3.ipx)

declare aExtents(*) byte public initial(' LSTOBJ'),
	aDebug(*) byte public initial('DEBUG');


/* overlay 3 appears to repair the code that starts here */

cmdSkipWhite: procedure public;
	declare cmdch based cmdch$p byte;
	
	do while (cmdch = ' ' or cmdch = 9) and cmdch$p <> actRead;
		cmdch$p = cmdch$p + 1;
	end;
end;

getDrive: procedure byte public;
	declare cmdch based cmdch$p byte;

	if cmdch = ':' then
	do;
		cmdch$p = cmdch$p + 2;
		return cmdch;
	end;
	else
		do ii = 0 to 4;
		if cmdch <> aDebug(ii) and aDebug(ii) + 20h <> cmdch then
				return '0';
			cmdch$p = cmdch$p + 1;
		end;
	call cmdSkipWhite;
	if cmdch <> ':' then
		return '0';
	cmdch$p = cmdch$p + 2;
	return cmdch;
end;

addExtents: procedure public;
	do ii = 1 to 3;
		lstFile(jj + ii) = aExtents(ii);
		objFile(jj + ii) = aExtents(ii+3);
	end;
end;

getAsmFileX: procedure public;		/* extended to include overlay file initialisation */
	declare cmdch based cmdch$p byte;

	cmdIsWhite: procedure byte;
		declare cmdch based cmdch$p byte;
		return cmdch = ' ' or cmdch = 9 or cmdch = CR;
	end;

	symTab(0) = .stdKeywords;
	w686E, w6868(0), symTab(1), w6868(1) = .EDATA;
	call rescan(1, .statusIO);
	call ioErrChk;
	call read(1, .cmdLineBuf, 128, .actRead, .statusIO);
	call ioErrChk;
	actRead = actRead + .cmdLineBuf;
	scanCmdLine = 0FFh;
	call write(0, .signonMsg, 29h, .statusIO);
	call write(0, .signonMsg, 2, .statusIO);
	call ioErrChk;
	call cmdSkipWhite;
	ovlFile(2), aF0Asxref(2) = getDrive; 

	do while not cmdIsWhite;
		cmdch$p = cmdch$p + 1;
	end;

	call cmdSkipWhite;
	if cmdch = CR then
		call runtimeError(4);	/* file error */

	infd = inOpen(cmdch$p, 1);
	rootfd, includefd = infd;
	ii = TRUE;
	jj = 0;

	do while not cmdIsWhite;
		files(0).name(jj) = cmdch;
		if ii then
			lstFile(jj), objFile(jj) = cmdch;
		if cmdch = '.' then
		do;
			ii = FALSE;
			call addExtents;
		end;
		jj = jj + 1;
		cmdch$p = cmdch$p + 1;
	end;
	controls$p = cmdch$p;
	if ii then
	do;
		lstFile(jj) = '.';
		objFile(jj) = '.';
		call addExtents;
	end;

	files(0).name(jj) = ' ';
	if lstFile(0) = ':' and lstFile(2) <> '0' then
		aF0Asxref$tmp(2) = lstFile(2);
end;




resetData: procedure public;
	call sub$3DCE;
	b6B33, scanCmdLine, skipping(0), b6B2C, inElse(0), finished, b674A(0), b674A(1), b6742, b6857, b6C21 = bZERO;
	b6743, primaryValid, ctlLIST, b6A6F, ctlCOND = bTRUE;
	saveIdx, lookAhead, activeSeg, ifDepth, opSP, opStack(0) = bZERO;
	segSize(0), segSize(1), segSize(2), w6B41(0), w6B41(1), w6B41(2), w68A6, w6750, errCnt = wZERO;
	b6882 = b6882 + 1;
	w6A4E, opType, pageCnt, lineCnt = 1;
	b68AE(0) = 0;
	curChar = 20h;
	do ii = 0 to 11;
		controlSeen(ii) = 0;
	end;
	if not isPhase1 then
	do;
		if fileIdx <> 0 then
		do;
			call closeF(includefd);
			call ioErrChk;
			includefd = rootfd;
		end;
		fileIdx = bZERO;
		off6C25 = .b68B8;
		off6C2C = off6C25 - 1;
		off6C2E = .b68B8;
		call seek(infd, 2, .azero, .azero, .statusIO);	/* SEEKABS */
		call ioErrChk;
	end;
	w6870 = physmem + 0BFh;
	endOutBuf = .b6A00;
end;


sub$70EE: procedure public;
	r$content.type = 6;
	r$content.len = 3;
	r$reloc.type = 22h;
	r$reloc.len = 1;
	r$interseg.type = 24h;
	r$interseg.len = 2;
	r$extref.type = 20h;
	r$extref.len = 1;
end;

end;
