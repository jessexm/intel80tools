asm80.pex
/* assembler routines & linkage */
ISIS            P(B b,A w)
pckTkn          P
EDATA		B

packToken       'pckTkn'
tokenSize       'toksiz'
tokStart        'tokst'


lit             'literally'
TRUE            '0FFh'
FALSE           '0'
CR              '0Dh'
LF              '0Ah'
TAB             '9'

/* character classes */
CC$BAD          '0'
CC$WS           '1'
CC$SEMI         '2'
CC$COLON        '3'
CC$CR           '4'
CC$PUNCT        '5'
CC$DOLLAR       '6'
CC$QUOTE        '7'
CC$DIGIT        '8'
CC$LET          '9'
CC$ESC          '11'

TT$ID           '0'
TT$NUM          '2'
TT$STR          '4'

/* ISIS syscall ids */
IOPEN           '0'
ICLOSE          '1'
IDELETE         '2'
IREAD           '3'
IWRITE          '4'
ISEEK           '5'
ILOAD           '6'
IEXIT           '9'
IRESCAN         '11'
IERROR          '12'

/* user defined types */
TOKENSYM$T      'structure(w0 address, w2 address, w4 address, type byte, flags byte)'
FILE$T          'structure(name(15) byte, blk address, byt address, b19 byte)'
MACRO$T1	'macroCondSP byte, ifDepth byte, mtype byte, b3 byte,w4 address'
MACRO$T2        'buf$p address, blk address, w10 address, w12 address, w14 address'
MACRO$T         'structure(MACRO$T1,MACRO$T2)'
CONTENT$T       'structure(type byte, len address, segid byte, offset address, dta(122) byte, crc byte)'
EOF$T           'structure(type byte, len address, crc byte)'
EXTNAMES$T	'structure(type byte, len address, dta(125) byte)'
EXTREF$T        'structure(type byte, len address, hilo byte, dta(30) address, crc byte)'
INTERSEG$T      'structure(type byte, len address, segid byte, hilo byte, dta(29) address, crc byte)'
MODEND$T        'structure(type byte, len address, modtyp byte, segid byte, offset address, crc byte)'
MODHDR$T	'structure(type byte, len address, dta(26) byte)'
PUBLICS$T       'structure(type byte, len address, segid byte, dta(124) byte, crc byte)'
RELOC$T         'structure(type byte, len address, hilo byte, dta(62) address)'
SYMENTRY$T	'structure(tok(2) address, b4 byte, delta byte, type byte, flags byte)'

/* common based variables */
curTokenSym     "TOKENSYM$T"..curTokenSym$p

$file(asm41.plm)
b$3782          B
b$3783          B
w$3780          A

$file(asm41.plm,asm51.plm)
aBadSyntax      BS
aCo             BS
aCommand        BS
aEof            BS
aError          BS
aError$0        BS
aFile           BS
aIsisIi80808085 BS
aMemory         BS
aModulePage     BS
ascCRLF         BS
aStack          BS
aTable          BS
bTRUE           B
bZERO           B
errStrs         AS
errStrsLen      BS
spaces24        BS

$file(asm42.plm)
isGT            PB
isLT            PB
sub$3D34        P(B arg1b)
sub$3D55        P(B arg1b)

$file(asm42.plm,asm52.plm)
-ovlFile

$file(asm42.plm,asm52.plm,asm801.plm)
blankAsmErrCode PB
blankMorPAsmErrCode PB
chkGenObj       PB
closeF          P(A arg1w)
flushout        P
getNibble       P(A bp,B idx)B
initialControls P
inOpen          P(A path$p,A access)A
ioErrChk        P
ioError         P(A arg1w)
isComma         PB
isCR            PB
isPhase1        PB
isPhase2Print   PB
isRParen        PB
isSpace         PB
isTab           PB
isWhite         PB
nibble2Ascii    P(B n)B
nxtCmdCh        PB
outch           P(B c)
outStrN         P(A s,B n)
physmem         PA
preStatementControls P
put2Hex         P(A arg1w,B arg2b)
runtimeError    P(B arg1b)
skip2EOL        P
sourceError     P(B arg1b)
sub3DCE$3DFB        P
wrConsole       P(A buf$p,A count)


$file(asm43.pl3)
readM           P(A arg1w)
sub$3FA9        PB
sub$40B9        P
writeM          P

$file(asm43.pl3,asm82.pl3)
skip2NextLine   P
skipWhite       P
skipWhite$2     P
sub$3F19        P

$file(asm44.plm)

$file(asm44.plm,asm83.plm)
b4181           BS
getPrec         P(B arg1b)B
sub$425B        P(B arg1b)B
sub$4274        P
sub$4291        P
sub$43D2        P
sub$43DD        PA
sub$450F        P(B arg1b)
sub$4646        PB
sub$465B        PB
sub$467F        P(B arg1b,A arg2w)
swapAccBytes    P
testBit         P(B arg1b,A arg2w)B

$file(asm45.plm)
pad9B73         A

$file(asm45.plm,asm55.plm,asm851.plm)
isSkipping      PB
strUCequ        P(A arg1w,A arg2w)B
sub4C1E$54FD    P
sub$546F        P

$file(asm46.pl3)
b6C21           B
b6C22           B
b6C23           B
b6C27           B
b6C30           B
fileIdx         B
files           "FILE$T"S
includefd       A
off6C25         A
off6C2C         A
off6C2E         A
rootfd          A
closeI          P
readF           P(B arg1b,A arg2w,A arg3w)
readI           P(A arg1w)
seekI           P(B arg1b)
sub$4879        PB
sub$4904        P

/* $file(asm46.pl3) */

/* $file(asm47.pl3) */

$file(asm47.pl3,asm85.pl3)
cond2Acc        P(B arg1b)
sub$4AAA        P(B arg1b)
sub$4B57        P(B arg1b)
sub$540D        P

$file(asm48.pl3)
b$9C3A          B
sub$5CAD        P(A arg1w,B arg2b)
sub$5CE8        P(A arg1w,B arg2b)
sub$65D9        P

$file(asm48.pl3,asm86.pl3)
getCh           PB
getChClass      PB
lookup          P(B arg1b)B
unpackToken     P(A src,A dst)

$file(asm49.pl3)
collectByte     P(B arg1b)
nestIFX         P(B arg1b)
sub$676D        P(B arg1b)

$file(asm49.pl3,asm861.plm)
balanceError    P
commandError    P
doubleDefError  P
expressionError P
fileError       P
getId           P(B arg1b)
getNum          P
getStr          P
haveTokens      PB
illegalCharError P
locationError   P
multipleDefError P
nameError       P
nestingError    P
OpcodeOperandError P
operandError    P
phaseError      P
popToken        P
pushToken       P(B arg1b)
stackError      P
syntaxError     P
undefinedSymbolError P
valueError      P

$file(asm4A.pl3)
sub$70D7        P

$file(asm4B.pl3)
b$9C77          B
sub$72A4        P(B arg1b)
sub$7327        P
sub$73AD        P
sub$7517        P
sub$753E        P
sub$75FF        P
sub$76CE        P
sub$770B        P
sub$7844        P
sub$787A        P
sub$78CE        P

$file(asm4C.pl3)
symb            BS..curTokenSym$p

$file(asm4C.pl3,asmov2.pl3)
ovl11           P
ovl8            P
sub$6E32        P
writeExtName    P
writeModend     P
writeModhdr     P
writeRec        P(A rec$p)

$file(asm4D.pl3)
outStr          P(A arg1w)
sub$8447        P
sub$872E        P

$file(asm4D.pl3,asmov1.pl3)
asmComplete     P
newPage         P
newPageHeader   P
ovl9            P
ovl10        P
printCmdLine    P
printDecimal    P(A arg1w)
skipToEOP       P
sub$6F4D        P
sub$721E        PB
sub$7229        P
sub$72D8        P

$file(asm4E.plm)
-stdKeywords

$file(asm4E.plm,asm5D.plm)
getAsmFile      P

$file(asm4E.plm,asm5D.plm,asmov3.plm)
aDebug          BS
aExtents        BS
addExtents      P
cmdSkipWhite    P
getDrive        PB
resetData       P
sub$70EE        P



/* $file(asm51.plm) */

$file(asm51.plm,asm801.plm)
signonMsg       BS

/* $file(asm52.plm) */
$file(asm52.plm,asm801.plm)
/* hide variables managed by $IF */
-argNestCnt
-b$8FD5
-b$9058
-b$9059
-b$905B
-b$905E
-b$9060
-off$9056
-w$906A
-w$919D



/* $file(asm55.plm) */

/* $file(asm57.pl3) */
$file(asm57.pl3,asm85.pl3)
sub$4B72        P
sub$518F        P

$file(asm5D.plm)
-b$905B
-b$905C
-b$905E
-b$9063
-b$9064
-ctlGEN
-curMacroBlk
-extKeywords
-macroCondStk
-macroCondSP
-w$9114
-w$919B


$file(asm801.plm)
ovlFile         BS
ovlMgr          P(B ovl)

/* $file(asm82.pl3) */
$file(asm83.plm)
-b$905B			/* special case due to $IF processing */
/* $file(asm85.pl3) */
/* $file(asm851.plm) */

$file(asm86.pl3)
b6CE4           B
chkLF           P
insertSym       P
sub$5819        P(A arg1w,B arg2b)

$file(asm861.plm)
addByte2Tok     P(B arg1b)
nestIF          P(B arg1b)
unnestIF        P(B arg1b)

$file(asmov0.pl3)
parseControls   P

$file(asmov1.pl3)
ovl3            P
sub$7041        P

/* $file(asmov2.pl3) */

$file(asmov3.plm)
getAsmFileX     P

$file(close.plm)
close           P(A conn,A status$p)

$file(delete.plm)
delete          P(A path$p,A status$p)

$file(error.plm)
error           P(A error$num)

$file(exit.plm)
exit            P

/* these share a common file with build controlled by $IF statements */
$file(glb.plm,glb4.plm,glb5.plm)
accum1          A
accum1$hb       B
accum1$lb       B
accum2          A
accum2$hb       B
accum2$lb       B
activeSeg       B
actRead         A
aF0Asmac$tmp    BS
aF0Asxref       BS
aF0Asxref$tmp   BS
alignTypes      BS
argNestCnt      B		/* glb4 */
asciiLineNo     BS
asmErrCode      B
azero           A
b6521           B
b6524           B
b6525           B
b6526           BS
b652B           BS
b652F           B
b6742           B
b6743           B
b6744           B
b6748           B
b6749           B
b674A           BS
b6754           B
b6855           B
b6856           B
b6857           B
b6858           B
b6859           B
b6872           B
b6873           BS
b6879           BS
b687F           B
b6880           B
b6881           B
b6882           B
b6883           B
b6884           B
b6885           B
b6897           B
b689A           B
b689B           B
b689C           B
b68AB           B
b68AD           B
b68AE           BS
b68B8           BS
b6A00           B
b6A56           B
b6A57           BS
b6A6F           B
b6A71           B
b6B20$9A77      B		
b6B23           B
b6B24           B
b6B25           B
b6B28           B
b6B29           B
b6B2B           B
b6B2C           B
b6B2D           B
b6B2F           B
b6B30           B
b6B31           B
b6B32           B
b6B33           B
b6B34           B
b6B35           B
b6B36           B
b6BD9           B
b6BDA           B
b6BDC           B
b$8FD5          BS		/* glb4 */
b$9058          B		/* glb4 */
b$9059          B		/* glb4 */
b$905A          B		/* glb4 */
b$905B          B		/* glb4 */
b$905C          B		/* glb4 */
b$905D          B		/* glb4 */
b$905E          B		/* glb4 */
b$9060          B		/* glb4 */
b$9061          B		/* glb4 */
b$9062          B		/* glb4 */
b$9063          B		/* glb4 */
b$9064          B		/* glb4 */
b$9065          B		/* glb4 */
b$9066          B		/* glb4 */
b$91A1          B		/* glb4 */
b$91A2          B		/* glb4 */
b$91A3          B		/* glb4 */
b$91A4          BS		/* glb4 */
bp6A4E          BS
bp6BE0          BS
cmdch$p         A
cmdLineBuf      BS
controlId       B
controls        BS
controlSeen     BS
controls$p      A
ctlCOND         B
ctlDEBUG        B
ctlEJECT        B
ctlGEN          B
ctlLIST         B
ctlMACRODEBUG   B
ctlMACROFILE    B
ctlMOD85        B
ctlOBJECT       B
ctlPAGELENGTH   B
ctlPAGEWIDTH    B
ctlPAGING       B
ctlPRINT        B
ctlSYMBOLS      B
ctlTITLE        B
ctlTITLESTR     BS
ctlTTY          B
ctlXREF         B
curChar         B
curCol          B
curFileName$p   A
curMacroBlk     A		/* glb4 */
curTokenSym$p   A
curTokStart     A
endLineBuf      A
endOutBuf       A
errCnt          A
extNamIdx       B
finished        B
fix20Idx        B
fix22Idx        B
fix24Idx        B
fix6Idx         B
has16bitOperand B
ifDepth         B
ii              B
inElse          BS
infd            A
jj              B
lineBuf         BS
lineCnt         A
lookAhead       B
lstFile         BS
macroBuf        BS		/* glb4 */
macroCondSP     B		/* glb4 */
macroCondStk    BS		/* glb4 */
MacroDebugOrGen B		/* glb & glb5 */
macrofd         A
macroStk        "MACRO$T"S	/* glb4 */
maxMacroBlk     A		/* glb4 */
mem             BS		/* glb4 */
moduleNameLen   B
nxtMacroBlk     A		/* glb4 */
objfd           A
objFile         BS
off$9056        A		/* glb4 */
openStatus      A
opSP            B
opStack         BS
opType          B
outbuf          BS
outfd           A
out$p           A
pageCnt         A
phase           B
primaryValid    B
r$content       "CONTENT$T"
reget           B
r$eof           "EOF$T"
r$extnames1     "EXTNAMES$T"
r$extnames2     "EXTNAMES$T"
r$extref        "EXTREF$T"
r$interseg      "INTERSEG$T"
r$modend        "MODEND$T"
r$publics       "PUBLICS$T"
r$reloc         "RELOC$T"
saveIdx         B
saveStack       BS
scanCmdLine     B
segSize         AS
skipping        BS
startDefined    B
startOffset     A
startSeg        B
statusIO        A
symTab          AS
titleLen        B
tmac$b3         B		/* glb4 */
tmac$blk        A		/* glb4 */
tmac$buf$p      A		/* glb4 */
tmac$ifDepth    B		/* glb4 */
tmac$macroCondSP B		/* glb4 */
tmac$mtype      B		/* glb4 */
tmac$w10        A		/* glb4 */
tmac$w12        A		/* glb4 */
tmac$w14        A		/* glb4 */
tmac$w4         A		/* glb4 */
tokBuf          BS
tokBufIdx       B
tokBufLen       B
tokenAttr       BS
tokenSP         B
tokenSym        AS
tokenSymId      AS
tokenType       BS
toksiz          BS
tokst           AS
tokType         B
w651F           A
w6522           A
w6750           A
w6752           A
w685A           A
w685C           A
w6866           A
w6868           AS
w686E           A
w6870           A
w68A0           A
w68A2           A
w68A6           A
w68B6           A
w6A4E           A
w6B1E           A
w6B41           AS
w6BCE           A
w6BE0           A
w6BE2           A
w$9054          A		/* glb4 */
w$9068          A		/* glb4 */
w$906A          A		/* glb4 */
w$9114          A		/* glb4 */
w$9197          A		/* glb4 */
w$9199          A		/* glb4 */
w$919B          A		/* glb4 */
w$919D          A		/* glb4 */
w$919F          A		/* glb4 */
wZERO           A
xreffd          A

$file(key4.plm)
extKeywords     AS

$file(keywrd.plm)
stdKeywords     AS

$file(load.plm)
load            P(A path$p,A load$offset,A switch,A entry$p,A status$p)

$file(open.plm)
open            P(A conn$p,A path$p,A access,A echo,A status$p)

$file(read.plm)
read            P(A conn,A buff$p,A count,A actual$p,A status$p)

$file(rescan.plm)
rescan          P(A conn,A status$p)

$file(seek.plm)
seek            P(A conn,A mode,A block$p,A byte$p,A status$p)

$file(write.plm)
write           P(A conn,A buff$p,A count,A status$p)

global.pac
declare
$IF OVL=4
	IN$BUF$SIZE lit '512',
	OUT$BUF$SIZE lit '512',
$ELSEIF OVL=5
	IN$BUF$SIZE lit '2048',
	OUT$BUF$SIZE lit '2048',
$ELSE
	IN$BUF$SIZE lit '200',
	OUT$BUF$SIZE lit '128',
$ENDIF

$IF OVL=4
	mem(1) byte public at(0),
	b$8FD5(127) byte public,
	w$9054 address public,
	off$9056 address public initial(.b$8FD5),
	b$9058 byte public initial(0),
	b$9059 byte public,
	b$905A byte public,
	b$905B byte public,
	b$905C byte public,
	b$905D byte public initial(0),
	b$905E byte public,
	b$905F byte,
	b$9060 byte public,
	b$9061 byte public,
	b$9062 byte public,
	b$9063 byte public,
	b$9064 byte public,
	b$9065 byte public,
	b$9066 byte public,
	argNestCnt byte public initial(0),
	w$9068 address public,
	w$906A address public,
	/*
		mtype has the following values
		1 -> IRP
		2 -> IRPC
		3 -> REPT
		4 -> ???
		5 -> ???
	*/
		
	macroStk(10) MACRO$T public,
	(tmac$macroCondSP, tmac$ifDepth,  tmac$mtype, tmac$b3) byte public at (.macroStk(0)),
	(tmac$w4, tmac$buf$p) address public at (.macroStk(0).w4),
	tmac$blk address public  at (.macroStk(0).blk) initial(0FFFFh),
	(tmac$w10, tmac$w12, tmac$w14) address public at (.macroStk(0).w10),
	w$910C address,
	curMacroBlk address public initial(0FFFFh),
	nxtMacroBlk address public initial(0),
	maxMacroBlk address public initial(0),
	w$9114 address public,
	macroBuf(129) byte public,
	w$9197 address public,
	w$9199 address public,
	w$919B address public,
	w$919D address public,
	w$919F address public,
	b$91A1 byte public initial(0),
	b$91A2 byte public initial(0),

	b$91A3 byte public initial(81h),
	b$91A4(*) byte public initial(3Fh, 3Fh, 0, 0, 0, 0, 80h),
$ENDIF
/* ov4 compat 2C8C */
	w651F address public,
	b6521 byte public,
	w6522 address public,
	b6524 byte public,
	b6525 byte public,
	b6526(4) byte public initial(0, 0, 0, 0),
	(fix22Idx, fix24Idx, fix20Idx, fix6Idx) byte public at (.b6526),
	extNamIdx byte public initial(0),
	b652B(4) byte public initial(0FFh, 0FFh, 0FFh, 0FFh),
	b652F byte public initial(0FFh),
	r$eof EOF$T public initial(0Eh, 0),
	r$extnames1 EXTNAMES$T public initial(18h, 0, 0),
	moduleNameLen byte public initial(6),
	r$extnames2 EXTNAMES$T public initial(18h, 0, 0),
	r$content CONTENT$T public at(.r$extnames2),
	r$publics PUBLICS$T public initial (16h, 1, 0, 0, 0),
	r$reloc RELOC$T public at(.r$publics),
	r$interseg INTERSEG$T public,
	r$extref EXTREF$T public,
	r$modend MODEND$T public initial( 4, 4, 0),
	wZERO address public initial(0),
	pad6741 byte initial(0ah),
	b6742 byte public initial(0),
	b6743 byte public initial(0),
	b6744 byte public,
	startSeg byte public initial(1),
	padb6746 byte,
	activeSeg byte public,
	b6748 byte public initial(0),
	b6749 byte public initial(0),
	b674A(2) byte public,
	alignTypes(4) byte public initial(3, 3, 3, 3),
	w6750 address public,
	w6752 address public,
	b6754 byte public initial(0),
	startDefined byte public initial(0),
	startOffset address public initial(0),
	tokenSP byte public initial(0),
	lineBuf(128) byte public,
	tokStart(9) address public initial(.lineBuf),
	curTokStart address public at(.tokStart),
	tokenSym(9) address public initial(0),
	curTokenSym$p address public at(.tokenSym(0)),
	curTokenSym based curTokenSym$p TOKENSYM$T,
	tokenType(9) byte public,
	tokenSize(9) byte public initial(0),
	tokenAttr(9) byte public,
	tokenSymId(9) address public,
/* end */
	endLineBuf address public initial(.tokStart),
	ifDepth byte public initial(0),
	skipping(9) byte public,
	inElse(9) byte public,
$IF OVL=4
	macroCondSP byte public initial(0),
	macroCondStk(17) byte public,
	b$94DD(2) byte,
$ENDIF
	opSP byte public,
	opStack(17) byte public,
/* ov4 compat 2CA0 */
	(accum1, accum2) address public,
	(accum1$lb, accum1$hb, accum2$lb, accum2$hb) byte public at(.accum1),
	b6855 byte public,
	b6856 byte public,
	b6857 byte public,
	b6858 byte public,
	b6859 byte public,
	w685A address public,
	w685C address public,
	curChar byte public initial(0),
	reget byte public initial(0),
	lookAhead byte public,
	pad6861 byte initial(0),
	symTab(2) address public,
	w6866 address public,
	w6868(3) address public,
	w686E address public,
	w6870 address public,
	b6872 byte public initial(0),
	b6873(6) byte public,
	b6879(6) byte public,
	b687F byte public,
	b6880 byte public,
	b6881 byte public initial(0),
	b6882 byte public initial(0),
	b6883 byte public initial(0),
	b6884 byte public initial(0),
	b6885 byte public initial(0),
	objfd address public,
	xreffd address public,
	infd address public,
	outfd address public,
	macrofd address public,
	statusIO address public,
	openStatus address public,
	pad6894 address initial(0FFFFh),
	asmErrCode byte public initial(20h),	
	b6897 byte public initial(0),
	primaryValid byte public initial(TRUE),
/* end */
$IF OVL=0
	pad6899 byte initial(0),
$ENDIF
/* ov4 compat 2C9F */
	b689A byte public,
	b689B byte public,
	b689C byte public,
	pad689D(2) byte,
	curCol byte public initial(1),
	w68A0 address public,
	w68A2 address public,
	lineCnt address public,
	w68A6 address public,
	pageCnt address public,
	pad68AA byte,
	b68AB byte public,
	pad68AC byte,
	b68AD byte public initial(0),
	b68AE(8) byte public initial(0, 0, 0, 0, 0, 0, 0, 0),
	w68B6 address public initial(IN$BUF$SIZE),
	b68B8(IN$BUF$SIZE) byte public,
	outbuf(OUT$BUF$SIZE) byte public,
/* end */
	b6A00 byte public,
/* ov4 compat 2F57 */
	out$p address public initial(.outbuf),
	endOutBuf address public,
	pad6A05 address initial(.outbuf),
	pad6A07 byte initial(0),
	objFile(15) byte public initial('               '), /* 15 spaces */
	lstFile(15) byte public initial('               '), /* 15 spaces */
	aF0Asxref$tmp(*) byte public initial(':F0:ASXREF.TMP '),
	aF0Asxref(*) byte public initial(':F0:ASXREF '),
	aF0Asmac$tmp(*) byte public initial(':F0:ASMAC.TMP '),
	w6A4E address public initial(1),
	bp6A4E(2) byte public at(.w6A4E),
	pad6A50(2) byte initial('  '),		/* protects for very big files */
	asciiLineNo(4) byte public initial('   0'),
	b6A56 byte public,
	b6A57(4) byte public initial('   0'),
	ctlDEBUG byte public initial(0),	/* DEBUG */
	controls(1) byte public at(.ctlDEBUG),
	ctlMACRODEBUG byte public initial(0),		/* MACRODEBUG */
	ctlXREF byte public initial(0),		/* XREF */
	ctlSYMBOLS byte public initial(0FFh),	/* SYMBOLS */
	ctlPAGING byte public initial(0FFh),	/* PAGING */
	ctlTTY byte public initial(0),		/* TTY */
	ctlMOD85 byte public initial(0),	/* MOD85 */
	ctlPRINT byte public initial(0FFh),	/* PRINT */
	ctlOBJECT byte public initial(0FFh),	/* OBJECT */
	ctlMACROFILE byte public initial(0),		/* MACROFILE */
	ctlPAGEWIDTH byte public initial(78h),		/* PAGEWIDTH */
	ctlPAGELENGTH byte public initial(42h),		/* PAGELENGTH */
	pad6A67 byte initial(0),		/* INCLUDE */
	ctlTITLE byte public initial(0),		/* TITLE */
	pad6A69(2) byte,			/* SAVE, RESTORE */
	ctlEJECT byte public initial(0),		/* EJECT */
	ctlLIST byte public initial(0FFh),	/* LIST */	/* SAVE/RESTORE act on next 3 opts */
	ctlGEN byte public initial(0FFh),	/* GEN */
	ctlCOND byte public initial(0FFh),	/* COND */
	b6A6F byte public initial(0FFh),
	titleLen byte public initial(0),
	b6A71 byte public,
	pad6A72(3) byte initial(78h, 0FFh),
	controlSeen(12) byte public initial(0,0,0,0,0,0,0,0,0,0,0,0),
	saveStack(24) byte public,
	saveIdx byte public initial(0),
	ctlTITLESTR(64) byte public,
	tokBufLen byte public,
	tokType byte public,
	controlId byte public,
	tokBuf(64) byte public,
	tokBufIdx byte public initial(0),
	w6B1E address public,
/* end */
	b6B20$9A77 byte public initial(0),
$IF OVL<>4
	MacroDebugOrGen byte public initial(0),
$ENDIF
/* ov4 compat 2F56 */
	scanCmdLine byte public,
	b6B23 byte public,
	b6B24 byte public,
	b6B25 byte public,
	has16bitOperand byte public,
	phase byte public,
	b6B28 byte public,
	b6B29 byte public,
	opType byte public,
	b6B2B byte public,
	b6B2C byte public,
	b6B2D byte public,
	finished byte public,
	b6B2F byte public,
	b6B30 byte public,
	b6B31 byte public,
	b6B32 byte public,
	b6B33 byte public,
	b6B34 byte public initial(0FFh),
	b6B35 byte public initial(0FFh),
	b6B36 byte public initial(0),
	segSize(4) address public initial(0, 0, 0, 0),	/* note treated as array */
	padw6B3E(2) byte initial(0, 0),
	w6B41(3) address public initial(0, 0, 0),
	cmdLineBuf(129) byte public,
	actRead address public,
	errCnt address public,
	padw6BCB(2) byte,
	w6BCE address public,
	pad6BD0(3) byte initial(0),
	azero address public initial(0),
	cmdch$p address public initial(.cmdLineBuf),
	controls$p address public,
	b6BD9 byte public initial(0),
	b6BDA byte public,
	ii byte public,
	b6BDC byte public,
	jj byte public,
/* end */
$IF OVL=4
	b$9B34 byte initial(0),
$ENDIF
/* ov4 compat 2F57 */
	curFileName$p address public,
	w6BE0 address public,
	bp6BE0(2) byte public at(.w6BE0),
	w6BE2 address public;
/* end */
asm801.plm
$SET(ASM801)
asm80$1:
do;

$include(asm801.ipx)

declare	spaces24(*) byte public data('                        ', 0),
	ascCRLF(*) byte public data(0Dh, 0Ah, 0),
	signonMsg(*) byte public data(0Dh, 0Ah),
	aIsisIi80808085(*) byte public data('ISIS-II 8080/8085 MACRO ASSEMBLER, V4.1', 9, 9),
	aModulePage(*) byte public data('MODULE ',9, ' PAGE ', 0),
	bZERO byte public data(0),
	bTRUE byte public data(0FFh),
	aC19761977197$0(*) byte data('(C) 1976,1977,1979,1980 INTEL CORP'),
	aStack(*) byte public data(0Dh, 0Ah, 'STACK', 0),
	aTable(*) byte public data(0Dh, 0Ah, 'TABLE', 0),
	aCommand(*) byte public data(0Dh, 0Ah, 'COMMAND', 0),
	aEof(*) byte public data(0Dh, 0Ah, 'EOF', 0),
	aFile(*) byte public data(0Dh, 0Ah, 'FILE', 0),
	aMemory(*) byte public data(0Dh, 0Ah, 'MEMORY', 0),
	aError(*) byte public data(' ERROR', 0Dh, 0Ah, 0),
	aError$0(*) byte public data(' ERROR, ', 0Dh,0Ah, 0),
	errStrs(*) address public data(.aStack, .aTable, .aCommand, .aEof, .aFile, .aMemory),
	errStrsLen(*) byte public data(7, 7, 9, 5, 6, 8),
	aBadSyntax(*) byte public data('BAD SYNTAX', 0Dh, 0Ah),
	aCo(*) byte public data(':CO:', 0);

declare	loadedOvl byte initial(4),
	ovlFile(*) byte public initial(':F0:ASM80.OV0 ');

$include(as4252.pac)


start:
	call getAsmFileX;
	phase = 1;
	call resetData;
	call initialControls;
	if ctlMACROFILE then
	do;
		if physmem < 8001h then
			call runtimeError(5);	 /* memory error */
		if includefd <> rootfd then
			call closeF(includefd);
		call closeF(infd);
		ovlFile(12) = '4';		/* use macro asm version */
		call load(.ovlFile, 0, 1, 0, .statusIO);
		call ioErrChk;
	end;
	if physmem > 8001h then
	do;
		if includefd <> rootfd then
			call closeF(includefd);
		call closeF(infd);
		ovlFile(12) = '5';		/* use big memory asm version */
		call load(.ovlFile, 0, 1, 0, .statusIO);
		call ioErrChk;
	end;

	if MacroDebugOrGen then			/* attempt to use macro features */
		call runtimeError(2);		/* command error */

	if ctlOBJECT then
	do;
		call delete(.objFile, .statusIO);
		objfd = inOpen(.objFile, 3);
	end;

	if ctlXREF then
	do;
		xreffd = inOpen(.aF0Asxref$tmp, 2);
		outfd = xreffd;
	end;

	call sub$540D;
	phase = 2;
	if ctlOBJECT then
	do;
		call ovlMgr(2);
		if r$extnames1.len > 0 then
			call writeRec(.r$extnames1); /* in overlay 2 */
		if w6750 = 0 then
			call writeModhdr;		/* in overlay 2 */
	end;
	if not ctlOBJECT or ctlPRINT then
	do;
		if ctlPRINT then
			outfd = inOpen(.lstFile, 2);

		call ovlMgr(3);
		call resetData;
		call initialControls;
		call sub$540D;
	end;
	if ctlPRINT then
	do;
		call ovlMgr(1);
		call asmComplete;
		call flushout;
	end;
	if ctlOBJECT then
	do;
		phase = 3;
		call ovlMgr(3);
		call resetData;
		call sub$70EE;
		call initialControls;
		call sub$540D;
		call ovlMgr(2);
		call ovl11;
		call writeModend;
	end;
	if not strUCequ(.aCo, .lstFile) then
	do;
		call ovlMgr(1);
		call ovl9;
	end;

	call ovlMgr(1);
	call ovl10;

end;
asm82.pl3
asm80$2:
do;

$include(asm82.ipx)

declare b3E5E(*) byte data(0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			   0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0),
	b3EA0(*) byte data(36h, 0, 0, 0, 6, 0, 0, 2),
	b3EA8(*) byte data(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0, 0, 0FFh,
			   0, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0,
			   0FFh, 0, 0, 0);


skipWhite: procedure public;
	do while isWhite;
		curChar = getCh;
	end;
end;


skipWhite$2: procedure public;
	do while getCh = ' ' or isTab;
	end;
end;


skip2NextLine: procedure public;
	call skip2EOL;
	call chkLF;
end;



sub$3F19: procedure public;

	sub$416B: procedure;
		if opType = 0 then
			call expressionError;
		b6B25 = 0;
		opType = 0;
	end;

	do while 1;
		if b689C then
		do;
			call preStatementControls;
			b689C = 0;
		end;

		do case getChClass;
	/* 0 CC$BAD */	call illegalCharError;
	/* 1 CC$WS  */	;
	/* 2 CC$SEMI */	do;
				b6742 = 0FFh;
				call skip2NextLine;
				b6B29 = 1;
				return;
			end;
	/* 3 CC$COLON */do;
				if not b6872 then
				do;
					if skipping(0) then
						call popToken;
					else
					do;
						b6CE4 = 2;
						call sub$5819(segSize(activeSeg), 2);
					end;

					b6B30 = 0;
					b6872, b6B31 = bTRUE;
				end;
				else
				do;
					call syntaxError;
					call popToken;
				end;

				call sub$467F(0, .b6873);
				b6880 = 0;
				opType = 3;
			end;
	/* 4 CC$CR */	do;
				call chkLF;
				b6B29 = 1;
				return;
			end;
	/* 5 CC$PUNCT */do;
				if curChar = '+' or curChar = '-' then
					if opType <> 0  and opType <> 3 then
						curChar = curChar + 3;
				b6B29 = (curChar - 28h) + 2;
				return;
			end;
	/* 6 CC$DOLLAR */do;
				call pushToken(0Ch);
				call addByte2Tok(low(segSize(activeSeg)));
				call addByte2Tok(high(segSize(activeSeg)));
				if activeSeg <> 0 then
					tokenAttr(0) = tokenAttr(0) or activeSeg or 18h;
				call sub$416B;
			end;
	/* 7 CC$QUOTE */do;
				call getStr;
				if b6B31 then
					call sub$43D2;
				call sub$416B;
			end;
	/* 8 CC$DIGIT */do;
				call getNum;
				if b6B31 then
					call sub$43D2;
				call sub$416B;
			end;
	/* 9 CC$LET*/	do;
				call getId(9);
				if tokenSize(0) > 6 then
					tokenSize(0) = 6;
				if ctlXREF then
				do;
					call move(6, .b6873, .b6879);
					call move(6, .spaces24 + 18, .b6873);	/* blanks */
				end;
				call move(tokenSize(0), tokStart(0), .b6873);
				b6744 = tokenSize(0);
				call packToken;
				if b6880 then
				do;
					b687F = 0FFh;
					b6880 = 0;
				end;

				if lookup(0) = 9 then	/* not a key word */
				do;
					tokenType(0) = lookup(1);	/* look up in symbol space */
					b6880 = 0FFh;	/* not key word */
				end;

				b6B29 = tokenType(0);
				b6885 = b3EA8(tokenType(0));
				if not b3E5E(tokenType(0)) then
					call popToken;

				if b687F then
				do;
					call sub$467F((not testBit(b6B29, .b3EA0)) and 1, .b6879);
					b687F = 0;
				end;
				if b6B29 < 10 or b6B29 = 9 or 80h then
				do;
					call sub$416B;
					if b6B31 then
						call sub$43D2;
				end;
				else
				do;
					b6B31 = 0;
					return;
				end;
			end;
		end;
	end;
end;



end;
asm83.plm
asm80$3: do;

/* to force the code generation this needs a non-standard definition
   of outStrN
*/
outStrN: procedure(s, n) external; declare s address, n address; end;


$include(asm83.ipx)
$include(as4483.pac)
end;
asm85.pl3
asm80$5: do;

$include(asm85.ipx)

declare b4A26(*) byte data(0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh,
			   0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh,
			   0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh,
			   0FFh, 0FFh, 0FFh, 0FFh, 0, 0FFh, 0FFh, 0FFh),
	b4A68(*) byte data(0, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0,
			   0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh,
			   0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh);

declare pad byte;

declare	accum(4) byte at(.accum1);


sub$4AAA: procedure(arg1b) public;
	declare arg1b byte;

	if b674A(arg1b) then
	do;
		if haveTokens then
		do;
			accum1 = sub$43DD;
			if alignTypes(arg1b) <> accum1$lb then
				call expressionError;
		end;
		else if alignTypes(arg1b) <> 3 then
			call expressionError;
	end;
	else
	do;
		b674A(arg1b) = TRUE;
		if haveTokens then
		do;
			accum1 = sub$43DD;
			if accum1 = 1 or accum1 = 2 then
				alignTypes(arg1b) = low(accum1);
			else
				call expressionError;
		end;
	end;
end;


cond2Acc: procedure(arg1b) public;
	declare arg1b byte;

	accum1 = arg1b;
	if accum1 then
		accum1 = 0FFFFh;
end;

sub$4B57: procedure(arg1b) public;
	declare arg1b byte;

	if (b6855 and 47h) <> 0 then
		b6855 = b6855 and 0E7h or arg1b;
end;

sub$4B72: procedure public;
	do case b6B2B;
/* 0 */		;
/* 1 */		call sub4C1E$54FD;			/* white space ? */
/* 2 */		goto case3;			/* ( */
/* 3 */ case3:	do;				/* : or ) */
			if not (b6B2B = 2 and opType = 3) then
				call balanceError;

			if tokenType(0) = 11 then
			do;
				tokenSize(0) = 1;
				tokenAttr(0) = 0;
				b6B36 = 0FFh;
			end;

			b6B35 = b6B2F;
			if opType = 3 then
				b6B2C = 0FFh;
		end;
/* 4 */		accum1 = accum1 * accum2;	/* * */
/* 5 */		accum1 = accum1 + accum2;	/* + */
/* 6 */		do;				/* , */
			call syntaxError;
			call popToken;
		end;
/* 7 */		accum1 = accum1 - accum2;	/* - */
/* 8 */		;				/* unary + */
/* 9 */		do;				/* / */
			if accum2 = 0 then
				call valueError;

			accum1 = accum1 / accum2;
		end;
/* 10 */	accum1 = -accum1;		/* unary - */
/* 11 */	call cond2Acc(accum1 = accum2);		/* EQ */
/* 12 */	call cond2Acc(accum1 < accum2);		/* LT */
/* 13 */	call cond2Acc(accum1 <= accum2);	/* LE */
/* 14 */	call cond2Acc(accum1 > accum2);		/* GT */
/* 15 */	call cond2Acc(accum1 >= accum2);	/* GE */
/* 16 */	call cond2Acc(accum1 <> accum2);	/* NE */
/* 17 */	accum1 = not accum1;			/* NOT */
/* 18 */	accum1 = accum1 and accum2;		/* AND */
/* 19 */	accum1 = accum1 or accum2;		/* OR */
/* 20 */	accum1 = accum1 xor accum2;		/* XOR */
/* 21 */	do;					/* MOD */
			if accum2 = 0 then
				call valueError;
			accum1 = accum1 mod accum2;
		end;
/* 22 */	do;					/* SHL */
			if accum2$lb <> 0 then
				accum1 = shl(accum1, accum2);
		end;
/* 23 */	do;					/* SHR */
			if accum2$lb <> 0 then
				accum1 = shr(accum1, accum2);
		end;
/* 24 */	do;					/* HIGH */
			accum1 = high(accum1);
			call sub$4B57(10h);
		end;
/* 25 */	do;					/* LOW */
			accum1 = low(accum1);
			call sub$4B57(8);
		end;
/* 26 */	do;					/* DB ? */
			if tokenType(0) <> 10 then
			do;
				accum1 = sub$43DD;
				if accum1$hb - 1 < 0FEh then
					call valueError;
				b6B28 = 22h;
				if (b6855 and 18h) = 18h then
				do;
					call valueError;
					b6855 = b6855 and 0E7h or 8;
				end;
			end;
			else
			do;
				b6855 = 0;
				tokenType(0) = 0Bh;
			end;

			if sub$425B(b6858) then
				call operandError;
			b6B2D = 0Bh;
			b6B23 = 0FFh;
		end;
/* 27 */	do;					/* DW ? */
			b6B2D = 0Bh;
			b6B24 = 0FFh;
		end;
/* 28 */	do;					/* DS ? */
			segSize(activeSeg) = segSize(activeSeg) + accum1;
			b68AB = 0FFh;
		end;
/* 29 */ case29:					/* EQU ? */
		do;
			b68AB = 0FFh;
			if (b6855 and 40h) = 40h then
			do;
				call expressionError;
				b6855 = 0;
			end;
			b6CE4 = 1;
			call sub$5819(accum1, 22h - b6B2B);	/* 4 for set, 5 for equ */
			b6B30 = 0;
		end;
/* 30 */	goto case29;				/* SET ? */
/* 31 */	do;					/* ORG ? */
			b68AB = 0FFh;
			if (b6855 and 40h) <> 40h then
			do;
				if (b6855 and 18h) <> 0 then
					if (b6855 and 7) <> activeSeg or (b6855 and 18h) <> 18h then
						call expressionError;
			end;
			else
				call expressionError;

			if ctlOBJECT then
				if segSize(activeSeg) > w6B41(activeSeg) then
					w6B41(activeSeg) = segSize(activeSeg);
			segSize(activeSeg) = accum1;
		end;
/* 32 */	do;					/* END ? */
			if tokenSP > 0 then
			do;
				startOffset = sub$43DD;
				startDefined = 1;
				startSeg = b6855 and 7;
				if (b6855 and 40h) = 40h then
					call expressionError;
				if sub$425B(b6858) then
					call operandError;

				b68AB = 0FFh;
			end;

			if ifDepth > 0 then
				call nestingError;
			if opType <> 1 then
				call syntaxError;
			if b6B35 then
				b6B33 = 0FFh;
			else
				call syntaxError;

		end;
/* 33 */	do;					/* IF ? */
			if b6B35 then
			do;
				b6B32 = 0FFh;
				call nestIF(2);
				b6881 = 0FFh;
				if skipping(0) = 0 then
					skipping(0) = not ((low(accum1) and 1) = 1);
				inElse(0) = 0;
			end;
		end;
/* 34 */	do;					/* ELSE ? */
			b6B32 = 0FFh;
			if ifDepth = 0 then
				call nestingError;
			else if not inElse(0) then
			do;
				if not skipping(0) then
					skipping(0) = 0FFh;
				else
					skipping(0) = skipping(ifDepth);
				inElse(0) = 0FFh;
			end;
			else
				call nestingError;
		end;
/* 35 */	do;					/* ENDIF ? */
			if b6B35 then
			do;
				b6B32 = 0FFh;
				call unnestIF(2);
			end;
		end;
/* 36 */	do;					/* LXI ? */
			if b6744 = 1 then
				if b6873(0) = 4Dh then
					call syntaxError;
			call sub$450F(85h);
		end;
/* 37 */	do;				/* POP DAD PUSH INX DCX ? */
			if b6744 = 1 then
				if b6873(0) = 4Dh then
					call syntaxError;
			call sub$450F(5);
		end;
/* 38 */	call sub$450F(7);		/* LDAX STAX ? */
/* 39 */	call sub$450F(2);		/* ADC ADD SUB ORA SBB XRA ANA CMP ? */
/* 40 */	call sub$450F(8);		/* ADI OUT SBI ORI IN CPI SUI XRI ANI ACI ? */
/* 41 */	call sub$450F(46h);		/* MVI ? */
/* 42 */	call sub$450F(6);		/* INR DCR ? */
/* 43 */	call sub$450F(36h);		/* MOV */
/* 44 */	call sub$450F(0);		/* CZ CNZ JZ STA JNZ JNC LHLD */
						/* CP JC SHLD CPE CPO CM LDA JP JM JPE */
						/* CALL JPO CC CNC JMP */
/* 45 */	call sub$450F(0);		/* RNZ STC DAA DI SIM SPHL RLC */
						/* RP RAL HLT RM RAR RPE RET RIM */
						/* PCHL CMA CNC RPO EI XTHL NOP */
						/* RC RNX XCHG RZ RRC */
/* 46 */	call sub$450F(6);		/* RST */
/* 47 */	activeSeg = 0;			/* ASEG ? */
/* 48 */	do;				/* CSEG ? */
			activeSeg = 1;
			call sub$4AAA(0);
		end;
/* 49 */	do;				/* DSEG ? */
			activeSeg = 2;
			call sub$4AAA(1);
		end;

/* 50 */	do;				/* PUBLIC */
			b6748 = 0FFh;
			b6CE4 = 0;
			call sub$5819(0, 6);
		end;
/* 51 */	do;				/* EXTRN ? */
			b6749 = 0FFh;
			if w6750 = 0 and isPhase1 and ctlOBJECT then
			do;
				call ovlMgr(2);
				call writeModhdr;
			end;
			b6CE4 = 0;
			call sub$5819(w6750, 2);
			if isPhase1 and ctlOBJECT and not b6754 then
			do;
				call ovlMgr(2);
				call writeExtName;
			end;
			if not b6754 then
				w6750 = w6750 + 1;
			b6754 = 0;
		end;
/* 52 */	do;				/* NAME */
			if tokenSP <> 0 and b6743 then
			do;
				call move(6, .spaces24 + 18, .aModulePage);
				call move(moduleNameLen := b6744, .b6873, .aModulePage);
			end;
			else
				call sourceError('R');

			call popToken;
		end;
/* 53 */	segSize(3) = accum1;		/* STKLN ? */
	end;

	if b6B2B <> 1 then
		b6743 = 0;
end;

sub$518F: procedure public;

	sub$53C0: procedure byte;
		if b6B29 > 3 then
			if b6B29 <> 6 then
				if b6B29 < 1Ah then
					return TRUE;
		return FALSE;
	end;

	sub$53DF: procedure(arg1b) byte;
		declare arg1b byte;
		return arg1b = 9 or arg1b = 64h;
	end;


	sub$53F8: procedure;
		if not b4A68(b6B2B) then
			b6B34 = 0;
	end;



	do while 1;
		if not (b6B29 = 1 or b6B29 >= 20h and b6B29 <= 23h) and skipping(0) then
		do;
			b6885 = 0;
			call popToken;
			return;
		end;
		
		if phase <> 1 then
			if b6B25 then
				if sub$53C0 then
					if getPrec(b6B29) <= getPrec(opStack(opSP)) then
						call expressionError;

		if getPrec(opType := b6B29) > getPrec(b6B2B := opStack(opSP)) or opType = 2 then
		do;
			if opSP >= 10h then
			do;
				opSP = 0;
				call stackError;
			end;
			else
				opStack(opSP := opSP + 1) = opType;
			if opType = 2 then
			do;
				b6B2F = b6B35;
				b6B35 = 0FFh;
			end;
			if phase > 1 then
				b6B25 = sub$53C0;
			return;
		end;

		b6B25 = 0;
		if not b6B35 and b6B2B > 3 then
			call syntaxError;

		if b6B2B = 0 then
			b6B2B = opType;
		else
			opSP = opSP - 1;
		

		if (b6B28 := b4181(b6B2B)) then
		do;
			accum2 = sub$43DD;
			b6856 = b6855;
			w685C = w685A;
			b6859 = b6858;
		end;

		if (b6B28 := ror(b6B28, 1)) then
			accum1 = sub$43DD;

		if not b6857 then
			b6857 = sub$53DF(b6858) or sub$53DF(b6859);

		b6B2D = 0Ch;
		if b6B2B > 3 and b6B2B < 1Ah then	/* expression op */
			call sub$4291;
		else
		do;
			call sub$53F8;
			call sub$4274;
		end;

		call sub$4B72;
		if not b4A26(b6B2B) then
			b6B35 = 0;

		if b6B2C then
		do;
			b6B2C = 0;
			return;
		end;

		if b6B2B <> 1Ch and b68AB then		/* DS */
			w68A6 = accum1;

		if (b6B28 and 1Eh) <> 0 then
			call pushToken(b6B2D);

		do ii = 0 to 3;
			if (b6B28 := ror(b6B28, 1)) then
				call addByte2Tok(accum(ii));
		end;

		tokenAttr(0) = b6855;
		tokenSymId(0) = w685A;
		if ror(b6B28, 1) then
			if opType = 6 then
			do;
				b6B29 = b6B2B;
				b6B35 = 0FFh;
			end;
	end;
end;



sub$540D: procedure public;
	do while finished = 0;
		call sub$3F19;
		call sub$518F;
	end;
end;

end;
asm851.plm
asm851: do;

$include(asm851.ipx)

declare pad1 address data(40h);
declare pad2 address;



strUCequ: procedure(arg1w, arg2w) byte public;
	declare (arg1w, arg2w) address;
	declare ch1 based arg1w byte,
		ch2 based arg2w byte;

	do while ch1 <> 0;
		if ch1 <> ch2 and ch1 <> (ch2 and 5Fh) then
			return FALSE;
		arg1w = arg1w + 1;
		arg2w = arg2w + 1;
	end;
	return TRUE;
end;


isSkipping: procedure byte public;
	return skipping(0);
end;


sub$546F: procedure public;
	b6A56 = sub$4646;
	if b6B30 then
		call syntaxError;
	if haveTokens then
		if not(tokenType(b6A56) = 0Bh or b68AD) then
			call syntaxError;
	if b6B23 or b6B24 then
	do;
		if tokenSP = 1 and not blankAsmErrCode and tokenSize(0) <> 1 then
			tokenSize(0) = 2;
	end;
	else if not blankAsmErrCode and haveTokens then
		if tokenSize(b6A56) > 3 then
			tokenSize(b6A56) = 3;
end;



sub4C1E$54FD: procedure public;
	declare lineno$p address, updating byte;
	declare ch based lineno$p byte;

	call sub$546F;
	if isPhase2Print then
	do;
		lineno$p = .asciiLineNo(3);	/* point to last digit */
		updating = TRUE;

		do while updating;	/* adjust the line number */
			if ch = '9' then	/* if 9 then roll over to 0 */
				ch = '0';
			else
			do;
				if ch = ' ' then	/* new digit */
					ch = '1';
				else			/* just increment */
					ch = ch + 1;
				updating = FALSE;
			end;
			lineno$p = lineno$p - 1;
		end;

		if sub$465B or not blankAsmErrCode then
		do;
			call ovlMgr(1);
			call ovl3;
		end;
	end;

	if b6BD9 then
	do;
		out$p = out$p + 1;
		call flushout;
		call exit;
	end;


	if not b6B20$9A77 then
	do;
		ii = 2;
		if tokenSP < 2 or b6B23 or b6B24 then
			ii = 0;

		w6BCE = tokStart(ii) + tokenSize(ii);
		if isSkipping or not b6B34 then
			w6BCE = .lineBuf;

		if chkGenObj then
		do;
			call ovlMgr(2);
			call ovl8;
		end;

		b6B2C = 0FFh;
		segSize(activeSeg), w68A6 = segSize(activeSeg) + (w6BCE - .lineBuf);
	end;

	if ctlXREF and b6880 then
		if phase = 1 then
			call sub$467F(1, .b6873);

	do while tokenSP > 0;
		call popToken;
	end;

	call sub3DCE$3DFB;
	if b6B33 then
	do;
		finished = 0FFh;
		if isPhase2Print and ctlSYMBOLS then
		do;
			call ovlMgr(1);
			call sub$7041;			/* in overlay 1 */
		end;

		call sub$467F(2, .b6873);
		if chkGenObj then
		do;
			call ovlMgr(2);
			call sub$6E32;
		end;
	end;
end;
end;
asm86.pl3
asm80$6: do;

$include(asm86.ipx)


declare	b5666(*) byte data(9, 2Dh, 80h),
	b5669(*) byte data(3Ah, 8, 80h, 0, 0, 0, 0, 0, 20h),
			/* 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
	op16(*) byte data(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
			   0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1),
			  /* 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
	chClass(*) byte data(0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 4, 0, 0,	/* 00 */
			     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 10 */
			     1, 0, 0, 0, 6, 0, 0, 7, 5, 5, 5, 5, 5, 5, 0, 5,	/* 20 */
			     8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 3, 2, 0, 0, 0, 9,	/* 30 */
			     9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,	/* 40 */
			     9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0,	/* 50 */
			     0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,	/* 60 */
			     9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0);	/* 70 */



unpackToken: procedure(src, dst) public;
	declare (src, dst) address;
	declare wrd based src address;
	declare ch based dst byte;
	declare packedword address;

	unpack1: procedure;
		ch = packedword mod 40;	
		if ch = 0 then
			ch = ' ';
		else if ch <= 10 then
			ch = ch + 2Fh;	/* digit */
		else 
			ch = ch + 34h;	/* ? @ and letters */
		packedword = packedword / 40;
		dst = dst - 1;
	end;


	src = src + 2;
	dst = dst + 5;
	packedword = wrd;
	call unpack1;
	call unpack1;
	call unpack1;
	src = src - 2;
	packedword = wrd;
	call unpack1;
	call unpack1;
	call unpack1;
end;




insertSym: procedure public;
	declare (w6CE0, w6CE2) address;
	declare ch1 based w6CE0 byte,
		ch2 based w6CE2 byte;

	w686E, w6CE0 = (w6CE2 := w686E) + 8;
	if w6CE0 > w6870 then
		call runtimeError(1);	/* table error */

	do while w6CE2  > curTokenSym$p;
		w6CE0 = w6CE0 - 1;
		w6CE2 = w6CE2 - 1;
		ch1 = ch2;
	end;

	call move(4, curTokStart, curTokenSym$p);
	curTokenSym.type = 0;
end;

declare b6CE4 byte public;

sub$5819: procedure(arg1w, arg2b) public;
	declare arg1w address, arg2b byte;
	declare (b6CE8, b6CE9, b6CEA, b6CEB, b6CEC) byte;

	sub$5B9A: procedure;
		tokenType(0) = arg2b;
		if (b6858 = 7 or b6858 = 8) and b6CEB then
			tokenType(0) = 12 - arg2b;
	end;


	b6CEC = tokenType(0);
	b6CEB = arg2b = 5 or arg2b = 4;
	b6CE9 = 0;
	b6CE8 = curTokenSym.flags;
	b6CEA = 0;
	if curTokenSym$p > w6868(1) or curTokenSym$p < symTab(1) then
	do;
		call syntaxError;
		return;
	end;

	if tokenSP > 1 then
		call syntaxError;

	if isPhase1 then
		if tokenType(0) = 9 then
		do;
			if b6883 then
			do;
				if curTokenSym.type >= 80h then
				do;
					call locationError;
					b6CE9 = 80h;
				end;
			end;
			else
			do;
				call insertSym;
				w6868(1) = w6868(1) + 8;
				b6CE8 = 0;
			end;

			b6CE8 = (activeSeg <> 0 and 18h) or (b6748 and 20h) or (b6749 and 58h);
			if b6CE4 = 1 then
				b6CE8 = b6855;

			if b6CE4 = 2 then
				b6CE8 = b6CE8 or activeSeg;
			if b6857 and b6CEB then
				tokenType(0) = 64h;
			else
				call sub$5B9A;
			goto L5A9B;
		end;

	if b6882 = 2 then
		if tokenType(0) = 9 then
			if b6858 <> 9 then
				if b6CEB then
				do;
					call sub$5B9A;
					if curTokenSym.type < 128 then
					do;
						curTokenSym.type = tokenType(0);
						curTokenSym.w4 = arg1w;
						b6CE8 = b6855;
						b6CEA = 0FFh;
					end;
					goto L5A9B;
				end;

	if isPhase1 then
		if tokenType(0) = 6 then
			if testBit(arg2b, .b5666) then
			do;
				if b6749 then
					tokenType(0) = 3;
				else
				do;
					tokenType(0) = arg2b;
					b6CE8 = b6CE8 and 0E0h;
					if b6CE4 = 1 then
						b6CE8 = b6855 or 20h;
					if b6CE4 = 2 then
						if activeSeg <> 0 then
							b6CE8 = b6CE8 or activeSeg or 38h;
				end;
				goto L5A9B;
			end;

	if isPhase1 then
		if arg2b = 6 then
			if testBit(tokenType(0), .b5666) then
			do;
				if (b6CE8 and 60h) <> 0 then
					tokenType(0) = 3;
				else
					b6CE8 = b6CE8 or 20h;
				goto L5A9B;
			end;

	if isPhase1 then
		if tokenType(0) <> arg2b and tokenType(0) <> 8 or arg2b = 5 then
			tokenType(0) = 3;

	if not b6748 and testBit(tokenType(0), .b5669) then
		b6CE8 = (b6CE8 and 20h) and tokenType(0) <> 3Ah or b6855;
	else
	do;
		if isPhase1 then
			tokenType(0) = 3;

		if not (b6748 or b6749) then
			if curTokenSym.w4 <> arg1w then
				call phaseError;
	end;

L5A9B:
	b6CE9 = b6CE9 or (curTokenSym.type and 80h);
	if isPhase1 and (arg2b = 9 or arg2b = 6 or b6CEC <> tokenType(0)) then
		curTokenSym.type = tokenType(0) or b6CE9;

	jj = curTokenSym.type;
	if tokenType(0) = 3 or jj = 3 then
		call multipleDefError;

	if jj >= 80h then
		call locationError;

	if isPhase1 and (tokenType(0) = arg2b or arg2b = 5 and tokenType(0) = 7) or arg2b = 4 and blankAsmErrCode or b6CEA then
		curTokenSym.w4 = arg1w;
	curTokenSym.flags = b6CE8;
	b6748 = 0;
	b6749 = 0;
	if curTokenSym.type = 6 then
		call undefinedSymbolError;

	b6857 = 0;
	if b6883 then
		call popToken;
end;



lookup: procedure(arg1b) byte public;
	declare arg1b byte;
	declare (lowOffset, highOffset, midOffset, deltaToNext, entryOffset, packedTok$p) address,
		x structure(i byte), b6CFB byte;
	declare symEntry based entryOffset SYMENTRY$T,
		packedTok based packedTok$p (2) address; 
	declare addr based w6BE0 address,
		addrAlt based w6BE0 address;


	packedTok$p = curTokStart;
	if arg1b = 0 then
	do;
		entryOffset = 0;	/* offset to current symbol to compare */
					/* offset of fist to use - hashes packed symbol name */
		deltaToNext = symTab(0) + ((packedTok(0) + packedTok(1)) mod 151) * 8;

		do while deltaToNext <> 0;	/* while not end of chain */
			entryOffset = entryOffset + deltaToNext;	/* point to the next in chain */
			if symEntry.tok(0) = packedTok(0) then		/* check for exact match */
				if symEntry.tok(1) = packedTok(1) then
				do;
					curTokenSym$p = entryOffset;
					tokenType(0) = curTokenSym.type;
					if tokenType(0) < 2Dh then	/* not pseudo op */
						if op16(tokenType(0)) then
							has16bitOperand = 0FFh;

					if curTokenSym.flags = 2 and not ctlMOD85 then	/* RIM/SIM only valid on 8085 */
						call sourceError('O');

					if tokenType(0) = 8 then		/* SP */
					do;
						if not(opType = 24h or opType = 25h) then /* lxi or push/pop/dad/inx/dcx */
							call sourceError('X');
						tokenType(0) = 7;		/* reg */
					end;
					return tokenType(0) and 7Fh;
				end;
			deltaToNext = symEntry.delta;
		end;
		return 9;
	end;

	lowOffset = symTab(arg1b);
	highOffset, entryOffset = w6868(arg1b);

	do while (midOffset := lowOffset + shr((highOffset - lowOffset) and 0FFF0h, 1)) <> entryOffset;
		entryOffset = midOffset;
		if packedTok(0) = symEntry.tok(0) then
		do;
			if packedTok(1) = symEntry.tok(1) then
			do;
				curTokenSym$p = entryOffset;
				tokenType(0) = curTokenSym.type;
				if tokenType(0) = 64h then
					tokenType(0) = 9;
				if (b6884 := (jj := tokenType(0) and 7Fh) = 9) then
					if b6885 then
						curTokenSym.type = 89h;
				return jj;
			end;
			else
				b6CFB = symEntry.tok(1) > packedTok(1);
		end;
		else
			b6CFB = symEntry.tok(0) > packedTok(0);

		entryOffset = midOffset;
		if b6CFB then
			highOffset = entryOffset;
		else
			lowOffset = entryOffset;
	end;

	curTokenSym$p = highOffset;
	if arg1b = 1 and not isSkipping then
	do;
		b6883 = 0;
		b6CE4 = 0;
		call sub$5819(w6A4E, b6885 and 80h or 9);
		w6BE0 = .tokenSym;
		do x.i = 1 to tokenSP;
			w6BE0 = w6BE0 + 2;
			if addr >= curTokenSym$p then
				addrAlt = addr + 8;
		end;
		b6883 = 0FFh;
	end;
	return 9;
end;

getCh: procedure byte public;
	declare (curCH, prevCH) byte;

	if not reget then
	do;
		prevCH = curCH;
	L5E54:
		curCH = lookAhead;
		if scanCmdLine then
			lookAhead = nxtCmdCh;
		else
			lookAhead = sub$4879;

		if chClass(curCH) = CC$BAD then
			if curCH = 0 or curCH = 7Fh or curCH = 0Ch then
				goto L5E54;
	end;
	reget = 0;
	return (curChar := curCH);
end;

getChClass: procedure byte public;
	curChar = getCh;
	return chClass(curChar);
end;


chkLF: procedure public;
	if lookAhead = 0Ah then
		lookAhead = 0;
	else
		call illegalCharError;
end;
end;
asm861.plm
asm861: do;

$include(asm861.ipx)


syntaxError: procedure public;
	call sourceError('Q');	/* syntaxError */
end;

doubleDefError: procedure public;
	call sourceError('D');	/* double defined symbol */
end;

expressionError: procedure public;
	call sourceError('E');	/* external error */
end;

commandError: procedure public;
	call sourceError('C');	/* command error */
end;

OpcodeOperandError: procedure public;
	call sourceError('O');
end;

nameError: procedure public;
	call sourceError('R');
end;

multipleDefError: procedure public;
	call sourceError('M');	/* multiply defined symbol */
end;

valueError: procedure public;
	call sourceError('V');	/* value error */
end;

nestingError: procedure public;
	call sourceError('N');	/* nesting error */
end;

phaseError: procedure public;
	call sourceError('P');	/* phase error */
end;

stackError: procedure public;
	call runtimeError(0);	/* stack error */
end;

fileError: procedure public;
	call runtimeError(4);	/* file error */
end;

illegalCharError: procedure public;
	call sourceError('I');
end;

balanceError: procedure public;
	call sourceError('B');
end;

undefinedSymbolError: procedure public;
	call sourceError('U');	/* undefined symbol */
end;

locationError: procedure public;
	call sourceError('L');
end;

operandError: procedure public;
	call sourceError('X');
end;

haveTokens: procedure byte public;
	return tokenSP <> 0;
end;


popToken: procedure public;
	tokStart(0) = tokStart(tokenSP);
	tokenSym(0) = tokenSym(tokenSP);
	tokenType(0) = tokenType(tokenSP);
	tokenAttr(0) = tokenAttr(tokenSP);
	tokenSize(0) = tokenSize(tokenSP);
	tokenSymId(0) = tokenSymId(tokenSP);
	if haveTokens then
		tokenSP = tokenSP - 1;
end;


nestIF: procedure(arg1b) public;
	declare arg1b byte;
	
	if (ifDepth := ifDepth + 1) > 8 then
	do;
		call stackError;
		ifDepth = 0;
	end;
	else
	do;
		skipping(ifDepth) = skipping(0);
		inElse(ifDepth) = inElse(0);
	end;
end;

unnestIF: procedure(arg1b) public;
	declare arg1b byte;

	if ifDepth = 0 then
		call nestingError;
	else
	do;
		skipping(0) = skipping(ifDepth);
		inElse(0) = inElse(ifDepth);
		ifDepth = ifDepth - 1;
	end;
end;

pushToken: procedure(arg1b) public;
	declare arg1b byte;
	if tokenSP >= 8 then
		call stackError;
	else
	do;
		tokenSP = tokenSP + 1;
		tokStart(tokenSP) = tokStart(0);
		tokenSym(tokenSP) = tokenSym(0);
		tokenType(tokenSP) = tokenType(0);
		tokenAttr(tokenSP) = tokenAttr(0);
		tokenSize(tokenSP) = tokenSize(0);
		tokenSymId(tokenSP) = tokenSymId(0);
		tokStart(0) = tokStart(0) + tokenSize(0);	/* advance for next token */
		tokenType(0) = arg1b;
		tokenAttr(0), tokenSize(0) = bZERO;
		tokenSym(0) = wZERO;
		tokenSymId(0) = tokenSym(0);
	end;
end;

addByte2Tok: procedure(arg1b) public;
	declare arg1b byte, s address;
	declare ch based s byte;

	if (s := tokStart(0) + tokenSize(0)) < endLineBuf then	/* check for lineBuf overrun */
	do;
		ch = arg1b;
		tokenSize(0) = tokenSize(0) + 1;
	end;
	else
		call stackError;
end;

getId: procedure(arg1b) public;
	declare arg1b byte;

	call pushToken(arg1b);
	reget = 1;

	do while (arg1b := getChClass) = CC$DIGIT or arg1b = CC$LET;	/* digit or letter */
		if curChar > 60h then			/* make sure upper case */
			curChar = curChar and 0DFh;
		call addByte2Tok(curChar);
	end;
	reget = 1;
end;


getNum: procedure public;
	declare accum address, (radix, digit, i) byte;
	declare chrs based curTokStart(1) byte;

	call getId(0Ch);
	

	radix = chrs(tokenSize(0) := tokenSize(0) - 1);
	if radix = 'H' then
		radix = 10h;

	if radix = 'D' then
		radix = 0Ah;

	if radix = 'O' or radix = 'Q' then
		radix = 8;

	if radix = 'B' then
		radix = 2;

	if radix > 10h then
		radix = 10;
	else
		tokenSize(0) = tokenSize(0) - 1;

	accum = 0;
	do i = 0 to tokenSize(0);
		if chrs(i) = '?' or chrs(i) = '@' then
		do;
			call illegalCharError;
			digit = 0;
		end;
		else
		do;
			digit = chrs(i) - '0';
			if digit > 9 then
				digit = digit - 7;
			if digit >= radix then
				if tokenType(2) <> 40h then
				do;
					call illegalCharError;
					digit = 0;
				end;
		end;

		accum = accum * radix + digit;
	end;

	/* replace with packed number */
	tokenSize(0) = 0;
	call addByte2Tok(low(accum));
	call addByte2Tok(high(accum));
end;


getStr: procedure public;
	call pushToken(0Ah);

	do while getCh <> 0Dh;
		if curChar = 27h then
			if getCh <> 27h then
				goto L6268;
		call addByte2Tok(curChar);
	end;

	call balanceError;

L6268:
	reget = 1;
end;

end;
asmov0.pl3
asmov0: do;

$include(asmov0.ipx)

declare controlTable(*) byte data(35h, 'DEBUG', 3Ah, 'MACRODEBUG',
			   34h, 'XREF', 37h, 'SYMBOLS',
			   36h, 'PAGING', 33h, 'TTY',
			   25h, 'MOD85', 35h, 'PRINT',
			   36h, 'OBJECT', 39h, 'MACROFILE',
			   29h, 'PAGEWIDTH', 2Ah, 'PAGELENGTH',
			   7, 'INCLUDE', 5, 'TITLE',
			   4, 'SAVE', 7, 'RESTORE',
			   5, 'EJECT', 14h, 'LIST',
			   13h, 'GEN', 14h, 'COND');

declare (b7463, b7464, b7465, controlError) byte;


chkParen: procedure(arg1b) byte;
	declare arg1b byte;
	call skipWhite;
	reget = 0;
	return arg1b + '(' = curChar;
end;



getTok: procedure byte;
	tokBufLen = 0;
	tokType = TT$ID;
	if isCR then
		return curChar;

	call skipWhite$2;
	if curChar > 40h and 5Bh > curChar or curChar >60h and 7Bh > curChar then
	do;	/* is letter */
		call getId(1);
		if blankAsmErrCode and tokenSize(0) < 14 then
			call move(tokBufLen := tokenSize(0), .lineBuf, .tokBuf);
	end;
	else if curChar > 2Fh  and  3Ah > curChar then
	do;	/* is digit */
		call getNum;
		if blankAsmErrCode then
		do;
			w6B1E = sub$43DD;
			tokType = TT$NUM;
			tokBuf(0) = 20h;
		end;
	end;
	else if curChar = 27h then
	do;	/* is string */
		call getStr;
		if blankAsmErrCode then
		do;
			tokBufLen = 40h;
			if tokenSize(0) < 40h then
				tokBufLen = tokenSize(0);
			tokType = TT$STR;
			if tokBufLen > 0 then
				call move(tokBufLen, .lineBuf, .tokBuf);
		end;
	end;
	else
	do;
		tokBufLen = 1;
		tokBuf(0) = curChar;
		return curChar;
	end;

	call popToken;
	return tokBuf(0);
end;



sub$6F07: procedure(arg1w) byte;
	declare arg1w address;
	declare pad address;

	if tokBufIdx = 0 then
		return 0;

	tokBuf(tokBufIdx) = 20h;
	tokBufLen = tokBufIdx;
	if isWhite then
		return chkParen(1);
	return 0FFh;
end;

sub$6F39: procedure;
	call skipWhite$2;

    do while 1;
	if isRParen or isWhite then
	do;
		if sub$6F07(.tokBuf(0)) then
			return;
		goto done;
	end;

	tokBuf(tokBufIdx) = curChar;
	tokBufIdx = tokBufIdx + 1;
	if tokBufIdx > 14 then
		goto done;
	curChar = getCh;
    end;
done:
	curFileName$p = .tokBuf;
	call fileError;
end;


getFileParam: procedure;
	tokBufIdx = 0;
	if not chkParen(0) then		/* ( */
		call fileError;
	else
	do;
		call sub$6F39;
		call move(tokBufIdx + 1, .tokBuf, curFileName$p);
		if not chkParen(1) then	/* ) */
			call fileError;
	end;
end;


getMacroFileDrive: procedure;
	call skipWhite$2;
	tokBufIdx = 0Dh;
	ii = 0;

	do while not isRParen and ii < 4;
		aF0Asmac$tmp(ii) = curChar;
		ii = ii + 1;
		curChar = getCh;
	end;

	if isRParen or isWhite then
		if sub$6F07(.aF0Asmac$tmp) then
			return;
	curFileName$p = .aF0Asmac$tmp;
	tokBufIdx = 0;
	call fileError;
end;




sub$702B: procedure byte;
	if chkParen(0) then	/* ( */
	do;
		b7463 = getTok;
		if tokType = TT$NUM then
			return chkParen(1);	/* ) */
	end;
	return 0;
end;


lookupControl: procedure byte;
	declare (cmdIdx, cmdStartIdx, ctlVal, cmdLen, ctlFlags, noInvalid) byte,
		(control$p, nextControl$p, ctlSeen$p) address;
	declare twoch address at(.tokBuf);
	declare ch based control$p byte;
	declare ctlSeen based ctlSeen$p byte;

	setControl: procedure;
		if not noInvalid then
		do;
			controls(controlId) = ctlVal;
			if not ctlVal then
				controlId = 17;		/* no action needed */
		end;
	end;

	cmdLen = tokBufLen;
	cmdStartIdx = 0;
	ctlVal = 0FFh;
	if twoch = 'ON' then	/* NO stored with bytes swapped */
	do;
		cmdStartIdx = 2;	/* don't match the NO in the table */
		ctlVal = 0;		/* control will be set as false */
		cmdLen = tokBufLen - 2;	/* length of string to match excludes the NO */
	end;
	control$p = .controlTable;
	controlId = 0;
	cmdIdx = cmdStartIdx;

	do while controlId < 20;
		nextControl$p = control$p + (ch and 0Fh) + 1;
		if (ch and 0Fh) = cmdLen then
		do;
			ctlFlags = ch;
			do while cmdIdx < tokBufLen;
				control$p = control$p + 1;
				if ch <> tokBuf(cmdIdx) then
					cmdIdx = tokBufLen + 1;	/* cause early exit */
				else
					cmdIdx = cmdIdx + 1;	/* check next character */
			end;
			if cmdIdx = tokBufLen then		/* found it */
				goto break;
		end;
		control$p = nextControl$p;
		controlId = controlId + 1;
		cmdIdx = cmdStartIdx;
	end;
	return 255;					/* not found */

break: if controlId = 1 or controlId = 12h then		/* MACRODEBUG or GEN */
	do;
		if scanCmdLine then			/* only valid on command line not $ line */
			MacroDebugOrGen = 0FFh;
		else
			return 255;			/* error otherwise */
	end;

	if (noInvalid := (ctlFlags and 10h) <> 10h) and not ctlVal then
		return 0FFh;				/* NO not supported */

	if (ctlFlags and 20h) <> 20h then		/* GENERAL control */
	do;
		call setControl;
		return controlId;
	end;
							/* is a PRIMARY control */
	if not primaryValid then
		return 255;

	ctlSeen$p = .controlSeen(controlId);		/* make sure we only see a primary once */
	if ctlSeen then
		return 255;
	ctlSeen = TRUE;
	call setControl;
	return controlId;
end;




processControl: procedure;
	if controlId >= 17 or controlId < 5 then
		return;

	do case controlId - 5;
/* 0 */		do;			/* TTY */
			ctlTTY = 0FFh;
			return;
		end;
/* 1 */		do;			/* MOD85 */
			ctlMOD85 = 0FFh;
			return;
		end;
/* 2 */		do;			/* PRINT */
			w6BE2 = 2;
			curFileName$p = .lstFile;
			call getFileParam;
			return;
		end;
/* 3 */		do;			/* OBJECT */
			w6BE2 = 3;
			curFileName$p = .objFile;
			call getFileParam;
			return;
		end;
/* 4 */		do;			/* MACROFILE */
			w6BE2 = 3;
			if chkParen(0) then	/* optional drive for tmp file */
				call getMacroFileDrive;
			else
				reget = 1;
			ctlMACROFILE = 0FFh;
			return;
		end;
/* 5 */		do;			/* PAGEWIDTH */
			if sub$702B then
			do;
				ctlPAGEWIDTH = w6B1E;
				if ctlPAGEWIDTH > 132 then
					ctlPAGEWIDTH = 132;
				if ctlPAGEWIDTH < 72 then
					ctlPAGEWIDTH = 72;
				return;
			end;
		end;
/* 6 */		do;			/* PAGELENGTH */
			if sub$702B then
			do;
				ctlPAGELENGTH = w6B1E;
				if ctlPAGELENGTH < 15 then
					ctlPAGELENGTH = 15;
				return;
			end;
		end;
/* 7 */		do;			/* INCLUDE */
			if not b6C21 then
			do;
				w6BE2 = 1;
				if fileIdx = 5 then
					call stackError;
				else
				do;
					fileIdx = fileIdx + 1;
					curFileName$p = .files(fileIdx);
					call getFileParam;
					b6C21 = 0FFh;
					if scanCmdLine then
						b6C22 = 0FFh;
					return;
				end;
			end;
		end;
/* 8 */		do;			/* TITLE */
			if chkParen(0) then
			do;
				b7463 = getTok;
				if tokType = TT$STR and tokBufLen <> 0 then
				do;
					if phase <> 1 or isPhase1 and primaryValid then
					do;
						call move(tokBufLen, .tokBuf, .ctlTITLESTR);
						ctlTITLESTR(titleLen := tokBufLen) = 0;
						if chkParen(1) then
						do;
							ctlTITLE = 0FFh;
							return;
						end;
					end;
				end;
			end;
		end;
/* 9 */		do;				/* SAVE */
			if saveIdx > 7 then
				call stackError;
			else
			do;
				call move(3, .ctlLIST, .saveStack + saveIdx * 3);
				saveIdx = saveIdx + 1;
				return;
			end;
		end;
/* 10 */	do;				/* RESTORE */
			if saveIdx > 0 then
			do;
				call move(3, .saveStack + (saveIdx := saveIdx - 1) * 3, .ctlLIST);
				return;
			end;
		end;
/* 11 */	do;				/* EJECT */
			ctlEJECT = ctlEJECT + 1;
			return;
		end;
	end;
	controlError = 0FFh;
end;


parseControls: procedure public;
	b6B20$9A77 = 0FFh;
	b6A6F, b7464 = ctlLIST;
	controlError = 0;

	do while getTok <> 0Dh and not controlError;
		if tokBuf(0) = ';' then
			call skip2EOL;
		else if lookupControl = 0FFh then	/* error ? */
			controlError = 0FFh;
		else
			call processControl;
	end;

	if controlError then
	do;
		if tokBuf(0) <> 0Dh then
		do;
			reget = 0;
			call skip2EOL;
		end;
		if scanCmdLine then
			call runtimeError(2);	/* command error */
		else
			call commandError;
	end;

	call chkLF;				/* gobble the line feed */
	if ctlLIST <> b7464 then
		b6A6F = 0FFh;
	reget = 0;
end;

end;
asmov1.pl3
asmov1: do;
/* override to force code */
put2Hex: procedure(arg1w, arg2w) external; declare arg1w address, arg2w address; end;
$include(asmov1.ipx)

declare	aAssemblyComple(*) byte initial(0Dh, 0Ah, 'ASSEMBLY COMPLETE,'),
	aNoErrors(*) byte initial('   NO ERRORS'),
	asc$751E(*) byte initial(' ('),
	asc$7520(*) byte initial('     )'),
	aPublicSymbols(*) byte initial(0Dh, 0Ah, 'PUBLIC SYMBOLS', 0Dh, 0Ah, 0),
	aExternalSymbol(*) byte initial(0Dh, 0Ah, 'EXTERNAL SYMBOLS', 0Dh, 0Ah, 0),
	pad754E address,

	aUserSymbols(*) byte data(0Dh, 0Ah, 'USER SYMBOLS', 0Dh, 0Ah, 0),
	aLocObjLineSour(*) byte data('  LOC  OBJ         LINE        SOURCE STATEMENT', 0Dh, 0Ah, 0Ah, 0),
	wa6DB2(*) address data(.aPublicSymbols, .aExternalSymbol, .aUserSymbols),
	asc$6DB8(*) byte data(0Dh, 0Ah, 0Ah, 0),
	asc$6DBC(*) byte data(0Dh),
	asc$6DBD(*) byte data(0Ah, 0Ah, 0Ah, 0),
	b6DC1(2) byte data(20h, 40h),
	ascLParen(*) byte data(' (', 0),
	ascRParen(*) byte data(')', 0),
	a1234(*) byte data('  1234');	



out2Hex: procedure(arg1b);
	declare arg1b byte;
	call put2Hex(.outch, arg1b);
end;


print2Hex: procedure(arg1b);
	declare arg1b byte;
	call put2Hex(.printChar, arg1b);
end;



printStr: procedure(arg1w) reentrant;
	declare arg1w address;
	declare ch based arg1w byte;

	do while ch <> 0;
		call printChar(ch);
		arg1w = arg1w + 1;
	end;
end;

printNStr: procedure(arg1b, arg2w) reentrant;
	declare arg1b byte, arg2w address;
	declare ch based arg2w byte;

	do while arg1b > 0;
		call printChar(ch);
		arg2w = arg2w + 1;
		arg1b = arg1b - 1;
	end;
end;


printCRLF: procedure reentrant;
	call printChar(0Dh);
	call printChar(0Ah);
end;

declare asc$7752 byte initial(' '),
	asc$7553(*) byte initial('    ', 0);


itoa: procedure(arg1w, arg2w);
	declare (arg1w, arg2w) address;
	declare ch based arg2w byte;

	call move(5, .spaces24 + 19, arg2w);
	arg2w = arg2w + 4;

	do while 1;
		ch = arg1w mod 10 + '0';
		arg2w = arg2w - 1;
		if (arg1w := arg1w /10) = 0 then
			return;
	end;
end;


printDecimal: procedure(arg1w) reentrant public;
	declare arg1w address;
	call itoa(arg1w, .asc$7752);
	call printStr(.asc$7553);
end;

skipToEOP: procedure public;
	do while lineCnt <= ctlPAGELENGTH;
		call outch(0Ah);
		lineCnt = lineCnt + 1;
	end;
end;


newPageHeader: procedure public;
	call printStr(.asc$6DBD);
	call printStr(.aIsisIi80808085);
	call printDecimal(pageCnt);
	call printCRLF;
	if ctlTITLE then
		call printNStr(titleLen, .ctlTITLESTR);

	call printCRLF;
	call printCRLF;
	if not b68AE(0) then
		call printStr(.aLocObjLineSour);
	pageCnt = pageCnt + 1;
end;


newPage: procedure public;
	if ctlTTY then
		call skipToEOP;
	else
		call outch(0Ch);

	lineCnt = 1;
	if not scanCmdLine then
		call newPageHeader;
end;


sub$6F4D: procedure public;
	if sub$465B then
	do while ctlEJECT > 0;
		call newPage;
		ctlEJECT = ctlEJECT - 1;
	end;
end;



printChar: procedure(arg1b) reentrant;
	declare arg1b byte;
	declare cnt byte;
	
	if arg1b = 0Ch then
	do;
		call newPage;
		return;
	end;
	if arg1b = 0Ah then
		if ctlPAGING then
		do;
			if (lineCnt := lineCnt + 1) >= ctlPAGELENGTH - 2 then
			do;
				if ctlTTY then
					call outch(0Ah);
				if ctlEJECT > 0 then
					ctlEJECT = ctlEJECT - 1;
				call newPage;
				return;
			end;
		end;
	if arg1b = 0Dh then
		curCol = 0;
	cnt = 1;
	if arg1b = 9 then
	do;
		cnt = 8 - (curCol and 7);
		arg1b = ' ';
	end;
	do while cnt <> 0;
		if curCol < 132 then
		do;
			if arg1b >= ' ' then
				curCol = curCol + 1;
			if curCol > ctlPAGEWIDTH then
			do;
				call printCRLF;
				call printStr(.spaces24);
				curCol = curCol + 1;
			end;
			call outch(arg1b);
		end;
		cnt = cnt - 1;
	end;
end;

declare b755C(*) byte initial(' CDSME');

sub$7041: procedure public;
	declare b7562 byte,
		w7563 address,
		(b7563, b7564) byte at(.w7563),
		b7565 byte;

	sub$718C: procedure(arg1w);
		declare arg1w address;
		declare ch based curTokenSym$p byte;

		curTokenSym$p = curTokenSym$p - 1;
		call arg1w(ch and not b7565);
	end;



	b68AE(0) = 0FFh;
	if not ctlSYMBOLS then
		return;
	b755C(0) = 'A';
	do b7562 = 0 to 2;
		jj = isPhase2Print and ctlSYMBOLS;
		curTokenSym$p = symTab(1) - 2;
		call printCRLF;
		call printStr(wa6DB2(b7562));

		do while (curTokenSym$p := curTokenSym$p + 8) < w6868(1);
		    w7563 = curTokenSym.w0;
		    if b7563 <> 9 then
			if b7563 <> 6 then
		    	    if b7562 <> 0 or b7563 <> 3 then
				if b7562 = 2 or (b7564 and b6DC1(b7562)) <> 0 then
				do;
				    call unpackToken(curTokenSym$p - 6, .b68AE + 1);
				    if jj then
				    do;
					if ctlPAGEWIDTH - curCol < 11h then
						call printCRLF;
					call printStr(.b68AE + 1);
					call printChar(' ');
					if (b7565 := (b7564 and 40h) <> 0) then
						call printChar('E');
					else
						call printChar(b755C(b7564 and 7));

					call printChar(' ');
					call sub$718C(.print2Hex);
					call sub$718C(.print2Hex);
					curTokenSym$p = curTokenSym$p + 2;
					call printStr(.spaces24 + 20);
				    end;
				end;

		end;

	end;
	if ctlDEBUG then
		b68AE(0) = 0;
	if jj then
		call printCRLF;
end;





printCmdLine: procedure public;
	declare ch based actRead byte;

	call outch(0Ch);
	call sub$6F4D;
	ch = 0;
	call printStr(.cmdLineBuf);
	call newPageHeader;
end;


outStr: procedure(arg1w) reentrant;
	declare arg1w address;
	declare ch based arg1w byte;

	do while ch <> 0;
		call outch(ch);
		arg1w = arg1w + 1;
	end;
end;

outNStr: procedure(arg1b, arg2w) reentrant;
	declare arg1b byte, arg2w address,
		ch based arg2w byte;

	do while arg1b > 0;
		call outch(ch);
		arg2w = arg2w + 1;
		arg1b = arg1b - 1;
	end;
end;


sub$721E: procedure byte public;
	return w68A2 < w68A0;
end;



sub$7229: procedure public;
	declare ch based w68A2 byte;
	declare b7568 byte;

	if (b68AB := sub$721E or b68AB) then
	do;
		call out2Hex(high(w68A6));
		call out2Hex(low(w68A6));
	end;
	else
		call outStr(.spaces24 + 20);

	call outch(' ');
	do  b7568 = 1 to 4;	/* may need structure access */
		if sub$721E and b6B34 then
		do;
			w68A6 = w68A6 + 1;
			call out2Hex(ch);
		end;
		else
			call outStr(.spaces24 + 22);

		w68A2 = w68A2 + 1;
	end;

	call outch(' ');
	if shr(jj := tokenAttr(b6A56), 6) then
		call outch('E');
	else if not b68AB then
		call outch(' ');
	else
		call outch(b755C(jj and 7));
end;


sub$72D8: procedure public;
	if not b689B then
		return;

	call printStr(.ascLParen);	/* " (" */
	call printNStr(4, .b6A57);
	call printStr(.ascRParen);	/* ")" */
	call printCRLF;
	call move(4, .asciiLineNo, .b6A57);
end;


ovl3: procedure public;
	declare ch based off6C2C byte;
    loop:
	w68A0 = (w68A2 := tokStart(b6A56)) + tokenSize(b6A56);
	if isSkipping then
		w68A0 = w68A2;

	call outch(asmErrCode);
	call outch(' ');
	if not blankAsmErrCode then
	do;
		asmErrCode = ' ';
		b689B = 0FFh;
	end;
	if b6B20$9A77 then
		call outStr(.spaces24 + 9);
	else
		call sub$7229;
	if fileIdx > 0 then
	do;
		call outch(a1234(ii := b6C21 + fileIdx));
		if ii > 0 then
			call outch('=');
		else
			call outch(' ');
	end;
	else
		call outStr(.spaces24 + 22);

	if b68AD then
	do;
		call outStr(.spaces24 + 20);
		call printCRLF;
	end;
	else
	do;
		b68AD = 0FFh;
		call outNStr(4, .asciiLineNo);
		call outch(' ');
		curCol = 18h;
		call printNStr(b6C30, off6C2E);
		if ch <> 0Ah then
			call printChar(0Ah);
	end;
	if b6B20$9A77 then
	do;
		if ctlPAGING then
			call sub$6F4D;
	end;
	else
	do;
		do while sub$721E;
			call outStr(.spaces24 + 22);
			call sub$7229;
			call printCRLF;
		end;
		if b6A56 > 0 and (b6B23 or b6B24) then
		do;
			call sub$546F;
			goto loop;
		end;
	end;
	call sub$72D8;
end;

asmComplete: procedure public;
	if errCnt > 0 then
		call itoa(errCnt, .aNoErrors);
	call printNStr((errCnt = 1) + 32, .aAssemblyComple);
	if errCnt > 0 then
	do;
		call move(4, .b6A57, .asc$7520);
		call printNStr(8, .asc$751E);
	end;
	call outch(0Dh);
	call outch(0Ah);
end;

ovl9: procedure public;
	if ctlPRINT then
		call closeF(outfd);
	outfd = 0;
	lineCnt = 1;
	call asmComplete;
	call flushout;
end;


ovl10: procedure public;
	declare ch based w68A6 byte;
	call closeF(infd);
	if ctlXREF then
	do;
		w68A6 = physmem - 1;
		ch = '0';
		if aF0Asxref$tmp(0) = ':' then
			ch = aF0Asxref$tmp(2);
		call load(.aF0Asxref, 0, 1, 0, .statusIO);
		call ioErrChk;

	end;
	call exit;
end;

end;
asmov2.pl3
asmov2: do;

$include(asmov2.ipx)


declare	controlTable(*) byte data(1, 2, 1, 3),
	off$6D72(*) address data(.r$publics.len, .r$interseg.len, .r$extref.len, .r$content.len),
	b6D7A(*) byte data(7Bh, 3Ah, 39h, 7Ch),
	b6D7E(*) byte data(0Ah, 12h, 40h);


declare	r$modhdr MODHDR$T initial(2), (dta$p, recSym$p) address;



writeRec: procedure(rec$p) public;
	declare rec$p address,
		len$p address, recLen address,
		i byte, crc byte;
	declare len based len$p address;
	declare ch based len$p byte;

	len$p = rec$p + 1;
	recLen = (len := len + 1) + 3;	/* include crc byte + type + len word */
	crc = 0;			/* crc */
	len$p = len$p - 1;
	do i = 2 to recLen;
		crc = crc - ch;
		len$p = len$p + 1;
	end;
	ch = crc;			/* insert crc byte */
	call write(objfd, rec$p, recLen, .statusIO);
	call ioErrChk;
end;


sub$6DF1: procedure byte;
	declare b7597 byte;
	if ((b7597 := tokenAttr(b6A56)) and 5Fh) = 0 then
		return 3;
	if (b7597 and 40h) <> 0 then
		return 2;
	if (b6521 := b7597 and 7) = 0 then
		return 3;
	return (b6521 <> activeSeg) and 1;
end;


sub$6E32: procedure public;
	declare b7598 byte;
	declare wrd based dta$p address;
	do b7598 = 0 to 3;
		ii = (b7598 - 1) and 3;
		dta$p = off$6D72(ii);
		if wrd > controlTable(ii) then
			call writeRec(dta$p - 1);

		wrd = controlTable(ii);
		b6526(ii) = 0;
		if b6525 <>  ii then
			b652B(ii) = 0FFh;
	end;
	r$content.offset = w6752 + segSize(r$content.segid := activeSeg);
	r$publics.segid = b6524;
	r$interseg.segid = tokenAttr(b6A56) and 7;
	r$interseg.hilo, r$extref.hilo = b6524;
end;



sub$6EE1: procedure;
	declare w7599 address;

	declare wrd based dta$p address;

	dta$p = off$6D72(b6525 := sub$6DF1);
	if wrd > b6D7A(b6525) or r$content.len + tokenSize(b6A56) > 7Ch then
		call sub$6E32;

	if b652F then
	do;
		b652F = 0;
		r$content.offset = segSize(r$content.segid := activeSeg) + w6752;
	end;
	else if r$content.segid <> activeSeg or (w7599 := r$content.offset + fix6Idx) <> segSize(activeSeg) + w6752
	  or w7599 < r$content.offset then
		call sub$6E32;


	do case b6525;
/* 0 */		do;
			if b652B(0) then
			do;
				b652B(0) = 0;
				r$publics.segid = b6524;
			end;
			else if r$publics.segid <> b6524 then
				call sub$6E32;
		end;
/* 1 */		do;
			if b652B(1) then
			do;
				b652B(1) = 0;
				r$interseg.segid = tokenAttr(b6A56) and 7;
				r$interseg.hilo = b6524;
			end;
			else if r$interseg.hilo <> b6524 or (tokenAttr(b6A56) and 7) <> r$interseg.segid then
				call sub$6E32;
		end;
/* 2 */		do;
			if b652B(2) then
			do;
				b652B(2) = 0;
				r$extref.hilo = b6524;
			end;
			else if r$extref.hilo <> b6524 then
				call sub$6E32;

		end;
/* 4 */		;
	end;
end;


sub$704D: procedure;
	declare b759B byte;

	declare ch based w651F byte;
	do b759B = 1 to tokenSize(b6A56);
		r$content.dta(fix6Idx) = ch;
		fix6Idx = fix6Idx + 1;
		w651F = w651F + 1;
	end;
	r$content.len = r$content.len + tokenSize(b6A56);
end;



sub$709D: procedure;
	r$reloc.len = r$reloc.len + 2;
	r$reloc.dta(fix22Idx) = w6522;
	fix22Idx = fix22Idx + 1;
end;


sub$70C1: procedure;
	r$interseg.len = r$interseg.len + 2;
	r$interseg.dta(fix24Idx) = w6522;
	fix24Idx = fix24Idx + 1;
end;

sub$70E5: procedure;
	r$extref.dta(fix20Idx) = tokenSymId(b6A56);
	r$extref.dta(fix20Idx + 1) = w6522;
	r$extref.len = r$extref.len + 4;
	fix20Idx = fix20Idx + 2;
end;

sub$7131: procedure;
	b6524 = shr(tokenAttr(b6A56) and 18h, 3);
	w6522 = segSize(activeSeg) + w6752;
	if not (b6B23 or b6B24) and (tokenSize(b6A56) = 2 or tokenSize(b6A56) = 3) then
		w6522 = w6522 + 1;
	call sub$6EE1;
	w651F = w68A2;
	call sub$704D;
	do case sub$6DF1;
/* 0 */ 	call sub$709D;
/* 1 */		call sub$70C1;
/* 2 */		call sub$70E5;
/* 3 */		;
	end;
end;


writeExtName: procedure public;
	declare i byte;

	if r$extnames1.len + 9 > 125 then	/* check room for extName */
	do;
		call writeRec(.r$extnames1);	/* flush existing extNam Record */
		r$extnames1.type = 18h;
		r$extnames1.len = 0;
		extNamIdx = 0;
	end;
	r$extnames1.len = r$extnames1.len + b6744 + 2;	/* update length for this ref */
	r$extnames1.dta(extNamIdx) = b6744;		/* write len */
	extNamIdx = extNamIdx + 1;
	do i = 0 to b6744;			/* and name */
		r$extnames1.dta(extNamIdx + i) = b6873(i);
	end;

	r$extnames1.dta(extNamIdx + b6744) = 0;	/* and terminating 0 */
	extNamIdx = extNamIdx + b6744 + 1;	/* update where next ref writes */
end;

writeSymbols: procedure(arg1b);			/* arg1b = 0FFH -> PUBLIC else LOCAL */
	declare arg1b byte;
	declare segId byte,
	symb based curTokenSym$p(1) byte;	/* TO CLEANUP */

	addSymbol: procedure;
		declare offsetInSeg$p address;
		declare symNam based dta$p(6) byte;
		declare len based recSym$p byte;
		declare symOffset based recSym$p address;
		declare offsetInSeg based offsetInSeg$p address;

		if (symb(1) and 40h) <> 0 then
			return;
		offsetInSeg$p = curTokenSym$p - 2;
		symOffset = offsetInSeg; 
		call unpackToken(curTokenSym$p - 6, (dta$p := (recSym$p := recSym$p + 2) + 1));
		symNam(6) = ' ';	/* trailing space to ensure end */
		len = 0;

		do while symNam(0) <> ' ';	/* find length of name */
			len = len + 1;
			dta$p = dta$p + 1;
		end;
		symNam(0) = 0;			/* terminate name with 0 */
		recSym$p = dta$p + 1;
	end;

	flushSymRec: procedure;
		if (r$publics.len := recSym$p - .r$publics.segid) > 1 then	/* something to write */
			call writeRec(.r$publics);
		r$publics.type = (arg1b and 4) or 12h;			/* PUBLIC or LOCAL */
		r$publics.segid = segId;
		recSym$p = .r$publics.dta;
	end;

	recSym$p = .r$publics.dta;
	do segId = 0 to 4;
		call flushSymRec;
		curTokenSym$p = symTab(1) - 2;

		do while (curTokenSym$p := curTokenSym$p + 8) < w6868(1);
			if recSym$p > .r$publics.dta(114) then		/* make sure there is room */
				call flushSymRec;

			if (symb(1) and 7) = segId and not testBit(symb(0), .b6D7E) and
			  (not arg1b or (symb(1) and 20h) <> 0) then
				call addSymbol;
		end;
		call flushSymRec;
	end;
end;








writeModhdr: procedure public;
	declare w based dta$p address;
	declare b based dta$p byte;
	declare i byte;

	/* fill the module name */
	call move((r$modhdr.dta(0) := moduleNameLen), .aModulePage, .r$modhdr.dta(1));
	dta$p = .r$modhdr + moduleNameLen + 4;
	w = 0;	/* the two xx bytes */
	dta$p = dta$p + 1;	/* past first x byte */

	if segSize(1) < w6B41(1) then	/* code segment */
		segSize(1) = w6B41(1);
	if segSize(2) < w6B41(2) then	/* data segment */
		segSize(2) = w6B41(2);

	do i = 1 to 4;
		dta$p = dta$p + 1;
		b = i;		/* seg id */
		dta$p = dta$p + 1;
		w = segSize(i);	/* seg size */
		dta$p = dta$p + 2;
		b = alignTypes(i - 1);	/* aln typ */
	end;
	r$modhdr.len = moduleNameLen + 19;	/* set record length */
	call writeRec(.r$modhdr);
end;

writeModend: procedure public;
	declare lenb byte at (.r$eof.len);
	r$modend.modtyp = startDefined;
	r$modend.segid = startSeg;
	r$modend.offset = startOffset;
	call writeRec(.r$modend);
	lenb = 0;
	call writeRec(.r$eof);
end;

ovl8: procedure public;
	w6752 = 0;
	b689A = 1;
	b6A56 = 1;
	if b6B33 then
		;
	else
	do while b6A56 <> 0;
		b6A56 = sub$4646;
		w68A0 = tokStart(b6A56) + tokenSize(b6A56);
		w68A2 = tokStart(b6A56);
		if isSkipping or not b6B34 then
			w68A0 = w68A2;
		if w68A0 > w68A2 then
		do;
			call sub$7131;
			w6752 = w6752 + tokenSize(b6A56);
		end;
		if not(b6B23 or b6B24) then
			b6A56 = 0;
	end;
end;


ovl11: procedure public;
	if w6750 <> 0 then
	do;
		call seek(objfd, 2, .azero, .azero, .statusIO);		/* SEEKABS */
		call writeModhdr;
		call seek(objfd, 4, .azero, .azero, .statusIO);		/* SEEKEND */
	end;
	r$publics.type = 16h;
	r$publics.len = 1;
	r$publics.segid = 0;
	r$publics.dta(0) = 0;
	call writeSymbols(0FFh);	  /* EMIT PUBLICS */
	if ctlDEBUG then
		call writeSymbols(0); /* EMIT LOCALS */
end;
end;
asmov3.plm
asm88: do;

$include(asmov3.ipx)

declare aExtents(*) byte public initial(' LSTOBJ'),
	aDebug(*) byte public initial('DEBUG');


/* overlay 3 appears to repair the code that starts here */

cmdSkipWhite: procedure public;
	declare cmdch based cmdch$p byte;
	
	do while (cmdch = ' ' or cmdch = 9) and cmdch$p <> actRead;
		cmdch$p = cmdch$p + 1;
	end;
end;

getDrive: procedure byte public;
	declare cmdch based cmdch$p byte;

	if cmdch = ':' then
	do;
		cmdch$p = cmdch$p + 2;
		return cmdch;
	end;
	else
		do ii = 0 to 4;
		if cmdch <> aDebug(ii) and aDebug(ii) + 20h <> cmdch then
				return '0';
			cmdch$p = cmdch$p + 1;
		end;
	call cmdSkipWhite;
	if cmdch <> ':' then
		return '0';
	cmdch$p = cmdch$p + 2;
	return cmdch;
end;

addExtents: procedure public;
	do ii = 1 to 3;
		lstFile(jj + ii) = aExtents(ii);
		objFile(jj + ii) = aExtents(ii+3);
	end;
end;

getAsmFileX: procedure public;		/* extended to include overlay file initialisation */
	declare cmdch based cmdch$p byte;

	cmdIsWhite: procedure byte;
		declare cmdch based cmdch$p byte;
		return cmdch = ' ' or cmdch = 9 or cmdch = CR;
	end;

	symTab(0) = .stdKeywords;
	w686E, w6868(0), symTab(1), w6868(1) = .EDATA;
	call rescan(1, .statusIO);
	call ioErrChk;
	call read(1, .cmdLineBuf, 128, .actRead, .statusIO);
	call ioErrChk;
	actRead = actRead + .cmdLineBuf;
	scanCmdLine = 0FFh;
	call write(0, .signonMsg, 29h, .statusIO);
	call write(0, .signonMsg, 2, .statusIO);
	call ioErrChk;
	call cmdSkipWhite;
	ovlFile(2), aF0Asxref(2) = getDrive; 

	do while not cmdIsWhite;
		cmdch$p = cmdch$p + 1;
	end;

	call cmdSkipWhite;
	if cmdch = CR then
		call runtimeError(4);	/* file error */

	infd = inOpen(cmdch$p, 1);
	rootfd, includefd = infd;
	ii = TRUE;
	jj = 0;

	do while not cmdIsWhite;
		files(0).name(jj) = cmdch;
		if ii then
			lstFile(jj), objFile(jj) = cmdch;
		if cmdch = '.' then
		do;
			ii = FALSE;
			call addExtents;
		end;
		jj = jj + 1;
		cmdch$p = cmdch$p + 1;
	end;
	controls$p = cmdch$p;
	if ii then
	do;
		lstFile(jj) = '.';
		objFile(jj) = '.';
		call addExtents;
	end;

	files(0).name(jj) = ' ';
	if lstFile(0) = ':' and lstFile(2) <> '0' then
		aF0Asxref$tmp(2) = lstFile(2);
end;




resetData: procedure public;
	call sub3DCE$3DFB;
	b6B33, scanCmdLine, skipping(0), b6B2C, inElse(0), finished, b674A(0), b674A(1), b6742, b6857, b6C21 = bZERO;
	b6743, primaryValid, ctlLIST, b6A6F, ctlCOND = bTRUE;
	saveIdx, lookAhead, activeSeg, ifDepth, opSP, opStack(0) = bZERO;
	segSize(0), segSize(1), segSize(2), w6B41(0), w6B41(1), w6B41(2), w68A6, w6750, errCnt = wZERO;
	b6882 = b6882 + 1;
	w6A4E, opType, pageCnt, lineCnt = 1;
	b68AE(0) = 0;
	curChar = 20h;
	do ii = 0 to 11;
		controlSeen(ii) = 0;
	end;
	if not isPhase1 then
	do;
		if fileIdx <> 0 then
		do;
			call closeF(includefd);
			call ioErrChk;
			includefd = rootfd;
		end;
		fileIdx = bZERO;
		off6C25 = .b68B8;
		off6C2C = off6C25 - 1;
		off6C2E = .b68B8;
		call seek(infd, 2, .azero, .azero, .statusIO);	/* SEEKABS */
		call ioErrChk;
	end;
	w6870 = physmem + 0BFh;
	endOutBuf = .b6A00;
end;


sub$70EE: procedure public;
	r$content.type = 6;
	r$content.len = 3;
	r$reloc.type = 22h;
	r$reloc.len = 1;
	r$interseg.type = 24h;
	r$interseg.len = 2;
	r$extref.type = 20h;
	r$extref.len = 1;
end;

end;
keywrd.plm
keywords: do;
declare copyright(*) byte data('(C) 1976,1977,1979,1980 INTEL CORP');

declare stdKeywords(*) address public initial(
/*
	4 byte packed keyword
	byte opcode base
	byte offset to next entry or 0 if end
	byte type
	byte special location
*/
	0A528h,	0,	0,	10h,	/* NE */
	63B0h,	0,	0CCh,	2Ch,	/* CZ */
	0,	0,	0,	0,	/* */
	0BFB6h,	0,	0C0h,	2Dh,	/* RNZ */
	0B354h,	0,	0C1h,	25h,	/* POP */
	6EE9h,	0,	0,	1Dh,	/* EQU */
	0AD70h,	0,	0E800h,	13h,	/* OR */
	0A1A5h,	0,	0E806h,	29h,	/* MVI */
	0C6CFh,	0,	37h,	2Dh,	/* STC */
	0C6CDh,	6158h,	0,	1B05h,	/* STACK */
	6615h,	0,	27h,	2Dh,	/* DAA */
	988Dh,	0E100h,	0Ah,	26h,	/* LDAX */
	61F6h,	0,	0C4h,	2Ch,	/* CNZ */
	53CFh,	0,	0D888h,	27h,	/* ADC */
	53D0h,	0,	80h,	27h,	/* ADD */
	6748h,	0,	0D0F3h,	2Dh,	/* DI */
	0,	0,	0,	0,	/* */
	0,	0,	0,	0,	/* */
	0,	0,	0,	0,	/* */
	53D5h,	0,	0C8C6h,	28h,	/* ADI */
	6A40h,	0,	0F003h,	7,	/* E */
	0,	0,	0,	0,	/* */
	0,	0,	0,	0,	/* */
	0,	0,	0,	0,	/* */
	0A088h,	0,	0,	15h,	/* MOD */
	0AD83h,	0,	0,	1Fh,	/* ORG */
	0,	0,	0,	0,	/* */
	8F70h,	0,	0E8CAh,	2Ch,	/* JZ */
	68E9h,	76C0h,	0,	31h,	/* DSEG */
	0C488h,	0,	0,	1Eh,	/* SET */
	0,	0,	0,	0,	/* */
	0C521h,	0,	30h,	22Dh,	/* SIM */
	0,	0,	0,	0,	/* */
	0,	0,	0,	0,	/* */
	0A4A1h,	6A40h,	0,	34h,	/* NAME */
	0C6CDh,	0,	32h,	2Ch,	/* STA */
	0AE08h,	0,	0D3h,	28h,	/* OUT */
	6630h,	0,	0,	1Ah,	/* DB */
	8DB6h,	0,	0C2h,	2Ch,	/* JNZ */
	0,	0,	0,	0,	/* */
	6618h,	0,	0C009h,	25h,	/* DAD */
	8D9Fh,	0,	0D2h,	2Ch,	/* JNC */
	0A09Ah,	0,	0C040h,	2Bh,	/* MOV */
	8610h,	0,	0C000h,	21h,	/* IF */
	6E60h,	0,	0A800h,	20h,	/* END */
	9938h,	6400h,	0B82Ah,	2Ch,	/* LHLD */
	9600h,	0,	0C005h,	7,	/* L */
	0C6F6h,	0,	90h,	27h,	/* SUB */
	0C634h,	9600h,	0F9h,	2Dh,	/* SPHL */
	0C405h,	0,	0DEh,	28h,	/* SBI */
	0B3FBh,	0,	6,	7,	/* PSW */
	0BF4Fh,	0,	7,	2Dh,	/* RLC */
	5780h,	0,	0,	7,	/* B */
	0,	0,	0,	0,	/* */
	6220h,	0,	0F0F4h,	2Ch,	/* CP */
	0,	0,	0,	0,	/* */
	0AD85h,	0,	0F6h,	28h,	/* ORI */
	0B11Bh,	6A40h,	2,	5,	/* PAGE */
	0,	0,	0,	0,	/* */
	0,	0,	0,	0,	/* */
	5629h,	76C0h,	0,	2Fh,	/* ASEG */
	8750h,	0,	0DBh,	28h,	/* IN */
	6E60h,	8610h,	0D000h,	23h,	/* ENDIF */
	0,	0,	0,	0,	/* */
	8BD8h,	0,	0F0DAh,	2Ch,	/* JC */
	0AD7Dh,	0,	0B0h,	27h,	/* ORA */
	0C3FEh,	0,	98h,	27h,	/* SBB */
	0C6D7h,	9A10h,	0,	35h,	/* STKLN */
	0BFE0h,	0,	0F0h,	2Dh,	/* RP */
	0C4F8h,	6400h,	22h,	2Ch,	/* SHLD */
	0C078h,	0,	0C7h,	2Eh,	/* RST */
	6231h,	0,	0ECh,	2Ch,	/* CPE */
	0B436h,	9957h,	0E800h,	32h,	/* PUBLIC */
	0BDA0h,	0,	0E817h,	2Dh,	/* RAL */
	80E0h,	0,	0E876h,	2Dh,	/* HLT */
	6235h,	0,	0FEh,	28h,	/* CPI */
	0BF68h,	0,	0F8h,	2Dh,	/* RM */
	0,	0,	0,	0,	/* */
	0,	0,	0,	0,	/* */
	0BDA6h,	0,	1Fh,	2Dh,	/* RAR */
	805Bh,	7D00h,	0D000h,	18h,	/* HIGH */
	623Bh,	0,	0D8E4h,	2Ch,	/* CPO */
	0B447h,	7D00h,	0E0C5h,	25h,	/* PUSH */
	0,	0,	0,	0,	/* */
	0C6FDh,	0,	0F0D6h,	28h,	/* SUI */
	61A8h,	0,	0FCh,	2Ch,	/* CM */
	0,	0,	0,	0,	/* */
	0,	0,	0,	0,	/* */
	0BFF1h,	0,	0E8h,	2Dh,	/* RPE */
	62A9h,	76C0h,	0,	30h,	/* CSEG */
	0BE48h,	0,	0C9h,	2Dh,	/* RET */
	876Eh,	0,	4,	2Ah,	/* INR */
	0BEE1h,	0,	20h,	22Dh,	/* RIM */
	0,	0,	0,	0,	/* */
	0B16Ch,	9600h,	0E9h,	2Dh,	/* PCHL */
	988Dh,	0,	3Ah,	2Ch,	/* LDA */
	7000h,	0BF90h,	0,	33h,	/* EXTRN */
	8774h,	0,	0B003h,	25h,	/* INX */
	61B5h,	0,	2Fh,	2Dh,	/* CMA */
	0,	0,	0,	0,	/* */
	61B7h,	0,	3Fh,	2Dh,	/* CNC */
	0BFFBh,	0,	0E0h,	2Dh,	/* RPO */
	0C6CDh,	0E100h,	7002h,	26h,	/* STAX */
	0E5BDh,	0,	0A8h,	27h,	/* XRA */
	9A5Bh,	0,	0,	19h,	/* LOW */
	6D88h,	0,	0FBh,	2Dh,	/* EI */
	8DE0h,	0,	0F2h,	2Ch,	/* JP */
	6676h,	0,	0D005h,	2Ah,	/* DCR */
	6400h,	0,	2,	7,	/* D */
	555Dh,	0,	0A0h,	27h,	/* ANA */
	0E5C5h,	0,	0EEh,	28h,	/* XRI */
	8D68h,	0,	0FAh,	2Ch,	/* JM */
	5560h,	0,	0,	12h,	/* AND */
	5140h,	0,	3807h,	7,	/* A */
	0E614h,	9600h,	0E3h,	2Dh,	/* XTHL */
	0,	0,	0,	0,	/* */
	876Ch,	5449h,	1,	5,	/* INPAGE */
	5565h,	0,	0E6h,	28h,	/* ANI */
	9B00h,	0,	0,	0Ch,	/* LT */
	8DF1h,	0,	0EAh,	2Ch,	/* JPE */
	61C4h,	0,	20B8h,	27h,	/* CMP */
	7BC0h,	0,	0,	0Eh,	/* GT */
	6978h,	0,	7800h,	1Bh,	/* DW */
	6EC8h,	0,	0,	0Bh,	/* EQ */
	667Ch,	0,	500Bh,	25h,	/* DCX */
	6E1Fh,	6A40h,	0A000h,	22h,	/* ELSE */
	0A6D4h,	0,	0,	2Dh,	/* NOP */
	9F01h,	0AD95h,	0,	1C05h,	/* MEMORY */
	5FE0h,	9600h,	0CDh,	2Ch,	/* CALL */
	0BDD8h,	0,	0D8h,	2Dh,	/* RC */
	53ADh,	0,	80CEh,	28h,	/* ACI */
	0BF9Fh,	0,	0D0h,	2Dh,	/* RNC */
	0E36Ch,	76C0h,	0EBh,	2Dh,	/* XCHG */
	8DFBh,	0,	0E2h,	2Ch,	/* JPO */
	68D8h,	0,	0,	1Ch,	/* DS */
	0C620h,	0,	6,	8,	/* SP */
	9C40h,	0,	6,	7,	/* M */
	98A8h,	0,	3800h,	0Dh,	/* LE */
	6018h,	0,	0DCh,	2Ch,	/* CC */
	7D00h,	0,	5004h,	7,	/* H */
	61DFh,	0,	50D4h,	2Ch,	/* CNC */
	0C4F8h,	0,	0,	16h,	/* SHL */
	5DC0h,	0,	1,	7,	/* C */
	0C170h,	0,	0C8h,	2Dh,	/* RZ */
	0E556h,	0,	0,	14h,	/* XOR */
	7968h,	0,	0,	0Fh,	/* GE */
	0A6D8h,	0,	0,	11h,	/* NOT */
	0C4FEh,	0,	0,	17h,	/* SHR */
	9BB5h,	0,	1,	24h,	/* LXI */
	8D84h,	0,	0C3h,	2Ch,	/* JMP */
	0C03Fh,	0,	0Fh,	2Dh	/* RRC */
);


end;
asm51.plm
asm51: do;
$include(asm51.ipx)
$include(as4151.pac)
end;
asm52.plm
asm52: do;
$include(asm52.ipx)
$include(as4252.pac)
end;
asm55.plm
asm851: do;
$include(asm55.ipx)

declare pad1 address data(40h);
declare pad2 address;


strUCequ: procedure(arg1w, arg2w) byte public;
	declare (arg1w, arg2w) address;
	declare ch1 based arg1w byte,
		ch2 based arg2w byte;

	do while ch1 <> 0;
		if ch1 <> ch2 and ch1 <> (ch2 and 5Fh) then
			return FALSE;
		arg1w = arg1w + 1;
		arg2w = arg2w + 1;
	end;
	return TRUE;
end;


isSkipping: procedure byte public;
	return skipping(0);
end;


sub$546F: procedure public;
	b6A56 = sub$4646;
	if b6B30 then
		call syntaxError;
	if haveTokens then
		if not(tokenType(b6A56) = 0Bh or b68AD) then
			call syntaxError;
	if b6B23 or b6B24 then
	do;
		if tokenSP = 1 and not blankAsmErrCode and tokenSize(0) <> 1 then
			tokenSize(0) = 2;
	end;
	else if not blankAsmErrCode and haveTokens then
		if tokenSize(b6A56) > 3 then
			tokenSize(b6A56) = 3;
end;



sub4C1E$54FD: procedure public;
	declare lineno$p address, updating byte;
	declare ch based lineno$p byte;

	call sub$546F;
	if isPhase2Print then
	do;
		lineno$p = .asciiLineNo(3);
		updating = TRUE;

		do while updating;
			if ch = '9' then
				ch = '0';
			else
			do;
				if ch = ' ' then
					ch = '1';
				else
					ch = ch + 1;
				updating = FALSE;
			end;
			lineno$p = lineno$p - 1;
		end;

		if sub$465B or not blankAsmErrCode then
		do;
			call ovl3;
		end;
	end;

	if b6BD9 then
	do;
		out$p = out$p + 1;
		call flushout;
		call exit;
	end;


	if not b6B20$9A77 then
	do;
		ii = 2;
		if tokenSP < 2 or b6B23 or b6B24 then
			ii = 0;

		w6BCE = tokStart(ii) + tokenSize(ii);
		if isSkipping or not b6B34 then
			w6BCE = .lineBuf;

		if chkGenObj then
		do;
			call ovl8;
		end;

		b6B2C = 0FFh;
		segSize(activeSeg), w68A6 = segSize(activeSeg) + (w6BCE - .lineBuf);
	end;

	if ctlXREF and b6880 then
		if phase = 1 then
			call sub$467F(1, .b6873);

	do while tokenSP > 0;
		call popToken;
	end;

	call sub3DCE$3DFB;
	if b6B33 then
	do;
		finished = 0FFh;
		if isPhase2Print and ctlSYMBOLS then
		do;
			call sub$7041;			/* in overlay 1 */
		end;

		call sub$467F(2, .b6873);
		if chkGenObj then
		do;
			call sub$6E32;
		end;
	end;
end;
end;
asm57.pl3
asm57: do;
$include(asm57.ipx)

declare b4A26(*) byte data(0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh,
			   0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh,
			   0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh,
			   0FFh, 0FFh, 0FFh, 0FFh, 0, 0FFh, 0FFh, 0FFh),
	b4A68(*) byte data(0, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0,
			   0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh,
			   0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh);

declare pad byte;

declare accum(4) byte at(.accum1);


sub$4AAA: procedure(arg1b) public;
	declare arg1b byte;

	if b674A(arg1b) then
	do;
		if haveTokens then
		do;
			accum1 = sub$43DD;
			if alignTypes(arg1b) <> accum1$lb then
				call expressionError;
		end;
		else if alignTypes(arg1b) <> 3 then
			call expressionError;
	end;
	else
	do;
		b674A(arg1b) = TRUE;
		if haveTokens then
		do;
			accum1 = sub$43DD;
			if accum1 = 1 or accum1 = 2 then
				alignTypes(arg1b) = low(accum1);
			else
				call expressionError;
		end;
	end;
end;


cond2Acc: procedure(cond) public;	/* convert conditional result to accum1 */
	declare cond byte;		/* 0 or 0ffffh */

	accum1 = cond;
	if accum1 then
		accum1 = 0FFFFh;
end;

sub$4B57: procedure(arg1b) public;
	declare arg1b byte;

	if (b6855 and 47h) <> 0 then
		b6855 = b6855 and 0E7h or arg1b;
end;

sub$4B72: procedure public;
	do case b6B2B;
/* 0 */		;
/* 1 */		call sub4C1E$54FD;
/* 2 */		goto case3;
/* 3 */ case3:	do;
			if not (b6B2B = 2 and opType = 3) then
				call balanceError;

			if tokenType(0) = 11 then
			do;
				tokenSize(0) = 1;
				tokenAttr(0) = 0;
				b6B36 = 0FFh;
			end;

			b6B35 = b6B2F;
			if opType = 3 then
				b6B2C = 0FFh;
		end;
/* 4 */		accum1 = accum1 * accum2;
/* 5 */		accum1 = accum1 + accum2;
/* 6 */		do;
			call syntaxError;
			call popToken;
		end;
/* 7 */		accum1 = accum1 - accum2;
/* 8 */		;
/* 9 */		do;
			if accum2 = 0 then
				call valueError;

			accum1 = accum1 / accum2;
		end;
/* 10 */	accum1 = -accum1;
/* 11 */	call cond2Acc(accum1 = accum2);
/* 12 */	call cond2Acc(accum1 < accum2);
/* 13 */	call cond2Acc(accum1 <= accum2);
/* 14 */	call cond2Acc(accum1 > accum2);
/* 15 */	call cond2Acc(accum1 >= accum2);
/* 16 */	call cond2Acc(accum1 <> accum2);
/* 17 */	accum1 = not accum1;
/* 18 */	accum1 = accum1 and accum2;
/* 19 */	accum1 = accum1 or accum2;
/* 20 */	accum1 = accum1 xor accum2;
/* 21 */	do;
			if accum2 = 0 then
				call valueError;
			accum1 = accum1 mod accum2;
		end;
/* 22 */	do;
			if accum2$lb <> 0 then
				accum1 = shl(accum1, accum2);
		end;
/* 23 */	do;
			if accum2$lb <> 0 then
				accum1 = shr(accum1, accum2);
		end;
/* 24 */	do;
			accum1 = high(accum1);
			call sub$4B57(10h);
		end;
/* 25 */	do;
			accum1 = low(accum1);
			call sub$4B57(8);
		end;
/* 26 */	do;
			if tokenType(0) <> 10 then
			do;
				accum1 = sub$43DD;
				if accum1$hb - 1 < 0FEh then
					call valueError;
				b6B28 = 22h;
				if (b6855 and 18h) = 18h then
				do;
					call valueError;
					b6855 = b6855 and 0E7h or 8;
				end;
			end;
			else
			do;
				b6855 = 0;
				tokenType(0) = 0Bh;
			end;

			if sub$425B(b6858) then
				call operandError;
			b6B2D = 0Bh;
			b6B23 = 0FFh;
		end;
/* 27 */	do;
			b6B2D = 0Bh;
			b6B24 = 0FFh;
		end;
/* 28 */	do;
			segSize(activeSeg) = segSize(activeSeg) + accum1;
			b68AB = 0FFh;
		end;
/* 29 */ case29:
		do;
			b68AB = 0FFh;
			if (b6855 and 40h) = 40h then
			do;
				call expressionError;
				b6855 = 0;
			end;
			b6CE4 = 1;
			call sub$5819(accum1, 22h - b6B2B);
			b6B30 = 0;
		end;
/* 30 */	goto case29;
/* 31 */	do;
			b68AB = 0FFh;
			if (b6855 and 40h) <> 40h then
			do;
				if (b6855 and 18h) <> 0 then
					if (b6855 and 7) <> activeSeg or (b6855 and 18h) <> 18h then
						call expressionError;
			end;
			else
				call expressionError;

			if ctlOBJECT then
				if segSize(activeSeg) > w6B41(activeSeg) then
					w6B41(activeSeg) = segSize(activeSeg);
			segSize(activeSeg) = accum1;
		end;
/* 32 */	do;
			if tokenSP > 0 then
			do;
				startOffset = sub$43DD;
				startDefined = 1;
				startSeg = b6855 and 7;
				if (b6855 and 40h) = 40h then
					call expressionError;
				if sub$425B(b6858) then
					call operandError;

				b68AB = 0FFh;
			end;

			if ifDepth > 0 then
				call nestingError;
			if opType <> 1 then
				call syntaxError;
			if b6B35 then
				b6B33 = 0FFh;
			else
				call syntaxError;

		end;
/* 33 */	do;
			if b6B35 then
			do;
				b6B32 = 0FFh;
				call nestIF(2);
				b6881 = 0FFh;
				if skipping(0) = 0 then
					skipping(0) = not ((low(accum1) and 1) = 1);
				inElse(0) = 0;
			end;
		end;
/* 34 */	do;
			b6B32 = 0FFh;
			if ifDepth = 0 then
				call nestingError;
			else if not inElse(0) then
			do;
				if not skipping(0) then
					skipping(0) = 0FFh;
				else
					skipping(0) = skipping(ifDepth);
				inElse(0) = 0FFh;
			end;
			else
				call nestingError;
		end;
/* 35 */	do;
			if b6B35 then
			do;
				b6B32 = 0FFh;
				call unnestIF(2);
			end;
		end;
/* 36 */	do;
			if b6744 = 1 then
				if b6873(0) = 4Dh then
					call syntaxError;
			call sub$450F(85h);
		end;
/* 37 */	do;
			if b6744 = 1 then
				if b6873(0) = 4Dh then
					call syntaxError;
			call sub$450F(5);
		end;
/* 38 */	call sub$450F(7);
/* 39 */	call sub$450F(2);
/* 40 */	call sub$450F(8);
/* 41 */	call sub$450F(46h);
/* 42 */	call sub$450F(6);
/* 43 */	call sub$450F(36h);
/* 44 */	call sub$450F(0);
/* 45 */	call sub$450F(0);
/* 46 */	call sub$450F(6);
/* 47 */	activeSeg = 0;
/* 48 */	do;
			activeSeg = 1;
			call sub$4AAA(0);
		end;
/* 49 */	do;
			activeSeg = 2;
			call sub$4AAA(1);
		end;

/* 50 */	do;
			b6748 = 0FFh;
			b6CE4 = 0;
			call sub$5819(0, 6);
		end;
/* 51 */	do;
			b6749 = 0FFh;
			if w6750 = 0 and isPhase1 and ctlOBJECT then
			do;
				call writeModhdr;
			end;
			b6CE4 = 0;
			call sub$5819(w6750, 2);
			if isPhase1 and ctlOBJECT and not b6754 then
			do;
				call writeExtName;
			end;
			if not b6754 then
				w6750 = w6750 + 1;
			b6754 = 0;
		end;
/* 52 */	do;
			if tokenSP <> 0 and b6743 then
			do;
				call move(6, .spaces24 + 18, .aModulePage);
				call move(moduleNameLen := b6744, .b6873, .aModulePage);
			end;
			else
				call sourceError('R');

			call popToken;
		end;
/* 53 */	segSize(3) = accum1;
	end;

	if b6B2B <> 1 then
		b6743 = 0;
end;


sub$518F: procedure public;

	sub$53C0: procedure byte;
		if b6B29 > 3 then
			if b6B29 <> 6 then
				if b6B29 < 1Ah then
					return TRUE;
		return FALSE;
	end;

	sub$53DF: procedure(arg1b) byte;
		declare arg1b byte;
		return arg1b = 9 or arg1b = 64h;
	end;


	sub$53F8: procedure;
		if not b4A68(b6B2B) then
			b6B34 = 0;
	end;



	do while 1;
		if not (b6B29 = 1 or b6B29 >= 20h and b6B29 <= 23h) and skipping(0) then
		do;
			b6885 = 0;
			call popToken;
			return;
		end;
		
		if phase <> 1 then
			if b6B25 then
				if sub$53C0 then
					if getPrec(b6B29) <= getPrec(opStack(opSP)) then
						call expressionError;

		if getPrec(opType := b6B29) > getPrec(b6B2B := opStack(opSP)) or opType = 2 then
		do;
			if opSP >= 10h then
			do;
				opSP = 0;
				call stackError;
			end;
			else
				opStack(opSP := opSP + 1) = opType;
			if opType = 2 then
			do;
				b6B2F = b6B35;
				b6B35 = 0FFh;
			end;
			if phase > 1 then
				b6B25 = sub$53C0;
			return;
		end;

		b6B25 = 0;
		if not b6B35 and b6B2B > 3 then
			call syntaxError;

		if b6B2B = 0 then
			b6B2B = opType;
		else
			opSP = opSP - 1;
		

		if (b6B28 := b4181(b6B2B)) then
		do;
			accum2 = sub$43DD;
			b6856 = b6855;
			w685C = w685A;
			b6859 = b6858;
		end;

		if (b6B28 := ror(b6B28, 1)) then
			accum1 = sub$43DD;

		if not b6857 then
			b6857 = sub$53DF(b6858) or sub$53DF(b6859);

		b6B2D = 0Ch;
		if b6B2B > 3 and b6B2B < 1Ah then
			call sub$4291;
		else
		do;
			call sub$53F8;
			call sub$4274;
		end;

		call sub$4B72;
		if not b4A26(b6B2B) then
			b6B35 = 0;

		if b6B2C then
		do;
			b6B2C = 0;
			return;
		end;

		if b6B2B <> 1Ch and b68AB then
			w68A6 = accum1;

		if (b6B28 and 1Eh) <> 0 then
			call pushToken(b6B2D);

		do ii = 0 to 3;
			if (b6B28 := ror(b6B28, 1)) then
				call addByte2Tok(accum(ii));
		end;

		tokenAttr(0) = b6855;
		tokenSymId(0) = w685A;
		if ror(b6B28, 1) then
			if opType = 6 then
			do;
				b6B29 = b6B2B;
				b6B35 = 0FFh;
			end;
	end;
end;



sub$540D: procedure public;
	do while finished = 0;
		call sub$3F19;
		call sub$518F;
	end;
end;

end;
asm5D.plm
asm5D: do;
$include(asm5D.ipx)
$include(as4e5d.pac)
end;
asm41.plm
$SET(ASM41)
asmov4:
do;
$include(asm41.ipx)
$include(as4151.pac)
end;
as4151.pac
$IF ASM41
declare w$3780 address public data(0),
	b$3782 byte public data(80h),
	b$3783 byte public data(81h);
$ENDIF
declare	spaces24(*) byte public data('                        ', 0),
	ascCRLF(*) byte public data(0Dh, 0Ah, 0),
	signonMsg(*) byte data(0Dh, 0Ah),
	aIsisIi80808085(*) byte public data('ISIS-II 8080/8085 MACRO ASSEMBLER, V4.1', 9, 9),
	aModulePage(*) byte public data('MODULE ', 9, ' PAGE ', 0),
	bZERO byte public data(0),
	bTRUE byte public data(0FFh),
	copyright(*) byte data('(C) 1976,1977,1979,1980 INTEL CORP'),
	aStack(*) byte public data(0Dh, 0Ah, 'STACK', 0),
	aTable(*) byte public data(0Dh, 0Ah, 'TABLE', 0),
	aCommand(*) byte public data(0Dh, 0Ah, 'COMMAND', 0),
	aEof(*) byte public data(0Dh, 0Ah, 'EOF', 0),
	aFile(*) byte public data(0Dh, 0Ah, 'FILE', 0),
	aMemory(*) byte public data(0Dh, 0Ah, 'MEMORY', 0),
	aError(*) byte public data(' ERROR', 0Dh, 0Ah, 0),
	aError$0(*) byte public data(' ERROR, ', 0Dh,0Ah, 0),
	errStrs(*) address public data(.aStack, .aTable, .aCommand, .aEof, .aFile, .aMemory),
	errStrsLen(*) byte public data(7, 7, 9, 5, 6, 8),
	aBadSyntax(*) byte public data('BAD SYNTAX', 0Dh, 0Ah),
	aCo(*) byte public data(':CO:', 0);

start$ov4$5:
	call getAsmFile;
	phase = 1;
	call resetData;
	call initialControls;
$IF ASM41
	macrofd = inOpen(.aF0Asmac$tmp, 3);
$ENDIF
	if ctlOBJECT then
	do;
		call delete(.objFile, .statusIO);
		objfd = inOpen(.objFile, 3);
	end;

	if ctlXREF then
	do;
		xreffd = inOpen(.aF0Asxref$tmp, 2);
		outfd = xreffd;
	end;

	call sub$540D;
	phase = 2;
	if ctlOBJECT then
	do;
		if r$extnames1.len > 0 then
			call writeRec(.r$extnames1);

		if w6750 = 0 then
			call writeModhdr;

		call sub$70EE;
	end;

	if ctlPRINT then
		outfd = inOpen(.lstFile, 2);

	call resetData;
	call initialControls;
	call sub$540D;
	if ctlPRINT then
	do;
		call asmComplete;
		call flushout;
	end;

	if ctlOBJECT then
	do;
		call ovl11;
		call writeModend;
	end;

	if not strUCequ(.aCo, .lstFile) then
		call ovl9;

	call ovl10;
asm42.plm
$SET(ASM42)
asm42:
do;
$include(asm42.ipx)
$include(as4252.pac)
end;
as4252.pac

physmem: procedure address public;
	declare top address at(4);

	return (top - 100h) and 0FF00h;
end;


nxtCmdCh: procedure byte public;
	declare cmdch based cmdch$p byte;
	declare ch byte;

	ch = cmdch;
	cmdch$p = cmdch$p + 1;
	if 'a' <= ch and ch <= 'z' then
		ch = ch and 5Fh;
	return ch;
end;	


ioErrChk: procedure public;
	if statusIO = 0 then
		return;
	call error(statusIO);
	call exit;
end;


flushout: procedure public;
	call write(outfd, .outbuf, out$p - .outbuf, .statusIO);
	out$p = .outbuf;
end;

outch: procedure(c) public;
	declare c byte;
	declare outc based out$p byte;

	if out$p = endOutBuf then
		call flushout;
	outc = c;
	out$p = out$p + 1;
end;

outStrN: procedure(s, n) public;
	declare s address, n byte;
	declare ch based s byte;

	do while n > 0;
		call outch(ch);
		s = s + 1;
		n = n - 1;
	end;
end;

$IF ASM801
ovlMgr: procedure(ovl) public;
	declare ovl byte;
	declare entry$p address;

	if ovl > 4 then
	do;
		statusIO = 0Dh;
		call ioErrChk;
	end;
	if ovl <> loadedOvl then
	do;
		ovlFile(12) = ovl + '0';
		call load(.ovlFile, 0, 0, .entry$p, .statusIO);
		call ioErrChk;
		loadedOvl = ovl;
	end;
end;
$ENDIF

closeF: procedure(arg1w) public;
	declare arg1w address;

	call close(arg1w, .statusIO);
end;

isSpace: procedure byte public;
	return curChar = ' ';
end;

isTab: procedure byte public;
	return curChar = TAB;
end;

isWhite: procedure byte public;
	return isSpace or isTab;
end;

isRParen: procedure byte public;
	return curChar = ')';
end;

isCR: procedure byte public;
	return curChar = CR;
end;

isComma: procedure byte public;
	return curChar = ',';
end;

$IF ASM42
isLT: procedure byte public;
	return curChar = '<';
end;


isGT: procedure byte public;
	return curChar = '>';
end;

$ENDIF

isPhase1: procedure byte public;
	return phase = 1;
end;

skip2EOL: procedure public;
	if not isCR then
		do while getCh <> 0Dh;
		end;
end;


chkGenObj: procedure byte public;
$IF ASM801
	return (phase > 2) and ctlOBJECT;
$ELSE
	return (phase = 2) and ctlOBJECT;
$ENDIF
end;


isPhase2Print: procedure byte public;
	return phase = 2 and ctlPRINT;
end;


wrConsole: procedure(buf$p, count) public;
	declare (buf$p, count) address;

	call write(0, buf$p, count, .statusIO);
	call ioErrChk;
end;


runtimeError: procedure(arg1b) public;
	declare arg1b byte;

	if b6BD9 then
		return;

	if isPhase1 and arg1b = 0 then
	do;
		b6B33 = TRUE;
		return;
	end;

	w6BE0 = .aError;		/* assume " ERROR\r\n" */
	if arg1b = 4 then		/* file error */
		w6BE0 = .aError$0;	/* replace with " ERROR, " */

	call wrConsole(errStrs(arg1b), errStrsLen(arg1b));	/* write the ERROR type */
	call wrConsole(w6BE0, 8);	/* write the ERROR string */
	if isPhase2Print then		/* repeat to the print file if required */
	do;
		call outStrN(errStrs(arg1b), errStrsLen(arg1b));
		call outStrN(w6BE0, 8);
	end;

	if arg1b = 4 or arg1b = 3 then	/* file or EOF error */
	do;
		if tokBufIdx = 0 then
		do;
			call wrConsole(.aBadSyntax, 12);
			if not scanCmdLine then
			do;
				call skip2NextLine;
				outfd = 0;
$IF ASM801
				call ovlMgr(1);
$ENDIF
				call printDecimal(w6A4E);	/* overlay 1 */
				call outch(LF);
			end;
		end;
		else
		do;
			call wrConsole(curFileName$p, tokBufIdx);
			call wrConsole(.ascCRLF, 2);
		end;
	end;

	if arg1b = 0 then	/* stack error */
	do;
		b6BD9 = TRUE;
		return;
	end;

	call exit;
end;

ioError: procedure(arg1w) public;
	declare arg1w address;
	declare ch based arg1w byte;

	tokBufIdx = 0;
	curFileName$p = arg1w;

	do while ch <> ' ' and ch <> 0dh and ch <> 9;
		tokBufIdx = tokBufIdx + 1;
		arg1w = arg1w + 1;
	end;
	if b6C27 then
		call runtimeError(3);	/* EOF error*/
	call runtimeError(4);		/* file error */
end;

inOpen: procedure(path$p, access) address public;
	declare (path$p, access) address;
	declare open$infd address;

	call open(.open$infd, path$p, access, 0, .openStatus);
	if openStatus <> 0 then
		call ioError(path$p);
	return open$infd;
end;


nibble2Ascii: procedure(n) byte public;
	declare n byte;
	n = (n and 0Fh) + '0';
	if n > '9' then
		n = n + 7;
	return n;
end;

put2Hex: procedure(arg1w, arg2b) public;
	declare arg1w address, arg2b byte;

	call arg1w(nibble2Ascii(ror(arg2b, 4)));
	call arg1w(nibble2Ascii(arg2b));
end;

blankAsmErrCode: procedure byte public;
	return asmErrCode = ' ';
end;

blankMorPAsmErrCode: procedure byte public;
	return blankAsmErrCode or asmErrCode = 'M' or asmErrCode = 'P';
end;


getNibble: procedure(bp, idx) byte public;
	declare bp address, idx byte;
	declare b based bp byte;
	declare n byte;

	bp = bp + shr(idx, 1);	/* index into buffer the number of nibbles */
	n = b;			/* pick up the byte there */
	if not idx then		/* pick up the right nibble */
		n = ror(n, 4);
	return n and 0Fh;	/* mask to leave just the nibble */
end;

sourceError: procedure(arg1b) public;
	declare arg1b byte;

	if not isSkipping or b6B2B = 22h then	/* ELSE */
	do;
		if b6749 then
			b6754 = TRUE;
		if blankAsmErrCode then
			errCnt = errCnt + 1;

		if blankMorPAsmErrCode or arg1b = 'L' or arg1b = 'U' then	/* no error or M, P L or U */
			if asmErrCode <> 'L' then	/* override unless already location counter error */
				asmErrCode = arg1b;

	end;
end;

$IF ASM42

sub$3D34: procedure(arg1b) public;
	declare arg1b byte;
	declare ch based w$906A byte;

	ch = arg1b;
	if (w$906A := w$906A + 1) > w6870 then
		call runtimeError(1);	/* table error */
end;


sub$3D55: procedure(arg1b) public;
	declare arg1b byte;

	call sub$3D34(arg1b);
	if arg1b = 0Dh then
		call sub$3D34(0Ah);
end;

$ENDIF


preStatementControls: procedure public;

	do while getCh = '$';
		if isSkipping then
		do;
			call skip2NextLine;
			b6B20$9A77 = 0FFh;
$IF ASM42
			if b$905E = 1 then
				b6897 = 0FFh;
$ENDIF
		end;
		else
		do;
$IF ASM801
			call ovlMgr(0);
$ENDIF
			call parseControls;
		end;
		call sub4C1E$54FD;
	end;
	reget = 1;
end;


initialControls: procedure public;
	cmdch$p = controls$p;
	scanCmdLine = TRUE;
$IF ASM801
	call ovlMgr(0);
$ENDIF
	call parseControls;
	if isPhase2Print then
	do;
$IF ASM801
		call ovlMgr(1);
$ENDIF
		call printCmdLine;
	end;
	if b6C21 then
		call sub$4904;

	b6C21, b6B20$9A77, scanCmdLine = bZERO;
	call preStatementControls;
	primaryValid = 0;
	ctlDEBUG = ctlDEBUG and ctlOBJECT;
	ctlXREF = ctlXREF and ctlPRINT;
	ctlSYMBOLS = ctlSYMBOLS and ctlPRINT;
	ctlPAGING = ctlPAGING and ctlPRINT;
end;


sub3DCE$3DFB: procedure public;
	off$6C2E = off$6C2C + 1;
	b6C30 = 0;
	if b6C21 then
		call sub$4904;

	b68AD, has16bitOperand, b6B20$9A77, b689B, b687F, b6B25, b6B30, b6881, b6872, b6880,
	b6B23, b6B24, b6B32, b68AB, b6884,
$IF ASM42
	b$9059, b$9060, 
$ENDIF
	b6885 = bZERO;

	b689C, b6B31, b6B34, b6B35 = bTRUE;
	ctlEJECT, b6857, tokenSP,
$IF ASM42
	b$9058, argNestCnt,
$ENDIF
	tokenSize(0), tokenType(0), b6858, b6859, b6742, b6855 = bZERO;
	asmErrCode = 20h;
$IF ASM42
	off$9056 = .b$8FD5;
	w$919D = w$906A;
	b$905B = b$905B > 0;
$ENDIF
	b689A = 1;
	w6A4E = w6A4E + 1;
$IF ASM42
	off$9056 = .b$8FD5;
$ENDIF
	skipping(0) = skipping(0) > 0;
end;

/* pckToken code follows */

asm43.pl3
asm43:
do;
$include(asm43.ipx)

declare b3E5E(*) byte data(0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			   0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0),
	b3EA0(*) byte data(36h, 0, 0, 0, 6, 0, 0, 2),
	b3EA8(*) byte data(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0, 0, 0FFh,
			   0, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0,
			   0FFh, 0, 0, 0),
	b$3F88(*) byte data(41h, 90h, 0, 0, 0, 0, 0, 0, 0, 40h);


skipWhite$2: procedure public;
	do while getCh = ' ' or isTab;
	end;
end;


sub$3FA9: procedure byte public;
	declare w$9B5A address,
		wrd based w$9B5A address;

	w$9B5A = curTokenSym$p - 6;
	return (wrd < 4679h) or ctlMACRODEBUG or (4682h < wrd);
end;



seekM: procedure(arg1w);
	declare arg1w address;

	if (w6BE0 := arg1w - nxtMacroBlk) <> 0 then
	do;
		jj = 3;			/* SEEKFWD */
		if arg1w < nxtMacroBlk then
		do;
			w6BE0 = - w6BE0;
			jj = 1;		/* SEEKBACK */
		end;

		call seek(macrofd, jj, .w6BE0, .w$3780, .statusIO);
		call ioErrChk;
	end;
	nxtMacroBlk = arg1w + 1;
end;



readM: procedure(arg1w) public;
	declare arg1w address;
	declare w$9B60 address;

	if arg1w >= maxMacroBlk then
		w$9B60 = 0;
	else if arg1w = curMacroBlk then
		return;
	else
	do;
		call seekM(arg1w);
		call read(macrofd, .macroBuf, 128, .w$9B60, .statusIO);
		call ioErrChk;
	end;

	tmac$blk, curMacroBlk = arg1w;
	macroBuf(w$9B60) = 0FEh;	/* flag end of macro buffer */
end;


writeM: procedure public;
	if phase = 1 then
	do;
		call seekM(maxMacroBlk);
		maxMacroBlk = maxMacroBlk + 1;
		call write(macrofd, w686E, 128, .statusIO);
		call ioErrChk;
	end;
	w$9114 = w$9114 + 1;
end;



sub$40B9: procedure public;
	declare w$9B62 address;

	if b$905E then
	do;
		do while (w$9B62 := w$906A - w686E) >= 128;
			call writeM;
			w686E = w686E + 128;
		end;
		if w$9B62 <> 0 then
			call move(w$9B62, w686E, w6868(2));
		w$906A = (w686E := w6868(2)) + w$9B62;
	end;
end;

skipWhite: procedure public;
	do while isWhite;
		curChar = getCh;
	end;
end;

skip2NextLine: procedure public;
	call skip2EOL;
	call chkLF;
end;



sub$3F19: procedure public;

	sub$416B: procedure;
		if opType = 0 then
			call expressionError;
		b6B25 = 0;
		opType = 0;
	end;


    do while 1;
	if b689C then
	do;
		call preStatementControls;
		b689C = 0;
	end;

	do case getChClass;
/* 0 */ case0:	call illegalCharError;
/* 1 */		;
/* 2 */		do;
			if not b$9058 then
			do;
				b6742 = 0FFh;
				if getChClass = 2 and b$905E then
				do;
					b$9059 = 0FFh;
					w$906A = w$906A - 2;
				end;
				call skip2NextLine;
				b6B29 = 1;
				return;
			end;
		end;
/* 3 */		do;
			if not b6872 then
			do;
				if skipping(0) or b$905E then
					call popToken;
				else
				do;
					b$9C3A = 2;
					call sub$5CE8(segSize(activeSeg), 2);
				end;

				b6B30 = 0;
				b6872, b6B31 = bTRUE;
			end;
			else
			do;
				call syntaxError;
				call popToken;
			end;

			call sub$467F(0, .b6873);
			b6880 = 0;
			opType = 3;
		end;
/* 4 */		do;
			call chkLF;
			b6B29 = 1;
			b$9058 = 0;
			return;
		end;
/* 5 */		do;
			if curChar = 2Bh or curChar = 2Dh then
				if not testBit(opType, .b$3F88) then
					curChar = curChar + 3;
			b6B29 = curChar - 28h + 2;
			return;
		end;
/* 6 */		do;
			call pushToken(0Ch);
			call collectByte(low(segSize(activeSeg)));
			call collectByte(high(segSize(activeSeg)));
			if activeSeg <> 0 then
				tokenAttr(0) = tokenAttr(0) or activeSeg or 18h;
			call sub$416B;
		end;
/* 7 */		do;
			if b6B29 = 37h then
			do;
				call illegalCharError;
				return;
			end;
			if b$905E then
				b$9058 = not b$9058;
			else
			do;
				call getStr;
				if b6B31 then
					call sub$43D2;
				call sub$416B;
			end;
		end;
/* 8 */		do;
			call getNum;
			if b6B31 then
				call sub$43D2;
			call sub$416B;
		end;
/* 9 */		do;
			w$919F = w$906A - 1;
			call getId(9);
			if tokenSize(0) > 6 then
				tokenSize(0) = 6;

			if ctlXREF then
			do;
				call move(6, .b6873, .b6879);
				call move(6, .spaces24 + 18, .b6873);
			end;

			call move(tokenSize(0), curTokStart, .b6873);
			b6744 = tokenSize(0);
			call packToken;
			if b6880 then
			do;
				b687F = 0FFh;
				b6880 = 0;
			end;

			if lookup(2) <> 9 and b$905E then
			do;
				if not b$9058 or (jj := tokenType(0) = 0) and (curChar = 26h or mem(w$919F-1) = 26h) then
				do;
					w$906A = w$919F;
					call sub$3D55(jj + 81h);
					call sub$3D34(sub$43DD);
					call sub$3D55(curChar);
					b6B29 = 9;
				end;
			end;
			else if b6B29 <> 37h and not b$905E = 2 then
			do;
				if lookup(0) = 9 then
				do;
					tokenType(0) = lookup(1);
					b6880 = 0FFh;
				end;

				b6B29 = tokenType(0);
				b6885 = b3EA8(tokenType(0));
				if not b3E5E(tokenType(0)) then
					call popToken;

				if b687F then
				do;
					call sub$467F((not testBit(b6B29, .b3EA0)) and 1, .b6879);
					b687F = 0;
				end;
			end;

			if b$905E = 1 then
			do;
				if b6B29 = 3Fh then
				do;
					b$905E = 2;
					if b6897 then
						call syntaxError;
					b6897 = 0;
				end;
				else
				do;
					b6897 = 0;
					b$905E = 0FFh;
				end;
			end;

			if b6B29 = 41h then
				call pushToken(40h);
			if b6B29 < 0Ah or b6B29 = 9 or 80h then
			do;
				call sub$416B;
				if b6B31 then
					call sub$43D2;
			end;
			else
			do;
				b6B31 = 0;
				return;
			end;
		end;
/* 10 */	do;
			b6BDA = 0;
			call sub$73AD;
			if b6BDA then
				return;
		end;
/* 11 */	do;
			if b$905B then
			do;
				skipping(0) = 0;
				b6B29 = 40h;
				return;
			end;
			else
				goto case0;
		end;
	end;
    end;
end;

end;
asm44.plm
$SET(ASM44)
asm44:
do;
/* to force the code generation this needs a non-standard definition
   of outStrN and put2Hex
*/
outStrN: procedure(s, n) external; declare s address, n address; end;
put2Hex: procedure(arg1w, arg2w) external; declare arg1w address, arg2w address; end;

$include(asm44.ipx)
$include(as4483.pac)

end;
as4483.pac
declare b4181(*) byte public data(0, 80h, 0, 0, 0Fh, 0Fh, 80h, 0Fh, 0Dh, 0Fh,
			   0Dh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Dh, 0Fh, 0Fh,
			   0Fh, 0Fh, 0Fh, 0Fh, 0Dh, 0Dh, 40h, 4Dh, 1, 1,
			   1, 1, 80h, 1, 0, 0, 47h, 7, 7, 7,
			   17h, 47h, 7, 47h, 37h, 5, 7, 0, 0, 0,
			   40h, 40h, 0, 1
$IF ASM44
			   ,80h, 40h, 80h, 0, 40h, 80h, 80h, 40h, 81h, 0C0h, 80h, 0Dh
$ENDIF
			   ),

	b41B7(*) byte data(41h, 0, 0, 0, 19h, 40h, 0, 1Ch, 0, 0),
	b41C1(*) byte data(1Ah, 5, 80h, 0, 0C0h),
	b41C6(*) byte data(57h, 71h, 0F4h, 57h, 76h, 66h, 66h, 67h, 77h, 77h, 77h, 55h),
	b41D2(*) byte data(57h, 6, 2, 20h, 0, 0, 0, 0, 0, 0, 0, 22h),
	b41DE(*) byte data(3Ah, 0FFh, 80h, 0, 0, 0Fh, 0FEh, 0, 20h),
	precedence(*) byte data(0, 0, 0, 0, 8, 7, 1, 7, 7, 8, 7, 6, 6, 6, 6, 6, 6,
			   5, 4, 3, 3, 8, 8, 8, 9, 9, 1, 1, 1, 1, 1, 1, 1, 1,
			   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			   1, 1, 1
$IF ASM44
	       /* extra */ ,0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0Ah
$ENDIF
			   );


testBit: procedure(arg1b, arg2w) byte public;
	declare arg1b byte, arg2w address;
	declare ch based arg2w byte;

	if ch < arg1b then
		return 0;
	
	arg2w = arg2w + shr(arg1b, 3) + 1;
	return (ch and ROR(1, (arg1b and 7) + 1)) <> 0;
end;

sub$425B: procedure(arg1b) byte public;
	declare arg1b byte;

	return arg1b = 7 or arg1b = 8;
end;

sub$4274: procedure public;
	if testBit(b6B2B, .b41B7) then
		if sub$425B(b6858) then
			call operandError;
end;

sub$4291: procedure public;
	if sub$425B(b6858) then
		call operandError;
	if (b4181(b6B2B) and 2) = 0 then
		b6856 = 0;
	else if sub$425B(b6859) then
		call operandError;

	b6858 = 0Ch;
	bp6BE0(0) = (b6855 and 18h) <> 0;
	bp6BE0(1) = (b6856 and 18h) <> 0;
	if (b6855 and 7) <> 0 then
		if (b6856 and 7) <> 0 then
			if ((b6855 xor b6856) and 1Fh) <> 0 then
				call expressionError;
	if (ii := (b6855 and 40h) <> 0) or (b6BDC := (b6856 and 40h) <> 0) then
	do;
		if b6B2B = 5 then	/* +? (PAGE INPAGE)? */
			if not (ii or bp6BE0(0)) then
			do;
				w685A = w685C;
				b6855 = b6856;
				return;
			end;
		if b6BDC or bp6BE0(1) or not testBit(b6B2B, .b41C1) then
			goto L4394;
		else
			return;
	end;
	jj = shl(b6B2B - 4, 2) or (bp6BE0(0) and 2) or (bp6BE0(1) and 1);
	if testBit(jj, .b41C6) then
L4394:	do;
		call expressionError;
		b6855 = 0;
		return;
	end;
	if testBit(jj, .b41D2) then
	do;
		if not bp6BE0(0) then
			b6855 = b6856;
		return;
	end;
	b6855 = 0;
end;


swapAccBytes: procedure public;
	declare b6C17 byte;
	b6C17 = accum1$lb;
	accum1$lb = accum1$hb;
	accum1$hb = b6C17;
end;



sub$43D2: procedure public;
	b6B30 = 0FFh;
	b6B31 = 0;
end;



sub$43DD: procedure address public;
	declare s based curTokStart(1) byte,
		wrd$p address,
		wrd based wrd$p address;
$IF ASM44
	logError: procedure(arg1b);
		declare arg1b byte;

		if tokenType(tokenSP) <> 40h then
		do;
			call sourceError(arg1b);
			return;
		end;
		if tokenSize(0) = 0 then
			tokenType(tokenSP) = 41h;
	end;
$ENDIF

	b6855 = 0;
	accum1 = 0;
	b6858 = 9;
$IF ASM44
	if tokenType(0) = 40h then
		call pushToken(0Dh);
$ENDIF
	if tokenSP = 0 or tokenType(0) = 0Bh and not b6B36 then
$IF ASM44
		call logError('Q');
$ELSE
		call syntaxError;
$ENDIF
	else
	do;
		if tokenType(0) = 9 or tokenType(0) = 6 then
$IF ASM44
			call logError('U');
$ELSE
			call undefinedSymbolError;
$ENDIF
		else
		do;
			b6858 = tokenType(0);
			if testBit(b6858, .b41DE) then
			do;
				curTokStart = curTokenSym$p + 7;
				b6855 = s(0) and 0DFh;
				curTokStart, wrd$p = curTokenSym$p + 4;
				w685A = wrd;
				tokenSize(0) = 2;

			end;
			else if tokenSize(0) = 0 then
$IF ASM44
				call logError('V');
$ELSE
				call valueError;
$ENDIF
			else
			do;
				if tokenSize(0) > 2 then
$IF ASM44
					call logError('V');
$ELSE
					call valueError;
$ENDIF
				b6855 = tokenAttr(0) and 0DFh;
				w685A = tokenSymId(0);
			end;

			if tokenSize(0) > 0 then
				accum1$lb = s(0);
			if tokenSize(0) > 1 then
				accum1$hb = s(1) and tokenType(0) <> 7;
		end;	

		if has16bitOperand then
			if tokenSize(0) = 2 then
				if tokenType(0) = 10 then
					call swapAccBytes;

		if (b6855 and 40h) <> 0 then
			if tokenType(0) < 9 then
				accum1 = 0;

		call popToken;
	end;

	b6B36 = 0;
	return accum1;
end;


getPrec: procedure(arg1b) byte public;
	declare arg1b byte;
	return precedence(arg1b);
end;

sub$450F: procedure(arg1b) public;
	declare arg1b byte;

	if (arg1b and 3) <> 0 then
	do;
		if accum2$hb <> 0
		   or accum2$lb > 7
		   or arg1b and accum2$lb
		   or (arg1b and 3) = 3 and accum2$lb > 2
		   or (not sub$425B(b6859) and b6B2B <> 2Eh) then    /* RST */
			call operandError;
		else if sub$425B(b6859) and b6B2B = 2Eh then	     /* RST */
			call operandError;
		if ror(arg1b, 2) then
			accum2$lb = rol(accum2$lb, 3);
		accum1$lb = accum1$lb or accum2$lb;
	end;
	else if b6B2B <> 2Dh then		/* single byte op */
		if sub$425B(b6859) then
			call operandError;

	if shr(arg1b, 3) then
	do;
		if (b6856 and 18h) = 18h then
		do;
			call valueError;
			b6856 = b6856 and 0E7h or 8;
		end;
		if accum2$hb + 1 > 1 then
			call valueError;
	end;
	if b6B2B = 28h or b6B2B = 2Ch then	/* Imm8 or imm16 */
	do;
		b6855 = b6856;
		w685A = w685C;
	end;
	else
		b6855 = 0;

	if b6B2B <> 2Dh then		     /* single byte op */
		if accum1$lb = 76h then
			call operandError;
	if (b6B2B := shr(arg1b, 4) + 24h) = 24h then	/* LXI */
		b6B2D = 0Bh;
end;

sub$4646: procedure byte public;
	if b689A >= tokenSP then
		return 0;
	return (b689A := b689A + 1);
end;



sub$465B: procedure byte public;
	return ((not b6B20$9A77) and ctlLIST or b6A6F and b6B20$9A77)
$IF ASM44
	        and (not (b$905B > 1) or ctlGEN)
$ENDIF
		and (not(b6B32 or skipping(0)) or ctlCOND);
end;

sub$467F: procedure(arg1b, arg2w) public;
	declare arg1b byte, arg2w address;
	declare (b6C1F, b6C20) byte;

	if not isPhase1 or not ctlXREF or isSkipping and not b6881 then
		return;

	call outch(arg1b + '0');
	if arg1b <> 2 then
	do;
		call outStrN(arg2w, 6);
		b6881 = 0;
		b6C20 = bp6A4E(1);
		b6C1F = 0;
		do while b6C1F < 4;
			b6C1F = b6C1F + 1;
			if b6C1F then
			do;
				if b6C1F = 3 then
					b6C20 = bp6A4E(0);
				call outch(nibble2Ascii(shr(b6C20, 4)));
			end;
			else
				call outch(nibble2Ascii(b6C20));
		end;
	end;
	else
	do;
		call outStrN(.lstFile, 15);
		if ctlPAGING then
			call outch('1');
		else
			call outch('0');

		call outch(nibble2Ascii(ror(ctlPAGELENGTH, 4)));
		call outch(nibble2Ascii(ctlPAGELENGTH));
		call outch(nibble2Ascii(ror(ctlPAGEWIDTH, 4)));
		call outch(nibble2Ascii(ctlPAGEWIDTH));
		call outch('3');
		call flushout;
		call closeF(xreffd);
	end;
end;

asm45.plm
asm45:
do;
$include(asm45.ipx)

declare pad4B3C address data(40h),
	pad9B73 address public;


strUCequ: procedure(arg1w, arg2w) byte public;
	declare (arg1w, arg2w) address;
	declare ch1 based arg1w byte,
		ch2 based arg2w byte;

	do while ch1 <> 0;
		if ch1 <> ch2 and ch1 <> (ch2 and 5Fh) then
			return FALSE;
		arg1w = arg1w + 1;
		arg2w = arg2w + 1;
	end;
	return TRUE;
end;


isSkipping: procedure byte public;
	return b$905E or skipping(0);
end;

sub$546F: procedure public;
	b6A56 = sub$4646;
	if b6B30 then
		call syntaxError;
	if haveTokens then
		if not(tokenType(b6A56) = 0Bh or b68AD) then
			call syntaxError;
	if b6B23 or b6B24 then
	do;
		if tokenSP = 1 and not blankAsmErrCode and tokenSize(0) <> 1 then
			tokenSize(0) = 2;
	end;
	else if not blankAsmErrCode and haveTokens then
		if tokenSize(b6A56) > 3 then
			tokenSize(b6A56) = 3;
end;


sub4C1E$54FD: procedure public;
	declare w$9B79 address,
		b$9B7B byte,
		ch based w$9B79 byte;

	call sub$546F;
	if isPhase2Print then
	do;
		w$9B79 = .asciiLineNo(3);
		b$9B7B = 0FFh;

		do while b$9B7B;
			if ch = '9' then
				ch = '0';
			else
			do;
				if ch = ' ' then
					ch = '1';
				else
					ch = ch + 1;
				b$9B7B = 0;
			end;
			w$9B79 = w$9B79 - 1;
		end;
		if sub$465B or not blankAsmErrCode then
			call sub$872E;
	end;

	if b6BD9 then
	do;
		out$p = out$p + 1;
		call flushout;
		call exit;
	end;

	if not b6B20$9A77 then
	do;
		ii = 2;
		if tokenSP < 2 or b6B23 or b6B24 then
			ii = 0;

		w6BCE = tokStart(ii) + tokenSize(ii);
		if isSkipping or not b6B34 then
			w6BCE = .lineBuf;

		if chkGenObj then
			call ovl8;

		b6B2C = 0FFh;
		segSize(activeSeg), w68A6 = segSize(activeSeg) + (w6BCE - .lineBuf);
	end;

	if ctlXREF and b6880 then
		if phase = 1 then
			call sub$467F(1, .b6873);

	call sub$40B9;

	do while tokenSP > 0;
		call popToken;
	end;

	call sub3DCE$3DFB;
	if b6B33 then
	do;
		finished = 0FFh;
		if isPhase2Print and ctlSYMBOLS then
			call sub$8447;

		call sub$467F(2, .b6873);
		if chkGenObj then
			call sub$6E32;
	end;
end;

end;
asm46.pl3
asm46: do;
$include(asm46.ipx)

declare	b6C21 byte public initial(0),
	b6C22 byte public initial(0),
	b6C23 byte public,
	fileIdx byte public initial(0),
	off6C25 address public initial(.b68B8),
	b6C27 byte public initial(0),
	includefd address public,
	rootfd address public,
	off6C2C address public initial(.b68B8 - 1),
	off6C2E address public initial(.b68B8),
	b6C30 byte public initial(0), 
	files(6) FILE$T public,
	seekIBlk address,
	seekIByte address,
	pad6CAD byte,  
	w6CAE address,
	w6CB0 address,
	pad6CB2(4) address,
	readFActual address,
	pad6CBC address;


readF: procedure(arg1b, arg2w, arg3w) public;
	declare arg1b byte, (arg2w, arg3w) address;
	call read(arg1b, arg2w, arg3w, .readFActual, .statusIO);
	call ioErrChk;
end;

seekI: procedure(arg1b) public;
	declare arg1b byte;
	call seek(includefd, arg1b, .seekIBlk, .seekIByte, .statusIO);
	call ioErrChk;
end;


readI: procedure(arg1w) public;
	declare arg1w address;
	declare pad byte;

	call readF(includefd, arg1w, .b68B8(w68B6) - arg1w);
	off6C25 = arg1w + readFActual;
end;



closeI: procedure public;
	call close(includefd, .statusIO);
	call ioErrChk;
	if fileIdx = 0 then
	do;
		b6C27 = 0FFh;
		call ioError(.files(0).name);
		return;
	end;
	fileIdx = fileIdx - 1;
	if fileIdx = 0 then
		includefd = rootfd;
	else
		includefd = inOpen(.files(fileIdx).name, 1);

	seekIByte = files(fileIdx).byt;
	seekIBlk = files(fileIdx).blk;
	call seekI(2);			/* SEEKABS */
	off6C25 = .b68B8;
	off6C2C = .b68B8 - 1;
end;


sub$4879: procedure byte public;
	declare ch based off6C2C byte;
	declare w6CC7 address;
    loop:
	off6C2C = off6C2C + 1;
	if off6C2C = off6C25 then
	do;
		w6CAE = off6C2E;
		w6CB0 = off6C25;
		if w6CB0 - w6CAE > 0 then
			call move(w6CB0 - w6CAE, off6C2E, .b68B8);
		off6C2E = .b68B8;
		call readI(w6CC7 := off6C2E + (w6CB0 - w6CAE));
		off6C2C = w6CC7;
	end;

	if readFActual = 0 then
	do;
		call closeI;
		goto loop;
	end;

	b6C30 = b6C30 + 1;
	return ch and 7Fh;
end;


sub$4904: procedure public;
	declare b6CC9 byte, w6CCA address;

	b6C21 = 0;
	call seekI(0);	/* SEEKTELL */
	if seekIByte = 128 then
	do;
		seekIBlk = seekIBlk + 1;
		seekIByte = 0;
	end;

	w6CCA = off6C25 - off6C2E;
x:						/* forces code alignment */
	if (b6CC9 := w6CCA mod 128) > seekIByte then
	do;
		seekIByte = seekIByte + 128;
		seekIBlk = seekIBlk - 1;
	end;

	files(fileIdx - 1).byt = seekIByte - b6CC9;
	files(fileIdx - 1).blk = seekIBlk - w6CCA / 128;
	if includefd <> rootfd then
	do;
		call close(includefd, .statusIO);
		call ioErrChk;
	end;

	off6C25 = .b68B8;
	off6C2C = off6C25 - 1;
	off6C2E = .b68B8;
	files(fileIdx).blk = 0;	
	files(fileIdx).byt = 0;	
	includefd = inOpen(.files(fileIdx).name, 1);
end;
end;
asm47.pl3
asm47:
do;
$include(asm47.ipx)

declare b4A26(*) byte data(0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh,
			   0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh,
			   0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh,
			   0FFh, 0FFh, 0FFh, 0FFh, 0, 0FFh, 0FFh, 0FFh),
	b4A68(*) byte data(0, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0,
			   0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh,
			   0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh);

declare	accum(4) byte at(.accum1);
declare pad9C27 byte;



sub$4AAA: procedure(arg1b) public;
	declare arg1b byte;

	if b674A(arg1b) then
	do;
		if haveTokens then
		do;
			accum1 = sub$43DD;
			if alignTypes(arg1b) <> accum1$lb then
				call expressionError;
		end;
		else if alignTypes(arg1b) <> 3 then
			call expressionError;
	end;
	else
	do;
		b674A(arg1b) = TRUE;
		if haveTokens then
		do;
			accum1 = sub$43DD;
			if accum1 = 1 or accum1 = 2 then
				alignTypes(arg1b) = low(accum1);
			else
				call expressionError;
		end;
	end;
end;


cond2Acc: procedure(arg1b) public;
	declare arg1b byte;

	accum1 = arg1b;
	if accum1 then
		accum1 = 0FFFFh;
end;

sub$4B57: procedure(arg1b) public;
	declare arg1b byte;

	if (b6855 and 47h) <> 0 then
		b6855 = b6855 and 0E7h or arg1b;
end;




sub$516F: procedure;
	do case b6B2B;
/* 0 */		;
/* 1 */		call sub4C1E$54FD;
/* 2 */		goto case3;
/* 3 */	case3:	do;
			if not (b6B2B = 2 and opType = 3) then
				call balanceError;

			if tokenType(0) = 11 then
			do;
				tokenSize(0) = 1;
				tokenAttr(0) = 0;
				b6B36 = 0FFh;
			end;
			b6B35 = b6B2F;
			if opType = 3 then
				b6B2C = 0FFh;
		end;
/* 4 */		accum1 = accum1 * accum2;
/* 5 */		accum1 = accum1 + accum2;
/* 6 */		do;
			call syntaxError;
			call popToken;
		end;
/* 7 */		accum1 = accum1 - accum2;
/* 8 */		;
/* 9 */		do;
			if accum2 = 0 then
				call valueError;
			accum1 = accum1 / accum2;
		end;
/* 10 */	accum1 = -accum1;
/* 11 */	call cond2Acc(accum1 = accum2);
/* 12 */	call cond2Acc(accum1 < accum2);
/* 13 */	call cond2Acc(accum1 <= accum2);
/* 14 */	call cond2Acc(accum1 > accum2);
/* 15 */	call cond2Acc(accum1 >= accum2);
/* 16 */	call cond2Acc(accum1 <> accum2);
/* 17 */	accum1 = not accum1;
/* 18 */	accum1 = accum1 and accum2;
/* 19 */	accum1 = accum1 or accum2;
/* 20 */	accum1 = accum1 xor accum2;
/* 21 */	do;
			if accum2 = 0 then
				call valueError;
			accum1 = accum1 mod accum2;
		end;
/* 22 */	do;
			if accum2$lb <> 0 then
				accum1 = shl(accum1, accum2);
		end;
/* 23 */	do;
			if accum2$lb <> 0 then
				accum1 = shr(accum1, accum2);
		end;
/* 24 */	do;
			accum1 = high(accum1);
			call sub$4B57(10h);
		end;
/* 25 */	do;
			accum1 = low(accum1);
			call sub$4B57(8);
		end;
/* 26 */	do;
			if tokenType(0) <> 10 then
			do;
				accum1 = sub$43DD;
				if accum1$hb - 1 < 0FEh then
					call valueError;
				b6B28 = 22h;
				if (b6855 and 18h) = 18h then
				do;
					call valueError;
					b6855 = b6855 and 0E7h or 8;
				end;
			end;
			else
			do;
				b6855 = 0;
				tokenType(0) = 0Bh;
			end;

			if sub$425B(b6858) then
				call operandError;
			b6B2D = 0Bh;
			b6B23 = 0FFh;
		end;
/* 27 */	do;
			b6B2D = 0Bh;
			b6B24 = 0FFh;
		end;
/* 28 */	do;
			segSize(activeSeg) = segSize(activeSeg) + accum1;
			b68AB = 0FFh;
		end;
/* 29 */ case29:
		do;
			b68AB = 0FFh;
			if (b6855 and 40h) = 40h then
			do;
				call expressionError;
				b6855 = 0;
			end;
			b$9C3A = 1;
			call sub$5CE8(accum1, 22h - b6B2B);
			b6B30 = 0;
		end;
/* 30 */	goto case29;
/* 31 */	do;
			b68AB = 0FFh;
			if (b6855 and 40h) <> 40h then
			do;
				if (b6855 and 18h) <> 0 then
					if (b6855 and 7) <> activeSeg or (b6855 and 18h) <> 18h then
						call expressionError;
			end;
			else
				call expressionError;

			if ctlOBJECT then
				if segSize(activeSeg) > w6B41(activeSeg) then
					w6B41(activeSeg) = segSize(activeSeg);

			segSize(activeSeg) = accum1;
		end;
/* 32 */	do;
			if tokenSP > 0 then
			do;
				startOffset = sub$43DD;
				startDefined = 1;
				startSeg = (b6855 and 7);

				if (b6855 and 40h) = 40h then
					call expressionError;

				if sub$425B(b6858) then
					call operandError;

				b68AB = 0FFh;
			end;

			jj = b$905E;		/* code diff */
			b$905E = 0;			/* code diff */

			if macroCondSP > 0 or jj then	/* code diff */
				call nestingError;

			if opType <> 1 then
				call syntaxError;

			if b6B35 then
				b6B33 = 0FFh;
			else
				call syntaxError;
		end;
/* 33 */	do;
			if b6B35 then
			do;
				b6B32 = 0FFh;
				call nestIFX(2);
				b6881 = 0FFh;
				if skipping(0) = 0 then
					skipping(0) = not ((low(accum1) and 1) = 1);

				inElse(0) = 0;

			end;
		end;
/* 34 */	do;
			b6B32 = 0FFh;
			if macroCondStk(0) <> 2 then
				call nestingError;
			else if not inElse(0) then
			do;
				if not skipping(0) then
					skipping(0) = 0FFh;
				else
					skipping(0) = skipping(ifDepth);
				inElse(0) = 0FFh;
			end;
			else
				call nestingError;
		end;
/* 35 */	do;
			if b6B35 then
			do;
				b6B32 = 0FFh;
				call sub$676D(2);
			end;
		end;
/* 36 */	do;
			if b6744 = 1 then
				if b6873(0) = 4Dh then
					call syntaxError;
			call sub$450F(85h);
		end;
/* 37 */	do;
			if b6744 = 1 then
				if b6873(0) = 4Dh then
					call syntaxError;
			call sub$450F(5);
		end;
/* 38 */	call sub$450F(7);
/* 39 */	call sub$450F(2);
/* 40 */	call sub$450F(8);
/* 41 */	call sub$450F(46h);
/* 42 */	call sub$450F(6);
/* 43 */	call sub$450F(36h);
/* 44 */	call sub$450F(0);
/* 45 */	call sub$450F(0);
/* 46 */	call sub$450F(6);
/* 47 */	activeSeg = 0;
/* 48 */	do;
			activeSeg = 1;
			call sub$4AAA(0);
		end;
/* 49 */	do;
			activeSeg = 2;
			call sub$4AAA(1);
		end;

/* 50 */	do;
			b6748 = 0FFh;
			b$9C3A = 0;
			call sub$5CE8(0, 6);
		end;
/* 51 */	do;
			b6749 = 0FFh;
			if w6750 = 0 and isPhase1 and ctlOBJECT then
				call writeModhdr;
			b$9C3A = 0;
			call sub$5CE8(w6750, 2);
			if isPhase1 and ctlOBJECT and not b6754 then
				call writeExtName;
			
			if not b6754 then
				w6750 = w6750 + 1;
			b6754 = 0;
		end;
/* 52 */	do;
			if tokenSP <> 0 and b6743 then
			do;
				call move(6, .spaces24 + 18, .aModulePage);
				call move(moduleNameLen := b6744, .b6873, .aModulePage);
			end;
			else
				call sourceError(52h);
			call popToken;
		end;
/* 53 */	segSize(3) = accum1;
/* 54 */	call sub$7517;			/* MACRO ? */
/* 55 */	call sub$753E;
/* 56 */	call sub$75FF;			/* ENDM */
/* 57 */	call sub$76CE;			/* EXITM */
/* 58 */	do;
			tmac$mtype = 4;
			call sub$7327;
		end;
/* 59 */	call sub$72A4(1);		/* IRP ? */
/* 60 */	call sub$72A4(2);		/* IRPC */
/* 61 */	call sub$770B;
/* 62 */	call sub$7844;			/* REPT ? */
/* 63 */	call sub$787A;			/* LOCAL */
/* 64 */	call sub$78CE;
/* 65 */	do;				/* NUL */
			call cond2Acc(tokenType(0) = 41h);
			call popToken;
			b6855 = 0;
		end;
	end;

	if b6B2B <> 1 then
		b6743 = 0;
end;


sub$518F: procedure;

	sub$53C0: procedure byte;
		if b6B29 > 3 then
			if b6B29 <> 6 then
				if b6B29 < 1Ah then
					return TRUE;
		return FALSE;
	end;

	sub$53DF: procedure(arg1b) byte;
		declare arg1b byte;
		return arg1b = 9 or arg1b = 64h;
	end;


	sub$53F8: procedure;
		if not b4A68(b6B2B) then
			b6B34 = 0;
	end;

    do while 1;
	if not (b6B29 = 1 or not (b6B29 < 20h)
	  and not (b6B29 > 23h)) and skipping(0)
	  or (b4181(b6B29) < 128 or b$9058) and b$905E then
		do;
			b6885 = 0;
			call popToken;
			return;
		end;

	if phase <> 1 then
		if b6B25 then
			if sub$53C0 then
				if getPrec(b6B29) <= getPrec(opStack(opSP)) then
					call expressionError;

	if getPrec(opType := b6B29) > getPrec(b6B2B := opStack(opSP)) or opType = 2 then
	do;
		if opSP >= 10h then
		do;
			opSP = 0;
			call stackError;
		end;
		else
			opStack(opSP := opSP + 1) = opType;

		if opType = 2 then
		do;
			b6B2F = b6B35;
			b6B35 = 0FFh;
		end;

		if phase > 1 then
			b6B25 = sub$53C0;

		return;
	end;

	b6B25 = 0;
	if not b6B35 and b6B2B > 3 then
		call syntaxError;

	if b6B2B = 0 then
		b6B2B = opType;
	else
		opSP = opSP - 1;

	if (b6B28 := b4181(b6B2B)) then
	do;
		accum2 = sub$43DD;
		b6856 = b6855;
		w685C = w685A;
		b6859 = b6858;
	end;

	if (b6B28 := ror(b6B28, 1)) then
		accum1 = sub$43DD;

	if not b6857 then
		b6857 = sub$53DF(b6858) or sub$53DF(b6859);

	b6B2D = 0Ch;
	if b6B2B > 3 and 1Ah > b6B2B then
		call sub$4291;
	else
	do;
		call sub$53F8;
		call sub$4274;
	end;

	call sub$516F;
	if not b4A26(b6B2B) then
		b6B35 = 0;

	if b6B2C then
	do;
		b6B2C = 0;
		return;
	end;

	if (b6B2B <> 1Ch) and b68AB then
		w68A6 = accum1;

	if (b6B28 and 1Eh) <> 0 then
		call pushToken(b6B2D);

	do ii = 0 to 3;
		if (b6B28 := ror(b6B28, 1)) then
			call collectByte(accum(ii));
	end;

	tokenAttr(0) = b6855;
	tokenSymId(0) = w685A;
	if ror(b6B28,1) then
		if opType = 6 then
		do;
			b6B29 = b6B2B;
			b6B35 = 0FFh;
		end;
    end;
end;

sub$540D: procedure public;
	do while finished = 0;
		call sub$3F19;
		call sub$518F;
	end;
end;
end;
asm48.pl3
asm48:
do;
/*$SET(ASM48)*/
$include(asm48.ipx)
declare	b5666(*) byte data(9, 2Dh, 80h),
	b5669(*) byte data(3Ah, 8, 80h, 0, 0, 0, 0, 0, 20h),
	op16(*) byte data(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0,
			   0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1),
			   /* 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
	chClass(*) byte data(0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 4, 0, 0,
			      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0Bh, 0, 0, 0, 0,	/* ESC maps to 0Bh */
			      1, 0, 0, 0, 6, 0, 0, 7, 5, 5, 5, 5, 5, 5, 0, 5,
			      8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 3, 2, 0, 0, 0, 9,
			      9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
			      9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0,
			      0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
			      9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0);

unpackToken: procedure(src, dst) public;
	declare (src, dst) address;
	declare wrd based src address;
	declare ch based dst byte;
	declare packedword address;

	unpack1: procedure;
		ch = packedword mod 40;	
		if ch = 0 then
			ch = ' ';
		else if ch <= 10 then
			ch = ch + 2Fh;	/* digit */
		else 
			ch = ch + 34h;	/* ? @ and letters */
		packedword = packedword / 40;
		dst = dst - 1;
	end;


	src = src + 2;
	dst = dst + 5;
	packedword = wrd;
	call unpack1;
	call unpack1;
	call unpack1;
	src = src - 2;
	packedword = wrd;
	call unpack1;
	call unpack1;
	call unpack1;
end;


insertSym: procedure;
	declare (w$9C32, w$9C34) address;
	declare ch1 based w$9C32 byte;
	declare ch2 based w$9C34 byte;

	w686E, w$9C32 = (w$9C34 := w686E) + 8;
	if w6870 < w$9C32 then
		call runtimeError(1);	/* table error */

	do while w$9C34 > curTokenSym$p;
		w$9C32 = w$9C32 - 1;
		w$9C34 = w$9C34 - 1;
		ch1 = ch2;
	end;

	call move(4, curTokStart, curTokenSym$p);
	w6868(2) = w6868(2) + 8;
	curTokenSym.type = 0;
end;


sub$5C73: procedure(arg1b) byte;
	declare arg1b byte;

	if w6868(arg1b) >= curTokenSym$p and curTokenSym$p >= symTab(arg1b) then
		return 0;

	call syntaxError;
	return 0FFh;
end;


sub$5CAD: procedure(arg1w, arg2b) public;
	declare arg1w address, arg2b byte;

	if sub$5C73(2) then
		return;
	call insertSym;
	curTokenSym.w4 = arg1w;
	curTokenSym.type = arg2b;
	curTokenSym.flags = 0;
	call popToken;
end;

declare b$9C3A byte public;

sub$5CE8: procedure(arg1w, arg2b) public;
	declare arg1w address, arg2b byte;
	declare (b6CE8, b6CE9, b6CEA, b6CEB, b6CEC) byte;

	sub$5B9A: procedure;
		tokenType(0) = arg2b;
		if (b6858 = 7 or b6858 = 8) and b6CEB then
			tokenType(0) = 12 - arg2b;
	end;

	b6CEC = tokenType(0);
	b6CEB = arg2b = 5 or arg2b = 4;
	b6CE9 = 0;
	b6CE8 = curTokenSym.flags;
	b6CEA = 0;
	if sub$5C73(1) then
		return;

	if tokenSP > 1 then
		call syntaxError;

	if isPhase1 then
		if tokenType(0) = 9 then
		do;
			if b6883 then
			do;
				if curTokenSym.type >= 80h or arg2b = 3Ah and curTokenSym.w4 <> w6A4E then
				do;
					call locationError;
					b6CE9 = 80h;
				end;
			end;
			else
			do;
				call insertSym;
				w6866 = w6866 + 8;
				w6868(1) = w6868(1) + 8;
				b6CE8 = 0;
			end;

			b6CE8 = (activeSeg <> 0 and 18h) or (b6748 and 20h) or (b6749 and 58h);
			if b$9C3A = 1 then
				b6CE8 = b6855;

			if b$9C3A = 2 then
				b6CE8 = b6CE8 or activeSeg;

			if b6857 and b6CEB then
				tokenType(0) = 64h;
			else
				call sub$5B9A;

			goto L5F82;
		end;

	if b6882 = 2 then
		if tokenType(0) = 9 then
			if b6858 <> 9 then
				if b6CEB then
				do;
					call sub$5B9A;
					if curTokenSym.type < 128 then
					do;
						curTokenSym.type = tokenType(0);
						curTokenSym.w4 = arg1w;
						b6CE8 = b6855;
						b6CEA = 0FFh;
					end;
					goto L5F82;
				end;

	if isPhase1 then
		if tokenType(0) = 6 then
			if testBit(arg2b, .b5666) then
			do;
				if b6749 then
					tokenType(0) = 3;
				else
				do;
					tokenType(0) = arg2b;
					b6CE8 = b6CE8 and 0E0h;
					if b$9C3A = 1 then
						b6CE8 = b6855 or 20h;

					if b$9C3A = 2 then
						if activeSeg <> 0 then
							b6CE8 = b6CE8 or activeSeg or 38h;
				end;
				goto L5F82;
			end;

	if isPhase1 then
		if arg2b = 6 then
			if testBit(tokenType(0), .b5666) then
			do;
				if (b6CE8 and 60h) <> 0 then
					tokenType(0) = 3;
				else
					b6CE8 = b6CE8 or 20h;
				goto L5F82;
			end;

	if isPhase1 then
		if tokenType(0) <> arg2b and tokenType(0) <> 8 or arg2b = 5 then
			tokenType(0) = 3;

	if not b6748 and testBit(tokenType(0), .b5669) then
		b6CE8 = (b6CE8 and 20h) and tokenType(0) <> 3Ah or b6855;
	else
	do;
		if isPhase1 then
			tokenType(0) = 3;

		if not (b6748 or b6749) then
			if curTokenSym.w4 <> arg1w then
				call phaseError;
	end;

L5F82:
	b6CE9 = b6CE9 or (curTokenSym.type and 80h);

	if isPhase1 and (arg2b = 9 or arg2b = 6 or b6CEC <> tokenType(0)) then
		curTokenSym.type = tokenType(0) or b6CE9;

	jj = curTokenSym.type;
	if tokenType(0) = 3 or jj = 3 then
		call multipleDefError;

	if jj >= 80h then
		call locationError;

	if isPhase1 and (tokenType(0) = arg2b or arg2b = 5 and tokenType(0) = 7) or arg2b = 4 and blankAsmErrCode
	   or b6CEA or arg2b = 3Ah then
		curTokenSym.w4 = arg1w;

	curTokenSym.flags = b6CE8;
	b6748 = 0;
	b6749 = 0;
	if curTokenSym.type = 6 then
		call undefinedSymbolError;

	b6857 = 0;
	if b6883 then
		call popToken;

end;



lookup: procedure(arg1b) byte public;
	declare arg1b byte;
	declare (lowOffset, highOffset, s6CF2$p, deltaToNext, entryOffset, packedTok$p) address,
		(i, b6CFB) byte;
	declare symEntry based entryOffset structure(tok(2) address, b4 byte, delta byte, type byte, flags byte),
		packedTok based packedTok$p (2) address;
	declare wrd based w6BE0 address;

	packedTok$p = curTokStart;
	if arg1b = 0 then		/* hash chain look up key word */
	do;
		entryOffset = 0;
		deltaToNext = symTab(0) + (packedTok(0) + packedTok(1)) mod 97h * 8;

		do while deltaToNext <> 0;
			entryOffset = entryOffset + deltaToNext;
			if symEntry.tok(0) = packedTok(0) then
				if symEntry.tok(1) = packedTok(1) then
				do;
					curTokenSym$p = entryOffset;
					tokenType(0) = curTokenSym.type;
					if tokenType(0) < 2Dh then
						if op16(tokenType(0)) then
							has16bitOperand = 0FFh;
					if curTokenSym.flags = 2 and not ctlMOD85 then
						call sourceError(4Fh);

					if tokenType(0) = 8 then	/* SP */
					do;
						if not (opType = 24h or opType = 25h) then /* lxi or push/pop/dad/inx/dcx */
							call sourceError(58h);
						tokenType(0) = 7;	/* reg */
					end;
					return (tokenType(0) and 7Fh);
				end;
			deltaToNext = symEntry.delta;
		end;
		return 9;
	end;

	lowOffset = symTab(arg1b);
	highOffset, entryOffset = w6868(arg1b);

	/* binary chop search for id */

	do while (s6CF2$p := lowOffset + shr((highOffset - lowOffset) and 0FFF0h, 1)) <> entryOffset;
		entryOffset = s6CF2$p;
		if packedTok(0) = symEntry.tok(0) then
		do;
			if packedTok(1) = symEntry.tok(1) then
			do;
				curTokenSym$p = entryOffset;
				tokenType(0) = curTokenSym.type;
				if tokenType(0) = 64h then
					tokenType(0) = 9;

				if (b6884 := (jj := (tokenType(0) and 7Fh)) = 9) then
					if b6885 then
						curTokenSym.type = 89h;
				return jj;
			end;
			else
				b6CFB = symEntry.tok(1) > packedTok(1);
		end;
		else
			b6CFB = symEntry.tok(0) > packedTok(0);

		entryOffset = s6CF2$p;
		if b6CFB then
			highOffset = entryOffset;
		else
			lowOffset = entryOffset;
	end;

	curTokenSym$p = highOffset;
	if arg1b = 1 and not isSkipping then
	do;
		b6883 = 0;
		b$9C3A = 0;
		call sub$5CE8(w6A4E, (b6885 and 80h) or 9);
		w6BE0 = .tokenSym;
		do i = 1 to tokenSP;
			w6BE0 = w6BE0 + 2;
			if wrd >= curTokenSym$p then
				wrd = wrd + 8;
		end;

		b6883 = 0FFh;
	end;
	return 9;
end;



getCh: procedure byte public;
	declare (curCH, prevCH) byte;
	declare ch based tmac$buf$p byte;
	declare ch1 based off$9056 byte;

L6339:
	if not reget then
	do;
		prevCH = curCH;

	L6347:
		curCH = lookAhead;
		if b$905B then
		do;
			do while (lookAhead := ch) = 0FEh;
				call readM(curMacroBlk + 1);
				tmac$buf$p = .macroBuf;
			end;

			tmac$buf$p = tmac$buf$p + 1;
		end;
		else if scanCmdLine then
			lookAhead = nxtCmdCh;
		else
			lookAhead = sub$4879;

		if chClass(curCH) = CC$BAD then
			if curCH = 0 or curCH = 7Fh or curCH = 0Ch then
				goto L6347;

		if b$905B then
		do;
			if curCH = 1Bh then
			do;
				goto L65B2;
			end;
			else if curCH = '&' then
			do;
				if not prevCH < 80h or lookAhead = 80h then
					goto L6339;
			end;
			else if curCH = '!' and prevCH <> 0 then
			do;
				if not (b$905D or b$905E) and b$905C then
				do;
					curCH = 0;
					goto L6339;
				end;
			end;
			else if curCH >= 128 then
			do;
				if not (b$905C := not b$905C) then
					tmac$buf$p = w$9197;
				else
				do;
					w$9197 = tmac$buf$p;
					if curCH = 80h then
					do;
						tmac$buf$p = tmac$w12;
						if b$9062 = 2 then
						do;
							b$91A2 = ch;
							tmac$buf$p = .b$91A2;
							if ch = '!' then
							do;
								b$91A1 = 21h;
								b$91A2 = mem(tmac$w12 + 1);
								tmac$buf$p = tmac$buf$p - 1;
							end;
						end;
						else
						do;
							do while (lookAhead := lookAhead - 1) <> 0FFh;
								tmac$buf$p = tmac$buf$p - (ch and 7Fh);
							end;

							tmac$buf$p = tmac$buf$p + 1;
						end;
					end;
					else
					do;
						tmac$buf$p = .b$91A4;
						w6BE0 = lookAhead + tmac$w4;
						do ii = 1 to 4;
							b$91A4(6 - ii) = w6BE0 mod 10 + '0';
							w6BE0 = w6BE0 / 10;
						end;
					end;
				end;

				lookAhead = 0;
				goto L6339;
			end;
		end;

		if b$905B > 1 then
			if isPhase2Print then
				if off$9056 < .w$9054 then
				do;
					ch1 = curCH;	
					off$9056 = off$9056 + 1;
				end;

		if b$905E then
			if w$919D <> w$906A and curCH = 0Dh or not b$9059 then
			call sub$3D55(curCH);

		if not(prevCH = '!' or b6742) then
		do;
			if curCH = '>' then
				argNestCnt = argNestCnt - 1;

			if curCH = '<' then
				argNestCnt = argNestCnt + 1;
		end;
	end;
L65B2:
	reget = 0;
	return (curChar := curCH);
end;

getChClass: procedure byte public;
	curChar = getCh;
	if b$905D then
		return 0Ah;

	return chClass(curChar);
end;



chkLF: procedure public;
	if lookAhead = 0Ah then
		lookAhead = 0;
	else
	do;
/* $IF ASM48 */
		b$905E = b$905E and 0FEh;
/* $ENDIF */
		call illegalCharError;
/* $IF ASM48 */
		b$905E = b$905E > 0;
/* $ENDIF */
	end;
end;

end;

asm49.pl3
asm49:
do;
$include(asm49.ipx)

syntaxError: procedure public;
	call sourceError('Q');
end;

doubleDefError: procedure public;
	call sourceError('D');
end;

expressionError: procedure public;
	call sourceError('E');
end;

commandError: procedure public;
	call sourceError('C');
end;

OpcodeOperandError: procedure public;
	call sourceError('O');
end;

nameError: procedure public;
	call sourceError('R');
end;

multipleDefError: procedure public;
	call sourceError('M');
end;

valueError: procedure public;
	call sourceError('V');
end;

nestingError: procedure public;
	call sourceError('N');
end;

phaseError: procedure public;
	call sourceError('P');
end;

stackError: procedure public;
	call runtimeError(0);
end;

fileError: procedure public;
	call runtimeError(4);
end;

illegalCharError: procedure public;
	call sourceError('I');
end;

balanceError: procedure public;
	call sourceError('B');
end;

undefinedSymbolError: procedure public;
	call sourceError('U');
end;

locationError: procedure public;
	call sourceError('L');
end;

operandError: procedure public;
	call sourceError('X');
end;

haveTokens: procedure byte public;
	return tokenSP <> 0;
end;


popToken: procedure public;
	tokStart(0) = tokStart(tokenSP);
	tokenSym(0) = tokenSym(tokenSP);
	tokenType(0) = tokenType(tokenSP);
	tokenAttr(0) = tokenAttr(tokenSP);
	tokenSize(0) = tokenSize(tokenSP);
	tokenSymId(0) = tokenSymId(tokenSP);
	if haveTokens then
		tokenSP = tokenSP - 1;
end;



nestIFX: procedure(arg1b) public;
	declare arg1b byte;

	macroCondStk(macroCondSP := macroCondSP + 1) = macroCondStk(0);
	if (macroCondStk(0) := arg1b) = 1 then
	do;
		if (b$9063 := b$9063 + 1) > 9 then
		do;
			call stackError;
			b$9063 = 0;
		end;
		else
		do;
			call move(16, .macroStk(0), .macroStk(b$9063));
			tmac$macroCondSP = macroCondSP;
			tmac$ifDepth = ifDepth;
			b$9061 = 0FFh;
		end;
	end;
	else
	do;
		if (ifDepth := ifDepth + 1) > 8 then
		do;
			call stackError;
			ifDepth = 0;
		end;
		else
		do;
			skipping(ifDepth) = skipping(0);
			inElse(ifDepth) = inElse(0);
		end;
	end;
end;


sub$676D: procedure(arg1b) public;
	declare arg1b byte;

	if arg1b <> macroCondStk(0) then
	do;
		call nestingError;
		if arg1b = 2 then
			return;
		macroCondSP = tmac$macroCondSP;
		ifDepth = tmac$ifDepth;
	end;

	macroCondStk(0) = macroCondStk(macroCondSP);
	macroCondSP = macroCondSP - 1;
	if arg1b = 1 then
	do;
		call move(16, .macroStk(b$9063), .macroStk(0));
		call readM(tmac$blk);
		b$9062 = tmac$mtype;
		if (b$9063 := b$9063 - 1) = 0 then
		do;
			b$905B = 0;
			w6870 = physmem + 0BFh;
		end;
	end;
	else
	do;
		skipping(0) = skipping(ifDepth);
		inElse(0) = inElse(ifDepth);
		ifDepth = ifDepth - 1;
	end;
end;

pushToken: procedure(arg1b) public;
	declare arg1b byte;

	if tokenSP >= 8 then
		call stackError;
	else
	do;
		tokenSP = tokenSP + 1;
		tokStart(tokenSP) = tokStart(0);
		tokenSym(tokenSP) = tokenSym(0);
		tokenType(tokenSP) = tokenType(0);
		tokenAttr(tokenSP) = tokenAttr(0);
		tokenSize(tokenSP) = tokenSize(0);
		tokenSymId(tokenSP) = tokenSymId(0);	
		tokStart(0) = tokStart(0) + tokenSize(0);	/* advance for next token */
		tokenType(0) = arg1b;
		tokenAttr(0), tokenSize(0) = bZERO;
		tokenSym(0) = wZERO;
		tokenSymId(0) = wZERO;
	end;
end;

collectByte: procedure(arg1b) public;
	declare arg1b byte;
	declare s address;
	declare ch based s byte;


	if (s := curTokStart + tokenSize(0)) < endLineBuf then	/* check for lineBuf overrun */
	do;
		ch = arg1b;
		tokenSize(0)= tokenSize(0)+ 1;
	end;
	else
		call stackError;
end;

getId: procedure(arg1b) public;
	declare arg1b byte;

	call pushToken(arg1b);
	reget = 1;

	do while (arg1b := getChClass) = 8 or arg1b = 9;	/* digit or letter */
		if curChar > 60h then	/* make sure upper case */
			curChar = curChar and 0DFh;
		call collectByte(curChar);
	end;
	reget = 1;
end;


getNum: procedure public;
	declare accum address,
		(radix, digit, i) byte;
	declare chrs based curTokStart(1) byte;

	call getId(0Ch);
	radix = chrs(tokenSize(0):= tokenSize(0)- 1);
	if radix = 'H' then
		radix = 16;

	if radix = 'D' then
		radix = 10;

	if radix = 'O' or radix = 'Q' then
		radix = 8;

	if radix = 'B' then
		radix = 2;

	if radix > 10h then
		radix = 0Ah;
	else
		tokenSize(0)= tokenSize(0)- 1;

	accum = 0;
	do i = 0 to tokenSize(0);
		if chrs(i) = '?' or chrs(i) = '@' then
		do;
			call illegalCharError;
			digit = 0;
		end;
		else
		do;
			if (digit := chrs(i) - '0') > 9 then
				digit = digit - 7;
			if digit >= radix then
				if not (tokenType(2) = 40h) then
				do;
					call illegalCharError;
					digit = 0;
				end;
		end;

		accum = accum * radix + digit;
	end;
	/* replace with packed number */
	tokenSize(0)= 0;
	call collectByte(low(accum));
	call collectByte(high(accum));
end;

getStr: procedure public;
	call pushToken(0Ah);

	do while getCh <> 0Dh;
		if curChar = 27h then
			if getCh <> 27h then
				goto L6268;
		call collectByte(curChar);
	end;

	call balanceError;

L6268:
	reget = 1;
end;

end;
asm4A.pl3
/*$SET(ASM4A)*/
asm4A: do;
$include(asm4a.ipx)

declare controlTable(*) byte data(35h, 'DEBUG', 3Ah, 'MACRODEBUG',
			   34h, 'XREF', 37h, 'SYMBOLS',
			   36h, 'PAGING', 33h, 'TTY',
			   25h, 'MOD85', 35h, 'PRINT',
			   36h, 'OBJECT', 39h, 'MACROFILE',
			   29h, 'PAGEWIDTH', 2Ah, 'PAGELENGTH',
			   7, 'INCLUDE', 5, 'TITLE',
			   4, 'SAVE', 7, 'RESTORE',
			   5, 'EJECT', 14h, 'LIST',
			   13h, 'GEN', 14h, 'COND');

declare (b7463, b7464, b7465, controlError) byte;


chkParen: procedure(arg1b) byte;
	declare arg1b byte;
	call skipWhite;
	reget = 0;
	return arg1b + '(' = curChar;
end;



getTok: procedure byte;
	tokBufLen = 0;
	tokType = TT$ID;
	if isCR then
		return curChar;

	call skipWhite$2;
	if curChar > 'A'-1 and 'Z'+1 > curChar or curChar > 'a'-1 and 'z'+1 > curChar then
	do;							/* letter */
		call getId(1);
		if blankAsmErrCode and tokenSize(0) < 14 then
			call move(tokBufLen := tokenSize(0), .lineBuf, .tokBuf);
	end;
	else if curChar > '0'-1  and  '9'+1 > curChar then	/* digit ? */
	do;
		call getNum;
		if blankAsmErrCode then
		do;
			w6B1E = sub$43DD;
			tokType = TT$NUM;
			tokBuf(0) = ' ';
		end;
	end;
	else if curChar = '''' then	/* string ? */
	do;
		call getStr;
		if blankAsmErrCode then
		do;
			tokBufLen = 64;
			if tokenSize(0) < 64 then
				tokBufLen = tokenSize(0);
			tokType = TT$STR;
			if tokBufLen > 0 then
				call move(tokBufLen, .lineBuf, .tokBuf);
		end;
	end;
	else
	do;
		tokBufLen = 1;
		tokBuf(0) = curChar;
		return curChar;
	end;

	call popToken;
	return tokBuf(0);
end;



sub$6F07: procedure(arg1w) byte;
	declare arg1w address;
	declare pad address;

	if tokBufIdx = 0 then
		return 0;

	tokBuf(tokBufIdx) = 20h;
	tokBufLen = tokBufIdx;
	if isWhite then
		return chkParen(1);
	return 0FFh;
end;

sub$6F39: procedure;
	call skipWhite$2;

    do while 1;
	if isRParen or isWhite then
	do;
		if sub$6F07(.tokBuf(0)) then
			return;
		goto done;
	end;

	tokBuf(tokBufIdx) = curChar;
	tokBufIdx = tokBufIdx + 1;
	if tokBufIdx > 14 then
		goto done;
	curChar = getCh;
    end;
done:
	curFileName$p = .tokBuf;
	call fileError;
end;


getFileParam: procedure;
	tokBufIdx = 0;
	if not chkParen(0) then	/* ( */
		call fileError;
	else
	do;
		call sub$6F39;
		call move(tokBufIdx + 1, .tokBuf, curFileName$p);
		if not chkParen(1) then	/* ) */
			call fileError;
	end;
end;


getMacroFileDrive: procedure;
	call skipWhite$2;
	tokBufIdx = 0Dh;
	ii = 0;

	do while not isRParen and ii < 4;
		aF0Asmac$tmp(ii) = curChar;
		ii = ii + 1;
		curChar = getCh;
	end;

	if isRParen or isWhite then
		if sub$6F07(.aF0Asmac$tmp) then
			return;
	curFileName$p = .aF0Asmac$tmp;
	tokBufIdx = 0;
	call fileError;
end;




sub$702B: procedure byte;
	if chkParen(0) then	/* ( */
	do;
		b7463 = getTok;
		if tokType = TT$NUM then
			return chkParen(1);	/* ) */
	end;
	return 0;
end;


lookupControl: procedure byte;
	declare (cmdIdx, cmdStartIdx, ctlVal, cmdLen, ctlFlags, noInvalid) byte,
		(control$p, nextControl$p, ctlSeen$p) address;
	declare twoch address at(.tokBuf);
	declare ch based control$p byte;
	declare ctlSeen based ctlSeen$p byte;

	setControl: procedure;
		if not noInvalid then
		do;
			controls(controlId) = ctlVal;
			if not ctlVal then
				controlId = 17;	/* no action needed */
		end;
	end;


	cmdLen = tokBufLen;
	cmdStartIdx = 0;
	ctlVal = 0FFh;
	if twoch = 'ON' then	/* NO stored with bytes swapped */
	do;
		cmdStartIdx = 2;	/* don't match the NO in the table */
		ctlVal = 0;		/* control will be set as false */
		cmdLen = tokBufLen - 2;	/* length of string to match excludes the NO */
	end;

	control$p = .controlTable;
	controlId = 0;
	cmdIdx = cmdStartIdx;

	do while controlId < 20;
		nextControl$p = control$p + (ch and 0Fh) + 1;
		if (ch and 0Fh) = cmdLen then
		do;
			ctlFlags = ch;
			do while cmdIdx < tokBufLen;
				control$p = control$p + 1;
				if ch <> tokBuf(cmdIdx) then
					cmdIdx = tokBufLen + 1;	/* cause early exit */
				else
					cmdIdx = cmdIdx + 1;	/* check next character */
			end;

			if cmdIdx = tokBufLen then		/* found it */
				goto break;
		end;
		control$p = nextControl$p;
		controlId = controlId + 1;
		cmdIdx = cmdStartIdx;
	end;
	return 255;						/* not found */

break:
/* $IF NOT ASM4A */
/*	if controlId = 1 or controlId = 12h then	/* MACRODEBUG or GEN */
/*	do;
/*		if scanCmdLine then			/* only valid on command line not $ line */
/*			MacroDebugOrGen = 0FFh;
/*		else
/*			return 255;			/* error otherwise */
/*	end;
/* $ENDIF */
	if (noInvalid := (ctlFlags and 10h) <> 10h) and not ctlVal then
		return 255;	/* NO not supported */

	if (ctlFlags and 20h) <> 20h then		/* GENERAL control */
	do;
		call setControl;
		return controlId;
	end;

	if not primaryValid then			/* is a PRIMARY control */
		return 255;

	ctlSeen$p = .controlSeen(controlId);		/* make sure we only see a primary once */
	if ctlSeen then
		return 255;
	ctlSeen = TRUE;
	call setControl;
	return controlId;
end;

processControl: procedure;
	if controlId >= 17 or controlId < 5 then
		return;

	do case controlId - 5;
/* 0 */		do;			/* TTY */
			ctlTTY = 0FFh;
			return;
		end;
/* 1 */		do;			/* MOD85 */
			ctlMOD85 = 0FFh;
			return;
		end;
/* 2 */		do;			/* PRINT */
			w6BE2 = 2;
			curFileName$p = .lstFile;
			call getFileParam;
			return;
		end;
/* 3 */		do;			/* OBJECT */
			w6BE2 = 3;
			curFileName$p = .objFile;
			call getFileParam;
			return;
		end;
/* 4 */		do;			/* MACROFILE */
			w6BE2 = 3;
			if chkParen(0) then	/* optional drive for tmp file */
				call getMacroFileDrive;
			else
				reget = 1;
			ctlMACROFILE = 0FFh;
			return;
		end;
/* 5 */		do;			/* PAGEWIDTH */
			if sub$702B then
			do;
				ctlPAGEWIDTH = w6B1E;
				if ctlPAGEWIDTH > 132 then
					ctlPAGEWIDTH = 132;
				if ctlPAGEWIDTH < 72 then
					ctlPAGEWIDTH = 72;
				return;
			end;
		end;
/* 6 */		do;			/* PAGELENGTH */
			if sub$702B then
			do;
				ctlPAGELENGTH = w6B1E;
				if ctlPAGELENGTH < 15 then
					ctlPAGELENGTH = 15;
				return;
			end;
		end;
/* 7 */		do;			/* INCLUDE */
			if not b6C21 then
			do;
				w6BE2 = 1;
				if fileIdx = 5 then
					call stackError;
				else
				do;
					fileIdx = fileIdx + 1;
					curFileName$p = .files(fileIdx);
					call getFileParam;
					b6C21 = 0FFh;
					if scanCmdLine then
						b6C22 = 0FFh;
					return;
				end;
			end;
		end;
/* 8 */		do;			/* TITLE */
			if chkParen(0) then
			do;
				b7463 = getTok;
				if tokType = TT$STR and tokBufLen <> 0 then
				do;
					if phase <> 1 or isPhase1 and primaryValid then
					do;
						call move(tokBufLen, .tokBuf, .ctlTITLESTR);
						ctlTITLESTR(titleLen := tokBufLen) = 0;
						if chkParen(1) then
						do;
							ctlTITLE = 0FFh;
							return;
						end;
					end;
				end;
			end;
		end;
/* 9 */		do;			/* SAVE */
			if saveIdx > 7 then
				call stackError;
			else
			do;
				call move(3, .ctlLIST, .saveStack + saveIdx * 3);
				saveIdx = saveIdx + 1;
				return;
			end;
		end;
/* 10 */	do;			/* RESTORE */
			if saveIdx > 0 then
			do;
				call move(3, .saveStack + (saveIdx := saveIdx - 1) * 3, .ctlLIST);
				return;
			end;
		end;
/* 11 */	do;			/* EJECT */
			ctlEJECT = ctlEJECT + 1;
			return;
		end;
	end;
	controlError = 0FFh;
end;

parseControls: procedure public;
	b6B20$9A77 = 0FFh;
	b6A6F, b7464 = ctlLIST;
/*$IF ASM4A */
	b7465 = ctlGEN;
/* $ENDIF */
	controlError = 0;

	do while getTok <> 0Dh and not controlError;
		if tokBuf(0) = ';' then		/* skip comments */
			call skip2EOL;
		else if lookupControl = 0FFh then	/* error ? */
			controlError = 0FFh;
		else
			call processControl;
	end;

	if controlError then
	do;
		if tokBuf(0) <> 0Dh then
		do;
			reget = 0;
			call skip2EOL;
		end;

		if scanCmdLine then
			call runtimeError(2);	/* command error */
		else
			call commandError;
	end;

	call chkLF;
	if ctlLIST <> b7464 then
		b6A6F = 0FFh;
	else if ctlGEN <> b7465 and b$905B then
		b6A6F = 0;

	reget = 0;
end;

end;
asm4B.pl3
asm4B:
do;
$include(asm4b.ipx)

declare b$7183(*) byte data(3Fh, 0, 4, 0, 0, 0, 8, 0, 10h),
	aMacro(*) byte data('MACRO', 0);

declare w$9C75 address,
	b$9C77 byte public;


sub$7192: procedure byte;
	if isCR then
	do;
		b$905A = 0;
		return TRUE;
	end;

	if b$905A then
		return argNestCnt = b$9066;

	if isLT or (not (tmac$mtype = 1) and isGT) then
	do;
		call illegalCharError;
		return TRUE;
	end;

	return isWhite or isComma or isGT or curChar = 3Bh;
end;



sub$71F2: procedure;
	w6866, w6868(2) = w686E;
	b$9065, tmac$b3 = bZERO;
	b6B29 = 37h;
end;


sub$720A: procedure;

	b$9062 = tmac$mtype;
	if not b$905B then
		b$905B = 1;

	if b$9063 = 0 then
		b$905B = 0FFh;

	if b$9061 then
		call move(4, .macroStk(0).buf$p, .macroStk(b$9063).buf$p);

	b$9061 = 0;
	tmac$w12 = w$9199;
	tmac$w4 = w$919B;
	w$919B = w$919B + tmac$b3;
	call readM(tmac$w10);
	tmac$buf$p = .macroBuf;
end;


sub$727F: procedure byte;
	if not b$905E then
		return TRUE;
	b$9064 = b$9064 + 1;
	b6B2C = b6B2B <> 3Eh;
	b6B29 = 37h;
	return FALSE;
end;


sub$72A4: procedure(arg1b) public;	/* 1 -> IRP, 2 -> IRPC */
	declare arg1b byte;

	if sub$727F then
	do;
		call sub$71F2;
		call nestIFX(1);
		tmac$w14 = 0;
		tmac$mtype = arg1b;
	end;
end;

sub$72C4: procedure;
	declare b$9C79(6) byte;

	call pushToken(0Dh);
	jj = 0;

L72CE:
	b$9C79(jj := jj + 1) = accum1 mod 10 + '0';
	if (accum1 := accum1 / 10) > 0 then
		goto L72CE;

	do while jj > 0;
		call collectByte(b$9C79(jj));
		jj = jj - 1;
	end;
end;


sub$7327: procedure public;
	w$9199 = w6870;
	b6B29 = 3Dh;
	b$905D = 0FFh;
	b$9060 = 0;
end;


sub$733D: procedure(arg1w, arg2w) address;
	declare (arg1w, arg2w) address;
	declare ch1 based w6870 byte,
		ch2 based arg2w byte;

	do while arg1w <= arg2w;
		if w6870 <= w686E then
			call runtimeError(1);	/* table error */
		ch1 = ch2;
		w6870 = w6870 - 1;
		arg2w = arg2w - 1;
	end;
	return w6870;
end;


sub$7383: procedure;
	b$9064 = 1;
	w$906A = w686E;
	b$905E = 1;
	w$9C75 = w$9114;
end;



sub$739A: procedure;
	if b6884 then
		if asmErrCode <> 55h then
			call locationError;
end;


sub$73AD: procedure public;
	declare b$9C83 byte;

	b$9C77 = tokenSP;
	call skipWhite;
	if not (b$9C83 := curChar = 25h) then
	do;
		b$9066 = argNestCnt - 1;
		if (b$905A := isLT) then
			curChar = getCh;

		call pushToken(0Dh);

	L73E2:	do while not sub$7192;
			if curChar = 27h then
			do;
				if (curChar := getCh) = 27h then
				do;
					curChar = getCh;
					call skipWhite;
					if sub$7192 then
						goto L7463;
					else
					do;
						call collectByte(27h);
						call collectByte(27h);
					end;
				end;
				else
				do;
					call collectByte(27h);
					goto L73E2;
				end;
			end;
			call collectByte(curChar);
			if tmac$mtype = 2 then
				tmac$w14 = tmac$w14 + 1;

			if curChar = 21h and getCh <> 0Dh then
			do;
				call collectByte(curChar);
				curChar = getCh;
			end;
		end;

	L7463:	if b$905A then
			curChar = getCh;

		call skipWhite;
		if isGT then
		do;
			curChar = getCh;
			call skipWhite;
		end;

		reget = 1;
	end;

	b$905D = 0;
	if tmac$mtype = 4 then
	do;
		if not b$905A and tokenSize(0) = 5 then
			if strUCequ(.aMacro, curTokStart) then
			do;
				b6B29 = 36h;
				call popToken;
				w$9199 = tmac$w12;
				opSP = opSP - 1;
				reget = 1;
				call sub$467F(0, .b6873);
				b6880 = 0;
				b6BDA = 0FFh;
				return;
			end;
		tmac$mtype = b$9062;
		call nestIFX(1);
		tmac$mtype = 0;
	end;

	if not b$9C83 then
		if not testBit(curChar, .b$7183) then
		do;
			call skip2EOL;
			call syntaxError;
			reget = 1;
		end;
end;



sub$7517: procedure public;
	if sub$727F then
	do;
		b6B30 = 0;
		w$9068 = curTokenSym$p + 4;
		call sub$5CE8(0, 3Ah);
		tmac$mtype = 0;
		call sub$71F2;
	end;
end;

sub$753E: procedure public;
	declare ch based w$9068 byte;

	if haveTokens then
	do;
		if tokenType(0) = 0 then
			call multipleDefError;

		call sub$5CAD((b$9065 := b$9065 + 1), 0);
	end;
	else if not (tmac$mtype = 0) then
		call syntaxError;

	if not tmac$mtype = 0 then
	do;
		call skipWhite;
		if isComma then
		do;
			reget = 0;
			opType = 0;
			call sub$7327;
			if tmac$mtype = 1 then
			do;
				curChar = getCh;
				call skipWhite;
				if not isLT then
				do;
					call syntaxError;
					reget = 1;
				end;
			end;
		end;
		else
		do;
			call syntaxError;
			call sub$7383;
		end;
	end;
	else if opType = 1 then
	do;
		if not blankMorPAsmErrCode then
		do;
			tmac$mtype = 5;
			w$9068 = w$9068 + 2;
			if (ch and 7Fh) = 3Ah then
				ch = (asmErrCode = 4Ch) and 80h or 9;
		end;
		call sub$7383;
	end;
end;

sub$75FF: procedure public;
	declare ch based w$906A byte;
	declare ch2 based w$9068 byte;
	declare wrd based w$9068 address;

	if b$905E then
	do;
		if (b$9064 := b$9064 - 1) = 0 then
		do;
			b$905E = 0;
			if not (tmac$mtype = 5) then
			do;
				if tmac$mtype = 2 then
					w$9199 = w6870 + 3;

				do w6BE0 = w$919D to w$919F - 1;
					curChar = mem(w6BE0);
					if not isWhite then
						call syntaxError;
				end;

				w$906A = w$919D;
				ch = 1Bh;
				call sub$40B9;
				call writeM;
				w686E, w6868(2) = w6866;
				if tmac$mtype = 0 then
				do;
					wrd = w$9C75;
					w$9068 = w$9068 + 3;
					ch2 = tmac$b3;
				end;
				else
				do;
					tmac$w10 = w$9C75;
					call sub$720A;
					if tmac$w14 = 0 then
						call sub$676D(1);
				end;
			end;
		end;
	end;
	else
		call nestingError;
end;


sub$76CE: procedure public;
	if b$905B then
	do;
		if opType = 1 then
		do;
			b6B32 = 0FFh;
			macroCondSP = tmac$macroCondSP;
			ifDepth = tmac$ifDepth;
			tmac$w14 = 1;
			lookAhead = 1Bh;
			macroCondStk(0) = 1;
		end;
		else
			call syntaxError;
	end;
	else
		call nestingError;
end;


sub$770B: procedure public;
	if b$9C77 + 1 <> tokenSP then
		call syntaxError;
	else if not b$9060 then
	do;
		if tokenType(0) <> 0Dh then
		do;
			accum1 = sub$43DD;
			call sub$72C4;
		end;

		if tmac$mtype = 2 then
			tmac$w14 = tokenSize(0) - (tokenSize(0) = 0);

		call collectByte((tokenSize(0) + 1) or 80h);
		w6870 = sub$733D(curTokStart, curTokStart + tokenSize(0) - 1);
		call popToken;

		if tmac$mtype = 0 or tmac$mtype = 1 and argNestCnt > 0 then
			b$905D = 0FFh;
		else
			b$9060 = 0FFh;

		if tmac$mtype = 1 then
			tmac$w14 = tmac$w14 + 1;
	end;
	else
		call syntaxError;

	if opType = 1 then
	do;
		b$905D = 0;
		if argNestCnt > 0 then
			call balanceError;

		if not blankMorPAsmErrCode then
		do;
			call sub$739A;
			if tmac$mtype = 0 then
			do;
				call sub$720A;
				call sub$676D(1);
				return;
			end;
			else
				tmac$w14 = 0;
		end;
		else
		do;
			w6870 = sub$733D(.b$3782, .b$3783);
			if tmac$mtype = 0 then
			do;
				tmac$b3 = curTokenSym.flags;
				tmac$w10 = sub$43DD;
				call sub$720A;
			end;
			else if tmac$w14 = 0 then
				call syntaxError;
		end;

		if not (tmac$mtype = 0) then
			call sub$7383;
	end;
end;



sub$7844: procedure public;
	call sub$72A4(3);
	if (b6B29 := opType) <> 1 then
		call syntaxError;

	if not b$905E then
	do;
		tmac$w14 = accum1;
		if not blankMorPAsmErrCode then
		do;
			call sub$739A;
			tmac$w14 = 0;
		end;

		call sub$7383;
	end;
end;


sub$787A: procedure public;
	if b$905E = 2 then
	do;
		if haveTokens then
		do;
			if (tmac$b3 := tmac$b3 + 1) = 0 then
				call stackError;

			if tokenType(0) <> 9 then
				call multipleDefError;

			call sub$5CAD(tmac$b3, 1);
			w$906A = w686E;
		end;
		if opType = 1 then
		do;
			b$905E = 1;
			w$906A = w686E;
		end;
	end;
	else
		call syntaxError;
end;



sub$78CE: procedure public;
	jj = mem(tmac$w12);
	bp6BE0(0) = 1 - (jj = 21h and b$9062 = 2);
	if b$9062 = 0 or (tmac$w14 := tmac$w14 - bp6BE0(0)) = 0 then
		call sub$676D(1);
	else
	do;
		if b$9062 = 1 then
			w$9199 = tmac$w12 - (jj and 7Fh);
		else
			w$9199 = tmac$w12 + bp6BE0(0);

		tmac$mtype = b$9062;
		call sub$720A;
	end;
	lookAhead = 0;
	b6B2C, b689C = bTRUE;
end;

end;
asm4C.pl3
asm4C:
do;
$include(asm4c.ipx)

declare	controlTable(*) byte data(1, 2, 1, 3),
	off$6D72(*) address data(.r$publics.len, .r$interseg.len, .r$extref.len, .r$content.len),
	b6D7A(*) byte data(7Bh, 3Ah, 39h, 7Ch),
	b6D7E(*) byte data(0Ah, 12h, 40h);


declare	r$modhdr MODHDR$T initial(2),
	(dta$p, recSym$p) address;


writeRec: procedure(rec$p) public;
	declare rec$p address,
		len$p address, recLen address,
		i byte, crc byte;
	declare len based len$p address;
	declare ch based len$p byte;

	len$p = rec$p + 1;
	recLen = (len := len + 1) + 3;	
	crc = 0;
	len$p = len$p - 1;
	do i = 2 to recLen;
		crc = crc - ch;
		len$p = len$p + 1;
	end;
	ch = crc;
	call write(objfd, rec$p, recLen, .statusIO);
	call ioErrChk;
end;


sub$6DF1: procedure byte;
	declare b7597 byte;
	if ((b7597 := tokenAttr(b6A56)) and 5Fh) = 0 then
		return 3;
	if (b7597 and 40h) <> 0 then
		return 2;
	if (b6521 := b7597 and 7) = 0 then
		return 3;
	return (b6521 <> activeSeg) and 1;
end;


sub$6E32: procedure public;
	declare b7598 byte;
	declare wrd based dta$p address;
	do b7598 = 0 to 3;
		ii = (b7598 - 1) and 3;
		dta$p = off$6D72(ii);
		if wrd > controlTable(ii) then
			call writeRec(dta$p - 1);

		wrd = controlTable(ii);
		b6526(ii) = 0;
		if b6525 <>  ii then
			b652B(ii) = 0FFh;
	end;
	r$content.offset = w6752 + segSize(r$content.segid := activeSeg);
	r$publics.segid = b6524;
	r$interseg.segid = tokenAttr(b6A56) and 7;
	r$interseg.hilo, r$extref.hilo = b6524;
end;



sub$6EE1: procedure;
	declare w7599 address;

	declare wrd based dta$p address;

	dta$p = off$6D72(b6525 := sub$6DF1);
	if wrd > b6D7A(b6525) or r$content.len + tokenSize(b6A56) > 7Ch then
		call sub$6E32;

	if b652F then
	do;
		b652F = 0;
		r$content.offset = segSize(r$content.segid := activeSeg) + w6752;
	end;
	else if r$content.segid <> activeSeg or (w7599 := r$content.offset + fix6Idx) <> segSize(activeSeg) + w6752
	  or w7599 < r$content.offset then
		call sub$6E32;


	do case b6525;
/* 0 */		do;
			if b652B(0) then
			do;
				b652B(0) = 0;
				r$publics.segid = b6524;
			end;
			else if r$publics.segid <> b6524 then
				call sub$6E32;
		end;
/* 1 */		do;
			if b652B(1) then
			do;
				b652B(1) = 0;
				r$interseg.segid = tokenAttr(b6A56) and 7;
				r$interseg.hilo = b6524;
			end;
			else if r$interseg.hilo <> b6524 or (tokenAttr(b6A56) and 7) <> r$interseg.segid then
				call sub$6E32;
		end;
/* 2 */		do;
			if b652B(2) then
			do;
				b652B(2) = 0;
				r$extref.hilo = b6524;
			end;
			else if r$extref.hilo <> b6524 then
				call sub$6E32;

		end;
/* 4 */		;
	end;
end;


sub$704D: procedure;
	declare b759B byte;

	declare ch based w651F byte;
	do b759B = 1 to tokenSize(b6A56);
		r$content.dta(fix6Idx) = ch;
		fix6Idx = fix6Idx + 1;
		w651F = w651F + 1;
	end;
	r$content.len = r$content.len + tokenSize(b6A56);
end;



sub$709D: procedure;
	r$reloc.len = r$reloc.len + 2;
	r$reloc.dta(fix22Idx) = w6522;
	fix22Idx = fix22Idx + 1;
end;


sub$70C1: procedure;
	r$interseg.len = r$interseg.len + 2;
	r$interseg.dta(fix24Idx) = w6522;
	fix24Idx = fix24Idx + 1;
end;

sub$70E5: procedure;
	r$extref.dta(fix20Idx) = tokenSymId(b6A56);
	r$extref.dta(fix20Idx + 1) = w6522;
	r$extref.len = r$extref.len + 4;
	fix20Idx = fix20Idx + 2;
end;

sub$7131: procedure;
	b6524 = shr(tokenAttr(b6A56) and 18h, 3);
	w6522 = segSize(activeSeg) + w6752;
	if not (b6B23 or b6B24) and (tokenSize(b6A56) = 2 or tokenSize(b6A56) = 3) then
		w6522 = w6522 + 1;
	call sub$6EE1;
	w651F = w68A2;
	call sub$704D;
	do case sub$6DF1;
/* 0 */ 	call sub$709D;
/* 1 */		call sub$70C1;
/* 2 */		call sub$70E5;
/* 3 */		;
	end;
end;


writeExtName: procedure public;
	declare i byte;

	if r$extnames1.len + 9 > 125 then	/* check room for extName */
	do;
		call writeRec(.r$extnames1);	/* flush existing extNam record */
		r$extnames1.type = 18h;
		r$extnames1.len = 0;
		extNamIdx = 0;
	end;
	r$extnames1.len = r$extnames1.len + b6744 + 2;	/* update length for this ref */
	r$extnames1.dta(extNamIdx) = b6744;		/* write len */
	extNamIdx = extNamIdx + 1;
	do i = 0 to b6744;			/* and name */
		r$extnames1.dta(extNamIdx + i) = b6873(i);
	end;

	r$extnames1.dta(extNamIdx + b6744) = 0;	/* and terminating 0 */
	extNamIdx = extNamIdx + b6744 + 1;	/* update where next ref writes */
end;


writeSymbols: procedure(arg1b);	/* arg1b = 0FFH -> PUBLIC else LOCAL */
	declare arg1b byte;
	declare segId byte;

	addSymbol: procedure;
		declare offsetInSeg$p address;
		declare symNam based dta$p(6) byte;
		declare len based recSym$p byte;
		declare symOffset based recSym$p address;
		declare offsetInSeg based offsetInSeg$p address;

		if (symb(1) and 40h) <> 0 then
			return;
		offsetInSeg$p = curTokenSym$p - 2;
		symOffset = offsetInSeg; 
		call unpackToken(curTokenSym$p - 6, (dta$p := (recSym$p := recSym$p + 2) + 1));
		symNam(6) = ' ';	/* trailing space to ensure end */

		len = 0;
		do while symNam(0) <> ' ';	/* find length of name */
			len = len + 1;
			dta$p = dta$p + 1;
		end;
		symNam(0) = 0;			/* terminate name with 0 */
		recSym$p = dta$p + 1;
	end;

	flushSymRec: procedure;
		if (r$publics.len := recSym$p - .r$publics.segid) > 1 then	/* something to write */
			call writeRec(.r$publics);
		r$publics.type = (arg1b and 4) or 12h;	/* PUBLIC or LOCAL */
		r$publics.segid = segId;
		recSym$p = .r$publics.dta;
	end;

	recSym$p = .r$publics.dta;
	do segId = 0 to 4;
		call flushSymRec;
		curTokenSym$p = symTab(1) - 2;
	
		do while (curTokenSym$p := curTokenSym$p + 8) < w6868(1);
			if recSym$p > .r$publics.dta(114) then		/* make sure there is room */
				call flushSymRec;

			if (symb(1) and 7) = segId and symb(0) <> 3Ah and sub$3FA9
			  and not testBit(symb(0), .b6D7E) and (not arg1b or (symb(1) and 20h) <> 0) then
				call addSymbol;
		end;
		call flushSymRec;
	end;
end;

writeModhdr: procedure public;
	declare w based dta$p address;
	declare b based dta$p byte;
	declare i byte;

	call move((r$modhdr.dta(0) := moduleNameLen), .aModulePage, .r$modhdr.dta(1));
	dta$p = .r$modhdr + moduleNameLen + 4;
	w = 0;
	dta$p = dta$p + 1;
	if segSize(1) < w6B41(1) then
		segSize(1) = w6B41(1);
	if segSize(2) < w6B41(2) then
		segSize(2) = w6B41(2);

	do i = 1 to 4;
		dta$p = dta$p + 1;
		b = i;
		dta$p = dta$p + 1;
		w = segSize(i);
		dta$p = dta$p + 2;
		b = alignTypes(i - 1);
	end;
	r$modhdr.len = moduleNameLen + 19;
	call writeRec(.r$modhdr);
end;


writeModend: procedure public;
	declare lenb byte at (.r$eof.len);
	r$modend.modtyp = startDefined;
	r$modend.segid = startSeg;
	r$modend.offset = startOffset;
	call writeRec(.r$modend);
	lenb = 0;
	call writeRec(.r$eof);
end;

ovl8: procedure public;
	w6752 = 0;
	b689A = 1;
	b6A56 = 1;
	if b6B33 then
		;
	else
	do while b6A56 <> 0;
		b6A56 = sub$4646;
		w68A0 = tokStart(b6A56) + tokenSize(b6A56);
		w68A2 = tokStart(b6A56);
		if isSkipping or not b6B34 then
			w68A0 = w68A2;
		if w68A0 > w68A2 then
		do;
			call sub$7131;
			w6752 = w6752 + tokenSize(b6A56);
		end;
		if not(b6B23 or b6B24) then
			b6A56 = 0;
	end;
end;


ovl11: procedure public;
	if w6750 <> 0 then
	do;
		call seek(objfd, 2, .azero, .azero, .statusIO);		/* SEEKABS */
		call writeModhdr;
		call seek(objfd, 4, .azero, .azero, .statusIO);		/* SEEKEND */
	end;
	r$publics.type = 16h;
	r$publics.len = 1;
	r$publics.segid = 0;
	r$publics.dta(0) = 0;
	call writeSymbols(0FFh);	  /* EMIT PUBLICS */
	if ctlDEBUG then
		call writeSymbols(0); /* EMIT LOCALS */
end;

end;
asm4D.pl3
asm4D:
do;
/* to force the code generation this needs a non-standard definition
   of put2Hex
*/
put2Hex: procedure(arg1w, arg2w) external; declare arg1w address, arg2w address; end;

$include(asm4d.ipx)
declare
    aAssemblyComple(*) byte initial(0Dh, 0Ah, 'ASSEMBLY COMPLETE,'),
    aNoErrors(*) byte initial('   NO ERRORS'),
    asc$751E(*) byte initial(' ('),
    asc$7520(*) byte initial('     )'),
    aPublicSymbols(*) byte initial(0Dh, 0Ah, 'PUBLIC SYMBOLS', 0Dh, 0Ah, 0),
    aExternalSymbol(*) byte initial(0Dh, 0Ah, 'EXTERNAL SYMBOLS', 0Dh, 0Ah, 0),
    pad754E address,

    aUserSymbols(*) byte data(0Dh, 0Ah, 'USER SYMBOLS', 0Dh, 0Ah, 0),
    aLocObjLineSour(*) byte data('  LOC  OBJ         LINE        SOURCE STATEMENT', 0Dh, 0Ah, 0Ah, 0),
    wa6DB2(*) address data(.aPublicSymbols, .aExternalSymbol, .aUserSymbols),
    asc$6DB8(*) byte data(0Dh, 0Ah, 0Ah, 0),
    asc$6DBC(*) byte data(0Dh),
    asc$6DBD(*) byte data(0Ah, 0Ah, 0Ah, 0),
    b6DC1(2) byte data(20h, 40h),
    ascLParen(*) byte data(' (', 0),
    ascRParen(*) byte data(')', 0),
    a1234(*) byte data('  1234');    


out2Hex: procedure(arg1b);
    declare arg1b byte;
    call put2Hex(.outch, arg1b);
end;


print2Hex: procedure(arg1b);
    declare arg1b byte;
    call put2Hex(.printChar, arg1b);
end;



printStr: procedure(arg1w) reentrant;
    declare arg1w address;
    declare ch based arg1w byte;

    do while ch <> 0;
        call printChar(ch);
        arg1w = arg1w + 1;
    end;
end;

printNStr: procedure(arg1b, arg2w) reentrant;
    declare arg1b byte, arg2w address;
    declare ch based arg2w byte;

    do while arg1b > 0;
        call printChar(ch);
        arg2w = arg2w + 1;
        arg1b = arg1b - 1;
    end;
end;


printCRLF: procedure reentrant;
    call printChar(0Dh);
    call printChar(0Ah);
end;

declare asc$7752 byte initial(' '),
    asc$7553(*) byte initial('    ', 0);


itoa: procedure(arg1w, arg2w);
    declare (arg1w, arg2w) address;
    declare ch based arg2w byte;

    call move(5, .spaces24 + 19, arg2w);
    arg2w = arg2w + 4;

    do while 1;
        ch = arg1w mod 10 + '0';
        arg2w = arg2w - 1;
        if (arg1w := arg1w /10) = 0 then
            return;
    end;
end;


printDecimal: procedure(arg1w) reentrant public;
    declare arg1w address;
    call itoa(arg1w, .asc$7752);
    call printStr(.asc$7553);
end;

skipToEOP: procedure public;
    do while lineCnt <= ctlPAGELENGTH;
        call outch(0Ah);
        lineCnt = lineCnt + 1;
    end;
end;


newPageHeader: procedure public;    
    call printStr(.asc$6DBD);
    call printStr(.aIsisIi80808085);
    call printDecimal(pageCnt);
    call printCRLF;
    if ctlTITLE then
        call printNStr(titleLen, .ctlTITLESTR);

    call printCRLF;
    call printCRLF;
    if not b68AE(0) then
        call printStr(.aLocObjLineSour);
    pageCnt = pageCnt + 1;
end;


newPage: procedure public;
    if ctlTTY then
        call skipToEOP;
    else
        call outch(0Ch);

    lineCnt = 1;
    if not scanCmdLine then
        call newPageHeader;
end;


sub$6F4D: procedure public;
    if sub$465B then
    do while ctlEJECT > 0;
        call newPage;
        ctlEJECT = ctlEJECT - 1;
    end;
end;




printChar: procedure(arg1b) reentrant;
    declare ch byte, arg1b byte;

    if arg1b = 0Ch then
    do;
        call newPage;
        return;
    end;

    if arg1b = 0Ah then
        if ctlPAGING then
        do;
            if (lineCnt := lineCnt + 1) >= ctlPAGELENGTH - 2 then
            do;
                if ctlTTY then
                    call outch(0Ah);
                if ctlEJECT > 0 then
                    ctlEJECT = ctlEJECT - 1;
                call newPage;
                return;
            end;
        end;

    if arg1b = 0Dh then
        curCol = 0;

    ch = 1;
    if arg1b = 9 then
    do;
        ch = 8 - (curCol and 7);
        arg1b = ' ';
    end;

    do while ch <> 0;
        if curCol < 132 then
        do;
            if arg1b >= ' ' then
                curCol = curCol + 1;
            if curCol > ctlPAGEWIDTH then
            do;
                call printCRLF;
                call printStr(.spaces24);
                curCol = curCol + 1;
            end;
            call outch(arg1b);
        end;
        ch = ch - 1;
    end;
end;

declare b755C(*) byte initial(' CDSME');

sub$8447: procedure public;
    declare b7562 byte,
        w7563 address,
        b7563 byte at(.w7563),
        b7564 byte at(.w7563 + 1),
        b7565 byte;

    sub$718C: procedure(arg1w);
        declare arg1w address;
        declare ch based curTokenSym$p byte;

        curTokenSym$p = curTokenSym$p - 1;
        call arg1w(ch and not b7565);
    end;


    b68AE(0) = 0FFh;
    if not ctlSYMBOLS then
        return;

    b755C(0) = 'A';
    do b7562 = 0 to 2;
        jj = isPhase2Print and ctlSYMBOLS;
        ctlDEBUG = ctlDEBUG or ctlMACRODEBUG;
        curTokenSym$p = symTab(1) - 2;
        call printCRLF;
        call printStr(wa6DB2(b7562));

        do while (curTokenSym$p := curTokenSym$p + 8) < w6868(1);
            w7563 = curTokenSym.w0;
            if b7563 <> 9 then
                if b7563 <> 6 then
                    if sub$3FA9 then
                        if b7562 <> 0 or b7563 <> 3 then
                            if b7562 = 2 or (b7564 and b6DC1(b7562)) <> 0 then
                            do;
                                call unpackToken(curTokenSym$p - 6, .b68AE(1));
                                if jj then
                                do;
                                    if (ctlPAGEWIDTH - curCol) < 11h then
                                        call printCRLF;

                                    call printStr(.b68AE(1));
                                    call printChar(' ');
                                    if b7563 = 3Ah then
                                        call printChar('+');
                                    else if (b7565 := (b7564 and 40h) <> 0) then
                                        call printChar('E');
                                    else
                                        call printChar(b755C(b7564 and 7));

                                    call printChar(' ');
                                    call sub$718C(.print2Hex);
                                    call sub$718C(.print2Hex);
                                    curTokenSym$p = curTokenSym$p + 2;
                                    call printStr(.spaces24 + 20);
                                end;
                            end;
        end;
    end;

    if ctlDEBUG then
        b68AE(0) = 0;

    if jj then
        call printCRLF;
end;

printCmdLine: procedure public;
    declare ch based actRead byte;

    call outch(0Ch);
    call sub$6F4D;
    ch = 0;
    call printStr(.cmdLineBuf);
    call newPageHeader;
end;


outStr: procedure(arg1w) reentrant public;
    declare arg1w address;
    declare ch based arg1w byte;

    do while ch <> 0;
        call outch(ch);
        arg1w = arg1w + 1;
    end;
end;

outNStr: procedure(arg1b, arg2w) reentrant;
    declare arg1b byte, arg2w address,
        ch based arg2w byte;

    do while arg1b > 0;
        call outch(ch);
        arg2w = arg2w + 1;
        arg1b = arg1b - 1;
    end;
end;


sub$721E: procedure byte public;
    return w68A2 < w68A0;
end;



sub$7229: procedure public;
    declare ch based w68A2 byte;
    declare b7568 byte;

    if (b68AB := sub$721E or b68AB) then
    do;
        call out2Hex(high(w68A6));
        call out2Hex(low(w68A6));
    end;
    else
        call outStr(.spaces24 + 20);

    call outch(' ');
    do  b7568 = 1 to 4; 
        if sub$721E and b6B34 then
        do;
            w68A6 = w68A6 + 1;
            call out2Hex(ch);
        end;
        else
            call outStr(.spaces24 + 22);

        w68A2 = w68A2 + 1;
    end;

    call outch(' ');
    if shr(jj := tokenAttr(b6A56), 6) then
        call outch('E');
    else if not b68AB then
        call outch(' ');
    else
        call outch(b755C(jj and 7));
end;


sub$72D8: procedure public;
    if not b689B then
        return;

    call printStr(.ascLParen);    /* " (" */
    call printNStr(4, .b6A57);
    call printStr(.ascRParen);    /* ")" */
    call printCRLF;
    call move(4, .asciiLineNo, .b6A57);
end;



sub$872E: procedure public;
    declare ch based off$9056 byte,
        ch1 based off$6C2C byte;
loop:

   
    w68A0 = (w68A2 := tokStart(b6A56)) + tokenSize(b6A56);
    if isSkipping then
        w68A0 = w68A2;

    call outch(asmErrCode);
    if b$905E = 0FFh then
        call outch('-');
    else
        call outch(' ');

    if not blankAsmErrCode then
    do;
        asmErrCode = ' ';
        b689B = 0FFh;
    end;
    if b6B20$9A77 then
        call outStr(.spaces24 + 9);
    else
        call sub$7229;

    if fileIdx > 0 then
    do;
        call outch(a1234(ii := b6C21 + fileIdx));
        if ii > 0 then    
            call outch(3Dh);
        else
            call outch(20h);
    end;
    else
        call outStr(.spaces24 + 22);

    if b68AD then
    do;
        call outStr(.spaces24 + 20);
        call printCRLF;
    end;
    else
    do;
        b68AD = 0FFh;
        call outNStr(4, .asciiLineNo);
        if b$905B > 1 then
            call outch('+');
        else
            call outch(' ');

        if b$905B > 1 then
        do;
            curCol = 18h;
            ch = 0;
            call printStr(.b$8FD5);
            call printChar(0Ah);
        end;
        else
        do;
            curCol = 18h;
            call printNStr(b6C30, off$6C2E);
            if ch1 <> 0Ah then
                call printChar(0Ah);
        end;
    end;

    if b6B20$9A77 then
    do;
        if ctlPAGING then
            call sub$6F4D;
    end;
    else
    do;
        do while sub$721E;
            call outStr(.spaces24 + 22);
            call sub$7229;
            call printCRLF;
        end;

        if b6A56 > 0 and (b6B23 or b6B24) then
        do;
            call sub$546F;
            goto loop;
        end;
    end;

    call sub$72D8;
end;

asmComplete: procedure public;
    if errCnt > 0 then
        call itoa(errCnt, .aNoErrors);
    call printNStr((errCnt = 1) + 32, .aAssemblyComple);
    if errCnt > 0 then
    do;
        call move(4, .b6A57, .asc$7520);
        call printNStr(8, .asc$751E);
    end;
    call outch(0Dh);
    call outch(0Ah);
end;

ovl9: procedure public;
    if ctlPRINT then
        call closeF(outfd);
    outfd = 0;
    lineCnt = 1;
    call asmComplete;
    call flushout;
end;

ovl10: procedure public;
    declare ch based w68A6 byte;

    call closeF(infd);
    call closeF(macrofd);
    call delete(.aF0Asmac$tmp, .statusIO);
    if ctlOBJECT then
        call closeF(objfd);

    if ctlXREF then
    do;
        w68A6 = physmem - 1;
        ch = '0';
        if aF0Asxref$tmp(0) = ':' then
            ch = aF0Asxref$tmp(2);
    
        call load(.aF0Asxref, 0, 1, 0, .statusIO);
        call ioErrChk;
    end;

    call exit;
end;
end;
asm4E.plm
$SET(ASM4E)
asm4E:
do;
$include(asm4e.ipx)
$include(as4e5d.pac)
end;
as4e5d.pac

declare aExtents(*) byte public initial(' LSTOBJ'),
    aDebug(*) byte public initial('DEBUG');


cmdSkipWhite: procedure public;
    declare cmdch based cmdch$p byte;
    
    do while (cmdch = ' ' or cmdch = TAB) and cmdch$p <> actRead;
        cmdch$p = cmdch$p + 1;
    end;
end;

getDrive: procedure byte public;
    declare cmdch based cmdch$p byte;

    if cmdch = ':' then
    do;
        cmdch$p = cmdch$p + 2;
        return cmdch;
    end;
    else
        do ii = 0 to 4;
        if cmdch <> aDebug(ii) and aDebug(ii) + 20h <> cmdch then
                return '0';
            cmdch$p = cmdch$p + 1;
        end;
    call cmdSkipWhite;
    if cmdch <> ':' then
        return '0';
    cmdch$p = cmdch$p + 2;
    return cmdch;
end;

addExtents: procedure public;
    do ii = 1 to 3;
        lstFile(jj + ii) = aExtents(ii);
        objFile(jj + ii) = aExtents(ii+3);
    end;
end;


getAsmFile: procedure public;
	declare cmdch based cmdch$p byte;

	cmdIsWhite: procedure byte;
		declare cmdch based cmdch$p byte;
		return cmdch = ' ' or cmdch = 9 or cmdch = CR;
	end;

$IF ASM4E
	symTab(0) = .extKeywords;	/* extended key words */
$ELSE
	symTab(0) = .stdKeywords;	/* no extended key words */
$ENDIF
	w686E, w6868(0), symTab(1), w6868(1) = .MEMORY;
	call rescan(1, .statusIO);	/* get the command line */
	call ioErrChk;
	call read(1, .cmdLineBuf, 128, .actRead, .statusIO);
	call ioErrChk;
	actRead = actRead + .cmdLineBuf;	/* convert to pointer */
	scanCmdLine = TRUE;		/* scanning command line */
	call cmdSkipWhite;
	aF0Asxref(2) = getDrive; 	/* tem defaults to current drive */

	do while not cmdIsWhite;
		cmdch$p = cmdch$p + 1;
	end;

	call cmdSkipWhite;
	if cmdch = CR then		/* no name !! */
		call runtimeError(4);

	infd = inOpen(cmdch$p, 1);	/* open file for reading */
	rootfd, includefd = infd;
	ii = TRUE;
	jj = 0;

	do while not cmdIsWhite;	/* copy file name over to the files list */
		files(0).name(jj) = cmdch;
		if ii then		/* and the name for the lst and obj files */
			lstFile(jj), objFile(jj) = cmdch;
		if cmdch = '.' then
		do;
			ii = FALSE;
			call addExtents;	/* add lst and obj file extents */
		end;
		jj = jj + 1;
		cmdch$p = cmdch$p + 1;
	end;
	controls$p = cmdch$p;		/* controls start after file name */
	if ii then			/* no extent in source file */
	do;
		lstFile(jj) = '.';	/* add the . and the extents */
		objFile(jj) = '.';
		call addExtents;
	end;

	files(0).name(jj) = ' ';	/* override current drive for tmp if explict in source file */
	if lstFile(0) = ':' and lstFile(2) <> '0' then
$IF ASM4E
		aF0Asmac$tmp(2),
$ENDIF
		aF0Asxref$tmp(2) = lstFile(2);
end;


resetData: procedure public;	/* extended initialisation */

    call sub3DCE$3DFB;

    b6B33, scanCmdLine, skipping(0), b6B2C, inElse(0), finished, b674A(0), b674A(1), b6742,
$IF ASM4E
    b$905B, b$905C, b$905E,
$ENDIF
    b6857, b6C21 = bZERO;
    b6743, primaryValid, ctlLIST, b6A6F,
$IF ASM4E
    ctlGEN,
$ENDIF
    ctlCOND = bTRUE;
$IF ASM4E
    b$9063, b$9064, macroCondStk(0), macroCondSP, 
$ENDIF
    saveIdx, lookAhead, activeSeg, ifDepth, opSP, opStack(0) = bZERO;
$IF ASM4E
    w$9114,
$ENDIF
    segSize(0), segSize(1), segSize(2), w6B41(0), w6B41(1), w6B41(2), w68A6,
$IF ASM4E
    w$919B,
$ENDIF
    w6750, errCnt = wZERO;
    b6882 = b6882 + 1;
    w6A4E, opType, pageCnt, lineCnt = 1;
    b68AE(0) = 0;
    curChar = ' ';
    do ii = 0 to 11;
        controlSeen(ii) = 0;
    end;
$IF ASM4E
    curMacroBlk = 0FFFFh;
$ENDIF
    if not isPhase1 then
    do;
        if fileIdx <> 0 then
        do;
            call closeF(includefd);
            call ioErrChk;
            includefd = rootfd;
        end;

        fileIdx = bZERO;
        off6C25 = .b68B8;
        off6C2C = off6C25 - 1;
        off6C2E = .b68B8;
        call seek(infd, 2, .azero, .azero, .statusIO);	/* SEEKABS */
        call ioErrChk;
    end;

    w6870 = physmem + 0BFh;
    endOutBuf = .b6A00;
end;

sub$70EE: procedure public;
    r$content.type = 6;
    r$content.len = 3;
    r$publics.type = 22h;
    r$publics.len = 1;
    r$interseg.type = 24h;
    r$interseg.len = 2;
    r$extref.type = 20h;
    r$extref.len = 1;
end;

key4.plm
keywords: do;
declare copyright(*) byte data('(C) 1976,1977,1979,1980 INTEL CORP');

declare extKeywords(*) address public initial(
/*
	4 byte packed keyword
	byte opcode base
	byte offset to next entry or 0 if end
	byte type
	byte special location
*/
	0A528h,	00000h,	00h,	010h,	/* NE */
	063B0h,	00000h,	0CCh,	02Ch,	/* CZ */
	06E60h,	09C40h,	00h,	038h,	/* ENDM */
	0BFB6h,	00000h,	0C0h,	02Dh,	/* RNZ */
	0B354h,	00000h,	0C1h,	025h,	/* POP */
	06EE9h,	00000h,	00h,	01Dh,	/* EQU */
	0C6CDh,	00000h,	08032h,	02Ch,	/* STA */
	0A1A5h,	00000h,	08006h,	029h,	/* MVI */
	0C6CFh,	00000h,	037h,	02Dh,	/* STC */
	0C6CDh,	06158h,	00h,	01B05h,	/* STACK */
	06615h,	00000h,	027h,	02Dh,	/* DAA */
	0988Dh,	0E100h,	0Ah,	026h,	/* LDAX */
	061F6h,	00000h,	0C4h,	02Ch,	/* CNZ */
	053CFh,	00000h,	08888h,	027h,	/* ADC */
	053D0h,	00000h,	080h,	027h,	/* ADD */
	08D9Fh,	00000h,	0A0D2h,	02Ch,	/* JNC */
	00000h,	00000h,	00h,	00h,	/*  */
	00000h,	00000h,	00h,	00h,	/*  */
	00000h,	00000h,	00h,	00h,	/*  */
	06E60h,	00000h,	08800h,	020h,	/* END */
	06A40h,	00000h,	0A003h,	07h,	/* E */
	00000h,	00000h,	00h,	00h,	/*  */
	0AD70h,	00000h,	00h,	013h,	/* OR */
	0AE08h,	00000h,	0D3h,	028h,	/* OUT */
	0A088h,	00000h,	00h,	015h,	/* MOD */
	0AD83h,	00000h,	00h,	01Fh,	/* ORG */
	00000h,	00000h,	00h,	00h,	/*  */
	08F70h,	00000h,	070CAh,	02Ch,	/* JZ */
	068E9h,	076C0h,	00h,	031h,	/* DSEG */
	0C488h,	00000h,	00h,	01Eh,	/* SET */
	08BD8h,	00000h,	010DAh,	02Ch,	/* JC */
	0C521h,	00000h,	030h,	022Dh,	/* SIM */
	06618h,	00000h,	0809h,	025h,	/* DAD */
	0B16Ch,	09600h,	0E9h,	02Dh,	/* PCHL */
	0A4A1h,	06A40h,	00h,	034h,	/* NAME */
	06748h,	00000h,	0F3h,	02Dh,	/* DI */
	053D5h,	00000h,	018C6h,	028h,	/* ADI */
	06630h,	00000h,	00h,	01Ah,	/* DB */
	08DB6h,	00000h,	0C2h,	02Ch,	/* JNZ */
	0AD7Dh,	00000h,	0B0h,	027h,	/* ORA */
	0B3FBh,	00000h,	06h,	07h,	/* PSW */
	0AD85h,	00000h,	0F6h,	028h,	/* ORI */
	0A09Ah,	00000h,	0B840h,	02Bh,	/* MOV */
	08610h,	00000h,	0B800h,	021h,	/* IF */
	00000h,	00000h,	00h,	00h,	/*  */
	09938h,	06400h,	0B02Ah,	02Ch,	/* LHLD */
	09600h,	00000h,	0B005h,	07h,	/* L */
	0C6F6h,	00000h,	090h,	027h,	/* SUB */
	0C634h,	09600h,	0F9h,	02Dh,	/* SPHL */
	0C405h,	00000h,	0DEh,	028h,	/* SBI */
	00000h,	00000h,	00h,	00h,	/*  */
	0BF4Fh,	00000h,	07h,	02Dh,	/* RLC */
	05780h,	00000h,	00h,	07h,	/* B */
	00000h,	00000h,	00h,	00h,	/*  */
	0E614h,	09600h,	0E8E3h,	02Dh,	/* XTHL */
	00000h,	00000h,	00h,	00h,	/*  */
	00000h,	00000h,	00h,	00h,	/*  */
	0B11Bh,	06A40h,	02h,	05h,	/* PAGE */
	00000h,	00000h,	00h,	00h,	/*  */
	00000h,	00000h,	00h,	00h,	/*  */
	0A7C0h,	00000h,	0D800h,	041h,	/* NUL */
	08750h,	00000h,	0DBh,	028h,	/* IN */
	06E60h,	08610h,	0D000h,	023h,	/* ENDIF */
	00000h,	00000h,	00h,	00h,	/*  */
	00000h,	00000h,	00h,	00h,	/*  */
	0C3FEh,	00000h,	098h,	027h,	/* SBB */
	0C6D7h,	09A10h,	00h,	035h,	/* STKLN */
	0BFE0h,	00000h,	0F0h,	02Dh,	/* RP */
	0C078h,	00000h,	0C7h,	02Eh,	/* RST */
	0C4F8h,	06400h,	022h,	02Ch,	/* SHLD */
	09E57h,	0BFB8h,	00h,	036h,	/* MACRO */
	06231h,	00000h,	0ECh,	02Ch,	/* CPE */
	0B436h,	09957h,	0A800h,	032h,	/* PUBLIC */
	0BDA0h,	00000h,	0A817h,	02Dh,	/* RAL */
	06FF5h,	0CBE8h,	0D800h,	039h,	/* EXITM */
	06235h,	00000h,	0FEh,	028h,	/* CPI */
	0BF68h,	00000h,	0F8h,	02Dh,	/* RM */
	00000h,	00000h,	00h,	00h,	/*  */
	00000h,	00000h,	00h,	00h,	/*  */
	0BDA6h,	00000h,	01Fh,	02Dh,	/* RAR */
	0805Bh,	07D00h,	0B800h,	018h,	/* HIGH */
	06400h,	00000h,	0C802h,	07h,	/* D */
	0B447h,	07D00h,	0D0C5h,	025h,	/* PUSH */
	0C6FDh,	00000h,	08D6h,	028h,	/* SUI */
	06220h,	00000h,	0F4h,	02Ch,	/* CP */
	061A8h,	00000h,	0FCh,	02Ch,	/* CM */
	00000h,	00000h,	00h,	00h,	/*  */
	05629h,	076C0h,	00h,	02Fh,	/* ASEG */
	0BFF1h,	00000h,	0E8h,	02Dh,	/* RPE */
	0880Ch,	05DC0h,	0A800h,	03Ch,	/* IRPC */
	0BE48h,	00000h,	0C9h,	02Dh,	/* RET */
	0876Eh,	00000h,	04h,	02Ah,	/* INR */
	0BEE1h,	00000h,	020h,	022Dh,	/* RIM */
	0BFFBh,	00000h,	0E0h,	02Dh,	/* RPO */
	0C6CDh,	0E100h,	02802h,	026h,	/* STAX */
	0988Dh,	00000h,	0983Ah,	02Ch,	/* LDA */
	07000h,	0BF90h,	00h,	033h,	/* EXTRN */
	08774h,	00000h,	09003h,	025h,	/* INX */
	061B5h,	00000h,	0902Fh,	02Dh,	/* CMA */
	0876Ch,	05449h,	01h,	05h,	/* INPAGE */
	09A47h,	05500h,	09800h,	03Fh,	/* LOCAL */
	0E5BDh,	00000h,	08A8h,	027h,	/* XRA */
	080E0h,	00000h,	076h,	02Dh,	/* HLT */
	08DE0h,	00000h,	0F2h,	02Ch,	/* JP */
	09A5Bh,	00000h,	00h,	019h,	/* LOW */
	06D88h,	00000h,	0FBh,	02Dh,	/* EI */
	0623Bh,	00000h,	0E4h,	02Ch,	/* CPO */
	06676h,	00000h,	06805h,	02Ah,	/* DCR */
	0E5C5h,	00000h,	0EEh,	028h,	/* XRI */
	0555Dh,	00000h,	0A0h,	027h,	/* ANA */
	062A9h,	076C0h,	00h,	030h,	/* CSEG */
	08D68h,	00000h,	0FAh,	02Ch,	/* JM */
	05560h,	00000h,	00h,	012h,	/* AND */
	05140h,	00000h,	05807h,	07h,	/* A */
	0BE44h,	0C800h,	00h,	03Eh,	/* REPT */
	08DF1h,	00000h,	0EAh,	02Ch,	/* JPE */
	0880Ch,	00000h,	00h,	03Bh,	/* IRP */
	05565h,	00000h,	0E6h,	028h,	/* ANI */
	09B00h,	00000h,	00h,	0Ch,	/* LT */
	061B7h,	00000h,	03Fh,	02Dh,	/* CMC */
	08DFBh,	00000h,	0E2h,	02Ch,	/* JPO */
	07BC0h,	00000h,	00h,	0Eh,	/* GT */
	06978h,	00000h,	07800h,	01Bh,	/* DW */
	06EC8h,	00000h,	00h,	0Bh,	/* EQ */
	068D8h,	00000h,	04800h,	01Ch,	/* DS */
	07968h,	00000h,	0A000h,	0Fh,	/* GE */
	0A6D4h,	00000h,	00h,	02Dh,	/* NOP */
	09F01h,	0AD95h,	00h,	01C05h,	/* MEMORY */
	05FE0h,	09600h,	0CDh,	02Ch,	/* CALL */
	0BDD8h,	00000h,	0D8h,	02Dh,	/* RC */
	053ADh,	00000h,	080CEh,	028h,	/* ACI */
	0BF9Fh,	00000h,	0D0h,	02Dh,	/* RNC */
	0E36Ch,	076C0h,	0EBh,	02Dh,	/* XCHG */
	061C4h,	00000h,	08B8h,	027h,	/* CMP */
	0667Ch,	00000h,	0Bh,	025h,	/* DCX */
	0C620h,	00000h,	06h,	08h,	/* SP */
	09C40h,	00000h,	06h,	07h,	/* M */
	098A8h,	00000h,	03800h,	0Dh,	/* LE */
	06018h,	00000h,	0DCh,	02Ch,	/* CC */
	07D00h,	00000h,	05004h,	07h,	/* H */
	0C03Fh,	00000h,	0500Fh,	02Dh,	/* RRC */
	0C4F8h,	00000h,	00h,	016h,	/* SHL */
	05DC0h,	00000h,	01h,	07h,	/* C */
	0C170h,	00000h,	0C8h,	02Dh,	/* RZ */
	0E556h,	00000h,	00h,	014h,	/* XOR */
	06E1Fh,	06A40h,	00h,	022h,	/* ELSE */
	0A6D8h,	00000h,	00h,	011h,	/* NOT */
	0C4FEh,	00000h,	00h,	017h,	/* SHR */
	09BB5h,	00000h,	01h,	024h,	/* LXI */
	08D84h,	00000h,	0C3h,	02Ch,	/* JMP */
	061DFh,	00000h,	0D4h,	02Ch	/* CNC */
);


end;
glb.plm
glb: do;
$SET(OVL=0)
$include(glb.ipx)
$include(global.pac)
end;
glb4.plm
glb4: do;
$SET(OVL=4)
$include(glb4.ipx)
$include(global.pac)
end;
glb5.plm
glb5: do;
$SET(OVL=5)
$include(glb5.ipx)
$include(global.pac)
end;
makefile
ISIS=..\..\thames
V4=../../plm80v4/
V3=../../plm80v3/
TOOLS=../../tools/
F0=./

PEXFILE=asm80.pex

OVERLAY=6D4Ch
#
# compilation and assembly rules
.SUFFIXES: .plm .pl3
.plm.obj:
	@SET ISIS_F0=$(F0)
	@SET ISIS_F1=$(V4)
	$(ISIS) :F1:PLM80 $< code
	@if not exist $*.obj exit /b 1

.pl3.obj:
	@SET ISIS_F0=$(F0)
	@SET ISIS_F1=$(V3)
	$(ISIS) :F1:PLM80 $< code
	@find $*.lst "     0 PROGRAM ERROR(S)" >nul || (del $*.obj & exit /b 1)

.plm.ipx:
	@SET ISIS_F0=$(F0)
	@SET ISIS_F1=$(V4)
	$(TOOLS:/=\)ngenpex $(PEXFILE) $<

.pl3.ipx:
	@SET ISIS_F0=$(F0)
	@SET ISIS_F1=$(V4)
	$(TOOLS:/=\)ngenpex $(PEXFILE) $<

.asm.obj:
	@SET ISIS_F0=$(F0)
	@SET ISIS_F1=$(V4)
	$(ISIS) :F1:ASM80 $< 
	@find $*.lst "ASSEMBLY COMPLETE,   NO ERRORS" >nul || (del $*.obj & exit /b 1)

all: asm80 asm80.ov0 asm80.ov1 asm80.ov2 asm80.ov3 asm80.ov4 asm80.ov5

asm80: base.abs asmov0.abs asmov1.abs asmov2.abs asmov3.abs keywrd.abs 
	@SET ISIS_F0=$(F0)
	@SET ISIS_F1=$(V4)
	$(ISIS) :F1:link base.abs,publics(asmov0.abs,asmov1.abs,asmov2.abs), "&" < <<
asmov3.abs,keywrd.abs to $*.rel &
map print($*.lin)
<<NOKEEP
	$(ISIS) :F1:locate $*.rel to $@ SYMBOLS MAP PUBLICS print($*.map) "&" < <<
STACKSIZE(0) PURGE NAME(ASM80)
exit
<<NOKEEP
	del $*.rel
	@find $*.lin "LINK MAP" >nul || (del $@ & exit /b 1)
	@(find $*.map "UNSATISFIED EXTERNAL" >nul && (del $@ & exit /b 1)) || exit /b 0)



asm80.ov0: asmov0.abs 
	@SET ISIS_F0=$(F0)
	@SET ISIS_F1=$(V4)
	$(ISIS) :F1:locate $** to $@ SYMBOLS MAP PUBLICS print($*.mo0) "&" < <<
STACKSIZE(0) PURGE NAME(A80O0)
<<NOKEEP
	@(find $*.mo0 "UNSATISFIED EXTERNAL" >nul && (del $@ & exit /b 1)) || exit /b 0)

asm80.ov1: asmov1.abs 
	@SET ISIS_F0=$(F0)
	@SET ISIS_F1=$(V4)
	$(ISIS) :F1:locate $** to $@ SYMBOLS MAP PUBLICS print($*.mo1) "&" < <<
STACKSIZE(0) PURGE NAME(A80O1)
<<NOKEEP	
	@(find $*.mo1 "UNSATISFIED EXTERNAL" >nul && (del $@ & exit /b 1)) || exit /b 0)


asm80.ov2: asmov2.abs 
	@SET ISIS_F0=$(F0)
	@SET ISIS_F1=$(V4)
	$(ISIS) :F1:locate $** to $@ SYMBOLS MAP PUBLICS print($*.mo2) "&" < <<
STACKSIZE(0) PURGE NAME(A80O2)
<<NOKEEP	
	@(find $*.mo2 "UNSATISFIED EXTERNAL" >nul && (del $@ & exit /b 1)) || exit /b 0)

asm80.ov3: asmov3.abs
	@SET ISIS_F0=$(F0)
	@SET ISIS_F1=$(V4)
	$(ISIS) :F1:locate $** to $@ SYMBOLS MAP PUBLICS print($*.mo3) "&" < <<
STACKSIZE(0) PURGE NAME(A80O3)
<<NOKEEP
	@(find $*.mo3 "UNSATISFIED EXTERNAL" >nul && (del $@ & exit /b 1)) || exit /b 0)




OBJS1 =	glb.obj asm801.obj asm82.obj asm83.obj asm46.obj asm85.obj\
	asm851.obj asm86.obj asm861.obj asm87.obj close.obj delete.obj error.obj\
       	exit.obj load.obj open.obj read.obj rescan.obj seek.obj write.obj

base.abs: $(OBJS1)
	@SET ISIS_F0=$(F0)
	@SET ISIS_F1=$(V4)
	$(ISIS) :F1:link "&" < <<
$(OBJS1: =, & 
),:f1:plm80.lib to $*.rel print($*.lin)
<<NOKEEP
	$(ISIS) :F1:locate $*.rel to $@ SYMBOLS MAP PUBLICS STACKSIZE(120) print($*.map)
	del $*.rel
	@find $*.lin "UNRESOLVED EXTERNAL" >nul || (del $@ & exit /b 1)


keywrd.abs: keywrd.obj memory.obj
	@SET ISIS_F0=$(F0)
	@SET ISIS_F1=$(V4)
	$(ISIS) :F1:link $(**: =,) to $*.rel map print($*.lin)
	$(ISIS) :F1:locate $*.rel to $@ SYMBOLS MAP PUBLICS CODE(075A2h) STACKSIZE(0) print($*.map)
	del $*.rel
	@find $*.lin "LINK MAP" >nul || (del $@ & exit /b 1)
	@(find $*.map "UNSATISFIED EXTERNAL" >nul && (del $@ & exit /b 1)) || exit /b 0)

asmov0.abs: base.abs cprite.obj asmov0.obj
	@SET ISIS_F0=$(F0)
	@SET ISIS_F1=$(V4)
	$(ISIS) :F1:link publics(base.abs),cprite.obj,asmov0.obj to $*.rel map print($*.la0)
	$(ISIS) :F1:locate $*.rel to $@ SYMBOLS MAP PUBLICS CODE($(OVERLAY)) STACKSIZE(0) print($*.ma0)
	del $*.rel
	@find $*.la0 "LINK MAP" >nul || (del $@ & exit /b 1)


asmov1.abs: base.abs cprite.obj asmov1.obj
	@SET ISIS_F0=$(F0)
	@SET ISIS_F1=$(V4)
	$(ISIS) :F1:link publics(base.abs),cprite.obj,asmov1.obj,:F1:plm80.lib "&" < <<
to $*.rel map print($*.la1)
<<NOKEEP
	$(ISIS) :F1:locate $*.rel to $@ SYMBOLS MAP PUBLICS CODE($(OVERLAY)) STACKSIZE(0) print($*.ma1)
	del $*.rel
	@find $*.la1 "LINK MAP" >nul || (del $@ & exit /b 1)



asmov2.abs: base.abs cprite.obj asmov2.obj
	@SET ISIS_F0=$(F0)
	@SET ISIS_F1=$(V4)
	$(ISIS) :F1:link publics(base.abs),cprite.obj,asmov2.obj to $*.rel map print($*.la2)
	$(ISIS) :F1:locate $*.rel to $@ SYMBOLS MAP PUBLICS CODE($(OVERLAY)) STACKSIZE(0) print($*.ma2)
	del $*.rel
	@find $*.la2 "LINK MAP" >nul || (del $@ & exit /b 1)


asmov3.abs: base.abs cprite.obj asmov3.obj keywrd.abs
	@SET ISIS_F0=$(F0)
	@SET ISIS_F1=$(V4)
	$(ISIS) :F1:link publics(base.abs),cprite.obj,asmov3.obj,publics(keywrd.abs) "&" < <<
to $*.rel map print($*.la3)
<<NOKEEP
	$(ISIS) :F1:locate $*.rel to $@ SYMBOLS MAP PUBLICS CODE($(OVERLAY)) STACKSIZE(0) print($*.ma3)
	del $*.rel
	@find $*.la3 "LINK MAP" >nul || (del $@ & exit /b 1)



clean:
	del *.obj *lst *.map *.abs *.rel *.lin *.*~ *.la? *.ma? *.lo? *.mo? *~ *.ipx *.*~ *.lst.prn

vclean: clean
	del asm80 asm80.ov?

uclean: vclean
	del ??????.* makefile

verify: asm80 asm80.ov0 asm80.ov1 asm80.ov2 asm80.ov3 asm80.ov4 asm80.ov5
	for %i in ($**) do $(TOOLS:/=\)diffbin %i $(V4)\%i

compare: asm80 asm80.ov0 asm80.ov1 asm80.ov2 asm80.ov3 asm80.ov4 asm80.ov5
	for %i in ($**) do fc /b %i $(V4)\%i


OBJS4 =	glb4.obj asm41.obj asm42.obj asm87.obj asm43.obj asm44.obj asm45.obj asm46.obj\
	asm47.obj asm48.obj asm49.obj asm4A.obj asm4B.obj asm4C.obj asm4D.obj asm4E.obj\
	close.obj delete.obj error.obj exit.obj\
	load.obj open.obj read.obj rescan.obj\
	seek.obj write.obj

asm80.ov4: $(OBJS4) key4.obj
	@SET ISIS_F0=$(F0)
	@SET ISIS_F1=$(V4)
	$(ISIS) :F1:link "&" < <<
$(OBJS4: =, & 
),:f1:plm80.lib,key4.obj to asmov4.rel map print(asmov4.lin)
<<NOKEEP
	$(ISIS) :F1:locate asmov4.rel to $@ SYMBOLS NAME(A80O4) PURGE "&" < <<
MAP PUBLICS code(3780h) STACKSIZE(144) print(asmov4.map)
exit
<<NOKEEP
	@find asmov4.lin "LINK MAP" >nul || (del $@ & exit /b 1)
	@(find asmov4.map "UNSATISFIED EXTERNAL" >nul && (del $@ & exit /b 1)) || exit /b 0)



OBJS5 =	glb5.obj asm51.obj asm52.obj asm87.obj asm82.obj asm83.obj asm55.obj asm46.obj\
	asm57.obj asm86.obj asm861.obj asmov0.obj asmov2.obj asmov1.obj asm5D.obj\
	close.obj delete.obj error.obj exit.obj\
	load.obj open.obj read.obj rescan.obj\
	seek.obj write.obj

asm80.ov5: $(OBJS5) keywrd.obj
	@SET ISIS_F0=$(F0)
	@SET ISIS_F1=$(V4)
	$(ISIS) :F1:link "&" < <<
$(OBJS5: =, &
),:f1:plm80.lib,keywrd.obj to asmov5.rel map print(asmov5.lin)
<<NOKEEP
	$(ISIS) :F1:locate asmov5.rel to $@ SYMBOLS NAME(A80O5) PURGE "&" < <<
MAP PUBLICS code(3780h) STACKSIZE(144) print(asmov5.map)
exit
<<NOKEEP
	@find asmov5.lin "LINK MAP" >nul || (del $@ & exit /b 1)
	@(find asmov5.map "UNSATISFIED EXTERNAL" >nul && (del $@ & exit /b 1)) || exit /b 0)

# pex file dependencies
$(OBJS1:.obj=.ipx): $(PEXFILE)
$(OBJS4:.obj=.ipx): $(PEXFILE)
$(OBJS5:.obj=.ipx): $(PEXFILE)
asmov0.ipx asmov1.ipx asmov2.ipx asmov3.ipx: $(PEXFILE)

close.plm
close: DO;
$include(close.ipx)

close: PROCEDURE(conn, status$p) public;
    declare (conn, status$p) address;
    CALL ISIS(ICLOSE, .conn);
end close;
end;
delete.plm
delete: DO;
$include(delete.ipx)

delete: procedure (path$p, status$p) public;
    declare (path$p, status$p) address;
    call ISIS(IDELETE, .path$p);
end delete;
end;
error.plm
error: DO;
$include(error.ipx)

error: procedure (error$num) public;
    declare (error$num) address;
    declare status address;
    status = .status;
    call ISIS(IERROR, .error$num);
end error;
end;
exit.plm
exit: DO;
$include(exit.ipx)

exit: procedure public;
    declare tmp address;
    tmp = .tmp;
    call ISIS(IEXIT, .tmp);
end exit;
end;
load.plm
load: DO;
$include(load.ipx)

load: procedure (path$p, load$offset, switch, entry$p, status$p) public;
    declare (path$p, load$offset, switch, entry$p, status$p) address;
    CALL ISIS(ILOAD, .path$p);
end load;
end;
open.plm
open: DO;
$include(open.ipx)

open: procedure (conn$p, path$p, access, echo, status$p) public;
    declare (conn$p, path$p, access, echo, status$p) address;
    CALL ISIS(IOPEN, .conn$p);
end open;
end;
read.plm
read: DO;
$include(read.ipx)

read: procedure (conn, buff$p, count, actual$p, status$p) public;
    declare (conn, buff$p, count, actual$p, status$p) address;
    call ISIS(IREAD, .conn);
end read;
end;
rescan.plm
rescan: DO;
$include(rescan.ipx)
rescan: procedure (conn, status$p) public;
    declare (conn, status$p) address;
    call ISIS(IRESCAN, .conn);
end rescan;
end;
seek.plm
seek: DO;
$include(seek.ipx)

seek: procedure (conn, mode, block$p, byte$p, status$p) public;
    declare (conn, mode, block$p, byte$p, status$p) address;
    CALL ISIS(ISEEK, .conn);
end seek;
end;
write.plm
write: DO;
$include(write.ipx)

write: procedure (conn, buff$p, count, status$p) public;
    declare (conn, buff$p, count, status$p) address;
    call ISIS(IWRITE, .conn);
end write;
end;
asm87.asm
	public pckTkn
	public ISIS
	extrn toksiz
	extrn tokst;

	aseg
ISIS	equ	40h	; definition of ISIS entry, here to avoid another asm file

; pckTkn - packs the token pointed by tokst, with length toksiz into 4 bytes
; packed version replaces original and toksize set to 4 bytes

	CSEG
pckTkn: lhld	tokst	; pointer to the token to pack
	xchg
	lxi	h, toksiz
	mov	c, m	; unpacked length
	mvi	m, 4	; new packed length is 4 bytes
	call pack3	; pack 3 chars into hl
	push	h
	call pack3
	pop	b
	xchg		; put the packed data into the first 4 bytes
	dcx	h
	dcx	h
	dcx	h
	mov	m, d
	dcx	h
	mov	m, e
	dcx	h
	mov	m, b
	dcx	h
	mov	m, c
	ret
pack3:
	lxi	h, 0	; get 3 chars packed into 2 bytes
	mvi	b, 3

L6291:
	push	d	; pointer to next char
	mov	d, h	; hl x 40
	mov	e, l
	dad	h
	dad	h
	dad	d
	dad	h
	dad	h
	dad	h
	pop	d	
	call pack1	; add in next char
	add	l
	mov	l, a
	mvi	a, 0
	adc	h
	mov	h, a
	dcr	b	; get the 3 chars
	jnz	L6291
	ret

pack1:	ldax	d		; pick up next character
	inx	d		; advance for next time
	dcr	c		; check it is valid
	jm	L62B7
	sui	2Fh		; /012345678  (0-9)
				; 9?@ABCDEFG  (10-19)
				; HIJKLMNOPQ  (20-29)
				; RSTUVWXYZ[  (30-39)
	cpi	10h		; digit so return
	rc
	sui	5		; exclude : ; < = >
	ret

L62B7:
	sub	a		; 0 no char
	ret

	end
cprite.asm
	CSEG
cprite:	db '(C) 1976,1977,1979,1980 INTEL CORP'
	end;
memory.asm
	public EDATA
	DSEG
EDATA	equ	$
	end

