asm80.pex
/* assembler routines & linkage */
Isis            P(B syscall,A param$p)
PckTkn          P
EDATA		B

packToken       'PckTkn'
tokenSize       'toksiz'
tokStart        'tokst'


lit             'literally'
TRUE            '0FFh'
FALSE           '0'
CR              '0Dh'
FF              '0Ch'
LF              '0Ah'
TAB             '9'
MACROEOB	'0FEh'

# primiative types
bool             'byte'
word             'address'
pointer          'address'

/* character classes */
CC$BAD          '0'
CC$WS           '1'
CC$SEMI         '2'
CC$COLON        '3'
CC$CR           '4'
CC$PUNCT        '5'
CC$DOLLAR       '6'
CC$QUOTE        '7'
CC$DIGIT        '8'
CC$LET          '9'
CC$ESC          '11'

TT$ID           '0'
TT$NUM          '2'
TT$STR          '4'

/* Isis syscall ids */
IOPEN           '0'
ICLOSE          '1'
IDELETE         '2'
IREAD           '3'
IWRITE          '4'
ISEEK           '5'
ILOAD           '6'
IEXIT           '9'
IRESCAN         '11'
IERROR          '12'
/* Seek operations */
SEEKTELL        '0'
SEEKBACK        '1'
SEEKABS         '2'
SEEKFWD         '3'
SEEKEND         '4'
/* segments */
SEG$ABS         '0'
SEG$CODE        '1'
SEG$DATA        '2'
SEG$STACK       '3'
SEG$MEMORY      '4'

/* relocatable record types */
OMF$MODHDR      '2'
OMF$MODEND      '4'
OMF$CONTENT     '6'
OMF$LINENO      '8'
OMF$EOF	        '0EH'
OMF$ANCESTOR    '10H'
OMF$LOCALS      '12H'
OMF$PUBLICS     '16H'
OMF$EXTNAMES    '18H'
OMF$EXTREF      '20H'
OMF$RELOC       '22H'
OMF$INTERSEG    '24H'
OMF$LIBLOCS     '26H'
OMF$LIBNAMES    '28H'
OMF$LIBDICT     '2AH'
OMF$LIBHDR      '2CH'
OMF$COMDEF      '2EH'

/* leftOp types */
T$CR            '1'
T$LPAREN        '2'
T$RPAREN        '3'
T$STAR          '4'
T$PLUS          '5'
T$COMMA         '6'
T$MINUS         '7'
T$UPLUS         '8'
T$SLASH         '9'
T$UMINUS        '0Ah'
O$NONE          '0'
O$LABEL         '3'
O$ID            '9'
O$STRING        '0Ah'
O$DATA          '0Bh'
O$NUMBER        '0Ch'
K$SPECIAL       '5'
K$REGNAME       '7'
K$SP            '8'
K$EQ            '0Bh'
K$LT            '0Ch'
K$LE            '0Dh'
K$GT            '0Eh'
K$GE            '0Fh'
K$NE            '10h'
K$NOT           '11h'
K$AND           '12h'
K$OR            '13h'
K$XOR           '14h'
K$MOD           '15h'
K$SHL           '16h'
K$SHR           '17h'
K$HIGH          '18h'
K$LOW           '19h'
K$DB            '1Ah'
K$DW            '1Bh'
K$DS            '1Ch'
K$EQU           '1Dh'
K$SET           '1Eh'
K$ORG           '1Fh'
K$END           '20h'
K$IF            '21h'
K$ELSE          '22h'
K$ENDIF         '23h'
K$LXI           '24h'
K$REG16         '25h'
K$LDSTAX        '26h'
K$ARITH         '27h'
K$IMM8          '28h'
K$MVI           '29h'
K$INRDCR        '2Ah'
K$MOV           '2Bh'
K$IMM16         '2Ch'
K$SINGLE        '2Dh'
K$RST           '2Eh'
K$ASEG          '2Fh'
K$CSEG          '30h'
K$DSEG          '31h'
K$PUBLIC        '32h'
K$EXTRN         '33h'
K$NAME          '34h'
K$STKLN         '35h'
K$MACRO         '36h'
O$37            '37h'
K$ENDM          '38h'
K$EXITM         '39h'
O$3A            '3Ah'
K$IRP           '3Bh'
K$IRPC          '3Ch'
O$3D            '3Dh'
K$REPT          '3Eh'
K$LOCAL         '3Fh'
K$NUL           '41h'
O$64            '64h'

/* type flags */
UF$SEGMASK	'7'
UF$LOW          '8'
UF$HIGH         '10h'
UF$BOTH         '18h'
UF$PUBLIC       '20h'
UF$EXTRN        '40h'

/* user defined types */
TOKENSYM$T      'structure(tok(2) address, val address, type byte, flags byte)'
FILE$T          'structure(name(15) byte, blk address, byt address, b19 byte)'
MACRO$T1	'macroCondSP byte, ifDepth byte, mtype byte, b3 byte,w4 address'
MACRO$T2        'buf$p address, blk address, w10 address, w12 address, w14 address'
MACRO$T         'structure(MACRO$T1,MACRO$T2)'
CONTENT$T       'structure(type byte, len address, segid byte, offset address, dta(122) byte, crc byte)'
EOF$T           'structure(type byte, len address, crc byte)'
EXTNAMES$T	'structure(type byte, len address, dta(125) byte)'
EXTREF$T        'structure(type byte, len address, hilo byte, dta(30) address, crc byte)'
INTERSEG$T      'structure(type byte, len address, segid byte, hilo byte, dta(29) address, crc byte)'
MODEND$T        'structure(type byte, len address, modtyp byte, segid byte, offset address, crc byte)'
MODHDR$T	'structure(type byte, len address, dta(26) byte)'
PUBLICS$T       'structure(type byte, len address, segid byte, dta(124) byte, crc byte)'
RELOC$T         'structure(type byte, len address, hilo byte, dta(62) address)'
KEYWORD$T	'structure(tok(2) address, base byte, delta byte, type byte, flags byte)'

/* common based variables */
curTokenSym     "TOKENSYM$T"..curTokenSym$p

$file(asm41.plm)
b$3782          B
b$3783          B
w$3780          A
IsGT            PB
IsLT            PB
Sub3D34        P(B c)
Sub3D55        P(B c)

$file(asm41.plm,asm51.plm,asm801.plm)
aBadSyntax      BS
aCo             BS
aCommand        BS
aEof            BS
aError          BS
aError$0        BS
aFile           BS
asmHeader BS
aMemory         BS
aModulePage     BS
ascCRLF         BS
aStack          BS
aTable          BS
bTRUE           B
bZERO           B
errStrs         AS
errStrsLen      BS
signonMsg       BS
spaces15        BS
spaces2         BS
spaces24        BS
spaces4         BS
spaces5         BS
spaces6         BS
BlankAsmErrCode PB
BlankMorPAsmErrCode PB
ChkGenObj       PB
CloseF          P(A conn)
Flushout        P
GetNibble       P(A bp,B idx)B
InitialControls P
InOpen          P(A path$p,A access)A
IoErrChk        P
IoError         P("pointer" s)
IsComma         PB
IsCR            PB
IsPhase1        PB
IsPhase2Print   PB
IsRParen        PB
IsSpace         PB
IsTab           PB
IsWhite         PB
Nibble2Ascii    P(B n)B
GetCmdCh        PB
Outch           P(B c)
OutStrN         P(A s,B n)
Physmem         PA
ParseControlLines P
Put2Hex         P(A pfunc,B val)
RuntimeError    P(B errCode)
Skip2EOL        P
SourceError     P(B errCh)
InitLine        P
WrConsole       P(A buf$p,A count)


$file(asm43.pl3)
ReadM           P(A blk)
Sub3FA9        PB
Sub40B9        P
WriteM          P

$file(asm43.pl3,asm82.pl3)
Skip2NextLine   P
SkipWhite       P
SkipWhite$2     P
TokeniseLine        P

/* $file(asm44.plm) */

$file(asm44.plm,asm83.plm)
b4181           BS
GetPrec         P(B leftOp)B
IsReg        P(B leftOp)"bool"
Sub4274        P
Sub4291        P
SetExpectOperands        P
GetNumVal        PA
MkCode        P(B arg1b)
NxtTokI        PB
ShowLine        PB
EmitXref        P(B arg1b,A arg2w)
SwapAccBytes    P
TestBit         P(B bitIdx,"pointer" bitVector)"bool"

/* $file(asm45.plm) */

$file(asm45.plm,asm55.plm,asm851.plm)
IsSkipping      PB
StrUCequ        P("pointer" s,"pointer" t)"bool"
FinishLine    P
Sub546F        P

$file(asm46.pl3)
needToOpenFile   "bool"
includeOnCmdLine "bool"
missingEnd      "bool"
lineChCnt           B
fileIdx         B
files           "FILE$T"S
srcfd       A
endInBuf$p         A
inCh$p         "pointer"
startLine$p         A
rootfd          A
CloseSrc          P
ReadF           P(B arg1b,A arg2w,A arg3w)
ReadSrc           P(A arg1w)
SeekI           P(B arg1b)
GetSrcCh        PB
OpenSrc        P

/* $file(asm47.pl3) */

$file(asm47.pl3,asm85.pl3)
Cond2Acc        P(B arg1b)
ChkSegAlignment        P(B arg1b)
UpdateHiLo        P(B hilo)
DoPass        P

$file(asm48.pl3)
Sub5CAD        P(A arg1w,B type)
Sub65D9        P

$file(asm48.pl3,asm86.pl3)
labelUse          B
GetCh           PB
GetChClass      PB
Lookup          P(B tableId)B
Sub5819$5CE8        P(A arg1w,B arg2b)
UnpackToken     P("pointer" src,"pointer" dst)

/* $file(asm49.pl3) */

$file(asm49.pl3,asm861.plm)
BalanceError    P
CollectByte     P(B arg1b)
CommandError    P
DoubleDefError  P
ExpressionError P
FileError       P
GetId           P(B arg1b)
Atoi          P
GetStr          P
HaveTokens      PB
IllegalCharError P
LocationError   P
MultipleDefError P
NameError       P
NestIF         P(B arg1b)
NestingError    P
OPcodeOperandError P
OperandError    P
PhaseError      P
PopToken        P
PushToken       P(B arg1b)
StackError      P
SyntaxError     P
UndefinedSymbolError P
UnnestIF        P(B arg1b)
ValueError      P

/* $file(asm4A.pl3) */
$file(asm4A.pl3,asmov0.pl3)
ParseControls   P

$file(asm4B.pl3)
b9C77          B
Sub72A4        P(B arg1b)
Sub7327        P
Sub73AD        P
Sub7517        P
Sub753E        P
Sub75FF        P
Sub76CE        P
Sub770B        P
Sub7844        P
Sub787A        P
Sub78CE        P

/* $file(asm4C.pl3) */

$file(asm4C.pl3,asmov2.pl3)
Ovl11           P
Ovl8            P
ReinitFixupRecs        P
WriteExtName    P
WriteModend     P
WriteModhdr     P
WriteRec        P(A rec$p)

/* $file(asm4D.pl3) */

$file(asm4D.pl3,asmov1.pl3)
AsmComplete     P
NewPage         P
NewPageHeader   P
OutStr          P(A arg1w)
PrintLine            P
Ovl9            P
Ovl10           P
PrintCmdLine    P
PrintDecimal    P(A arg1w)
SkipToEOP       P
DoEject        P
Sub7041$8447    P
MoreBytes        PB
Sub7229        P
Sub72D8        P

/* $file(asm4E.plm) */

$file(asm4E.plm,asm5D.plm,asmov3.plm)
aDebug          BS
aExtents        BS
AddExtents      P
CmdSkipWhite    P
GetAsmFile      P
GetDrive        PB
ResetData       P
InitRecTypes        P



/* $file(asm51.plm) */

/* $file(asm52.plm) */

/* $file(asm55.plm) */

/* $file(asm57.pl3) */
$file(asm57.pl3,asm85.pl3)
HandleOp        P
ParseLine        P

/* $file(asm5D.plm) */


$file(asm801.plm)
ovlFile         BS
OvlMgr          P(B ovl)

/* $file(asm82.pl3) */
/* $file(asm83.plm) */
/* $file(asm85.pl3) */
/* $file(asm851.plm) */

$file(asm86.pl3)
ChkLF           P
InsertSym       P

/* $file(asm861.plm) */

/* $file(asmov0.pl3) */

/* $file(asmov1.pl3) */

/* $file(asmov2.pl3) */

/* $file(asmov3.plm) */

$file(close.plm)
Close           P(A conn,A status$p)

$file(Delete.plm)
Delete          P(A path$p,A status$p)

$file(Error.plm)
Error           P(A Error$num)

$file(Exit.plm)
Exit            P

/* these share a common file with build controlled by $IF statements */
$file(glb.plm,glb4.plm,glb5.plm)
accum1          A
accum1$hb       B
accum1$lb       B
accum2          A
accum2$hb       B
accum2$lb       B
activeSeg       B
actRead         "pointer"
asmax$ref    BS
asxref       BS
asxref$tmp   BS
alignTypes      BS
argNestCnt      B		/* glb4 */
asciiLineNo     BS
asmErrCode      B
azero           A
fixupSeg        B
curFixupHiLoSegId B
curFixupType    B
fixIdxs         BS
initFixupReq    "bool"S
firstContent    "bool"
inComment           "bool"
noOpsYet           "bool"
nameLen         B
inPublic           B
inExtrn           B
segHasData           BS
badExtrn           B
acc1Flags           B
acc2Flags           B
hasVarRef           B
acc1ValType           B
acc2ValType           B
gotLabel           B
name         BS
savName           BS
lhsUserSymbol           "bool"
rhsUserSymbol  "bool"
b6881           "bool"
passCnt           B
b6883           "bool"
b6884           "bool"
needsAbsValue           "bool"
b6897           "bool"
tokI           B
errorOnLine    "bool"
atStartLine           B
showAddr        "bool"
lineNumberEmitted           "bool"
b68AE           "bool"
inBuf           BS
b6A00           B
spIdx           B
b6A57           BS
ctlLISTChanged           "bool"
b6A71           B
isControlLine      B		
inDB           B
inDW           B
inExpression           "bool"
b6B28           B
effectiveToken           B
leftOp              B
b6B2C           "bool"
b6B2D           B
inNestedParen           B
expectingOperands     "bool"
expectingOpcode       "bool"
b6B32           "bool"
b6B33           "bool"
b6B34           "bool"
inParen           "bool"
b6B36           "bool"
b6BD9           "bool"
b6BDA           "bool"
jj           B
macroLine          BS		/* glb4 */
b9058          "bool"		/* glb4 */
b9059          "bool"		/* glb4 */
b905A          B		/* glb4 */
expandingMacro B		/* glb4 */
b905C          B		/* glb4 */
b905D          "bool"		/* glb4 */
b905E          B		/* glb4 */
b9060          "bool"		/* glb4 */
b9061          "bool"		/* glb4 */
b9062          B		/* glb4 */
macroDepth          B		/* glb4 */
b9064          B		/* glb4 */
b9065          B		/* glb4 */
b9066          B		/* glb4 */
b91A1          B		/* glb4 */
b91A2          B		/* glb4 */
b91A3          B		/* glb4 */
b91A4          BS		/* glb4 */
bp6A4E          BS
accFixFlags          BS
cmdch$p         "pointer"
cmdLineBuf      BS
controlId       B
controls        BS
controlSeen     "bool"S
controls$p      A
ctlCOND         "bool"
ctlDEBUG        "bool"
ctlEJECT        B
ctlGEN          "bool"
ctlLIST         "bool"
ctlMACRODEBUG   "bool"
ctlMACROFILE    "bool"
ctlMOD85        "bool"
ctlOBJECT       "bool"
ctlPAGELENGTH   B
ctlPAGEWIDTH    B
ctlPAGING       "bool"
ctlPRINT        "bool"
ctlSYMBOLS      "bool"
ctlTITLE        "bool"
ctlTITLESTR     BS
ctlTTY          "bool"
ctlXREF         "bool"
curChar         B
curCol          B
curFileName$p   A
curMacroBlk     A		/* glb4 */
curTokenSym$p   "pointer"
tokPtr          "pointer"
endLineBuf      A
endOutBuf       A
endSymTab       AS
errCnt          A
extNamIdx       B
finished        "bool"
fix20Idx        B
fix22Idx        B
fix24Idx        B
fix6Idx         B
has16bitOperand B
ifDepth         B
ii              B
inElse          "bool"S
infd            A
kk              B
lineBuf         BS
pageLineCnt         A
lookAhead       B
lstFile         BS
macroBuf        BS		/* glb4 */
macroCondSP     B		/* glb4 */
macroCondStk    BS		/* glb4 */
MacroDebugOrGen B		/* glb & glb5 */
macrofd         A
macroStk        "MACRO$T"S	/* glb4 */
maxMacroBlk     A		/* glb4 */
maxSegSize      AS
byteAt          BS		/* glb4 */
moduleNameLen   B
nxtMacroBlk     A		/* glb4 */
objfd           A
objFile         BS
macro$p         "pointer"	/* glb4 */
openStatus      A
opSP            B
opStack         BS
rightOp          B
outbuf          BS
outfd           A
out$p           "pointer"
pageCnt         A
phase           B
primaryValid    B
r$content       "CONTENT$T"
reget           B
r$eof           "EOF$T"
r$extnames1     "EXTNAMES$T"
r$extnames2     "EXTNAMES$T"
r$extref        "EXTREF$T"
r$interseg      "INTERSEG$T"
r$modend        "MODEND$T"
r$publics       "PUBLICS$T"
r$reloc         "RELOC$T"
saveIdx         B
saveStack       BS
scanCmdLine     B
segSize         AS
skipping        "bool"S
startDefined    B
startOffset     A
startSeg        B
statusIO        A
symTab          AS
titleLen        B
tmac$b3         B		/* glb4 */
tmac$blk        A		/* glb4 */
tmac$buf$p      "pointer"	/* glb4 */
tmac$ifDepth    B		/* glb4 */
tmac$macroCondSP B		/* glb4 */
tmac$mtype      B		/* glb4 */
tmac$w10        A		/* glb4 */
tmac$w12        A		/* glb4 */
tmac$w14        A		/* glb4 */
tmac$w4         A		/* glb4 */
tokBuf          BS
tokBufIdx       B
tokBufLen       B
tokenAttr       BS
tokenIdx         B
tokStr          BS
tokenSym        AS
tokenSymId      AS
tokenType       BS
toksiz          BS
tokst           AS
tokType         B
contentBytePtr  "pointer"
fixOffset           A
externId           A
itemOffset           A
acc1NumVal           A
acc2NumVal           A
symHighMark           A
w6870           "pointer"
endItem           A
startItem           A
effectiveAddr           A
sizeInBuf           A
srcLineCnt           A
tokNumVal           A
w6BCE           A
w6BE0          "pointer" 
controlFileType           A
endMacroLine   BS		/* glb4 */
w9068          "pointer"	/* glb4 */
w906A          "pointer"	/* glb4 */
macroBlkCnt          A		/* glb4 */
w9197          A		/* glb4 */
w9199          A		/* glb4 */
w919B          A		/* glb4 */
w919D          A		/* glb4 */
w919F          A		/* glb4 */
wZERO           A
xreffd          A

$file(key4.plm)
extKeywords     AS

$file(keywrd.plm)
stdKeywords     AS

$file(Load.plm)
Load            P(A path$p,A Load$offset,A switch,A entry$p,A status$p)

$file(Open.plm)
Open            P(A conn$p,A path$p,A access,A echo,A status$p)

$file(Read.plm)
Read            P(A conn,A buff$p,A count,A actual$p,A status$p)

$file(Rescan.plm)
Rescan          P(A conn,A status$p)

$file(Seek.plm)
Seek            P(A conn,A mode,A block$p,A byte$p,A status$p)

$file(Write.plm)
Write           P(A conn,A buff$p,A count,A status$p)

notes.txt
symbol table format
tok(2) address - packed symbol 3 chars per address field
val address - keywords - high byte is link to next entry
	      user - offset of symbol
	      macro - 
type byte
flags byte keywords xxxxxxrx	r = rim/sim
	   user - xeph lsss	e = external p = public h = high l = low sss = seg
	   macro table


global.plx
global: do;
$IF BASE
$include(glb.ipx)
$ELSEIF OVL4
$include(glb4.ipx)
$ELSE
$include(glb5.ipx)
$ENDIF

$IF OVL4
declare	IN$BUF$SIZE lit '512',
	OUT$BUF$SIZE lit '512';
$ELSEIF OVL5
declare	IN$BUF$SIZE lit '2048',
	OUT$BUF$SIZE lit '2048';
$ELSE
declare	IN$BUF$SIZE lit '200',
	OUT$BUF$SIZE lit '128';
$ENDIF

$IF OVL4
declare	byteAt(1) byte public at(0),
	macroLine(127) byte public,
	endMacroLine(2) byte public,			/* space for 0 and a guard byte */
	macro$p pointer public initial(.macroLine),
	b9058 bool public initial(FALSE),
	b9059 bool public,
	b905A byte public,
	expandingMacro byte public,
	b905C byte public,
	b905D bool public initial(FALSE),
	b905E byte public,
	b905F byte,
	b9060 bool public,
	b9061 bool public,
	b9062 byte public,
	macroDepth byte public,
	b9064 byte public,
	b9065 byte public,
	b9066 byte public,
	argNestCnt byte public initial(0),
	w9068 pointer public,
	w906A pointer public,
	/*
		mtype has the following values
		1 -> IRP
		2 -> IRPC
		3 -> REPT
		4 -> ???
		5 -> ???
	*/
		
	macroStk(10) MACRO$T public,
	(tmac$macroCondSP, tmac$ifDepth,  tmac$mtype, tmac$b3) byte public at (.macroStk(0)),
	(tmac$w4, tmac$buf$p) address public at (.macroStk(0).w4),
	tmac$blk address public  at (.macroStk(0).blk) initial(0FFFFh),
	(tmac$w10, tmac$w12, tmac$w14) address public at (.macroStk(0).w10),
	w910C address,
	curMacroBlk address public initial(0FFFFh),
	nxtMacroBlk address public initial(0),
	maxMacroBlk address public initial(0),
	macroBlkCnt address public,
	macroBuf(129) byte public,
	w9197 address public,
	w9199 address public,
	w919B address public,
	w919D address public,
	w919F address public,
	b91A1 byte public initial(0),
	b91A2 byte public initial(0),

	b91A3 byte public initial(81h),
	b91A4(*) byte public initial(3Fh, 3Fh, 0, 0, 0, 0, 80h);
$ENDIF
/* ov4 compat 2C8C */
declare	contentBytePtr pointer public,
	fixupSeg byte public,
	fixOffset address public,
	curFixupHiLoSegId byte public,
	curFixupType byte public,
	fixIdxs(4) byte public initial(0, 0, 0, 0),
	(fix22Idx, fix24Idx, fix20Idx, fix6Idx) byte public at (.fixIdxs),
	extNamIdx byte public initial(0),
	initFixupReq(4) bool public initial(TRUE, TRUE, TRUE, TRUE),
	firstContent byte public initial(TRUE),
	r$eof EOF$T public initial(0Eh, 0),
	r$extnames1 EXTNAMES$T public initial(18h, 0, 0),
	moduleNameLen byte public initial(6),
	r$extnames2 EXTNAMES$T public initial(18h, 0, 0),
	r$content CONTENT$T public at(.r$extnames2),
	r$publics PUBLICS$T public initial (16h, 1, 0, 0, 0),
	r$reloc RELOC$T public at(.r$publics),
	r$interseg INTERSEG$T public,
	r$extref EXTREF$T public,
	r$modend MODEND$T public initial( 4, 4, 0),
	wZERO address public initial(0),
	pad6741 byte initial(0ah),
	inComment bool public initial(FALSE),
	noOpsYet bool public initial(FALSE),
	nameLen byte public,
	startSeg byte public initial(1),
	padb6746 byte,
	activeSeg byte public,
	inPublic byte public initial(0),
	inExtrn byte public initial(0),
	segHasData(2) byte public,
	alignTypes(4) byte public initial(3, 3, 3, 3),
	externId address public,
	itemOffset address public,
	badExtrn byte public initial(0),
	startDefined byte public initial(0),
	startOffset address public initial(0),
	tokenIdx byte public initial(0),
	lineBuf(128) byte public,
	tokStart(9) address public initial(.lineBuf),
	tokPtr pointer public at(.tokStart),
	tokenSym(9) address public initial(0),
	curTokenSym$p pointer public at(.tokenSym(0)),
	tokenType(9) byte public,
	tokenSize(9) byte public initial(0),
	tokenAttr(9) byte public,
	tokenSymId(9) address public,
/* end */
	endLineBuf address public initial(.tokStart),
	ifDepth byte public initial(0),
	skipping(9) bool public,
	inElse(9) bool public;
$IF OVL4
declare	macroCondSP byte public initial(0),
	macroCondStk(17) byte public,
	b94DD(2) byte;
$ENDIF
declare	opSP byte public,
	opStack(17) byte public,
/* ov4 compat 2CA0 */
	(accum1, accum2) address public,
	(accum1$lb, accum1$hb, accum2$lb, accum2$hb) byte public at(.accum1),
	acc1Flags byte public,
	acc2Flags byte public,
	hasVarRef byte public,
	acc1ValType byte public,
	acc2ValType byte public,
	acc1NumVal address public,
	acc2NumVal address public,
	curChar byte public initial(0),
	reget byte public initial(0),
	lookAhead byte public,
	pad6861 byte initial(0),
	symTab(3) address public,
	endSymTab(3) address public,
	symHighMark address public,
	w6870 pointer public,
	gotLabel byte public initial(0),
	name(6) byte public,
	savName(6) byte public,
	lhsUserSymbol bool public,
	rhsUserSymbol bool public,
	b6881 bool public initial(FALSE),
	passCnt byte public initial(0),
	b6883 bool public initial(FALSE),
	b6884 bool public initial(FALSE),
	needsAbsValue bool public initial(FALSE),
	objfd address public,
	xreffd address public,
	infd address public,
	outfd address public,
	macrofd address public,
	statusIO address public,
	openStatus address public,
	pad6894 address initial(0FFFFh),
	asmErrCode byte public initial(' '),	
	b6897 bool public initial(FALSE),
	primaryValid byte public initial(TRUE);
/* end */
$IF BASE
declare	pad6899 byte initial(0);
$ENDIF
/* ov4 compat 2C9F */
declare	tokI byte public,
	errorOnLine bool public,
	atStartLine byte public,
	pad689D(2) byte,
	curCol byte public initial(1),
	endItem address public,
	startItem address public,
	pageLineCnt address public,
	effectiveAddr address public,
	pageCnt address public,
	pad68AA byte,
	showAddr bool public,
	pad68AC byte,
	lineNumberEmitted bool public initial(FALSE),
	b68AE bool public initial(FALSE),
	tokStr(7) byte public initial(0, 0, 0, 0, 0, 0, 0),
	sizeInBuf address public initial(IN$BUF$SIZE),
	inBuf(IN$BUF$SIZE) byte public,
	outbuf(OUT$BUF$SIZE) byte public,
/* end */
	b6A00 byte public,
/* ov4 compat 2F57 */
	out$p pointer public initial(.outbuf),
	endOutBuf address public,
	pad6A05 address initial(.outbuf),
	pad6A07 byte initial(0),
	objFile(15) byte public initial('               '), /* 15 spaces */
	lstFile(15) byte public initial('               '), /* 15 spaces */
	asxref$tmp(*) byte public initial(':F0:ASXREF.TMP '),
	asxref(*) byte public initial(':F0:ASXREF '),
	asmax$ref(*) byte public initial(':F0:ASMAC.TMP '),
	srcLineCnt address public initial(1),
	pad6A50(2) byte initial('  '),		/* protects for very big files */
	asciiLineNo(4) byte public initial('   0'),
	spIdx byte public,
	b6A57(4) byte public initial('   0'),
	ctlDEBUG bool public initial(FALSE),	/* DEBUG */
	controls(1) byte public at(.ctlDEBUG),
	ctlMACRODEBUG bool public initial(FALSE),	/* MACRODEBUG */
	ctlXREF bool public initial(FALSE),	/* XREF */
	ctlSYMBOLS bool public initial(TRUE),	/* SYMBOLS */
	ctlPAGING bool public initial(TRUE),	/* PAGING */
	ctlTTY bool public initial(FALSE),	/* TTY */
	ctlMOD85 bool public initial(FALSE),	/* MOD85 */
	ctlPRINT bool public initial(TRUE),	/* PRINT */
	ctlOBJECT bool public initial(TRUE),	/* OBJECT */
	ctlMACROFILE bool public initial(FALSE),	/* MACROFILE */
	ctlPAGEWIDTH byte public initial(120),	/* PAGEWIDTH */
	ctlPAGELENGTH byte public initial(66),	/* PAGELENGTH */
	ctlINLCUDE byte initial(0),		/* INCLUDE */
	ctlTITLE bool public initial(FALSE),	/* TITLE */
	ctlSAVE byte,				/* SAVE */
	ctlRESTORE byte,			/* RESTORE */
	ctlEJECT byte public initial(0),	/* EJECT */
	ctlLIST bool public initial(TRUE),	/* LIST */	/* SAVE/RESTORE act on next 3 opts */
	ctlGEN bool public initial(TRUE),	/* GEN */
	ctlCOND bool public initial(TRUE),	/* COND */
	ctlLISTChanged bool public initial(TRUE),
	titleLen byte public initial(0),
	b6A71 byte public,
	pad6A72(3) byte initial(120, TRUE),
	controlSeen(12) bool public initial(0,0,0,0,0,0,0,0,0,0,0,0),
	saveStack(24) byte public,
	saveIdx byte public initial(0),
	ctlTITLESTR(64) byte public,
	tokBufLen byte public,
	tokType byte public,
	controlId byte public,
	tokBuf(64) byte public,
	tokBufIdx byte public initial(0),
	tokNumVal address public,
/* end */
	isControlLine byte public initial(FALSE);
$IF NOT OVL4
declare	MacroDebugOrGen byte public initial(0);
$ENDIF
/* ov4 compat 2F56 */
declare	scanCmdLine byte public,
	inDB byte public,
	inDW byte public,
	inExpression bool public,
	has16bitOperand byte public,
	phase byte public,
	b6B28 byte public,
	effectiveToken byte public,
	rightOp byte public,
	leftOp byte public,
	b6B2C bool public,
	b6B2D byte public,
	finished bool public,
	inNestedParen byte public,
	expectingOperands bool public,
	expectingOpcode bool public,
	b6B32 bool public,
	b6B33 bool public,
	b6B34 bool public initial(TRUE),
	inParen bool public initial(TRUE),
	b6B36 bool public initial(FALSE),
	segSize(5) address public initial(0, 0, 0, 0, 0),	/* note treated as array */
	maxSegSize(3) address public initial(0, 0, 0),
	cmdLineBuf(129) byte public,
	actRead pointer public,
	errCnt address public,
	padw6BCB(2) byte,
	w6BCE address public,
	pad6BD0(3) byte initial(0),
	azero address public initial(0),
	cmdch$p pointer public initial(.cmdLineBuf),
	controls$p address public,
	b6BD9 bool public initial(FALSE),
	b6BDA bool public,
	ii byte public,
	jj byte public,
	kk byte public;
/* end */
$IF OVL4
declare	b9B34 byte initial(0);
$ENDIF
/* ov4 compat 2F57 */
declare	curFileName$p address public,
	w6BE0 pointer public,
	accFixFlags(2) byte public at(.w6BE0),
	controlFileType address public;	 /* 1->INCLUDE 2->PRINT, 3->OBJECT or MACROFILE */
/* end */
end;
asm475785.plx
asm80$47$57$85: do;
$IF OVL4
$include(asm47.ipx)
$ELSEIF OVL5
$include(asm57.ipx)
$ELSE
$include(asm85.ipx)
$ENDIF

$IF BASE
declare	CHKOVL$2 lit	'call OvlMgr(2)';
$ELSE
declare	CHKOVL$2 lit	' ';
$ENDIF

			/* 0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F */
declare isExprOrMacroMap(*) bool data(
			   0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,
			   0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0,   0,   0,   0,   0,   0,
			   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
			   0,   0,   0,   0,   0,   0,   0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh, 0,  0FFh,
			   0FFh,0FFh),
   isInstrMap(*) bool data(0,   0FFh,0FFh,0FFh,0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
		           0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0FFh,0FFh,0,   0,   0,   0,
			   0,   0,   0,   0,   0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0,
			   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
			   0FFh,0FFh);

declare pad byte;

declare	accum(4) byte at(.accum1);


ChkSegAlignment: procedure(seg) public;	/* seg = 0 => CSEG, seg = 1 => DSEG */
	declare seg byte;

	if segHasData(seg) then
	do;
		if HaveTokens then
		do;
			accum1 = GetNumVal;
			if alignTypes(seg) <> accum1$lb then
				call ExpressionError;
		end;
		else if alignTypes(seg) <> 3 then	/* no speficier - check byte algined */
			call ExpressionError;
	end;
	else
	do;
		segHasData(seg) = TRUE;
		if HaveTokens then
		do;
			accum1 = GetNumVal;
			if accum1 = 1 or accum1 = 2 then	/* only allow inPage and Page */
				alignTypes(seg) = low(accum1);
			else
				call ExpressionError;
		end;
	end;
end;


Cond2Acc: procedure(cond) public;	/* convert conditional result to accum1 */
	declare cond byte;		/* 0 or 0ffffh */

	accum1 = cond;
	if accum1 then
		accum1 = 0FFFFh;
end;

UpdateHiLo: procedure(hilo) public;
	declare hilo byte;

	if (acc1Flags and (UF$EXTRN + UF$SEGMASK)) <> 0 then
		acc1Flags = acc1Flags and 0E7h or hilo;
end;

HandleOp: procedure public;
	do case leftOp;
/* 0 */		;
/* 1 */		call FinishLine;		/* CR */
/* 2 */		goto case3;			/* ( */
/* 3 */ case3:	do;				/* ) */
			if not (leftOp = T$LPAREN and rightOp = T$RPAREN) then
				call BalanceError;

			if tokenType(0) = O$DATA then
			do;
				tokenSize(0) = 1;
				tokenAttr(0) = 0;
				b6B36 = TRUE;
			end;

			inParen = inNestedParen;
			if rightOp = T$RPAREN then
				b6B2C = TRUE;
		end;
/* 4 */		accum1 = accum1 * accum2;	/* * */
/* 5 */		accum1 = accum1 + accum2;	/* + */
/* 6 */		do;				/* , */
			call SyntaxError;
			call PopToken;
		end;
/* 7 */		accum1 = accum1 - accum2;	/* - */
/* 8 */		;				/* unary + */
/* 9 */		do;				/* / */
			if accum2 = 0 then
				call ValueError;

			accum1 = accum1 / accum2;
		end;
/* 10 */	accum1 = -accum1;			/* unary - */
/* 11 */	call Cond2Acc(accum1 = accum2);		/* EQ */
/* 12 */	call Cond2Acc(accum1 < accum2);		/* LT */
/* 13 */	call Cond2Acc(accum1 <= accum2);	/* LE */
/* 14 */	call Cond2Acc(accum1 > accum2);		/* GT */
/* 15 */	call Cond2Acc(accum1 >= accum2);	/* GE */
/* 16 */	call Cond2Acc(accum1 <> accum2);	/* NE */
/* 17 */	accum1 = not accum1;			/* NOT */
/* 18 */	accum1 = accum1 and accum2;		/* AND */
/* 19 */	accum1 = accum1 or accum2;		/* OR */
/* 20 */	accum1 = accum1 xor accum2;		/* XOR */
/* 21 */	do;					/* MOD */
			if accum2 = 0 then
				call ValueError;
			accum1 = accum1 mod accum2;
		end;
/* 22 */	do;					/* SHL */
			if accum2$lb <> 0 then
				accum1 = shl(accum1, accum2);
		end;
/* 23 */	do;					/* SHR */
			if accum2$lb <> 0 then
				accum1 = shr(accum1, accum2);
		end;
/* 24 */	do;					/* HIGH */
			accum1 = high(accum1);
			call UpdateHiLo(UF$HIGH);
		end;
/* 25 */	do;					/* LOW */
			accum1 = low(accum1);
			call UpdateHiLo(UF$LOW);
		end;
/* 26 */	do;					/* DB ? */
			if tokenType(0) <> O$STRING then
			do;
				accum1 = GetNumVal;
				if accum1$hb - 1 < 0FEh then	/* not 0 or FF */
					call ValueError;
				b6B28 = 22h;
				if (acc1Flags and UF$BOTH) = UF$BOTH then
				do;
					call ValueError;
					acc1Flags = acc1Flags and 0E7h or UF$LOW;
				end;
			end;
			else
			do;
				acc1Flags = 0;
				tokenType(0) = O$DATA;
			end;

			if IsReg(acc1ValType) then
				call OperandError;
			b6B2D = O$DATA;
			inDB = TRUE;
		end;
/* 27 */	do;					/* DW ? */
			b6B2D = O$DATA;
			inDW = TRUE;
		end;
/* 28 */	do;					/* DS ? */
			segSize(activeSeg) = segSize(activeSeg) + accum1;
			showAddr = TRUE;
		end;
/* 29 */ case29:					/* EQU ? */
		do;
			showAddr = TRUE;
			if (acc1Flags and UF$EXTRN) = UF$EXTRN then
			do;
				call ExpressionError;
				acc1Flags = 0;
			end;
			labelUse = 1;
			call Sub5819$5CE8(accum1, (K$SET + 4) - leftOp);	/* 4 for set, 5 for equ */
			expectingOperands = FALSE;
		end;
/* 30 */	goto case29;				/* SET ? */
/* 31 */	do;					/* ORG ? */
			showAddr = TRUE;
			if (acc1Flags and UF$EXTRN) <> UF$EXTRN then
			do;
				if (acc1Flags and UF$BOTH) <> 0 then
					if (acc1Flags and UF$SEGMASK) <> activeSeg
					    or (acc1Flags and UF$BOTH) <> UF$BOTH then
						call ExpressionError;
			end;
			else
				call ExpressionError;

			if ctlOBJECT then
				if segSize(activeSeg) > maxSegSize(activeSeg) then
					maxSegSize(activeSeg) = segSize(activeSeg);
			segSize(activeSeg) = accum1;
		end;
/* 32 */	do;					/* END ? */
			if tokenIdx > 0 then
			do;
				startOffset = GetNumVal;
				startDefined = 1;
				startSeg = acc1Flags and 7;
				if (acc1Flags and UF$EXTRN) = UF$EXTRN then
					call ExpressionError;
				if IsReg(acc1ValType) then
					call OperandError;

				showAddr = TRUE;
			end;
$IF OVL4
			kk = b905E;
			b905E = 0;

			if macroCondSP > 0 or kk then
$ELSE
			if ifDepth > 0 then
$ENDIF
				call NestingError;
			if rightOp <> T$CR then
				call SyntaxError;
			if inParen then
				b6B33 = TRUE;
			else
				call SyntaxError;

		end;
/* 33 */	do;					/* IF ? */
			if inParen then
			do;
				b6B32 = TRUE;
				call NestIF(2);
				b6881 = TRUE;
				if skipping(0) = FALSE then
					skipping(0) = not ((low(accum1) and 1) = 1);
				inElse(0) = FALSE;
			end;
		end;
/* 34 */	do;					/* ELSE ? */
			b6B32 = TRUE;
$IF OVL4
			if macroCondStk(0) <> 2 then
$ELSE
			if ifDepth = 0 then
$ENDIF
				call NestingError;
			else if not inElse(0) then
			do;
				if not skipping(0) then
					skipping(0) = TRUE;
				else
					skipping(0) = skipping(ifDepth);
				inElse(0) = TRUE;
			end;
			else
				call NestingError;
		end;
/* 35 */	do;					/* ENDIF ? */
			if inParen then
			do;
				b6B32 = TRUE;
				call UnnestIF(2);
			end;
		end;
/* 36 */	do;					/* LXI ? */
			if nameLen = 1 then
				if name(0) = 'M' then
					call SyntaxError;
			call MkCode(85h);
		end;
/* 37 */	do;				/* POP DAD PUSH INX DCX ? */
			if nameLen = 1 then
				if name(0) = 'M' then
					call SyntaxError;
			call MkCode(5);
		end;
/* 38 */	call MkCode(7);		/* LDAX STAX ? */
/* 39 */	call MkCode(2);		/* ADC ADD SUB ORA SBB XRA ANA CMP ? */
/* 40 */	call MkCode(8);		/* ADI OUT SBI ORI IN CPI SUI XRI ANI ACI ? */
/* 41 */	call MkCode(46h);		/* MVI ? */
/* 42 */	call MkCode(6);		/* INR DCR ? */
/* 43 */	call MkCode(36h);		/* MOV */
/* 44 */	call MkCode(0);		/* CZ CNZ JZ STA JNZ JNC LHLD */
						/* CP JC SHLD CPE CPO CM LDA JP JM JPE */
						/* CALL JPO CC CNC JMP */
/* 45 */	call MkCode(0);		/* RNZ STC DAA DI SIM SPHL RLC */
						/* RP RAL HLT RM RAR RPE RET RIM */
						/* PCHL CMA CNC RPO EI XTHL NOP */
						/* RC RNX XCHG RZ RRC */
/* 46 */	call MkCode(6);		/* RST */
/* 47 */	activeSeg = 0;			/* ASEG ? */
/* 48 */	do;				/* CSEG ? */
			activeSeg = 1;
			call ChkSegAlignment(0);
		end;
/* 49 */	do;				/* DSEG ? */
			activeSeg = 2;
			call ChkSegAlignment(1);
		end;

/* 50 */	do;				/* PUBLIC */
			inPublic = TRUE;
			labelUse = 0;
			call Sub5819$5CE8(0, 6);
		end;
/* 51 */	do;				/* EXTRN ? */
			inExtrn = TRUE;
			if externId = 0 and IsPhase1 and ctlOBJECT then
			do;
				CHKOVL$2;
				call WriteModhdr;
			end;
			labelUse = 0;
			call Sub5819$5CE8(externId, 2);
			if IsPhase1 and ctlOBJECT and not badExtrn then
			do;
				CHKOVL$2;
				call WriteExtName;
			end;
			if not badExtrn then
				externId = externId + 1;
			badExtrn = 0;
		end;
/* 52 */	do;				/* NAME */
			if tokenIdx <> 0 and noOpsYet then
			do;
				/* set the module name in the header - padded to 6 chars */
				call move(6, .spaces6, .aModulePage);
				call move(moduleNameLen := nameLen, .name, .aModulePage);
			end;
			else
				call SourceError('R');

			call PopToken;
		end;
/* 53 */	segSize(SEG$STACK) = accum1;	/* STKLN ? */
$IF OVL4
/* 54 */	call Sub7517;			/* MACRO ? */
/* 55 */	call Sub753E;
/* 56 */	call Sub75FF;			/* ENDM */
/* 57 */	call Sub76CE;			/* EXITM */
/* 58 */	do;
			tmac$mtype = 4;
			call Sub7327;
		end;
/* 59 */	call Sub72A4(1);		/* IRP ? */
/* 60 */	call Sub72A4(2);		/* IRPC */
/* 61 */	call Sub770B;
/* 62 */	call Sub7844;			/* REPT ? */
/* 63 */	call Sub787A;			/* LOCAL */
/* 64 */	call Sub78CE;
/* 65 */	do;				/* NUL */
			call Cond2Acc(tokenType(0) = K$NUL);
			call PopToken;
			acc1Flags = 0;
		end;
$ENDIF
	end;

	if leftOp <> T$CR then
		noOpsYet = FALSE;
end;

ParseLine: procedure public;

	IsExpressionOp: procedure byte;
		if effectiveToken > 3 then
			if effectiveToken <> T$COMMA then
				if effectiveToken < 1Ah then
					return TRUE;
		return FALSE;
	end;

	isVar: procedure(arg1b) byte;
		declare arg1b byte;
		return arg1b = O$ID or arg1b = O$64;
	end;


	Sub53F8: procedure;
		if not isInstrMap(leftOp) then
			b6B34 = FALSE;
	end;



	do while 1;
		if not (effectiveToken = T$CR or effectiveToken >= K$END and effectiveToken <= K$ENDIF) and skipping(0)
$IF OVL4
	           or (b4181(effectiveToken) < 128 or b9058) and b905E

$ENDIF
	        then
		do;
			needsAbsValue = FALSE;
			call PopToken;
			return;
		end;
		
		if phase <> 1 then
			if inExpression then
				if IsExpressionOp then
					if GetPrec(effectiveToken) <= GetPrec(opStack(opSP)) then
						call ExpressionError;

		if GetPrec(rightOp := effectiveToken) > GetPrec(leftOp := opStack(opSP)) or rightOp = T$LPAREN then
		do;
			if opSP >= 16 then
			do;
				opSP = 0;
				call StackError;
			end;
			else
				opStack(opSP := opSP + 1) = rightOp;
			if rightOp = T$LPAREN then
			do;
				inNestedParen = inParen;
				inParen = TRUE;
			end;
			if phase > 1 then
				inExpression = IsExpressionOp;
			return;
		end;

		inExpression = 0;
		if not inParen and leftOp > 3 then
			call SyntaxError;

		if leftOp = O$NONE then
			leftOp = rightOp;
		else
			opSP = opSP - 1;
		

		if (b6B28 := b4181(leftOp)) then
		do;
			accum2 = GetNumVal;
			acc2Flags = acc1Flags;
			acc2NumVal = acc1NumVal;
			acc2ValType = acc1ValType;
		end;

		if (b6B28 := ror(b6B28, 1)) then
			accum1 = GetNumVal;

		if not hasVarRef then
			hasVarRef = isVar(acc1ValType) or isVar(acc2ValType);

		b6B2D = O$NUMBER;
		if leftOp > T$RPAREN and leftOp < K$DB then	/* expression leftOp */
			call Sub4291;
		else
		do;
			call Sub53F8;
			call Sub4274;
		end;

		call HandleOp;
		if not isExprOrMacroMap(leftOp) then
			inParen = FALSE;

		if b6B2C then
		do;
			b6B2C = FALSE;
			return;
		end;

		if leftOp <> K$DS and showAddr then		/* DS */
			effectiveAddr = accum1;

		if (b6B28 and 1Eh) <> 0 then
			call PushToken(b6B2D);

		do ii = 0 to 3;
			if (b6B28 := ror(b6B28, 1)) then
				call CollectByte(accum(ii));
		end;

		tokenAttr(0) = acc1Flags;
		tokenSymId(0) = acc1NumVal;
		if ror(b6B28, 1) then
			if rightOp = T$COMMA then
			do;
				effectiveToken = leftOp;
				inParen = TRUE;
			end;
	end;
end;



DoPass: procedure public;
	do while finished = FALSE;
		call TokeniseLine;
		call ParseLine;
	end;
end;

end;
asm4cov2.plx
asm4c$ov2: do;
$IF OVL4
$include(asm4c.ipx)
$ELSE
$include(asmov2.ipx)
$ENDIF

declare	fixupInitialLen(*) byte data(1, 2, 1, 3),
	fixupRecLenPtrs(*) address data(.r$publics.len, .r$interseg.len, .r$extref.len, .r$content.len),
	fixupRecLenChks(*) byte data(123, 58, 57, 124),
	b6D7E(*) byte data(10, 12h, 40h); /* 11 bits 00010010010 index left to right */


declare	r$modhdr MODHDR$T initial(2),
	(dta$p, recSym$p) pointer;



WriteRec: procedure(rec$p) public;
	declare rec$p address,
		len$p pointer, recLen address,
		i byte, crc byte;
	declare len based len$p address;
	declare ch based len$p byte;

	len$p = rec$p + 1;
	recLen = (len := len + 1) + 3;	/* include crc byte + type + len word */
	crc = 0;			/* crc */
	len$p = len$p - 1;
	do i = 2 to recLen;
		crc = crc - ch;
		len$p = len$p + 1;
	end;
	ch = crc;			/* insert crc byte */
	call Write(objfd, rec$p, recLen, .statusIO);
	call IoErrChk;
end;


GetFixupType: procedure byte;
	declare attr byte;
	if ((attr := tokenAttr(spIdx)) and 5Fh) = 0 then
		return 3;
	if (attr and UF$EXTRN) <> 0 then	/* external */
		return 2;
	if (fixupSeg := attr and UF$SEGMASK) = 0 then	/* absolute */
		return 3;
	return (fixupSeg <> activeSeg) and 1;
end;


ReinitFixupRecs: procedure public;
	declare i byte;
	declare wrd based dta$p address;
	do i = 0 to 3;
		ii = (i - 1) and 3;
		dta$p = fixupRecLenPtrs(ii);
		if wrd > fixupInitialLen(ii) then
			call WriteRec(dta$p - 1);

		wrd = fixupInitialLen(ii);
		fixIdxs(ii) = 0;
		if curFixupType <>  ii then
			initFixupReq(ii) = TRUE;
	end;
	r$content.offset = itemOffset + segSize(r$content.segid := activeSeg);
	r$publics.segid = curFixupHiLoSegId;
	r$interseg.segid = tokenAttr(spIdx) and 7;
	r$interseg.hilo, r$extref.hilo = curFixupHiLoSegId;
end;



Sub6EE1: procedure;
	declare effectiveOffset address;

	declare wrd based dta$p address;

	dta$p = fixupRecLenPtrs(curFixupType := GetFixupType);
	if wrd > fixupRecLenChks(curFixupType) or r$content.len + tokenSize(spIdx) > 124 then
		call ReinitFixupRecs;

	if firstContent then
	do;
		firstContent = FALSE;
		r$content.offset = segSize(r$content.segid := activeSeg) + itemOffset;
	end;
	else if r$content.segid <> activeSeg
	      or (effectiveOffset := r$content.offset + fix6Idx) <> segSize(activeSeg) + itemOffset
	      or effectiveOffset < r$content.offset then
		call ReinitFixupRecs;


	do case curFixupType;
/* 0 */		do;
			if initFixupReq(0) then
			do;
				initFixupReq(0) = FALSE;
				r$publics.segid = curFixupHiLoSegId;
			end;
			else if r$publics.segid <> curFixupHiLoSegId then
				call ReinitFixupRecs;
		end;
/* 1 */		do;
			if initFixupReq(1) then
			do;
				initFixupReq(1) = FALSE;
				r$interseg.segid = tokenAttr(spIdx) and 7;
				r$interseg.hilo = curFixupHiLoSegId;
			end;
			else if r$interseg.hilo <> curFixupHiLoSegId or (tokenAttr(spIdx) and 7) <> r$interseg.segid then
				call ReinitFixupRecs;
		end;
/* 2 */		do;
			if initFixupReq(2) then
			do;
				initFixupReq(2) = FALSE;
				r$extref.hilo = curFixupHiLoSegId;
			end;
			else if r$extref.hilo <> curFixupHiLoSegId then
				call ReinitFixupRecs;

		end;
/* 3 */		;		/* abs no fixup */
	end;
end;


RecAddContentBytes: procedure;
	declare i byte;

	declare ch based contentBytePtr byte;

	do i = 1 to tokenSize(spIdx);
		r$content.dta(fix6Idx) = ch;
		fix6Idx = fix6Idx + 1;
		contentBytePtr = contentBytePtr + 1;
	end;
	r$content.len = r$content.len + tokenSize(spIdx);
end;



IntraSegFix: procedure;
	r$reloc.len = r$reloc.len + 2;
	r$reloc.dta(fix22Idx) = fixOffset;
	fix22Idx = fix22Idx + 1;
end;


InterSegFix: procedure;
	r$interseg.len = r$interseg.len + 2;
	r$interseg.dta(fix24Idx) = fixOffset;
	fix24Idx = fix24Idx + 1;
end;

ExternalFix: procedure;
	r$extref.dta(fix20Idx) = tokenSymId(spIdx);
	r$extref.dta(fix20Idx + 1) = fixOffset;
	r$extref.len = r$extref.len + 4;
	fix20Idx = fix20Idx + 2;
end;

Sub7131: procedure;
	curFixupHiLoSegId = shr(tokenAttr(spIdx) and 18h, 3);
	fixOffset = segSize(activeSeg) + itemOffset;
	if not (inDB or inDW) and (tokenSize(spIdx) = 2 or tokenSize(spIdx) = 3) then
		fixOffset = fixOffset + 1;
	call Sub6EE1;
	contentBytePtr = startItem;
	call RecAddContentBytes;
	do case GetFixupType;
/* 0 */ 	call IntraSegFix;
/* 1 */		call InterSegFix;
/* 2 */		call ExternalFix;
/* 3 */		;			/* no fixup as absolute */
	end;
end;


WriteExtName: procedure public;
	declare i byte;

	if r$extnames1.len + 9 > 125 then	/* check room for name */
	do;
		call WriteRec(.r$extnames1);	/* flush existing extNam Record */
		r$extnames1.type = OMF$EXTNAMES;
		r$extnames1.len = 0;
		extNamIdx = 0;
	end;
	r$extnames1.len = r$extnames1.len + nameLen + 2;	/* update length for this ref */
	r$extnames1.dta(extNamIdx) = nameLen;		/* Write len */
	extNamIdx = extNamIdx + 1;
	do i = 0 to nameLen;			/* and name */
		r$extnames1.dta(extNamIdx + i) = name(i);
	end;

	r$extnames1.dta(extNamIdx + nameLen) = 0;	/* and terminating 0 */
	extNamIdx = extNamIdx + nameLen + 1;	/* update where next ref writes */
end;

WriteSymbols: procedure(isPublic);			/* isPublic= TRUE -> PUBLICs else LOCALs */
    declare isPublic byte;
    declare segId byte;
    declare symb based curTokenSym$p (1) byte;

    AddSymbol: procedure;
        declare offsetInSeg$p pointer;
        declare symNam based dta$p (1) byte;
        declare len based recSym$p byte;
        declare symOffset based recSym$p address;
        declare offsetInSeg based offsetInSeg$p address;

        if (symb(1) and 40h) <> 0 then
            return;
        offsetInSeg$p = curTokenSym$p - 2;
        symOffset = offsetInSeg; 
        call UnpackToken(curTokenSym$p - 6, (dta$p := (recSym$p := recSym$p + 2) + 1));
        symNam(6) = ' ';	/* trailing space to ensure end */
        len = 0;

        do while symNam(0) <> ' ';	/* find length of name */
            len = len + 1;
            dta$p = dta$p + 1;
        end;
        symNam(0) = 0;			/* terminate name with 0 */
        recSym$p = dta$p + 1;
    end;

    flushSymRec: procedure;
        if (r$publics.len := recSym$p - .r$publics.segid) > 1 then	/* something to Write */
            call WriteRec(.r$publics);
        r$publics.type = (isPublic and 4) or OMF$LOCALS;		/* PUBLIC or LOCAL */
        r$publics.segid = segId;
        recSym$p = .r$publics.dta;
    end;

    recSym$p = .r$publics.dta;
    do segId = 0 to 4;
        call FlushSymRec;
        curTokenSym$p = symTab(1) - 2;		/* point to type byte of user symbol (-1) */

        do while (curTokenSym$p := curTokenSym$p + 8) < endSymTab(1);
        	if recSym$p > .r$publics.dta(114) then		/* make sure there is room */
        		call FlushSymRec;

            if (symb(1) and 7) = segId
$IF OVL4
               and symb(0) <> O$3A and Sub3FA9
$ENDIF
               and not TestBit(symb(0), .b6D7E) and
               (not isPublic or (symb(1) and 20h) <> 0) then
       	        call AddSymbol;
        end;
        call FlushSymRec;
    end;
end;



WriteModhdr: procedure public;
	declare w based dta$p address;
	declare b based dta$p byte;
	declare i byte;

	/* fill the module name */
	call move((r$modhdr.dta(0) := moduleNameLen), .aModulePage, .r$modhdr.dta(1));
	dta$p = .r$modhdr + moduleNameLen + 4;
	w = 0;	/* the two xx bytes */
	dta$p = dta$p + 1;	/* past first x byte */

	if segSize(SEG$CODE) < maxSegSize(SEG$CODE) then	/* code segment */
		segSize(SEG$CODE) = maxSegSize(SEG$CODE);
	if segSize(SEG$DATA) < maxSegSize(SEG$DATA) then	/* data segment */
		segSize(SEG$DATA) = maxSegSize(SEG$DATA);

	do i = 1 to 4;
		dta$p = dta$p + 1;
		b = i;		/* seg id */
		dta$p = dta$p + 1;
		w = segSize(i);	/* seg size */
		dta$p = dta$p + 2;
		b = alignTypes(i - 1);	/* aln typ */
	end;
	r$modhdr.len = moduleNameLen + 19;	/* set record length */
	call WriteRec(.r$modhdr);
end;

WriteModend: procedure public;
	declare lenb byte at (.r$eof.len);
	r$modend.modtyp = startDefined;
	r$modend.segid = startSeg;
	r$modend.offset = startOffset;
	call WriteRec(.r$modend);
	lenb = 0;
	call WriteRec(.r$eof);
end;

Ovl8: procedure public;
	itemOffset = 0;
	tokI = 1;
	spIdx = 1;
	if b6B33 then
		;
	else
	do while spIdx <> 0;
		spIdx = NxtTokI;
		endItem = tokStart(spIdx) + tokenSize(spIdx);
		startItem = tokStart(spIdx);
		if IsSkipping or not b6B34 then
			endItem = startItem;
		if endItem > startItem then
		do;
			call Sub7131;
			itemOffset = itemOffset + tokenSize(spIdx);
		end;
		if not(inDB or inDW) then
			spIdx = 0;
	end;
end;


Ovl11: procedure public;
	if externId <> 0 then
	do;
		call Seek(objfd, SEEKABS, .azero, .azero, .statusIO);	/* rewind */
		call WriteModhdr;
		call Seek(objfd, SEEKEND, .azero, .azero, .statusIO);	/* back to end */
	end;
	r$publics.type = OMF$PUBLICS;		  /* public declarations record */
	r$publics.len = 1;
	r$publics.segid = SEG$ABS;
	r$publics.dta(0) = 0;
	call WriteSymbols(TRUE);	  /* EMIT PUBLICS */
	if ctlDEBUG then
		call WriteSymbols(FALSE); /* EMIT LOCALS */
end;
end;
keywrd.plm
keywords: do;
$include(keywrd.ipx)
declare copyright(*) byte data('(C) 1976,1977,1979,1980 INTEL CORP');

declare stdKeywords(151) KEYWORD$T public initial(
/*
	4 byte packed keyword
	byte opcode base
	byte offset to next entry or 0 if end
	byte type
	byte flags
*/
	/* token	opBase	offset	type		flags */
	0A528h,	0,	0,	0,	K$NE,		0,	/* NE */
	63B0h,	0,	0CCh,	0,	K$IMM16,	0,	/* CZ */
	0,	0,	0,	0,	0,		0,	/* */
	0BFB6h,	0,	0C0h,	0,	K$SINGLE,	0,	/* RNZ */
	0B354h,	0,	0C1h,	0,	K$REG16,	0,	/* POP */
	6EE9h,	0,	0,	0,	K$EQU,		0,	/* EQU */
	0AD70h,	0,	0,	0E8h,	K$OR,		0,	/* OR */
	0A1A5h,	0,	6,	0E8h,	K$MVI,		0,	/* MVI */
	0C6CFh,	0,	37h,	0,	K$SINGLE,	0,	/* STC */
	0C6CDh,	6158h,	0,	0,	K$SPECIAL,	1Bh,	/* STACK */
	6615h,	0,	27h,	0,	K$SINGLE,	0,	/* DAA */
	988Dh,	0E100h,	0Ah,	0,	K$LDSTAX,	0,	/* LDAX */
	61F6h,	0,	0C4h,	0,	K$IMM16,	0,	/* CNZ */
	53CFh,	0,	88h,	0D8h,	K$ARITH,	0,	/* ADC */
	53D0h,	0,	80h,	0,	K$ARITH,	0,	/* ADD */
	6748h,	0,	0F3h,	0D0h,	K$SINGLE,	0,	/* DI */
	0,	0,	0,	0,	0,		0,	/* */
	0,	0,	0,	0,	0,		0,	/* */
	0,	0,	0,	0,	0,		0,	/* */
	53D5h,	0,	0C6h,	0C8h,	K$IMM8,		0,	/* ADI */
	6A40h,	0,	3,	0F0h,	K$REGNAME,	0,	/* E */
	0,	0,	0,	0,	0,		0,	/* */
	0,	0,	0,	0,	0,		0,	/* */
	0,	0,	0,	0,	0,		0,	/* */
	0A088h,	0,	0,	0,	K$MOD,		0,	/* MOD */
	0AD83h,	0,	0,	0,	K$ORG,		0,	/* ORG */
	0,	0,	0,	0,	0,		0,	/* */
	8F70h,	0,	0CAh,	0E8h,	K$IMM16,	0,	/* JZ */
	68E9h,	76C0h,	0,	0,	K$DSEG,		0,	/* DSEG */
	0C488h,	0,	0,	0,	K$SET,		0,	/* SET */
	0,	0,	0,	0,	0,		0,	/* */
	0C521h,	0,	30h,	0,	K$SINGLE,	2,	/* SIM */
	0,	0,	0,	0,	0,		0,	/* */
	0,	0,	0,	0,	0,		0,	/* */
	0A4A1h,	6A40h,	0,	0,	K$NAME,		0,	/* NAME */
	0C6CDh,	0,	32h,	0,	K$IMM16,	0,	/* STA */
	0AE08h,	0,	0D3h,	0,	K$IMM8,		0,	/* OUT */
	6630h,	0,	0,	0,	K$DB,		0,	/* DB */
	8DB6h,	0,	0C2h,	0,	K$IMM16,	0,	/* JNZ */
	0,	0,	0,	0,	0,		0,	/* */
	6618h,	0,	9,	0C0h,	K$REG16,	0,	/* DAD */
	8D9Fh,	0,	0D2h,	0,	K$IMM16,	0,	/* JNC */
	0A09Ah,	0,	40h,	0C0h,	K$MOV,		0,	/* MOV */
	8610h,	0,	0,	0C0h,	K$IF,		0,	/* IF */
	6E60h,	0,	0,	0A8h,	K$END,		0,	/* END */
	9938h,	6400h,	2Ah,	0B8h,	K$IMM16,	0,	/* LHLD */
	9600h,	0,	5,	0C0h,	K$REGNAME,	0,	/* L */
	0C6F6h,	0,	90h,	0,	K$ARITH,	0,	/* SUB */
	0C634h,	9600h,	0F9h,	0,	K$SINGLE,	0,	/* SPHL */
	0C405h,	0,	0DEh,	0,	K$IMM8,		0,	/* SBI */
	0B3FBh,	0,	6,	0,	K$REGNAME,	0,	/* PSW */
	0BF4Fh,	0,	7,	0,	K$SINGLE,	0,	/* RLC */
	5780h,	0,	0,	0,	K$REGNAME,	0,	/* B */
	0,	0,	0,	0,	0,		0,	/* */
	6220h,	0,	0F4h,	0F0h,	K$IMM16,	0,	/* CP */
	0,	0,	0,	0,	0,		0,	/* */
	0AD85h,	0,	0F6h,	0,	K$IMM8,		0,	/* ORI */
	0B11Bh,	6A40h,	2,	0,	K$SPECIAL,	0,	/* PAGE */
	0,	0,	0,	0,	0,		0,	/* */
	0,	0,	0,	0,	0,		0,	/* */
	5629h,	76C0h,	0,	0,	K$ASEG,		0,	/* ASEG */
	8750h,	0,	0DBh,	0,	K$IMM8,		0,	/* IN */
	6E60h,	8610h,	0,	0D0h,	K$ENDIF,	0,	/* ENDIF */
	0,	0,	0,	0,	0,		0,	/* */
	8BD8h,	0,	0DAh,	0F0h,	K$IMM16,	0,	/* JC */
	0AD7Dh,	0,	0B0h,	0,	K$ARITH,	0,	/* ORA */
	0C3FEh,	0,	98h,	0,	K$ARITH,	0,	/* SBB */
	0C6D7h,	9A10h,	0,	0,	K$STKLN,	0,	/* STKLN */
	0BFE0h,	0,	0F0h,	0,	K$SINGLE,	0,	/* RP */
	0C4F8h,	6400h,	22h,	0,	K$IMM16,	0,	/* SHLD */
	0C078h,	0,	0C7h,	0,	K$RST,		0,	/* RST */
	6231h,	0,	0ECh,	0,	K$IMM16,	0,	/* CPE */
	0B436h,	9957h,	0,	0E8h,	K$PUBLIC,	0,	/* PUBLIC */
	0BDA0h,	0,	17h,	0E8h,	K$SINGLE,	0,	/* RAL */
	80E0h,	0,	76h,	0E8h,	K$SINGLE,	0,	/* HLT */
	6235h,	0,	0FEh,	0,	K$IMM8,		0,	/* CPI */
	0BF68h,	0,	0F8h,	0,	K$SINGLE,	0,	/* RM */
	0,	0,	0,	0,	0,		0,	/* */
	0,	0,	0,	0,	0,		0,	/* */
	0BDA6h,	0,	1Fh,	0,	K$SINGLE,	0,	/* RAR */
	805Bh,	7D00h,	0,	0D0h,	K$HIGH,		0,	/* HIGH */
	623Bh,	0,	0E4h,	0D8h,	K$IMM16,	0,	/* CPO */
	0B447h,	7D00h,	0C5h,	0E0h,	K$REG16,	0,	/* PUSH */
	0,	0,	0,	0,	0,		0,	/* */
	0C6FDh,	0,	0D6h,	0F0h,	K$IMM8,		0,	/* SUI */
	61A8h,	0,	0FCh,	0,	K$IMM16,	0,	/* CM */
	0,	0,	0,	0,	0,		0,	/* */
	0,	0,	0,	0,	0,		0,	/* */
	0BFF1h,	0,	0E8h,	0,	K$SINGLE,	0,	/* RPE */
	62A9h,	76C0h,	0,	0,	K$CSEG,		0,	/* CSEG */
	0BE48h,	0,	0C9h,	0,	K$SINGLE,	0,	/* RET */
	876Eh,	0,	4,	0,	K$INRDCR,	0,	/* INR */
	0BEE1h,	0,	20h,	0,	K$SINGLE,	2,	/* RIM */
	0,	0,	0,	0,	0,		0,	/* */
	0B16Ch,	9600h,	0E9h,	0,	K$SINGLE,	0,	/* PCHL */
	988Dh,	0,	3Ah,	0,	K$IMM16,	0,	/* LDA */
	7000h,	0BF90h,	0,	0,	K$EXTRN,	0,	/* EXTRN */
	8774h,	0,	3,	0B0h,	K$REG16,	0,	/* INX */
	61B5h,	0,	2Fh,	0,	K$SINGLE,	0,	/* CMA */
	0,	0,	0,	0,	0,		0,	/* */
	61B7h,	0,	3Fh,	0,	K$SINGLE,	0,	/* CNC */
	0BFFBh,	0,	0E0h,	0,	K$SINGLE,	0,	/* RPO */
	0C6CDh,	0E100h,	2,	70h,	K$LDSTAX,	0,	/* STAX */
	0E5BDh,	0,	0A8h,	0,	K$ARITH,	0,	/* XRA */
	9A5Bh,	0,	0,	0,	K$LOW,		0,	/* LOW */
	6D88h,	0,	0FBh,	0,	K$SINGLE,	0,	/* EI */
	8DE0h,	0,	0F2h,	0,	K$IMM16,	0,	/* JP */
	6676h,	0,	5,	0D0h,	K$INRDCR,	0,	/* DCR */
	6400h,	0,	2,	0,	K$REGNAME,	0,	/* D */
	555Dh,	0,	0A0h,	0,	K$ARITH,	0,	/* ANA */
	0E5C5h,	0,	0EEh,	0,	K$IMM8,		0,	/* XRI */
	8D68h,	0,	0FAh,	0,	K$IMM16,	0,	/* JM */
	5560h,	0,	0,	0,	K$AND,		0,	/* AND */
	5140h,	0,	7,	38h,	K$REGNAME,	0,	/* A */
	0E614h,	9600h,	0E3h,	0,	K$SINGLE,	0,	/* XTHL */
	0,	0,	0,	0,	0,		0,	/* */
	876Ch,	5449h,	1,	0,	K$SPECIAL,	0,	/* INPAGE */
	5565h,	0,	0E6h,	0,	K$IMM8,		0,	/* ANI */
	9B00h,	0,	0,	0,	K$LT,		0,	/* LT */
	8DF1h,	0,	0EAh,	0,	K$IMM16,	0,	/* JPE */
	61C4h,	0,	0B8h,	20h,	K$ARITH,	0,	/* CMP */
	7BC0h,	0,	0,	0,	K$GT,		0,	/* GT */
	6978h,	0,	0,	78h,	K$DW,		0,	/* DW */
	6EC8h,	0,	0,	0,	K$EQ,		0,	/* EQ */
	667Ch,	0,	0Bh,	50h,	K$REG16,	0,	/* DCX */
	6E1Fh,	6A40h,	0,	0A0h,	K$ELSE,		0,	/* ELSE */
	0A6D4h,	0,	0,	0,	K$SINGLE,	0,	/* NOP */
	9F01h,	0AD95h,	0,	0,	K$SPECIAL,	1Ch,	/* MEMORY */
	5FE0h,	9600h,	0CDh,	0,	K$IMM16,	0,	/* CALL */
	0BDD8h,	0,	0D8h,	0,	K$SINGLE,	0,	/* RC */
	53ADh,	0,	0CEh,	80h,	K$IMM8,		0,	/* ACI */
	0BF9Fh,	0,	0D0h,	0,	K$SINGLE,	0,	/* RNC */
	0E36Ch,	76C0h,	0EBh,	0,	K$SINGLE,	0,	/* XCHG */
	8DFBh,	0,	0E2h,	0,	K$IMM16,	0,	/* JPO */
	68D8h,	0,	0,	0,	K$DS,		0,	/* DS */
	0C620h,	0,	6,	0,	K$SP,		0,	/* SP */
	9C40h,	0,	6,	0,	K$REGNAME,	0,	/* M */
	98A8h,	0,	0,	38h,	K$LE,		0,	/* LE */
	6018h,	0,	0DCh,	0,	K$IMM16,	0,	/* CC */
	7D00h,	0,	4,	50h,	K$REGNAME,	0,	/* H */
	61DFh,	0,	0D4h,	50h,	K$IMM16,	0,	/* CNC */
	0C4F8h,	0,	0,	0,	K$SHL,		0,	/* SHL */
	5DC0h,	0,	1,	0,	K$REGNAME,	0,	/* C */
	0C170h,	0,	0C8h,	0,	K$SINGLE,	0,	/* RZ */
	0E556h,	0,	0,	0,	K$XOR,		0,	/* XOR */
	7968h,	0,	0,	0,	K$GE,		0,	/* GE */
	0A6D8h,	0,	0,	0,	K$NOT,		0,	/* NOT */
	0C4FEh,	0,	0,	0,	K$SHR,		0,	/* SHR */
	9BB5h,	0,	1,	0,	K$LXI,		0,	/* LXI */
	8D84h,	0,	0C3h,	0,	K$IMM16,	0,	/* JMP */
	0C03Fh,	0,	0Fh,	0,	K$SINGLE,	0	/* RRC */
);


end;
start.plx
start: do;
$IF BASE
$include(asm801.ipx)
$ELSEIF OVL4
$include(asm41.ipx)
$ELSE
$include(asm51.ipx)
$ENDIF

$IF BASE
declare CHKOVL$0 lit	'call OvlMgr(0)',
	CHKOVL$1 lit	'call OvlMgr(1)',
	CHKOVL$2 lit	'call OvlMgr(2)',
	CHKOVL$3 lit	'call OvlMgr(3)';
$ELSE
declare CHKOVL$0 lit	' ',
	CHKOVL$1 lit	' ',
	CHKOVL$2 lit	' ',
	CHKOVL$3 lit	' ';
$ENDIF

$IF OVL4
declare w$3780 address public data(0),
	b$3782 byte public data(80h),
	b$3783 byte public data(81h);
$ENDIF

declare	spaces24(*) byte public data('         '),
	spaces15(*) byte public data('         '),
	spaces6(*) byte public data(' '),
	spaces5(*) byte public data(' '),
	spaces4(*) byte public data('  '),
	spaces2(*) byte public data('  ', 0),
	ascCRLF(*) byte public data(CR, LF, 0),
	signonMsg(*) byte public data(CR, LF),
	asmHeader(*) byte public data('ISIS-II 8080/8085 MACRO ASSEMBLER, V4.1', TAB, TAB),
	aModulePage(*) byte public data('MODULE ', TAB, ' PAGE ', 0),
	bZERO byte public data(0),
	bTRUE byte public data(TRUE),
	copyright(*) byte data('(C) 1976,1977,1979,1980 INTEL CORP'),
	aStack(*) byte public data(CR, LF, 'STACK', 0),
	aTable(*) byte public data(CR, LF, 'TABLE', 0),
	aCommand(*) byte public data(CR, LF, 'COMMAND', 0),
	aEof(*) byte public data(CR, LF, 'EOF', 0),
	aFile(*) byte public data(CR, LF, 'FILE', 0),
	aMemory(*) byte public data(CR, LF, 'MEMORY', 0),
	aError(*) byte public data(' ERROR', CR, LF, 0),
	aError$0(*) byte public data(' ERROR, ', CR,LF, 0),
	errStrs(*) address public data(.aStack, .aTable, .aCommand, .aEof, .aFile, .aMemory),
	errStrsLen(*) byte public data(7, 7, 9, 5, 6, 8),
	aBadSyntax(*) byte public data('BAD SYNTAX', CR, LF),
	aCo(*) byte public data(':CO:', 0);

$IF BASE
declare	loadedOvl byte initial(4),
	ovlFile(*) byte public initial(':F0:ASM80.OV0 ');
$ENDIF

Physmem: procedure address public;
	declare top address at(4);

	return (top - 100h) and 0FF00h;
end;


GetCmdCh: procedure byte public;
	declare cmdch based cmdch$p byte;
	declare ch byte;

	ch = cmdch;
	cmdch$p = cmdch$p + 1;
	if 'a' <= ch and ch <= 'z' then
		ch = ch and 5Fh;
	return ch;
end;	


IoErrChk: procedure public;
	if statusIO = 0 then
		return;
	call Error(statusIO);
	call Exit;
end;


Flushout: procedure public;
	call Write(outfd, .outbuf, out$p - .outbuf, .statusIO);
	out$p = .outbuf;
end;

Outch: procedure(c) public;
	declare c byte;
	declare outc based out$p byte;

	if out$p = endOutBuf then
		call Flushout;
	outc = c;
	out$p = out$p + 1;
end;

OutStrN: procedure(s, n) public;
	declare s pointer, n byte;
	declare ch based s byte;

	do while n > 0;
		call Outch(ch);
		s = s + 1;
		n = n - 1;
	end;
end;

$IF BASE
OvlMgr: procedure(ovl) public;
	declare ovl byte;
	declare entry$p address;

	if ovl > 4 then
	do;
		statusIO = 0Dh;
		call IoErrChk;
	end;
	if ovl <> loadedOvl then
	do;
		ovlFile(12) = ovl + '0';
		call Load(.ovlFile, 0, 0, .entry$p, .statusIO);
		call IoErrChk;
		loadedOvl = ovl;
	end;
end;
$ENDIF

CloseF: procedure(conn) public;
	declare conn address;

	call Close(conn, .statusIO);
end;

IsSpace: procedure byte public;
	return curChar = ' ';
end;

IsTab: procedure byte public;
	return curChar = TAB;
end;

IsWhite: procedure byte public;
	return IsSpace or IsTab;
end;

IsRParen: procedure byte public;
	return curChar = ')';
end;

IsCR: procedure byte public;
	return curChar = CR;
end;

IsComma: procedure byte public;
	return curChar = ',';
end;

$IF OVL4
IsLT: procedure byte public;
	return curChar = '<';
end;


IsGT: procedure byte public;
	return curChar = '>';
end;

$ENDIF

IsPhase1: procedure byte public;
	return phase = 1;
end;

Skip2EOL: procedure public;
	if not IsCR then
		do while GetCh <> 0Dh;
		end;
end;


ChkGenObj: procedure byte public;
$IF BASE
	return (phase > 2) and ctlOBJECT;
$ELSE
	return (phase = 2) and ctlOBJECT;
$ENDIF
end;


IsPhase2Print: procedure byte public;
	return phase = 2 and ctlPRINT;
end;


WrConsole: procedure(buf$p, count) public;
	declare (buf$p, count) address;

	call Write(0, buf$p, count, .statusIO);
	call IoErrChk;
end;


RuntimeError: procedure(errCode) public;
	declare errCode byte;

	if b6BD9 then
		return;

	if IsPhase1 and errCode = 0 then
	do;
		b6B33 = TRUE;
		return;
	end;

	w6BE0 = .aError;		/* assume " ERROR\r\n" */
	if errCode = 4 then		/* file Error */
		w6BE0 = .aError$0;	/* replace with " ERROR, " */

	call WrConsole(errStrs(errCode), errStrsLen(errCode));	/* Write the ERROR type */
	call WrConsole(w6BE0, 8);	/* Write the ERROR string */
	if IsPhase2Print then		/* repeat to the print file if required */
	do;
		call OutStrN(errStrs(errCode), errStrsLen(errCode));
		call OutStrN(w6BE0, 8);
	end;

	if errCode = 4 or errCode = 3 then	/* file or EOF Error */
	do;
		if tokBufIdx = 0 then
		do;
			call WrConsole(.aBadSyntax, 12);
			if not scanCmdLine then
			do;
				call Skip2NextLine;
				outfd = 0;
				CHKOVL$1;
				call PrintDecimal(srcLineCnt);	/* overlay 1 */
				call Outch(LF);
			end;
		end;
		else
		do;
			call WrConsole(curFileName$p, tokBufIdx);
			call WrConsole(.ascCRLF, 2);
		end;
	end;

	if errCode = 0 then	/* stack Error */
	do;
		b6BD9 = TRUE;
		return;
	end;

	call Exit;
end;

IoError: procedure(s) public;
	declare s pointer;
	declare ch based s byte;

	tokBufIdx = 0;
	curFileName$p = s;

	do while ch <> ' ' and ch <> CR and ch <> TAB;
		tokBufIdx = tokBufIdx + 1;
		s = s + 1;
	end;
	if missingEnd then
		call RuntimeError(3);	/* EOF Error*/
	call RuntimeError(4);		/* file Error */
end;

InOpen: procedure(path$p, access) address public;
	declare (path$p, access) address;
	declare Open$infd address;

	call Open(.Open$infd, path$p, access, 0, .openStatus);
	if openStatus <> 0 then
		call IoError(path$p);
	return Open$infd;
end;


Nibble2Ascii: procedure(n) byte public;
	declare n byte;
	n = (n and 0Fh) + '0';
	if n > '9' then
		n = n + 7;
	return n;
end;

Put2Hex: procedure(pfunc, val) public;
	declare pfunc address, val byte;

	call pfunc(Nibble2Ascii(ror(val, 4)));
	call pfunc(Nibble2Ascii(val));
end;

BlankAsmErrCode: procedure byte public;
	return asmErrCode = ' ';
end;

BlankMorPAsmErrCode: procedure byte public;
	return BlankAsmErrCode or asmErrCode = 'M' or asmErrCode = 'P';
end;


GetNibble: procedure(bp, idx) byte public;
	declare bp pointer, idx byte;
	declare b based bp byte;
	declare n byte;

	bp = bp + shr(idx, 1);	/* index into buffer the number of nibbles */
	n = b;			/* pick up the byte there */
	if not idx then		/* pick up the right nibble */
		n = ror(n, 4);
	return n and 0Fh;	/* mask to leave just the nibble */
end;

SourceError: procedure(errCh) public;
	declare errCh byte;

	if not IsSkipping or leftOp = K$ELSE then	/* ELSE */
	do;
		if inExtrn then
			badExtrn = TRUE;
		if BlankAsmErrCode then
			errCnt = errCnt + 1;

		if BlankMorPAsmErrCode or errCh = 'L' or errCh = 'U' then	/* no Error or M, P L or U */
			if asmErrCode <> 'L' then	/* override unless already location counter Error */
				asmErrCode = errCh;

	end;
end;

$IF OVL4

Sub3D34: procedure(c) public;
	declare c byte;
	declare ch based w906A byte;

	ch = c;
	if (w906A := w906A + 1) > w6870 then
		call RuntimeError(1);	/* table Error */
end;


Sub3D55: procedure(c) public;
	declare c byte;

	call Sub3D34(c);
	if c = CR then
		call Sub3D34(LF);
end;

$ENDIF


ParseControlLines: procedure public;

	do while GetCh = '$';
		if IsSkipping then
		do;
			call Skip2NextLine;
			isControlLine = TRUE;
$IF OVL4
			if b905E = 1 then
				b6897 = TRUE;
$ENDIF
		end;
		else
		do;
			CHKOVL$0;
			call ParseControls;
		end;
		call FinishLine;
	end;
	reget = 1;
end;


InitialControls: procedure public;
	cmdch$p = controls$p;
	scanCmdLine = TRUE;
	CHKOVL$0;
	call ParseControls;
	if IsPhase2Print then
	do;
		CHKOVL$1;
		call PrintCmdLine;
	end;
	if needToOpenFile then
		call OpenSrc;

	needToOpenFile, isControlLine, scanCmdLine = bZERO;
	call ParseControlLines;			/* initial control lines allow primary controls */
	primaryValid = FALSE;			/* not allowed from now on */
	ctlDEBUG = ctlDEBUG and ctlOBJECT;	/* debug doesn't make sense if no object code */
	ctlXREF = ctlXREF and ctlPRINT;		/* disable controls if not printing */
	ctlSYMBOLS = ctlSYMBOLS and ctlPRINT;
	ctlPAGING = ctlPAGING and ctlPRINT;
end;


InitLine: procedure public;
	startLine$p = inCh$p + 1;	
	lineChCnt = 0;
	if needToOpenFile then
		call OpenSrc;

	lineNumberEmitted, has16bitOperand, isControlLine, errorOnLine, lhsUserSymbol,
	inExpression, expectingOperands, b6881, gotLabel, rhsUserSymbol,
	inDB, inDW, b6B32, showAddr, b6884,
$IF OVL4
	b9059, b9060, 
$ENDIF
	needsAbsValue = bZERO;

	atStartLine, expectingOpcode, b6B34, inParen = bTRUE;
	ctlEJECT, hasVarRef, tokenIdx,
$IF OVL4
	b9058, argNestCnt,
$ENDIF
	tokenSize(0), tokenType(0), acc1ValType, acc2ValType, inComment, acc1Flags = bZERO;

	asmErrCode = ' ';
$IF OVL4
	macro$p = .macroLine;
	w919D = w906A;
	expandingMacro = expandingMacro > 0;
$ENDIF
	tokI = 1;
	srcLineCnt = srcLineCnt + 1;
$IF OVL4
	macro$p = .macroLine;
$ENDIF
	skipping(0) = skipping(0) > 0;
end;


start:
	call GetAsmFile;
	phase = 1;
	call ResetData;
	call InitialControls;
$IF BASE
	if ctlMACROFILE then
	do;
		if Physmem < 8001h then
			call RuntimeError(5);	 /* memory Error */
		if srcfd <> rootfd then
			call CloseF(srcfd);
		call CloseF(infd);
		ovlFile(12) = '4';		/* use macro asm version */
		call Load(.ovlFile, 0, 1, 0, .statusIO);
		call IoErrChk;
	end;
	if Physmem > 8001h then
	do;
		if srcfd <> rootfd then
			call CloseF(srcfd);
		call CloseF(infd);
		ovlFile(12) = '5';		/* use big memory asm version */
		call Load(.ovlFile, 0, 1, 0, .statusIO);
		call IoErrChk;
	end;

	if MacroDebugOrGen then			/* attempt to use macro features */
		call RuntimeError(2);		/* command Error */
$ELSEIF OVL4
	macrofd = InOpen(.asmax$ref, 3);
$ENDIF

	if ctlOBJECT then
	do;
		call Delete(.objFile, .statusIO);
		objfd = InOpen(.objFile, 3);
	end;

	if ctlXREF then
	do;
		xreffd = InOpen(.asxref$tmp, 2);
		outfd = xreffd;
	end;

	call DoPass;
	phase = 2;
	if ctlOBJECT then
	do;
		CHKOVL$2;	/* for small version Load in overlay 2 for writeRec & WriteModhdr */
		if r$extnames1.len > 0 then
			call WriteRec(.r$extnames1);	/* in overlay 2 */

		if externId = 0 then
			call WriteModhdr;		/* in overlay 2 */
$IF NOT BASE
		call InitRecTypes;
$ENDIF
	end;
$IF BASE
	if not ctlOBJECT or ctlPRINT then
$ENDIF
	do;
		if ctlPRINT then
			outfd = InOpen(.lstFile, 2);
		CHKOVL$3;
		call ResetData;
		call InitialControls;
		call DoPass;
	end;
	if ctlPRINT then
	do;
		CHKOVL$1;
		call AsmComplete;
		call Flushout;
	end;

	if ctlOBJECT then
	do;
$IF BASE
		phase = 3;
		CHKOVL3;
		call ResetData;
		call InitRecTypes;
		call InitialControls;
		call DoPass;
		CHKOVL2;
$ENDIF
		call Ovl11;
		call WriteModend;
	end;

	if not StrUCequ(.aCo, .lstFile) then
	do;
		CHKOVL$1;
		call Ovl9;
	end;
	CHKOVL$1;
	call Ovl10;
end;

asm4382.plx
asm43$82:
do;
$IF OVL4
$include(asm43.ipx)
$ELSE
$include(asm82.ipx)
$ENDIF

			/* 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
declare b3E5E(*) byte data(0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			   0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
			   0, 0),
	b3EA0(*) byte data(36h, 0, 0, 0, 6, 0, 0, 2),
		/* bit vector 55 -> 0 x 24 00000110 0 x 16 0000001 */
		/* 29, 30, 55 */
			/* 0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F */
	b3EA8(*) bool data(0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
		 	   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0FFh,0,   0,   0FFh,
			   0,   0FFh,0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
			   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0FFh,0FFh,0FFh,0,   0FFh,0,
			   0,   0);
	/* true for DS, ORG, IF, 3A?, IRP, IRPC REPT */ 
$IF OVL4
declare	b$3F88(*) byte data(41h, 90h, 0, 0, 0, 0, 0, 0, 0, 40h);
	/* bit vector 66 -> 10010000 0 x 56 01 */

SkipWhite$2: procedure public;
	do while GetCh = ' ' or IsTab;
	end;
end;


Sub3FA9: procedure byte public;
	declare w9B5A pointer,
		wrd based w9B5A address;

	w9B5A = curTokenSym$p - 6;
	return (wrd < 4679h) or ctlMACRODEBUG or (4682h < wrd);
end;



SeekM: procedure(blk);
	declare blk address;

	if (w6BE0 := blk - nxtMacroBlk) <> 0 then
	do;
		kk = SEEKFWD;
		if blk < nxtMacroBlk then
		do;
			w6BE0 = - w6BE0;
			kk = SEEKBACK;
		end;

		call Seek(macrofd, kk, .w6BE0, .w$3780, .statusIO);
		call IoErrChk;
	end;
	nxtMacroBlk = blk + 1;
end;



ReadM: procedure(blk) public;
	declare blk address;
	declare actual address;

	if blk >= maxMacroBlk then
		actual = 0;
	else if blk = curMacroBlk then
		return;
	else
	do;
		call SeekM(blk);
		call Read(macrofd, .macroBuf, 128, .actual, .statusIO);
		call IoErrChk;
	end;

	tmac$blk, curMacroBlk = blk;
	macroBuf(actual) = 0FEh;	/* flag end of macro buffer */
end;


WriteM: procedure public;
	if phase = 1 then
	do;
		call SeekM(maxMacroBlk);
		maxMacroBlk = maxMacroBlk + 1;
		call Write(macrofd, symHighMark, 128, .statusIO);
		call IoErrChk;
	end;
	macroBlkCnt = macroBlkCnt + 1;
end;



Sub40B9: procedure public;
	declare w9B62 address;

	if b905E then
	do;
		do while (w9B62 := w906A - symHighMark) >= 128;
			call WriteM;
			symHighMark = symHighMark + 128;
		end;
		if w9B62 <> 0 then
			call move(w9B62, symHighMark, endSymTab(2));
		w906A = (symHighMark := endSymTab(2)) + w9B62;
	end;
end;

$ENDIF

SkipWhite: procedure public;
	do while IsWhite;
		curChar = GetCh;
	end;
end;


$IF BASE
SkipWhite$2: procedure public;
	do while GetCh = ' ' or IsTab;
	end;
end;
$ENDIF

Skip2NextLine: procedure public;
	call Skip2EOL;
	call ChkLF;
end;



TokeniseLine: procedure public;

	Sub416B: procedure;
		if rightOp = O$NONE then
			call ExpressionError;
		inExpression = 0;
		rightOp = O$NONE;
	end;


    do while 1;
	if atStartLine then
	do;
		call ParseControlLines;
		atStartLine = 0;
	end;

	do case GetChClass;
        case0:	call IllegalCharError;		/* CC$BAD */
		;				/* CC$WS */
		do;				/* CC$SEMI */
$IF OVL4
			if not b9058 then
$ENDIF
			do;
				inComment = TRUE;
$IF OVL4
				if GetChClass = CC$SEMI and b905E then
				do;
					b9059 = TRUE;
					w906A = w906A - 2;
				end;
$ENDIF
				call Skip2NextLine;
				effectiveToken = T$CR;
				return;
			end;
		end;
		do;				/* CC$COLON */
			if not gotLabel then
			do;
				if skipping(0)
$IF OVL4
				   or b905E
$ENDIF
				then
					call PopToken;
				else
				do;
					labelUse = 2;
					call Sub5819$5CE8(segSize(activeSeg), 2);
				end;

				expectingOperands = FALSE;
				gotLabel, expectingOpcode = bTRUE;
			end;
			else
			do;
				call SyntaxError;
				call PopToken;
			end;

			call EmitXref(0, .name);
			rhsUserSymbol = FALSE;
			rightOp = O$LABEL;
		end;
		do;				/* CC$CR */
			call ChkLF;
			effectiveToken = T$CR;
$IF OVL4
			b9058 = 0;
$ENDIF
			return;
		end;
		do;				/* CC$PUNCT */
			if curChar = '+' or curChar = '-' then
$IF OVL4
				if not TestBit(rightOp, .b$3F88) then /* not 0, 3 or 41h */
$ELSE
				if rightOp <> O$NONE and rightOp <> T$RPAREN then
$ENDIF
					curChar = curChar + (T$UPLUS - T$PLUS);	/* make unary versions */
			effectiveToken = curChar - '(' + T$LPAREN;
			return;
		end;
		do;				/* CC$DOLLAR */
			call PushToken(O$NUMBER);
			call CollectByte(low(segSize(activeSeg)));
			call CollectByte(high(segSize(activeSeg)));
			if activeSeg <> SEG$ABS then
				tokenAttr(0) = tokenAttr(0) or activeSeg or 18h;
			call Sub416B;
		end;
		do;				/* CC$QUOTE */
$IF OVL4
			if effectiveToken = 37h then
			do;
				call IllegalCharError;
				return;
			end;
			if b905E then
				b9058 = not b9058;
			else
$ENDIF
			do;
				call GetStr;
				if expectingOpcode then
					call SetExpectOperands;
				call Sub416B;
			end;
		end;
		do;				/* CC$DIGIT */
			call Atoi;
			if expectingOpcode then
				call SetExpectOperands;
			call Sub416B;
		end;
		do;				/* CC$LET */
$IF OVL4
			w919F = w906A - 1;
$ENDIF
			call GetId(O$ID);	/* assume it's an id */
			if tokenSize(0) > 6 then	/* cap length */
				tokenSize(0) = 6;

			if ctlXREF then
			do;
				call move(6, .name, .savName);
				call move(6, .spaces6, .name);
			end;
			/* copy the token to name */
			call move(tokenSize(0), tokPtr, .name);
			nameLen = tokenSize(0);
			call PackToken;		/* make into 4 byte name */
			if rhsUserSymbol then
			do;
				lhsUserSymbol = TRUE;
				rhsUserSymbol = FALSE;
			end;


$IF OVL4
			if Lookup(2) <> O$ID and b905E then
			do;
				if not b9058 or (kk := tokenType(0) = 0) and (curChar = '&' or byteAt(w919F-1) = '&') then
				do;
					w906A = w919F;
					call Sub3D55(kk + 81h);
					call Sub3D34(GetNumVal);
					call Sub3D55(curChar);
					effectiveToken = O$ID;
				end;
			end;
			else if effectiveToken <> O$37 and not b905E = 2 then
$ENDIF
			do;
				if Lookup(0) = O$ID then		/* not a key word */
				do;
					tokenType(0) = Lookup(1);	/* look up in symbol space */
					rhsUserSymbol = TRUE;		/* note we have a used symbol */
				end;

				effectiveToken = tokenType(0);
				needsAbsValue = b3EA8(tokenType(0));		/* DS, ORG, IF, O$3A, IRP, IRPC REPT */
				if not b3E5E(tokenType(0)) then		/* i.e. not instruction, reg or O$37 or 1,2,3,4,6,A */
					call PopToken;

				if lhsUserSymbol then
				do;			   /* EQU, SET or O$37 */
					call EmitXref((not TestBit(effectiveToken, .b3EA0)) and 1, .savName);
					lhsUserSymbol = FALSE;
				end;
			end;
$IF OVL4
			if b905E = 1 then
			do;
				if effectiveToken = K$LOCAL then
				do;
					b905E = 2;
					if b6897 then
						call SyntaxError;
					b6897 = FALSE;
				end;
				else
				do;
					b6897 = FALSE;
					b905E = 0FFh;
				end;
			end;

			if effectiveToken = K$NUL then
				call PushToken(40h);
$ENDIF
			if effectiveToken < 10 or effectiveToken = 9 or 80h then /* !! only first term contributes */
			do;
				call Sub416B;
				if expectingOpcode then
					call SetExpectOperands;
			end;
			else
			do;
				expectingOpcode = FALSE;
				return;
			end;
		end;
$IF OVL4
		do;				/* 10? */
			b6BDA = FALSE;
			call Sub73AD;
			if b6BDA then
				return;
		end;
		do;				/* CC$ESC */
			if expandingMacro then
			do;
				skipping(0) = FALSE;
				effectiveToken = 40h;
				return;
			end;
			else
				goto case0;
		end;
$ENDIF
	end;
    end;
end;

end;
as4483.plx
as4483: do;

/* force the non standard code generation of outStrN and put2Hex */

OutStrN: procedure(s, n) external; declare s address, n address; end;
$IF OVL4
Put2Hex: procedure(arg1w, arg2w) external; declare arg1w address, arg2w address; end;
$include(asm44.ipx)
$ELSE
$include(asm83.ipx)
$ENDIF
/* 
	0	-> ?
	1	-> start single word expression
	5	-> single byte opcode no operand
	7	-> reg operand
	0Fh	-> binary leftOp
	0Dh	-> unary leftOp
	17h	-> IMM8 operand
	37h	-> imm16 operand
	40h	-> ? start byte list
	47h	-> 2 operand leftOp
	4Dh	-> start word list
	80h	-> end expression
	81h	-> rept operand
	0C0h	-> local operand

	-------x	-> getnum to acc1 & copy to acc2
	------x-	-> getnum to acc1
	-----x--	-> collect low(acc1)
	----x---	-> collect high(acc1)
	---x----	-> collect low(acc2)
	--x-----	-> collect high(acc2)
	-x------	-> list
*/

				/* 0   1    2    3    4    5    6    7    8    9    A    B    C    D    E    F */
declare b4181(*) byte public data(0, 80h,   0,   0, 0Fh, 0Fh, 80h, 0Fh, 0Dh, 0Fh, 0Dh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh,
				0Fh, 0Dh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Dh, 0Dh, 40h, 4Dh,   1,   1,   1,   1,
				80h,   1,   0,   0, 47h,   7,   7,   7, 17h, 47h,   7, 47h, 37h,   5,   7,   0,
				  0,   0, 40h, 40h,   0,   1
$IF OVL4
							    , 80h, 40h, 80h,   0, 40h, 80h, 80h, 40h, 81h,0C0h,
				80h, 0Dh
$ENDIF
			   ),

	b41B7(*) byte data(41h, 0, 0, 0, 19h, 40h, 0, 1Ch, 0, 0),
		/* bit vector 66 -> 0 x 24 00011001 01000000 00000000 00011100 00000000 00 */
	b41C1(*) byte data(1Ah, 5, 80h, 0, 0C0h),
		/* bit vector 27 -> 00000101 10000000 00000000 110 */
	opCompat(*) byte data(57h, 71h, 0F4h, 57h, 76h, 66h, 66h, 67h, 77h, 77h, 77h, 55h),
		/* bit vector 88 -> 01110001 11110100 01010111 01110110
                                    01100110 01100110 01100111 01110111
				    01110111 01110111 01010101 */
	propagateFlags(*) byte data(57h, 6, 2, 20h, 0, 0, 0, 0, 0, 0, 0, 22h),
		/* bit vector 88 -> 00000110 00000010 00100000 00000000
				    00000000 00000000 00000000 00000000
				    00000000 00000000 00100010 */ 
	b41DE(*) byte data(3Ah, 0FFh, 80h, 0, 0, 0Fh, 0FEh, 0, 20h),
		/* bit vector 59 -> 11111111 10000000 00000000 00000000
				    00001111 11111110 00000000 001 */
		/* O$NONE, T$CR, T$LPAREN, T$RPAREN/O$LABEL, T$STAR, T$PLUS/K$SPECIAL, T$COMMA, */
		/* T$MINUS/K$REGNAME, T$UPLUS/K$SP */
		/* K$LXI, K$REG16, K$LDSTAX, K$ARITH, K$IMM8, K$MVI, K$INRDCR. K$MOV, K$IMM16, K$SINGLE */
		/* K$RST
/* precedence table */
/*
   10 - NULL
    9 - HIGH, LOW
    8 - *, /, MOD, SHL, SHR
    7 - +, -, UPLUS, UMINUS
    6 - =, <, <=, >, >=, <>
    5 - NOT
    4 - AND
    3 - OR, XOR,
    2 - not used
    1 - COMMA, DB - STKLEN, O$37, ENDM, EXITM, O$3D, REPT, LOCAL
    0 - all others
*/
			     /* 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
	precedence(*) byte data(0, 0, 0, 0, 8, 7, 1, 7, 7, 8, 7, 6, 6, 6, 6, 6,
				6, 5, 4, 3, 3, 8, 8, 8, 9, 9, 1, 1, 1, 1, 1, 1,
				1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
				1, 1, 1, 1, 1, 1
$IF OVL4
	       /* for macro ver */ 		, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1,
				0, 0Ah
$ENDIF
			   );


TestBit: procedure(bitIdx, bitVector) bool public;
	declare bitIdx byte, bitVector pointer;
	declare ch based bitVector byte;

	if ch < bitIdx then
		return FALSE;
	
	bitVector = bitVector + shr(bitIdx, 3) + 1;
	return (ch and ROR(1, (bitIdx and 7) + 1)) <> 0;
end;

IsReg: procedure(leftOp) bool public;
	declare leftOp byte;

	return leftOp = K$REGNAME or leftOp = K$SP;
end;

Sub4274: procedure public;
	if TestBit(leftOp, .b41B7) then
		if IsReg(acc1ValType) then
			call OperandError;
end;

Sub4291: procedure public;
	if IsReg(acc1ValType) then
		call OperandError;
	if (b4181(leftOp) and 2) = 0 then
		acc2Flags = 0;
	else if IsReg(acc2ValType) then
		call OperandError;

	acc1ValType = O$NUMBER;
	accFixFlags(0) = (acc1Flags and UF$BOTH) <> 0;
	accFixFlags(1) = (acc2Flags and UF$BOTH) <> 0;
	if (acc1Flags and UF$SEGMASK) <> SEG$ABS then
		if (acc2Flags and UF$SEGMASK) <> SEG$ABS then
			if ((acc1Flags xor acc2Flags) and 1Fh) <> 0 then
				call ExpressionError;
	if (ii := (acc1Flags and UF$EXTRN) <> 0) or (jj := (acc2Flags and UF$EXTRN) <> 0) then
	do;
		if leftOp = K$SPECIAL then	/* +? (PAGE INPAGE)? */
			if not (ii or accFixFlags(0)) then
			do;
				acc1NumVal = acc2NumVal;
				acc1Flags = acc2Flags;
				return;
			end;
		if jj or accFixFlags(1) or not TestBit(leftOp, .b41C1) then
			goto L4394;
		else
			return;
	end;
	kk = shl(leftOp - 4, 2) or (accFixFlags(0) and 2) or (accFixFlags(1) and 1);
	if TestBit(kk, .opCompat) then
L4394:	do;
		call ExpressionError;
		acc1Flags = 0;
		return;
	end;
	if TestBit(kk, .propagateFlags) then
	do;
		if not accFixFlags(0) then
			acc1Flags = acc2Flags;
		return;
	end;
	acc1Flags = 0;
end;


SwapAccBytes: procedure public;
	declare tmp byte;
	tmp = accum1$lb;
	accum1$lb = accum1$hb;
	accum1$hb = tmp;
end;



SetExpectOperands: procedure public;
	expectingOperands = TRUE;
	expectingOpcode = FALSE;
end;



GetNumVal: procedure address public;
	declare tokByte based tokPtr (1) byte,	/* and high byte if not a register */
		val$p pointer,
		val based val$p address;
$IF OVL4
	LogError: procedure(arg1b);
		declare arg1b byte;

		if tokenType(tokenIdx) <> 40h then
		do;
			call SourceError(arg1b);
			return;
		end;
		if tokenSize(0) = 0 then
			tokenType(tokenIdx) = 41h;
	end;
$ENDIF

	acc1Flags = 0;
	accum1 = 0;
	acc1ValType = O$ID;
$IF OVL4
	if tokenType(0) = 40h then
		call PushToken(0Dh);
$ENDIF
	if tokenIdx = 0 or tokenType(0) = O$DATA and not b6B36 then
$IF OVL4
		call LogError('Q');
$ELSE
		call SyntaxError;
$ENDIF
	else
	do;
		if tokenType(0) = O$ID or tokenType(0) = T$COMMA then
$IF OVL4
			call LogError('U');
$ELSE
			call UndefinedSymbolError;
$ENDIF
		else
		do;
			acc1ValType = tokenType(0);
			if TestBit(acc1ValType, .b41DE) then
			do;
				tokPtr = curTokenSym$p + 7;	/* point to flags */
				acc1Flags = tokByte(0) and 0DFh;
				tokPtr, val$p = curTokenSym$p + 4;
				acc1NumVal = val;			/* pick up value */
				tokenSize(0) = 2;

			end;
			else if tokenSize(0) = 0 then
$IF OVL4
				call LogError('V');
$ELSE
				call ValueError;
$ENDIF
			else
			do;
				if tokenSize(0) > 2 then
$IF OVL4
					call LogError('V');
$ELSE
					call ValueError;
$ENDIF
				acc1Flags = tokenAttr(0) and 0DFh;
				acc1NumVal = tokenSymId(0);
			end;

			if tokenSize(0) > 0 then	/* get low byte */
				accum1$lb = tokByte(0);
			if tokenSize(0) > 1 then	/* and high byte if not a register */
				accum1$hb = tokByte(1) and tokenType(0) <> 7;
		end;	

		if has16bitOperand then
			if tokenSize(0) = 2 then
				if tokenType(0) = O$STRING then
					call SwapAccBytes;

		if (acc1Flags and 40h) <> 0 then
			if tokenType(0) < 9 then
				accum1 = 0;

		call PopToken;
	end;

	b6B36 = FALSE;
	return accum1;
end;


GetPrec: procedure(leftOp) byte public;
	declare leftOp byte;
	return precedence(leftOp);
end;

/*
   arg1b
   xxxx1xxx	single byte arg
   xxxxx11x	acc1 = acc1 | (acc2 << 3) 
   xxxxx01x	acc1 = acc1 | acc2
   
*/   
MkCode: procedure(arg1b) public;
	declare arg1b byte;

	if (arg1b and 3) <> 0 then
	do;
		if accum2$hb <> 0
		   or accum2$lb > 7
		   or arg1b and accum2$lb
		   or (arg1b and 3) = 3 and accum2$lb > 2
		   or (not IsReg(acc2ValType) and leftOp <> K$RST) then    /* RST */
			call OperandError;
		else if IsReg(acc2ValType) and leftOp = K$RST then	     /* RST */
			call OperandError;
		if ror(arg1b, 2) then
			accum2$lb = rol(accum2$lb, 3);
		accum1$lb = accum1$lb or accum2$lb;
	end;
	else if leftOp <> K$SINGLE then		/* single byte leftOp */
		if IsReg(acc2ValType) then
			call OperandError;

	if shr(arg1b, 3) then
	do;
		if (acc2Flags and UF$BOTH) = UF$BOTH then
		do;
			call ValueError;
			acc2Flags = acc2Flags and 0E7h or UF$LOW;
		end;
		if accum2$hb + 1 > 1 then	/* Error if not FF or 00 */
			call ValueError;
	end;
	if leftOp = K$IMM8 or leftOp = K$IMM16 then	/* Imm8 or imm16 */
	do;
		acc1Flags = acc2Flags;
		acc1NumVal = acc2NumVal;
	end;
	else
		acc1Flags = 0;

	if leftOp <> K$SINGLE then		     /* single byte leftOp */
		if accum1$lb = 76h then	     /* mov m,m is actually Halt */
			call OperandError;
	if (leftOp := shr(arg1b, 4) + 24h) = 24h then
		b6B2D = O$DATA;
end;

NxtTokI: procedure byte public;
	if tokI >= tokenIdx then
		return 0;
	return (tokI := tokI + 1);
end;



ShowLine: procedure byte public;
	return ((not isControlLine) and ctlLIST or ctlLISTChanged and isControlLine)
$IF OVL4
	        and (not (expandingMacro > 1) or ctlGEN)
$ENDIF
		and (not(b6B32 or skipping(0)) or ctlCOND);
end;

/*
	xrefMode= 0 -> defined
		= 1 -> used
		= 2 -> finalise
*/
EmitXref: procedure(xrefMode, name) public;
	declare xrefMode byte, name address;
	declare (i, byteval) byte;
	declare (srcLineLow, srcLineHigh) byte at(.srcLineCnt);

	if not IsPhase1 or not ctlXREF or IsSkipping and not b6881 then
		return;

	call Outch(xrefMode + '0');
	if xrefMode <> 2 then	/* not finalise */
	do;
		call OutStrN(name, 6);
		b6881 = FALSE;
		byteval = srcLineHigh;	/* high byte */
		i = 0;
		do while i < 4;
			i = i + 1;
			if i then	/* high nibble ? */
			do;
				if i = 3 then	/* get low byte */
					byteval = srcLineLow;
				/* emit high nibble */
				call Outch(Nibble2Ascii(shr(byteval, 4)));
			end;
			else	/* emit low nibble */
				call Outch(Nibble2Ascii(byteval));
		end;
	end;
	else	/* finalise */
	do;
		call OutStrN(.lstFile, 15);
		if ctlPAGING then
			call Outch('1');
		else
			call Outch('0');

		call Outch(Nibble2Ascii(ror(ctlPAGELENGTH, 4)));
		call Outch(Nibble2Ascii(ctlPAGELENGTH));
		call Outch(Nibble2Ascii(ror(ctlPAGEWIDTH, 4)));
		call Outch(Nibble2Ascii(ctlPAGEWIDTH));
		call Outch('3');
		call Flushout;
		call CloseF(xreffd);
	end;
end;
end;
as4555851.plx
asm45$55$851:
do;
$IF OVL4
$include(asm45.ipx)
$ELSEIF OVL5
$include(asm55.ipx)
$ELSE
$include(asm851.ipx)
$ENDIF

$IF BASE
declare CHKOVL$1 lit	'call OvlMgr(1)',
	CHKOVL$2 lit	'call OvlMgr(2)';
$ELSE
declare CHKOVL$1 lit	' ',
	CHKOVL$2 lit	' ';
$ENDIF

declare pad1 address data(40h),
	pad2 address;


StrUCequ: procedure(s, t) bool public;
	declare (s, t) pointer;
	declare ch1 based s byte,
		ch2 based t byte;

	do while ch1 <> 0;
		if ch1 <> ch2 and ch1 <> (ch2 and 5Fh) then
			return FALSE;
		s = s + 1;
		t = t + 1;
	end;
	return TRUE;
end;


IsSkipping: procedure byte public;
	return 
$IF OVL4
	b905E or
$ENDIF
		 skipping(0);
end;

Sub546F: procedure public;
	spIdx = NxtTokI;
	if expectingOperands then
		call SyntaxError;
	if HaveTokens then
		if not(tokenType(spIdx) = O$DATA or lineNumberEmitted) then
			call SyntaxError;
	if inDB or inDW then
	do;
		if tokenIdx = 1 and not BlankAsmErrCode and tokenSize(0) <> 1 then
			tokenSize(0) = 2;
	end;
	else if not BlankAsmErrCode and HaveTokens then
		if tokenSize(spIdx) > 3 then
			tokenSize(spIdx) = 3;
end;


FinishLine: procedure public;
	declare lineno$p pointer,
		updating byte,
		ch based lineno$p byte;

	call Sub546F;
	if IsPhase2Print then
	do;	/* update the ascii line number */
		lineno$p = .asciiLineNo(3);	/* point to last digit */
		updating = TRUE;

		do while updating;		/* adjust the line number */
			if ch = '9' then	/* if 9 then roll over to 0 */
				ch = '0';
			else
			do;
				if ch = ' ' then	/* new digit */
					ch = '1';
				else			/* just increment */
					ch = ch + 1;
				updating = FALSE;
			end;
			lineno$p = lineno$p - 1;
		end;

		if ShowLine or not BlankAsmErrCode then
		do;
			CHKOVL$1;
			call PrintLine;
		end;
	end;

	if b6BD9 then
	do;
		out$p = out$p + 1;
		call Flushout;
		call Exit;
	end;

	if not isControlLine then
	do;
		ii = 2;
		if tokenIdx < 2 or inDB or inDW then
			ii = 0;

		w6BCE = tokStart(ii) + tokenSize(ii);
		if IsSkipping or not b6B34 then
			w6BCE = .lineBuf;

		if ChkGenObj then
		do;
			CHKOVL$2;
			call Ovl8;
		end;
		b6B2C = TRUE;
		segSize(activeSeg), effectiveAddr = segSize(activeSeg) + (w6BCE - .lineBuf);
	end;

	if ctlXREF and rhsUserSymbol then
		if phase = 1 then
			call EmitXref(1, .name);

$IF OVL4
	call Sub40B9;
$ENDIF

	do while tokenIdx > 0;
		call PopToken;
	end;

	call InitLine;
	if b6B33 then
	do;
		finished = TRUE;
		if IsPhase2Print and ctlSYMBOLS then
		do;
			CHKOVL$1;
			call Sub7041$8447;
		end;

		call EmitXref(2, .name);	/* finalise xref file */
		if ChkGenObj then
		do;
			CHKOVL$2;
			call ReinitFixupRecs;
		end;
	end;
end;

end;
asm46.pl3
asm46: do;
$include(asm46.ipx)

declare	needToOpenFile bool public initial(FALSE),
	includeOnCmdLine bool public initial(FALSE),
	padb6C23 byte,
	fileIdx byte public initial(0),
	endInBuf$p address public initial(.inBuf),
	missingEnd bool public initial(FALSE),
	srcfd address public,
	rootfd address public,
	inCh$p pointer public initial(.inBuf - 1),
	startLine$p address public initial(.inBuf),
	lineChCnt byte public initial(0), 
	files(6) FILE$T public,
	seekIBlk address,
	seekIByte address,
	pad6CAD byte,  
	savInBuf$p address,
	savEndInBuf$p address,
	pad6CB2(4) address,
	readFActual address,
	pad6CBC address;


ReadF: procedure(conn, buff$p, count) public;
	declare conn byte, (buff$p, count) address;
	call Read(conn, buff$p, count, .readFActual, .statusIO);
	call IoErrChk;
end;

SeekI: procedure(seekOp) public;
	declare seekOP byte;
	call Seek(srcfd, seekOp, .seekIBlk, .seekIByte, .statusIO);
	call IoErrChk;
end;


ReadSrc: procedure(bufLoc) public;
	declare bufLoc address;
	declare pad byte;

	call ReadF(srcfd, bufLoc, .inBuf(sizeInBuf) - bufLoc);
	endInBuf$p = bufLoc + readFActual;
end;



CloseSrc: procedure public;
	call Close(srcfd, .statusIO);
	call IoErrChk;
	if fileIdx = 0 then
	do;
		missingEnd = TRUE;
		call IoError(.files(0).name);
		return;
	end;
	fileIdx = fileIdx - 1;
	/* Open the previous file */
	if fileIdx = 0 then
		srcfd = rootfd;
	else
		srcfd = InOpen(.files(fileIdx).name, 1);

	seekIByte = files(fileIdx).byt;	/* move to saved location */
	seekIBlk = files(fileIdx).blk;
	call SeekI(SEEKABS);
	endInBuf$p = .inBuf;		/* force Read */
	inCh$p = .inBuf - 1;
end;


GetSrcCh: procedure byte public;
	declare ch based inCh$p byte;
	declare insertPt address;
    loop:
	inCh$p = inCh$p + 1;

	if inCh$p = endInBuf$p then	/* buffer all used */
	do;
		savInBuf$p = startLine$p;
		savEndInBuf$p = endInBuf$p;
		/* copy the current line down to start of buffer */
		if savEndInBuf$p - savInBuf$p > 0 then
			call move(savEndInBuf$p - savInBuf$p, startLine$p, .inBuf);
		startLine$p = .inBuf;
		/* Read in  characters to rest of inBuf */
		call ReadSrc(insertPt := startLine$p + (savEndInBuf$p - savInBuf$p));
		inCh$p = insertPt;
	end;

	if readFActual = 0 then
	do;
		call CloseSrc;
		goto loop;
	end;

	lineChCnt = lineChCnt + 1;
	return ch and 7Fh;
end;


OpenSrc: procedure public;
	declare curByteLoc byte, curBlkLoc address;

	needToOpenFile = 0;
	call SeekI(SEEKTELL);
	if seekIByte = 128 then		/* adjust for 128 boundary */
	do;
		seekIBlk = seekIBlk + 1;
		seekIByte = 0;
	end;

	curBlkLoc = endInBuf$p - startLine$p;	/* un-used characters */
x:						/* forces code alignment */
	if (curByteLoc := curBlkLoc mod 128) > seekIByte then
	do;
		seekIByte = seekIByte + 128;	/* adjust to allow for un-used chars */
		seekIBlk = seekIBlk - 1;
	end;
	/* save the current file location */
	files(fileIdx - 1).byt = seekIByte - curByteLoc;
	files(fileIdx - 1).blk = seekIBlk - curBlkLoc / 128;
	if srcfd <> rootfd then		/* close if include file */
	do;
		call Close(srcfd, .statusIO);
		call IoErrChk;
	end;

	endInBuf$p = .inBuf;			/* force Read */
	inCh$p = endInBuf$p - 1;
	startLine$p = .inBuf;
	files(fileIdx).blk = 0;			/* record at start of file */
	files(fileIdx).byt = 0;	
	srcfd = InOpen(.files(fileIdx).name, 1);	/* Open the file */
end;
end;
asm4886.plx
asm48$86:
do;
$IF OVL4
$include(asm48.ipx)
$ELSE
$include(asm86.ipx)
$ENDIF
declare	b5666(*) byte data(9, 2Dh, 80h), /* bit vector 10 -> 00101101 10 */
	b5669(*) byte data(3Ah, 8, 80h, 0, 0, 0, 0, 0, 20h),
		/* bit vector 59 -> 00001000 1000000 00000000 0000000
				    00000000 0000000 00000000 001 */
		       /* 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
	op16(*) byte data(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
                          0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1),
			  /* 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
	chClass(*) byte data(0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 4, 0, 0,	/* 00 */
$IF OVL4
			     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0Bh,0, 0, 0, 0,	/* 10 - ESC maps to 0Bh */
$ELSE
			     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ,0, 0, 0, 0,	/* 10 */
$ENDIF
			     1, 0, 0, 0, 6, 0, 0, 7, 5, 5, 5, 5, 5, 5, 0, 5,	/* 20 */
			     8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 3, 2, 0, 0, 0, 9,	/* 30 */
			     9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,	/* 40 */
			     9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0,	/* 50 */
			     0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,	/* 60 */
			     9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0);	/* 70 */

UnpackToken: procedure(src, dst) public;
	declare (src, dst) pointer;
	declare wrd based src address;
	declare ch based dst byte;
	declare packedword address;

	Unpack1: procedure;
		ch = packedword mod 40;	
		if ch = 0 then
			ch = ' ';
		else if ch <= 10 then
			ch = ch + 2Fh;	/* digit */
		else 
			ch = ch + 34h;	/* ? @ and letters */
		packedword = packedword / 40;
		dst = dst - 1;
	end;


	src = src + 2;
	dst = dst + 5;
	packedword = wrd;
	call Unpack1;
	call Unpack1;
	call Unpack1;
	src = src - 2;
	packedword = wrd;
	call Unpack1;
	call Unpack1;
	call Unpack1;
end;


InsertSym: procedure public;
	declare (q, p) pointer;
	declare ch1 based q byte;
	declare ch2 based p byte;

	/* move up the top block of the symbol tables to make room */
	symHighMark, q = (p := symHighMark) + 8;
	if w6870 < q then
		call RuntimeError(1);	/* table Error */

	do while p > curTokenSym$p;	/* byte copy */
		q = q - 1;
		p = p - 1;
		ch1 = ch2;
	end;
	/* insert the new symbol name */
	call move(4, tokPtr, curTokenSym$p);
$IF OVL4
	endSymTab(2) = endSymTab(2) + 8;	/* mark new top of macro table */
$ENDIF
	curTokenSym.type = 0;			/* clear the type */
end;

$IF OVL4
Sub5C73: procedure(arg1b) bool;
	declare arg1b byte;

	if endSymTab(arg1b) >= curTokenSym$p and curTokenSym$p >= symTab(arg1b) then
		return FALSE;

	call SyntaxError;
	return TRUE;
end;


Sub5CAD: procedure(arg1w, type) public;
	declare arg1w address, type byte;

	if Sub5C73(2) then
		return;
	call InsertSym;
	curTokenSym.val = arg1w;		/* fill in the rest of the new entry */
	curTokenSym.type = type;
	curTokenSym.flags = 0;
	call PopToken;
end;
$ENDIF

declare labelUse byte public;

Sub5819$5CE8: procedure(arg1w, type) public;
	declare arg1w address, type byte;
	declare (flags, b6CE9) byte,
		(b6CEA, isSetOrEqu) bool,
		b6CEC byte;

	/* type = 2 -> extrn or label def
		  4 -> set
		  5 -> equ
		  6 -> public
		  9 -> address ref
		 3ah-> ??
	         89h-> none reloc ref
	*/

	Sub5B9A: procedure;
		tokenType(0) = type;
		if (acc1ValType = K$REGNAME or acc1ValType = K$SP) and isSetOrEqu then
			tokenType(0) = 12 - type;	/* set-> K$SP, equ->K$REGNAME */
	end;

	b6CEC = tokenType(0);
	isSetOrEqu = type = 5 or type = 4;
	b6CE9 = 0;
	flags = curTokenSym.flags;
	b6CEA = FALSE;
$IF OVL4
	if Sub5C73(1) then
	do;
$ELSE
	if curTokenSym$p > endSymTab(1) or curTokenSym$p < symTab(1) then
	do;
		call SyntaxError;
$ENDIF
		return;
	end;

	if tokenIdx > 1 then
		call SyntaxError;

	if IsPhase1 then
		if tokenType(0) = 9 then
		do;
			if b6883 then
			do;
				if curTokenSym.type >= 80h
$IF OVL4
					 or type = O$3A and curTokenSym.val <> srcLineCnt
$ENDIF
				then
				do;
					call LocationError;
					b6CE9 = 80h;
				end;
			end;
			else
			do;
				call InsertSym;
$IF OVL4
				symTab(2) = symTab(2) + 8;		/* adjust the base of the macro table */
$ENDIF
				endSymTab(1) = endSymTab(1) + 8;	/* adjust the end of the user symbol table */
				flags = 0;
			end;

			flags = (activeSeg <> SEG$ABS and UF$BOTH)
				or (inPublic and UF$PUBLIC)
				or (inExtrn and (UF$EXTRN + UF$BOTH));
			if labelUse = 1 then	/* set or equ */
				flags = acc1Flags;

			if labelUse = 2 then	/* label: */
				flags = flags or activeSeg;

			if hasVarRef and isSetOrEqu then
				tokenType(0) = O$64;
			else
				call Sub5B9A;

			goto L5A9B$5F82;
		end;

	if passCnt = 2 then
		if tokenType(0) = O$ID then
			if acc1ValType <> O$ID then
				if isSetOrEqu then
				do;
					call Sub5B9A;
					if curTokenSym.type < 128 then
					do;
						curTokenSym.type = tokenType(0);
						curTokenSym.val = arg1w;
						flags = acc1Flags;
						b6CEA = TRUE;
					end;
					goto L5A9B$5F82;
				end;

	if IsPhase1 then
		if tokenType(0) = 6 then
			if TestBit(type, .b5666) then
			do;
				if inExtrn then
					tokenType(0) = 3;
				else
				do;
					tokenType(0) = type;
					flags = flags and 0E0h;
					if labelUse = 1 then
						flags = acc1Flags or 20h;

					if labelUse = 2 then
						if activeSeg <> 0 then
							flags = flags or activeSeg or 38h;
				end;
				goto L5A9B$5F82;
			end;

	if IsPhase1 then
		if type = 6 then
			if TestBit(tokenType(0), .b5666) then
			do;
				if (flags and 60h) <> 0 then
					tokenType(0) = 3;
				else
					flags = flags or 20h;
				goto L5A9B$5F82;
			end;

	if IsPhase1 then
		if tokenType(0) <> type and tokenType(0) <> 8 or type = 5 then
			tokenType(0) = 3;

	if not inPublic and TestBit(tokenType(0), .b5669) then
		flags = (flags and UF$PUBLIC) and tokenType(0) <> O$3A or acc1Flags;
	else
	do;
		if IsPhase1 then
			tokenType(0) = 3;

		if not (inPublic or inExtrn) then
			if curTokenSym.val <> arg1w then
				call PhaseError;
	end;

L5A9B$5F82:
	b6CE9 = b6CE9 or (curTokenSym.type and 80h);

	if IsPhase1 and (type = 9 or type = 6 or b6CEC <> tokenType(0)) then
		curTokenSym.type = tokenType(0) or b6CE9;

	kk = curTokenSym.type;
	if tokenType(0) = 3 or kk = 3 then
		call MultipleDefError;

	if kk >= 80h then
		call LocationError;

	if IsPhase1 and (tokenType(0) = type or type = 5 and tokenType(0) = 7)
	   or type = 4 and BlankAsmErrCode or b6CEA
$IF OVL4
	   or type = O$3A
$ENDIF
	then
		curTokenSym.val = arg1w;

	curTokenSym.flags = flags;
	inPublic = 0;
	inExtrn = 0;
	if curTokenSym.type = 6 then
		call UndefinedSymbolError;

	hasVarRef = 0;
	if b6883 then
		call PopToken;

end;



Lookup: procedure(tableId) byte public;
	declare tableId byte;
	declare (lowOffset, highOffset, midOffset, deltaToNext) address,
		(entryOffset, packedTok$p) pointer,
		(i, gt) byte;
	declare symEntry based entryOffset KEYWORD$T,
		packedTok based packedTok$p (2) address;
	declare addr based w6BE0 address;

	packedTok$p = tokPtr;
	if tableId = 0 then		/* hash chain look up key word */
	do;
		entryOffset = 0;	/* offset to current symbol to compare */
					/* offset of first to use - hashes packed symbol name */
		deltaToNext = symTab(0) + ((packedTok(0) + packedTok(1)) mod 151) * 8;

		do while deltaToNext <> 0;	/* while not end of chain */
			entryOffset = entryOffset + deltaToNext;	/* point to the next in chain */
			if symEntry.tok(0) = packedTok(0) then		/* check for exact match */
				if symEntry.tok(1) = packedTok(1) then
				do;
					curTokenSym$p = entryOffset;
					tokenType(0) = curTokenSym.type;
					if tokenType(0) < K$SINGLE then	/* instruction with arg */
						if op16(tokenType(0)) then
							has16bitOperand = TRUE;

					if curTokenSym.flags = 2 and not ctlMOD85 then	/* RIM/SIM only valid on 8085 */
						call SourceError('O');

					if tokenType(0) = K$SP then		/* SP */
					do;
						if not(rightOp = K$LXI or rightOp = K$REG16) then 
							call SourceError('X');
						tokenType(0) = K$REGNAME;	/* reg */
					end;
					return tokenType(0) and 7Fh;
				end;
			deltaToNext = symEntry.delta;
		end;
		return O$ID;
	end;

	lowOffset = symTab(tableId);
	highOffset, entryOffset = endSymTab(tableId);

	/* binary chop search for id */

	do while (midOffset := lowOffset + shr((highOffset - lowOffset) and 0FFF0h, 1)) <> entryOffset;
		entryOffset = midOffset;
		if packedTok(0) = symEntry.tok(0) then
		do;
			if packedTok(1) = symEntry.tok(1) then
			do;
				curTokenSym$p = entryOffset;
				tokenType(0) = curTokenSym.type;
				if tokenType(0) = O$64 then
					tokenType(0) = O$ID;

				if (b6884 := (kk := (tokenType(0) and 7Fh)) = O$ID) then
					if needsAbsValue then
						curTokenSym.type = 89h;
				return kk;
			end;
			else
				gt = symEntry.tok(1) > packedTok(1);
		end;
		else
			gt = symEntry.tok(0) > packedTok(0);

		entryOffset = midOffset;
		if gt then
			highOffset = entryOffset;
		else
			lowOffset = entryOffset;
	end;

	curTokenSym$p = highOffset;
	if tableId = 1 and not IsSkipping then
	do;
		b6883 = FALSE;
		labelUse = 0;
		call Sub5819$5CE8(srcLineCnt, (needsAbsValue and 80h) or 9);
		w6BE0 = .tokenSym;
		do i = 1 to tokenIdx;
			w6BE0 = w6BE0 + 2;
			if addr >= curTokenSym$p then
				addr = addr + 8;
		end;

		b6883 = TRUE;
	end;
	return O$ID;
end;



GetCh: procedure byte public;
	declare (curCH, prevCH) byte;
$IF OVL4
	declare ch based tmac$buf$p byte;
	declare ch1 based macro$p byte;
$ENDIF

L6339:
	if not reget then
	do;
		prevCH = curCH;

	L6347:
		curCH = lookAhead;
$IF OVL4
		if expandingMacro then
		do;
			do while (lookAhead := ch) = MACROEOB;
				call ReadM(curMacroBlk + 1);
				tmac$buf$p = .macroBuf;
			end;

			tmac$buf$p = tmac$buf$p + 1;
		end;
		else
$ENDIF
	        if scanCmdLine then
			lookAhead = GetCmdCh;
		else
			lookAhead = GetSrcCh;

		if chClass(curCH) = CC$BAD then
			if curCH = 0 or curCH = 7Fh or curCH = FF then
				goto L6347;
$IF OVL4
		if expandingMacro then
		do;
			if curCH = 1Bh then
			do;
				goto L65B2;
			end;
			else if curCH = '&' then
			do;
				if not prevCH < 80h or lookAhead = 80h then
					goto L6339;
			end;
			else if curCH = '!' and prevCH <> 0 then
			do;
				if not (b905D or b905E) and b905C then
				do;
					curCH = 0;
					goto L6339;
				end;
			end;
			else if curCH >= 128 then
			do;
				if not (b905C := not b905C) then
					tmac$buf$p = w9197;
				else
				do;
					w9197 = tmac$buf$p;
					if curCH = 80h then
					do;
						tmac$buf$p = tmac$w12;
						if b9062 = 2 then
						do;
							b91A2 = ch;
							tmac$buf$p = .b91A2;
							if ch = '!' then
							do;
								b91A1 = 21h;
								b91A2 = byteAt(tmac$w12 + 1);
								tmac$buf$p = tmac$buf$p - 1;
							end;
						end;
						else
						do;
							do while (lookAhead := lookAhead - 1) <> 0FFh;
								tmac$buf$p = tmac$buf$p - (ch and 7Fh);
							end;

							tmac$buf$p = tmac$buf$p + 1;
						end;
					end;
					else
					do;
						tmac$buf$p = .b91A4;
						w6BE0 = lookAhead + tmac$w4;
						do ii = 1 to 4;
							b91A4(6 - ii) = w6BE0 mod 10 + '0';
							w6BE0 = w6BE0 / 10;
						end;
					end;
				end;

				lookAhead = 0;
				goto L6339;
			end;
		end;

		if expandingMacro > 1 then
			if IsPhase2Print then
				if macro$p < .endMacroLine then	/* append character */
				do;
					ch1 = curCH;	
					macro$p = macro$p + 1;
				end;

		if b905E then
			if w919D <> w906A and curCH = 0Dh or not b9059 then
			call Sub3D55(curCH);

		if not(prevCH = '!' or inComment) then
		do;
			if curCH = '>' then
				argNestCnt = argNestCnt - 1;

			if curCH = '<' then
				argNestCnt = argNestCnt + 1;
		end;
$ENDIF
	end;
L65B2:
	reget = 0;
	return (curChar := curCH);
end;

GetChClass: procedure byte public;
	curChar = GetCh;
$IF OVL4
	if b905D then
		return 0Ah;
$ENDIF

	return chClass(curChar);
end;



ChkLF: procedure public;
	if lookAhead = LF then
		lookAhead = 0;
	else
	do;
$IF OVL4 
		b905E = b905E and 0FEh;
$ENDIF
		call IllegalCharError;
$IF OVL4
		b905E = b905E > 0;
$ENDIF
	end;
end;

end;

asm49861.plx
asm49$861:
do;
$IF OVL4
$include(asm49.ipx)
$ELSE
$include(asm861.ipx)
$ENDIF

SyntaxError: procedure public;
	call SourceError('Q');
end;

DoubleDefError: procedure public;
	call SourceError('D');
end;

ExpressionError: procedure public;
	call SourceError('E');
end;

CommandError: procedure public;
	call SourceError('C');
end;

OpcodeOperandError: procedure public;
	call SourceError('O');
end;

NameError: procedure public;
	call SourceError('R');
end;

MultipleDefError: procedure public;
	call SourceError('M');
end;

ValueError: procedure public;
	call SourceError('V');
end;

NestingError: procedure public;
	call SourceError('N');
end;

PhaseError: procedure public;
	call SourceError('P');
end;

StackError: procedure public;
	call RuntimeError(0);
end;

FileError: procedure public;
	call RuntimeError(4);
end;

IllegalCharError: procedure public;
	call SourceError('I');
end;

BalanceError: procedure public;
	call SourceError('B');
end;

UndefinedSymbolError: procedure public;
	call SourceError('U');
end;

LocationError: procedure public;
	call SourceError('L');
end;

OperandError: procedure public;
	call SourceError('X');
end;

HaveTokens: procedure byte public;
	return tokenIdx <> 0;
end;


PopToken: procedure public;
	tokStart(0) = tokStart(tokenIdx);
	tokenSym(0) = tokenSym(tokenIdx);
	tokenType(0) = tokenType(tokenIdx);
	tokenAttr(0) = tokenAttr(tokenIdx);
	tokenSize(0) = tokenSize(tokenIdx);
	tokenSymId(0) = tokenSymId(tokenIdx);
	if HaveTokens then
		tokenIdx = tokenIdx - 1;
end;



NestIF: procedure(arg1b) public;
	declare arg1b byte;
$IF OVL4
	macroCondStk(macroCondSP := macroCondSP + 1) = macroCondStk(0);
	if (macroCondStk(0) := arg1b) = 1 then
	do;
		if (macroDepth := macroDepth + 1) > 9 then
		do;
			call StackError;
			macroDepth = 0;
		end;
		else
		do;
			call move(16, .macroStk(0), .macroStk(macroDepth));
			tmac$macroCondSP = macroCondSP;
			tmac$ifDepth = ifDepth;
			b9061 = TRUE;
		end;
	end;
	else
$ENDIF
	do;
		if (ifDepth := ifDepth + 1) > 8 then
		do;
			call StackError;
			ifDepth = 0;
		end;
		else
		do;
			skipping(ifDepth) = skipping(0);
			inElse(ifDepth) = inElse(0);
		end;
	end;
end;


UnnestIF: procedure(arg1b) public;
	declare arg1b byte;

$IF OVL4
	if arg1b <> macroCondStk(0) then
	do;
		call NestingError;
		if arg1b = 2 then
			return;
		macroCondSP = tmac$macroCondSP;
		ifDepth = tmac$ifDepth;
	end;

	macroCondStk(0) = macroCondStk(macroCondSP);
	macroCondSP = macroCondSP - 1;
	if arg1b = 1 then
	do;
		call move(16, .macroStk(macroDepth), .macroStk(0));
		call ReadM(tmac$blk);
		b9062 = tmac$mtype;
		if (macroDepth := macroDepth - 1) = 0 then
		do;
			expandingMacro = 0;
			w6870 = Physmem + 0BFh;
		end;
	end;
$ELSE
	if ifDepth = 0 then
		call NestingError;
$ENDIF
	else
	do;
			skipping(0) = skipping(ifDepth);
			inElse(0) = inElse(ifDepth);
		ifDepth = ifDepth - 1;
	end;
end;

PushToken: procedure(type) public;
	declare type byte;

	if tokenIdx >= 8 then
		call StackError;
	else
	do;
		tokenIdx = tokenIdx + 1;
		tokStart(tokenIdx) = tokStart(0);
		tokenSym(tokenIdx) = tokenSym(0);
		tokenType(tokenIdx) = tokenType(0);
		tokenAttr(tokenIdx) = tokenAttr(0);
		tokenSize(tokenIdx) = tokenSize(0);
		tokenSymId(tokenIdx) = tokenSymId(0);	
		tokStart(0) = tokStart(0) + tokenSize(0);	/* advance for next token */
		tokenType(0) = type;
		tokenAttr(0), tokenSize(0) = bZERO;
		tokenSym(0) = wZERO;
$IF OVL4
		tokenSymId(0) = wZERO;
$ELSE
		tokenSymId(0) = tokenSym(0);
$ENDIF
	end;
end;

CollectByte: procedure(c) public;
	declare c byte;
	declare s pointer;
	declare ch based s byte;


	if (s := tokPtr + tokenSize(0)) < endLineBuf then	/* check for lineBuf overrun */
	do;
		ch = c;
		tokenSize(0) = tokenSize(0) + 1;
	end;
	else
		call StackError;
end;

GetId: procedure(type) public;
	declare type byte;

	call PushToken(type);	/* save any previous token and initialise this one */
	reget = 1;		/* force re get of first character */

	do while (type := GetChClass) = CC$DIGIT or type = CC$LET;	/* digit or letter */
		if curChar > 60h then	/* make sure upper case */
			curChar = curChar and 0DFh;
		call CollectByte(curChar);
	end;
	reget = 1;		/* force re get of Exit char */
end;


Atoi: procedure public;
	declare accum address,
		(radix, digit, i) byte;
	declare chrs based tokPtr (1) byte;

	call GetId(O$NUMBER);
	radix = chrs(tokenSize(0):= tokenSize(0) - 1);
	if radix = 'H' then
		radix = 16;

	if radix = 'D' then
		radix = 10;

	if radix = 'O' or radix = 'Q' then
		radix = 8;

	if radix = 'B' then
		radix = 2;

	if radix > 16 then
		radix = 10;
	else
		tokenSize(0)= tokenSize(0) - 1;

	accum = 0;
	do i = 0 to tokenSize(0);
		if chrs(i) = '?' or chrs(i) = '@' then
		do;
			call IllegalCharError;
			digit = 0;
		end;
		else
		do;
			if (digit := chrs(i) - '0') > 9 then
				digit = digit - 7;
			if digit >= radix then
				if not (tokenType(2) = 40h) then /* risk that may be uninitialised */
				do;
					call IllegalCharError;
					digit = 0;
				end;
		end;

		accum = accum * radix + digit;
	end;
	/* replace with packed number */
	tokenSize(0) = 0;
	call CollectByte(low(accum));
	call CollectByte(high(accum));
end;

GetStr: procedure public;
	call PushToken(O$STRING);

	do while GetCh <> CR;
		if curChar = '''' then
			if GetCh <> '''' then
				goto L6268;
		call CollectByte(curChar);
	end;

	call BalanceError;

L6268:
	reget = 1;
end;

end;
asm4aov0.plx
asm4A$OV0: do;
$IF OVL4
$include(asm4a.ipx)
$ELSE
$include(asmov0.ipx)
$ENDIF

declare controlTable(*) byte data(35h, 'DEBUG', 3Ah, 'MACRODEBUG',
			   34h, 'XREF', 37h, 'SYMBOLS',
			   36h, 'PAGING', 33h, 'TTY',
			   25h, 'MOD85', 35h, 'PRINT',
			   36h, 'OBJECT', 39h, 'MACROFILE',
			   29h, 'PAGEWIDTH', 2Ah, 'PAGELENGTH',
			   7, 'INCLUDE', 5, 'TITLE',
			   4, 'SAVE', 7, 'RESTORE',
			   5, 'EJECT', 14h, 'LIST',
			   13h, 'GEN', 14h, 'COND');

declare (b7463, savedCtlLIST, savedCtlGEN) byte,
	controlError bool;


ChkParen: procedure(arg1b) bool;
	declare arg1b byte;
	call SkipWhite;
	reget = 0;
	return arg1b + '(' = curChar;
end;



GetTok: procedure byte;
	tokBufLen = 0;
	tokType = O$NONE;
	if IsCR then
		return curChar;

	call SkipWhite$2;
	if curChar > 'A'-1 and 'Z'+1 > curChar or curChar > 'a'-1 and 'z'+1 > curChar then
	do;							/* letter */
		call GetId(1);
		if BlankAsmErrCode and tokenSize(0) < 14 then
			call move(tokBufLen := tokenSize(0), .lineBuf, .tokBuf);
	end;
	else if curChar > '0'-1  and  '9'+1 > curChar then	/* digit ? */
	do;
		call Atoi;
		if BlankAsmErrCode then
		do;
			tokNumVal = GetNumVal;
			tokType = TT$NUM;
			tokBuf(0) = ' ';
		end;
	end;
	else if curChar = '''' then	/* string ? */
	do;
		call GetStr;
		if BlankAsmErrCode then
		do;
			tokBufLen = 64;
			if tokenSize(0) < 64 then
				tokBufLen = tokenSize(0);
			tokType = TT$STR;
			if tokBufLen > 0 then
				call move(tokBufLen, .lineBuf, .tokBuf);
		end;
	end;
	else
	do;
		tokBufLen = 1;
		tokBuf(0) = curChar;
		return curChar;
	end;

	call PopToken;
	return tokBuf(0);
end;



Sub6F07: procedure(arg1w) bool;
	declare arg1w address;
	declare pad address;

	if tokBufIdx = 0 then
		return FALSE;

	tokBuf(tokBufIdx) = 20h;
	tokBufLen = tokBufIdx;
	if IsWhite then
		return ChkParen(1);
	return TRUE;
end;

Sub6F39: procedure;
	call SkipWhite$2;

    do while 1;
	if IsRParen or IsWhite then
	do;
		if Sub6F07(.tokBuf(0)) then
			return;
		goto done;
	end;

	tokBuf(tokBufIdx) = curChar;
	tokBufIdx = tokBufIdx + 1;
	if tokBufIdx > 14 then
		goto done;
	curChar = GetCh;
    end;
done:
	curFileName$p = .tokBuf;
	call FileError;
end;


GetFileParam: procedure;
	tokBufIdx = 0;
	if not ChkParen(0) then	/* ( */
		call FileError;
	else
	do;
		call Sub6F39;
		call move(tokBufIdx + 1, .tokBuf, curFileName$p);
		if not ChkParen(1) then	/* ) */
			call FileError;
	end;
end;


GetMacroFileDrive: procedure;
	call SkipWhite$2;
	tokBufIdx = 0Dh;
	ii = 0;

	do while not IsRParen and ii < 4;
		asmax$ref(ii) = curChar;
		ii = ii + 1;
		curChar = GetCh;
	end;

	if IsRParen or IsWhite then
		if Sub6F07(.asmax$ref) then
			return;
	curFileName$p = .asmax$ref;
	tokBufIdx = 0;
	call FileError;
end;




GetControlNumArg: procedure bool;
	if ChkParen(0) then	/* ( */
	do;
		b7463 = GetTok;
		if tokType = TT$NUM then
			return ChkParen(1);	/* ) */
	end;
	return FALSE;
end;


LookupControl: procedure byte;
	declare (cmdIdx, cmdStartIdx) byte, 
		ctlVal bool,
		(cmdLen, ctlFlags, noInvalid) byte,
		(control$p, nextControl$p, ctlSeen$p) pointer;
	declare twoch address at(.tokBuf);
	declare ch based control$p byte;
	declare ctlSeen based ctlSeen$p byte;

	SetControl: procedure;
		if not noInvalid then
		do;
			controls(controlId) = ctlVal;
			if not ctlVal then
				controlId = 17;	/* no action needed */
		end;
	end;


	cmdLen = tokBufLen;
	cmdStartIdx = 0;
	ctlVal = TRUE;
	if twoch = 'ON' then	/* NO stored with bytes swapped */
	do;
		cmdStartIdx = 2;	/* don't match the NO in the table */
		ctlVal = FALSE;		/* control will be set as false */
		cmdLen = tokBufLen - 2;	/* length of string to match excludes the NO */
	end;

	control$p = .controlTable;
	controlId = 0;
	cmdIdx = cmdStartIdx;

	do while controlId < 20;
		nextControl$p = control$p + (ch and 0Fh) + 1;
		if (ch and 0Fh) = cmdLen then
		do;
			ctlFlags = ch;
			do while cmdIdx < tokBufLen;
				control$p = control$p + 1;
				if ch <> tokBuf(cmdIdx) then
					cmdIdx = tokBufLen + 1;	/* cause early Exit */
				else
					cmdIdx = cmdIdx + 1;	/* check next character */
			end;

			if cmdIdx = tokBufLen then		/* found it */
				goto found;
		end;
		control$p = nextControl$p;
		controlId = controlId + 1;
		cmdIdx = cmdStartIdx;
	end;
	return 255;						/* not found */

found:
$IF OVL0 
	if controlId = 1 or controlId = 12h then	/* MACRODEBUG or GEN */
	do;
		if scanCmdLine then			/* only valid on command line not $ line */
			MacroDebugOrGen = TRUE;
		else
			return 255;			/* Error otherwise */
	end;
$ENDIF
	if (noInvalid := (ctlFlags and 10h) <> 10h) and not ctlVal then
		return 255;	/* NO not supported */

	if (ctlFlags and 20h) <> 20h then		/* GENERAL control */
	do;
		call SetControl;
		return controlId;
	end;

	if not primaryValid then			/* is a PRIMARY control */
		return 255;

	ctlSeen$p = .controlSeen(controlId);		/* make sure we only see a primary once */
	if ctlSeen then
		return 255;
	ctlSeen = TRUE;
	call SetControl;
	return controlId;
end;

ProcessControl: procedure;
	if controlId >= 17 or controlId < 5 then
		return;

	do case controlId - 5;
/* 0 */		do;			/* TTY */
			ctlTTY = TRUE;
			return;
		end;
/* 1 */		do;			/* MOD85 */
			ctlMOD85 = TRUE;
			return;
		end;
/* 2 */		do;			/* PRINT */
			controlFileType = 2;
			curFileName$p = .lstFile;
			call GetFileParam;
			return;
		end;
/* 3 */		do;			/* OBJECT */
			controlFileType = 3;
			curFileName$p = .objFile;
			call GetFileParam;
			return;
		end;
/* 4 */		do;			/* MACROFILE */
			controlFileType = 3;
			if ChkParen(0) then	/* optional drive for tmp file */
				call GetMacroFileDrive;
			else
				reget = 1;
			ctlMACROFILE = TRUE;
			return;
		end;
/* 5 */		do;			/* PAGEWIDTH */
			if GetControlNumArg then
			do;
				ctlPAGEWIDTH = tokNumVal;
				if ctlPAGEWIDTH > 132 then
					ctlPAGEWIDTH = 132;
				if ctlPAGEWIDTH < 72 then
					ctlPAGEWIDTH = 72;
				return;
			end;
		end;
/* 6 */		do;			/* PAGELENGTH */
			if GetControlNumArg then
			do;
				ctlPAGELENGTH = tokNumVal;
				if ctlPAGELENGTH < 15 then
					ctlPAGELENGTH = 15;
				return;
			end;
		end;
/* 7 */		do;			/* INCLUDE */
			if not needToOpenFile then
			do;
				controlFileType = 1;
				if fileIdx = 5 then
					call StackError;
				else
				do;
					fileIdx = fileIdx + 1;
					curFileName$p = .files(fileIdx);
					call GetFileParam;
					needToOpenFile = TRUE;
					if scanCmdLine then
						includeOnCmdLine = TRUE;
					return;
				end;
			end;
		end;
/* 8 */		do;			/* TITLE */
			if ChkParen(0) then
			do;
				b7463 = GetTok;
				if tokType = TT$STR and tokBufLen <> 0 then
				do;
					if phase <> 1 or IsPhase1 and primaryValid then
					do;
						call move(tokBufLen, .tokBuf, .ctlTITLESTR);
						ctlTITLESTR(titleLen := tokBufLen) = 0;
						if ChkParen(1) then
						do;
							ctlTITLE = TRUE;
							return;
						end;
					end;
				end;
			end;
		end;
/* 9 */		do;			/* SAVE */
			if saveIdx > 7 then
				call StackError;
			else
			do;
				call move(3, .ctlLIST, .saveStack + saveIdx * 3);
				saveIdx = saveIdx + 1;
				return;
			end;
		end;
/* 10 */	do;			/* RESTORE */
			if saveIdx > 0 then
			do;
				call move(3, .saveStack + (saveIdx := saveIdx - 1) * 3, .ctlLIST);
				return;
			end;
		end;
/* 11 */	do;			/* EJECT */
			ctlEJECT = ctlEJECT + 1;
			return;
		end;
	end;
	controlError = TRUE;
end;

ParseControls: procedure public;
	isControlLine = TRUE;
	ctlLISTChanged, savedCtlLIST = ctlLIST;
$IF OVL4
	savedCtlGEN = ctlGEN;
$ENDIF
	controlError = FALSE;

	do while GetTok <> CR and not controlError;
		if tokBuf(0) = ';' then		/* skip comments */
			call Skip2EOL;
		else if LookupControl = 255 then	/* Error ? */
			controlError = TRUE;
		else
			call ProcessControl;
	end;

	if controlError then
	do;
		if tokBuf(0) <> CR then
		do;
			reget = 0;
			call Skip2EOL;
		end;

		if scanCmdLine then
			call RuntimeError(2);	/* command Error */
		else
			call CommandError;
	end;

	call ChkLF;			/* eat the LF */
	if ctlLIST <> savedCtlLIST then
		ctlLISTChanged = TRUE;
$IF OVL4
	else if ctlGEN <> savedCtlGEN and expandingMacro then
		ctlLISTChanged = FALSE;
$ENDIF

	reget = 0;
end;

end;
asm4B.pl3
asm4B:
do;
$include(asm4b.ipx)

declare b7183(*) byte data(3Fh, 0, 4, 0, 0, 0, 8, 0, 10h),
	/* bit vector 64 - 00000000 00000100 00000000 00000000 00000000 00001000 00000000 00010000 */
	/*                 CR, COMMA, SEMI */                                  
	aMacro(*) byte data('MACRO', 0);

declare w9C75 address,
	b9C77 byte public;


Sub7192: procedure byte;
	if IsCR then
	do;
		b905A = 0;
		return TRUE;
	end;

	if b905A then
		return argNestCnt = b9066;

	if IsLT or (not (tmac$mtype = 1) and IsGT) then
	do;
		call IllegalCharError;
		return TRUE;
	end;

	return IsWhite or IsComma or IsGT or curChar = ';';
end;



Sub71F2: procedure;
	symTab(2), endSymTab(2) = symHighMark;
	b9065, tmac$b3 = bZERO;
	effectiveToken = 37h;
end;


Sub720A: procedure;

	b9062 = tmac$mtype;
	if not expandingMacro then
		expandingMacro = 1;

	if macroDepth = 0 then
		expandingMacro = 0FFh;

	if b9061 then
		call move(4, .macroStk(0).buf$p, .macroStk(macroDepth).buf$p);

	b9061 = FALSE;
	tmac$w12 = w9199;
	tmac$w4 = w919B;
	w919B = w919B + tmac$b3;
	call ReadM(tmac$w10);
	tmac$buf$p = .macroBuf;
end;


Sub727F: procedure bool;
	if not b905E then
		return TRUE;
	b9064 = b9064 + 1;
	b6B2C = leftOp <> K$REPT;
	effectiveToken = 37h;
	return FALSE;
end;


Sub72A4: procedure(arg1b) public;	/* 1 -> IRP, 2 -> IRPC */
	declare arg1b byte;

	if Sub727F then
	do;
		call Sub71F2;
		call NestIF(1);
		tmac$w14 = 0;
		tmac$mtype = arg1b;
	end;
end;

Sub72C4: procedure;
	declare b9C79(6) byte;

	call PushToken(0Dh);
	kk = 0;

L72CE:
	b9C79(kk := kk + 1) = accum1 mod 10 + '0';
	if (accum1 := accum1 / 10) > 0 then
		goto L72CE;

	do while kk > 0;
		call CollectByte(b9C79(kk));
		kk = kk - 1;
	end;
end;


Sub7327: procedure public;
	w9199 = w6870;
	effectiveToken = 3Dh;
	b905D = TRUE;
	b9060 = FALSE;
end;


EnterMacro: procedure(lowAddr, highAddr) address;
	declare (lowAddr, highAddr) pointer;
	declare ch1 based w6870 byte,
		ch2 based highAddr byte;

	do while lowAddr <= highAddr;
		if w6870 <= symHighMark then
			call RuntimeError(1);	/* table Error */
		ch1 = ch2;
		w6870 = w6870 - 1;
		highAddr = highAddr - 1;
	end;
	return w6870;
end;


Sub7383: procedure;
	b9064 = 1;
	w906A = symHighMark;
	b905E = 1;
	w9C75 = macroBlkCnt;
end;



Sub739A: procedure;
	if b6884 then
		if asmErrCode <> 'U' then
			call LocationError;
end;


Sub73AD: procedure public;
	declare isPercent byte;

	b9C77 = tokenIdx;
	call SkipWhite;
	if not (isPercent := curChar = '%') then
	do;
		b9066 = argNestCnt - 1;
		if (b905A := IsLT) then
			curChar = GetCh;

		call PushToken(0Dh);

	L73E2:	do while not Sub7192;
			if curChar = '''' then
			do;
				if (curChar := GetCh) = '''' then
				do;
					curChar = GetCh;
					call SkipWhite;
					if Sub7192 then
						goto L7463;
					else
					do;
						call CollectByte('''');
						call CollectByte('''');
					end;
				end;
				else
				do;
					call CollectByte('''');
					goto L73E2;
				end;
			end;
			call CollectByte(curChar);
			if tmac$mtype = 2 then
				tmac$w14 = tmac$w14 + 1;

			if curChar = '!' and GetCh <> CR then
			do;
				call CollectByte(curChar);
				curChar = GetCh;
			end;
		end;

	L7463:	if b905A then
			curChar = GetCh;

		call SkipWhite;
		if IsGT then
		do;
			curChar = GetCh;
			call SkipWhite;
		end;

		reget = 1;
	end;

	b905D = FALSE;
	if tmac$mtype = 4 then
	do;
		if not b905A and tokenSize(0) = 5 then
			if StrUCequ(.aMacro, tokPtr) then
			do;
				effectiveToken = K$MACRO;
				call PopToken;
				w9199 = tmac$w12;
				opSP = opSP - 1;
				reget = 1;
				call EmitXref(0, .name);
				rhsUserSymbol = FALSE;
				b6BDA = TRUE;
				return;
			end;
		tmac$mtype = b9062;
		call NestIF(1);
		tmac$mtype = 0;
	end;

	if not isPercent then
		if not TestBit(curChar, .b7183) then	/* not CR, COMMA or SEMI */
		do;
			call Skip2EOL;
			call SyntaxError;
			reget = 1;
		end;
end;



Sub7517: procedure public;
	if Sub727F then
	do;
		expectingOperands = FALSE;
		w9068 = curTokenSym$p + 4;
		call Sub5819$5CE8(0, O$3A);
		tmac$mtype = 0;
		call Sub71F2;
	end;
end;

Sub753E: procedure public;
	declare ch based w9068 byte;

	if HaveTokens then
	do;
		if tokenType(0) = 0 then
			call MultipleDefError;

		call Sub5CAD((b9065 := b9065 + 1), 0);
	end;
	else if not (tmac$mtype = 0) then
		call SyntaxError;

	if not tmac$mtype = 0 then
	do;
		call SkipWhite;
		if IsComma then
		do;
			reget = 0;
			rightOp = O$NONE;
			call Sub7327;
			if tmac$mtype = 1 then
			do;
				curChar = GetCh;
				call SkipWhite;
				if not IsLT then
				do;
					call SyntaxError;
					reget = 1;
				end;
			end;
		end;
		else
		do;
			call SyntaxError;
			call Sub7383;
		end;
	end;
	else if rightOp = T$CR then
	do;
		if not BlankMorPAsmErrCode then
		do;
			tmac$mtype = 5;
			w9068 = w9068 + 2;
			if (ch and 7Fh) = 3Ah then
				ch = (asmErrCode = 'L') and 80h or 9;
		end;
		call Sub7383;
	end;
end;

Sub75FF: procedure public;
	declare ch based w906A byte;
	declare ch2 based w9068 byte;
	declare wrd based w9068 address;

	if b905E then
	do;
		if (b9064 := b9064 - 1) = 0 then
		do;
			b905E = 0;
			if not (tmac$mtype = 5) then
			do;
				if tmac$mtype = 2 then
					w9199 = w6870 + 3;

				do w6BE0 = w919D to w919F - 1;
					curChar = byteAt(w6BE0);
					if not IsWhite then
						call SyntaxError;
				end;

				w906A = w919D;
				ch = 1Bh;
				call Sub40B9;
				call WriteM;
				symHighMark, endSymTab(2) = symTab(2);
				if tmac$mtype = 0 then
				do;
					wrd = w9C75;
					w9068 = w9068 + 3;
					ch2 = tmac$b3;
				end;
				else
				do;
					tmac$w10 = w9C75;
					call Sub720A;
					if tmac$w14 = 0 then
						call UnnestIF(1);
				end;
			end;
		end;
	end;
	else
		call NestingError;
end;


Sub76CE: procedure public;
	if expandingMacro then
	do;
		if rightOp = T$CR then
		do;
			b6B32 = TRUE;
			macroCondSP = tmac$macroCondSP;
			ifDepth = tmac$ifDepth;
			tmac$w14 = 1;
			lookAhead = 1Bh;
			macroCondStk(0) = 1;
		end;
		else
			call SyntaxError;
	end;
	else
		call NestingError;
end;


Sub770B: procedure public;
	if b9C77 + 1 <> tokenIdx then
		call SyntaxError;
	else if not b9060 then
	do;
		if tokenType(0) <> 0Dh then
		do;
			accum1 = GetNumVal;
			call Sub72C4;
		end;

		if tmac$mtype = 2 then
			tmac$w14 = tokenSize(0) - (tokenSize(0) = 0);

		call CollectByte((tokenSize(0) + 1) or 80h);
		w6870 = EnterMacro(tokPtr, tokPtr + tokenSize(0) - 1);
		call PopToken;

		if tmac$mtype = 0 or tmac$mtype = 1 and argNestCnt > 0 then
			b905D = TRUE;
		else
			b9060 = TRUE;

		if tmac$mtype = 1 then
			tmac$w14 = tmac$w14 + 1;
	end;
	else
		call SyntaxError;

	if rightOp = T$CR then
	do;
		b905D = FALSE;
		if argNestCnt > 0 then
			call BalanceError;

		if not BlankMorPAsmErrCode then
		do;
			call Sub739A;
			if tmac$mtype = 0 then
			do;
				call Sub720A;
				call UnnestIF(1);
				return;
			end;
			else
				tmac$w14 = 0;
		end;
		else
		do;
			w6870 = EnterMacro(.b$3782, .b$3783);
			if tmac$mtype = 0 then
			do;
				tmac$b3 = curTokenSym.flags;
				tmac$w10 = GetNumVal;
				call Sub720A;
			end;
			else if tmac$w14 = 0 then
				call SyntaxError;
		end;

		if not (tmac$mtype = 0) then
			call Sub7383;
	end;
end;



Sub7844: procedure public;
	call Sub72A4(3);
	if (effectiveToken := rightOp) <> T$CR then
		call SyntaxError;

	if not b905E then
	do;
		tmac$w14 = accum1;
		if not BlankMorPAsmErrCode then
		do;
			call Sub739A;
			tmac$w14 = 0;
		end;

		call Sub7383;
	end;
end;


Sub787A: procedure public;
	if b905E = 2 then
	do;
		if HaveTokens then
		do;
			if (tmac$b3 := tmac$b3 + 1) = 0 then
				call StackError;

			if tokenType(0) <> 9 then
				call MultipleDefError;

			call Sub5CAD(tmac$b3, 1);
			w906A = symHighMark;
		end;
		if rightOp = T$CR then
		do;
			b905E = 1;
			w906A = symHighMark;
		end;
	end;
	else
		call SyntaxError;
end;



Sub78CE: procedure public;
	kk = byteAt(tmac$w12);
	accFixFlags(0) = 1 - (kk = 21h and b9062 = 2);
	if b9062 = 0 or (tmac$w14 := tmac$w14 - accFixFlags(0)) = 0 then
		call UnnestIF(1);
	else
	do;
		if b9062 = 1 then
			w9199 = tmac$w12 - (kk and 7Fh);
		else
			w9199 = tmac$w12 + accFixFlags(0);

		tmac$mtype = b9062;
		call Sub720A;
	end;
	lookAhead = 0;
	b6B2C, atStartLine = bTRUE;
end;

end;
asm4dov1.plx
asm4D$OV1:
do;
/* to force the code generation this needs a non-standard definition
   of put2Hex
*/
Put2Hex: procedure(arg1w, arg2w) external; declare arg1w address, arg2w address; end;

$IF OVL4
$include(asm4d.ipx)
$ELSE
$include(asmov1.ipx)
$ENDIF

declare aAssemblyComple(*) byte initial(CR, LF, 'ASSEMBLY COMPLETE,'),
	aNoErrors(*) byte initial('   NO ERRORS'),
	spaceLP(*) byte initial(' ('),
	space5RP(*) byte initial('     )'),
	aPublicSymbols(*) byte initial(CR, LF, 'PUBLIC SYMBOLS', CR, LF, 0),
	aExternalSymbol(*) byte initial(CR, LF, 'EXTERNAL SYMBOLS', CR, LF, 0),
	pad754E address,

	aUserSymbols(*) byte data(CR, LF, 'USER SYMBOLS', CR, LF, 0),
	lstHeader(*) byte data('  LOC  OBJ         LINE        SOURCE STATEMENT', CR, LF, LF, 0),
	symbolMsgTable(*) address data(.aPublicSymbols, .aExternalSymbol, .aUserSymbols),
	aCRLFLF(*) byte data(CR, LF, LF, 0),
	aCR(*) byte data(CR),
	topLFs(*) byte data(LF, LF, LF, 0),
	b6DC1(2) byte data(20h, 40h),
	ascLParen(*) byte data(' (', 0),
	ascRParen(*) byte data(')', 0),
	a1234(*) byte data('  1234');


Out2Hex: procedure(n);
    declare n byte;
    call Put2Hex(.outch, n);
end;


Print2Hex: procedure(n);
    declare n byte;
    call Put2Hex(.printChar, n);
end;



PrintStr: procedure(str) reentrant;
    declare str pointer;
    declare ch based str byte;

    do while ch <> 0;
        call PrintChar(ch);
        str = str + 1;
    end;
end;

PrintNStr: procedure(cnt, str) reentrant;
    declare cnt byte, str pointer;
    declare ch based str byte;

    do while cnt > 0;
        call PrintChar(ch);
        str = str + 1;
        cnt = cnt - 1;
    end;
end;


PrintCRLF: procedure reentrant;
    call PrintChar(CR);
    call PrintChar(LF);
end;

declare aNumStr(*) byte initial('     ', 0);


Itoa: procedure(n, buf);
    declare n address, buf pointer;
    declare ch based buf byte;

    call move(5, .spaces5, buf);
    buf = buf + 4;

    do while 1;
        ch = n mod 10 + '0';
        buf = buf - 1;
        if (n := n /10) = 0 then
            return;
    end;
end;


PrintDecimal: procedure(n) reentrant public;
    declare n address;
    call Itoa(n, .aNumStr);
    call PrintStr(.aNumStr(1));
end;

SkipToEOP: procedure public;
    do while pageLineCnt <= ctlPAGELENGTH;
        call Outch(LF);
        pageLineCnt = pageLineCnt + 1;
    end;
end;


NewPageHeader: procedure public;
    call PrintStr(.topLFs);
    call PrintStr(.asmHeader);
    call PrintDecimal(pageCnt);
    call PrintCRLF;
    if ctlTITLE then
        call PrintNStr(titleLen, .ctlTITLESTR);

    call PrintCRLF;
    call PrintCRLF;
    if not b68AE then
        call PrintStr(.lstHeader);
    pageCnt = pageCnt + 1;
end;


NewPage: procedure public;
    if ctlTTY then
        call SkipToEOP;
    else
        call Outch(FF);

    pageLineCnt = 1;
    if not scanCmdLine then
        call NewPageHeader;
end;


DoEject: procedure public;
    if ShowLine then
    do while ctlEJECT > 0;
        call NewPage;
        ctlEJECT = ctlEJECT - 1;
    end;
end;




PrintChar: procedure(c) reentrant;
    declare c byte;
    declare cnt byte;

    if c = FF then
    do;
        call NewPage;
        return;
    end;

    if c = LF then
        if ctlPAGING then
        do;
            if (pageLineCnt := pageLineCnt + 1) >= ctlPAGELENGTH - 2 then
            do;
                if ctlTTY then
                    call Outch(LF);
                if ctlEJECT > 0 then
                    ctlEJECT = ctlEJECT - 1;
                call NewPage;
                return;
            end;
        end;

    if c = CR then
        curCol = 0;

    cnt = 1;
    if c = TAB then
    do;
        cnt = 8 - (curCol and 7);
        c = ' ';
    end;

    do while cnt <> 0;
        if curCol < 132 then
        do;
            if c >= ' ' then
                curCol = curCol + 1;
            if curCol > ctlPAGEWIDTH then
            do;
                call PrintCRLF;
                call PrintStr(.spaces24);
                curCol = curCol + 1;
            end;
            call Outch(c);
        end;
        cnt = cnt - 1;
    end;
end;

declare segChar(*) byte initial(' CDSME');	/* seg id char */

Sub7041$8447: procedure public;
    declare symGrp byte,
        flagsAndType address,
        (type, flags) byte at(.flagsAndType),
        zeroAddr byte;
    declare tokBytePair based curTokenSym$p address;

    PrintAddr2: procedure(printFunc);
        declare printFunc address;
        declare ch based curTokenSym$p byte;

        curTokenSym$p = curTokenSym$p - 1;	/* backup into value */
        call printFunc(ch and not zeroAddr);	/* print address or 0 */
    end;


    b68AE = TRUE;
    if not ctlSYMBOLS then
        return;

    segChar(0) = 'A';		/* show A instead of space for absolute */
    do symGrp = 0 to 2;
        kk = IsPhase2Print and ctlSYMBOLS;
$IF OVL4
        ctlDEBUG = ctlDEBUG or ctlMACRODEBUG;
$ENDIF
        curTokenSym$p = symTab(1) - 2;		/* address user sym(-1).type */
        call PrintCRLF;
        call PrintStr(symbolMsgTable(symGrp));

        do while (curTokenSym$p := curTokenSym$p + 8) < endSymTab(1);
            flagsAndType = tokBytePair;
            if type <> 9 then
                if type <> 6 then
$IF OVL4
                    if Sub3FA9 then
$ENDIF
                        if symGrp <> 0 or type <> 3 then
                            if symGrp = 2 or (flags and b6DC1(symGrp)) <> 0 then
                            do;
                                call UnpackToken(curTokenSym$p - 6, .tokStr);
                                if kk then
                                do;
                                    if (ctlPAGEWIDTH - curCol) < 17 then
                                        call PrintCRLF;

                                    call PrintStr(.tokStr);
                                    call PrintChar(' ');
$IF OVL4
                                    if type = O$3A then
                                        call PrintChar('+');
                                    else
$ENDIF
				    if (zeroAddr := (flags and UF$EXTRN) <> 0) then
                                        call PrintChar('E');
                                    else
                                        call PrintChar(segChar(flags and UF$SEGMASK));

                                    call PrintChar(' ');
                                    call PrintAddr2(.print2Hex);
                                    call PrintAddr2(.print2Hex);
                                    curTokenSym$p = curTokenSym$p + 2;
                                    call PrintStr(.spaces4);
                                end;
                            end;
        end;
    end;

    if ctlDEBUG then
        b68AE = FALSE;

    if kk then
        call PrintCRLF;
end;

PrintCmdLine: procedure public;
    declare ch based actRead byte;

    call Outch(FF);
    call DoEject;
    ch = 0;
    call PrintStr(.cmdLineBuf);
    call NewPageHeader;
end;


OutStr: procedure(s) reentrant public;
    declare s address;
    declare ch based s byte;

    do while ch <> 0;
        call Outch(ch);
        s = s + 1;
    end;
end;

OutNStr: procedure(cnt, s) reentrant;
    declare cnt byte, s address,
        ch based s byte;

    do while cnt > 0;
        call Outch(ch);
        s = s + 1;
        cnt = cnt - 1;
    end;
end;


MoreBytes: procedure byte public;
    return startItem < endItem;
end;



Sub7229: procedure public;
    declare ch based startItem byte;
    declare i byte;

    if (showAddr := MoreBytes or showAddr) then
    do;	/* print the address */
        call Out2Hex(high(effectiveAddr));
        call Out2Hex(low(effectiveAddr));
    end;
    else
        call OutStr(.spaces4);

    call Outch(' ');
    do  i = 1 to 4;
        if MoreBytes and b6B34 then
        do;
            effectiveAddr = effectiveAddr + 1;
            call Out2Hex(ch);
        end;
        else
            call OutStr(.spaces2);

        startItem = startItem + 1;
    end;

    call Outch(' ');
    if shr(kk := tokenAttr(spIdx), 6) then
        call Outch('E');
    else if not showAddr then
        call Outch(' ');
    else
        call Outch(segChar(kk and 7));
end;


Sub72D8: procedure public;
    if not errorOnLine then
        return;

    call PrintStr(.ascLParen);    /* " (" */
    call PrintNStr(4, .b6A57);
    call PrintStr(.ascRParen);    /* ")" */
    call PrintCRLF;
    call move(4, .asciiLineNo, .b6A57);
end;



PrintLine: procedure public;
    declare ch based inCh$p byte;
$IF OVL4
    declare ch1 based macro$p byte;
$ENDIF
loop:
    endItem = (startItem := tokStart(spIdx)) + tokenSize(spIdx);
    if IsSkipping then
        endItem = startItem;

    call Outch(asmErrCode);
$IF OVL4
    if b905E = 0FFh then
        call Outch('-');
    else
$ENDIF
        call Outch(' ');

    if not BlankAsmErrCode then
    do;
        asmErrCode = ' ';
        errorOnLine = TRUE;
    end;
    if isControlLine then
        call OutStr(.spaces15);
    else
        call Sub7229;

    if fileIdx > 0 then
    do;
	/* note byte arith used so needToOpenFile = TRUE(255h) treated as -1 */
        call Outch(a1234(ii := needToOpenFile + fileIdx));
        if ii > 0 then    
            call Outch('=');
        else
            call Outch(' ');
    end;
    else
        call OutStr(.spaces2);

    if lineNumberEmitted then
    do;
        call OutStr(.spaces4);
        call PrintCRLF;
    end;
    else
    do;
        lineNumberEmitted = TRUE;
        call OutNStr(4, .asciiLineNo);
$IF OVL4
        if expandingMacro > 1 then
            call Outch('+');
        else
$ENDIF
            call Outch(' ');
$IF OVL4
        if expandingMacro > 1 then
        do;
            curCol = 24;
            ch1 = 0;
            call PrintStr(.macroLine);
            call PrintChar(LF);
        end;
        else
        do;
$ENDIF
            curCol = 24;
            call PrintNStr(lineChCnt, startLine$p);
	    if ch <> LF then
                 call PrintChar(LF);
$IF OVL4
        end;
$ENDIF
    end;

    if isControlLine then
    do;
        if ctlPAGING then
            call DoEject;
    end;
    else
    do;
        do while MoreBytes;
            call OutStr(.spaces2);
            call Sub7229;
            call PrintCRLF;
        end;

        if spIdx > 0 and (inDB or inDW) then
        do;
            call Sub546F;
            goto loop;
        end;
    end;

    call Sub72D8;
end;

AsmComplete: procedure public;
    if errCnt > 0 then
        call Itoa(errCnt, .aNoErrors);
    call PrintNStr((errCnt = 1) + 32, .aAssemblyComple);
    if errCnt > 0 then
    do;
        call move(4, .b6A57, .space5RP);
        call PrintNStr(8, .spaceLP);
    end;
    call Outch(CR);
    call Outch(LF);
end;

Ovl9: procedure public;
    if ctlPRINT then
        call CloseF(outfd);
    outfd = 0;
    pageLineCnt = 1;
    call AsmComplete;
    call Flushout;
end;

Ovl10: procedure public;
    declare ch based effectiveAddr byte;

    call CloseF(infd);
$IF OVL4
    call CloseF(macrofd);
    call Delete(.asmax$ref, .statusIO);
    if ctlOBJECT then
        call CloseF(objfd);
$ENDIF
    if ctlXREF then
    do;
        effectiveAddr = Physmem - 1;
        ch = '0';
        if asxref$tmp(0) = ':' then
            ch = asxref$tmp(2);
    
        call Load(.asxref, 0, 1, 0, .statusIO);
        call IoErrChk;
    end;

    call Exit;
end;
end;
init.plx
init: do;
$IF OVL4
$include(asm4e.ipx)
$ELSEIF OVL5
$include(asm5d.ipx)
$ELSE
$include(asmov3.ipx)
$ENDIF

declare aExtents(*) byte public initial(' LSTOBJ'),
    aDebug(*) byte public initial('DEBUG');


CmdSkipWhite: procedure public;
    declare cmdch based cmdch$p byte;
    
    do while (cmdch = ' ' or cmdch = TAB) and cmdch$p <> actRead;
        cmdch$p = cmdch$p + 1;
    end;
end;

GetDrive: procedure byte public;
    declare cmdch based cmdch$p byte;

    if cmdch = ':' then
    do;
        cmdch$p = cmdch$p + 2;
        return cmdch;
    end;
    else
        do ii = 0 to 4;		/* case insensitive compare to DEBUG */
        if cmdch <> aDebug(ii) and aDebug(ii) + 20h <> cmdch then
                return '0';	/* must be a file name so drive 0 */
            cmdch$p = cmdch$p + 1;
        end;
    call CmdSkipWhite;
    if cmdch <> ':' then
        return '0';
    cmdch$p = cmdch$p + 2;
    return cmdch;
end;

AddExtents: procedure public;
    do ii = 1 to 3;
        lstFile(kk + ii) = aExtents(ii);
        objFile(kk + ii) = aExtents(ii+3);
    end;
end;


/* asmov3 usage include overlay file initiatisation */

GetAsmFile: procedure public;
	declare cmdch based cmdch$p byte;

	CmdIsWhite: procedure byte;
		declare cmdch based cmdch$p byte;
		return cmdch = ' ' or cmdch = TAB or cmdch = CR;
	end;

$IF OVL4
	symTab(0) = .extKeywords;	/* extended key words */
$ELSE
	symTab(0) = .stdKeywords;	/* no extended key words */
$ENDIF
	symHighMark, endSymTab(0), symTab(1), endSymTab(1) =
$IF NOT OVL3
						 .MEMORY;
$ELSE
						 .EDATA;
$ENDIF
	call Rescan(1, .statusIO);	/* get the command line */
	call IoErrChk;
	call Read(1, .cmdLineBuf, 128, .actRead, .statusIO);
	call IoErrChk;
	actRead = actRead + .cmdLineBuf;	/* convert to pointer */
	scanCmdLine = TRUE;		/* scanning command line */
$IF OVL3
	call Write(0, .signonMsg, 29h, .statusIO);
	call Write(0, .signonMsg, 2, .statusIO);
	call IoErrChk;
$ENDIF
	call CmdSkipWhite;
$IF OVL3
	ovlFile(2),
$ENDIF
	asxref(2) = GetDrive; 	/* tem defaults to current drive */

	do while not CmdIsWhite;
		cmdch$p = cmdch$p + 1;
	end;

	call CmdSkipWhite;
	if cmdch = CR then		/* no name !! */
		call RuntimeError(4);

	infd = InOpen(cmdch$p, 1);	/* Open file for reading */
	rootfd, srcfd = infd;
	ii = TRUE;
	kk = 0;

	do while not CmdIsWhite;	/* copy file name over to the files list */
		files(0).name(kk) = cmdch;
		if ii then		/* and the name for the lst and obj files */
			lstFile(kk), objFile(kk) = cmdch;
		if cmdch = '.' then
		do;
			ii = FALSE;
			call AddExtents;	/* add lst and obj file extents */
		end;
		kk = kk + 1;
		cmdch$p = cmdch$p + 1;
	end;
	controls$p = cmdch$p;		/* controls start after file name */
	if ii then			/* no extent in source file */
	do;
		lstFile(kk) = '.';	/* add the . and the extents */
		objFile(kk) = '.';
		call AddExtents;
	end;

	files(0).name(kk) = ' ';	/* override current drive for tmp if explict in source file */
	if lstFile(0) = ':' and lstFile(2) <> '0' then
$IF OVL4
		asmax$ref(2),
$ENDIF
		asxref$tmp(2) = lstFile(2);
end;


ResetData: procedure public;	/* extended initialisation */

    call InitLine;

    b6B33, scanCmdLine, skipping(0), b6B2C, inElse(0), finished, segHasData(0), segHasData(1), inComment,
$IF OVL4
    expandingMacro, b905C, b905E,
$ENDIF
    hasVarRef, needToOpenFile = bZERO;
    noOpsYet, primaryValid, ctlLIST, ctlLISTChanged,
$IF OVL4
    ctlGEN,
$ENDIF
    ctlCOND = bTRUE;
$IF OVL4
    macroDepth, b9064, macroCondStk(0), macroCondSP, 
$ENDIF
    saveIdx, lookAhead, activeSeg, ifDepth, opSP, opStack(0) = bZERO;
$IF OVL4
    macroBlkCnt,
$ENDIF
    segSize(SEG$ABS), segSize(SEG$CODE), segSize(SEG$DATA),
    maxSegSize(SEG$ABS), maxSegSize(SEG$CODE), maxSegSize(SEG$DATA), effectiveAddr,
$IF OVL4
    w919B,
$ENDIF
    externId, errCnt = wZERO;
    passCnt = passCnt + 1;
    srcLineCnt, rightOp, pageCnt, pageLineCnt = 1;
    b68AE = FALSE;
    curChar = ' ';
    do ii = 0 to 11;		/* reset all the control seen flags */
        controlSeen(ii) = 0;
    end;
$IF OVL4
    curMacroBlk = 0FFFFh;
$ENDIF
    if not IsPhase1 then	/* close any Open include file */
    do;
        if fileIdx <> 0 then
        do;
            call CloseF(srcfd);
            call IoErrChk;
            srcfd = rootfd;
        end;

        fileIdx = bZERO;	/* reset files for another pass */
        endInBuf$p = .inBuf;
        inCh$p = endInBuf$p - 1;
        startLine$p = .inBuf;
        call Seek(infd, SEEKABS, .azero, .azero, .statusIO);	/* rewind */
        call IoErrChk;
    end;

    w6870 = Physmem + 0BFh;
    endOutBuf = .b6A00;
end;

InitRecTypes: procedure public;
    r$content.type = OMF$CONTENT;
    r$content.len = 3;
    r$publics.type = OMF$RELOC;
    r$publics.len = 1;
    r$interseg.type = OMF$INTERSEG;
    r$interseg.len = 2;
    r$extref.type = OMF$EXTREF;
    r$extref.len = 1;
end;
end;
key4.plm
keywords: do;
$include(key4.ipx)
declare copyright(*) byte data('(C) 1976,1977,1979,1980 INTEL CORP');

declare extKeywords(151) KEYWORD$T public initial(
/*
	4 byte packed keyword
	byte opcode base
	byte offset to next entry or 0 if end
	byte type
	byte flags
*/
	/* token        opBase	offset	type		flags */
	0A528h,	0,	0,	0,	K$NE,		0,	/* NE */
	63B0h,	0,	0CCh,	0,	K$IMM16,	0,	/* CZ */
	6E60h,	9C40h,	0,	0,	K$ENDM,		0,	/* ENDM */
	0BFB6h,	0,	0C0h,	0,	K$SINGLE,	0,	/* RNZ */
	0B354h,	0,	0C1h,	0,	K$REG16,	0,	/* POP */
	6EE9h,	0,	0,	0,	K$EQU,		0,	/* EQU */
	0C6CDh,	0,	32h,	80h,	K$IMM16,	0,	/* STA */
	0A1A5h,	0,	6,	80h,	K$MVI,		0,	/* MVI */
	0C6CFh,	0,	37h,	0,	K$SINGLE,	0,	/* STC */
	0C6CDh,	6158h,	0,	0,	K$SPECIAL,	1Bh,	/* STACK */
	6615h,	0,	27h,	0,	K$SINGLE,	0,	/* DAA */
	988Dh,	0E100h,	0Ah,	0,	K$LDSTAX,	0,	/* LDAX */
	61F6h,	0,	0C4h,	0,	K$IMM16,	0,	/* CNZ */
	53CFh,	0,	88h,	88h,	K$ARITH,	0,	/* ADC */
	53D0h,	0,	80h,	0,	K$ARITH,	0,	/* ADD */
	8D9Fh,	0,	0D2h,	0A0h,	K$IMM16,	0,	/* JNC */
	0,	0,	0,	0,	0,		0,	/*  */
	0,	0,	0,	0,	0,		0,	/*  */
	0,	0,	0,	0,	0,		0,	/*  */
	6E60h,	0,	0,	88h,	K$END,		0,	/* END */
	6A40h,	0,	3,	0A0h,	K$REGNAME,	0,	/* E */
	0,	0,	0,	0,	0,		0,	/*  */
	0AD70h,	0,	0,	0,	K$OR,		0,	/* OR */
	0AE08h,	0,	0D3h,	0,	K$IMM8,		0,	/* OUT */
	0A088h,	0,	0,	0,	K$MOD,		0,	/* MOD */
	0AD83h,	0,	0,	0,	K$ORG,		0,	/* ORG */
	0,	0,	0,	0,	0,		0,	/*  */
	8F70h,	0,	0CAh,	70h,	K$IMM16,	0,	/* JZ */
	68E9h,	76C0h,	0,	0,	K$DSEG,		0,	/* DSEG */
	0C488h,	0,	0,	0,	K$SET,		0,	/* SET */
	8BD8h,	0,	0DAh,	10h,	K$IMM16,	0,	/* JC */
	0C521h,	0,	30h,	0,	K$SINGLE,	2,	/* SIM */
	6618h,	0,	9,	8,	K$REG16,	0,	/* DAD */
	0B16Ch,	9600h,	0E9h,	0,	K$SINGLE,	0,	/* PCHL */
	0A4A1h,	6A40h,	0,	0,	K$NAME,		0,	/* NAME */
	6748h,	0,	0F3h,	0,	K$SINGLE,	0,	/* DI */
	53D5h,	0,	0C6h,	18h,	K$IMM8,		0,	/* ADI */
	6630h,	0,	0,	0,	K$DB,		0,	/* DB */
	8DB6h,	0,	0C2h,	0,	K$IMM16,	0,	/* JNZ */
	0AD7Dh,	0,	0B0h,	0,	K$ARITH,	0,	/* ORA */
	0B3FBh,	0,	6,	0,	K$REGNAME,	0,	/* PSW */
	0AD85h,	0,	0F6h,	0,	K$IMM8,		0,	/* ORI */
	0A09Ah,	0,	40h,	0B8h,	K$MOV,		0,	/* MOV */
	8610h,	0,	0,	0B8h,	K$IF,		0,	/* IF */
	0,	0,	0,	0,	0,		0,	/*  */
	9938h,	6400h,	2Ah,	0B0h,	K$IMM16,	0,	/* LHLD */
	9600h,	0,	5,	0B0h,	K$REGNAME,	0,	/* L */
	0C6F6h,	0,	90h,	0,	K$ARITH,	0,	/* SUB */
	0C634h,	9600h,	0F9h,	0,	K$SINGLE,	0,	/* SPHL */
	0C405h,	0,	0DEh,	0,	K$IMM8,		0,	/* SBI */
	0,	0,	0,	0,	0,		0,	/*  */
	0BF4Fh,	0,	7,	0,	K$SINGLE,	0,	/* RLC */
	5780h,	0,	0,	0,	K$REGNAME,	0,	/* B */
	0,	0,	0,	0,	0,		0,	/*  */
	0E614h,	9600h,	0E3h,	0E8h,	K$SINGLE,	0,	/* XTHL */
	0,	0,	0,	0,	0,		0,	/*  */
	0,	0,	0,	0,	0,		0,	/*  */
	0B11Bh,	6A40h,	2,	0,	K$SPECIAL,	0,	/* PAGE */
	0,	0,	0,	0,	0,		0,	/*  */
	0,	0,	0,	0,	0,		0,	/*  */
	0A7C0h,	0,	0,	0D8h,	K$NUL,		0,	/* NUL */
	8750h,	0,	0DBh,	0,	K$IMM8,		0,	/* IN */
	6E60h,	8610h,	0,	0D0h,	K$ENDIF,	0,	/* ENDIF */
	0,	0,	0,	0,	0,		0,	/*  */
	0,	0,	0,	0,	0,		0,	/*  */
	0C3FEh,	0,	98h,	0,	K$ARITH,	0,	/* SBB */
	0C6D7h,	9A10h,	0,	0,	K$STKLN,	0,	/* STKLN */
	0BFE0h,	0,	0F0h,	0,	K$SINGLE,	0,	/* RP */
	0C078h,	0,	0C7h,	0,	K$RST,		0,	/* RST */
	0C4F8h,	6400h,	22h,	0,	K$IMM16,	0,	/* SHLD */
	9E57h,	0BFB8h,	0,	0,	K$MACRO,	0,	/* MACRO */
	6231h,	0,	0ECh,	0,	K$IMM16,	0,	/* CPE */
	0B436h,	9957h,	0,	0A8h,	K$PUBLIC,	0,	/* PUBLIC */
	0BDA0h,	0,	17h,	0A8h,	K$SINGLE,	0,	/* RAL */
	6FF5h,	0CBE8h,	0,	0D8h,	K$EXITM,	0,	/* EXITM */
	6235h,	0,	0FEh,	0,	K$IMM8,		0,	/* CPI */
	0BF68h,	0,	0F8h,	0,	K$SINGLE,	0,	/* RM */
	0,	0,	0,	0,	0,		0,	/*  */
	0,	0,	0,	0,	0,		0,	/*  */
	0BDA6h,	0,	1Fh,	0,	K$SINGLE,	0,	/* RAR */
	805Bh,	7D00h,	0,	0B8h,	K$HIGH,		0,	/* HIGH */
	6400h,	0,	2,	0C8h,	K$REGNAME,	0,	/* D */
	0B447h,	7D00h,	0C5h,	0D0h,	K$REG16,	0,	/* PUSH */
	0C6FDh,	0,	0D6h,	8,	K$IMM8,		0,	/* SUI */
	6220h,	0,	0F4h,	0,	K$IMM16,	0,	/* CP */
	61A8h,	0,	0FCh,	0,	K$IMM16,	0,	/* CM */
	0,	0,	0,	0,	0,		0,	/*  */
	5629h,	76C0h,	0,	0,	K$ASEG,		0,	/* ASEG */
	0BFF1h,	0,	0E8h,	0,	K$SINGLE,	0,	/* RPE */
	880Ch,	5DC0h,	0,	0A8h,	K$IRPC,		0,	/* IRPC */
	0BE48h,	0,	0C9h,	0,	K$SINGLE,	0,	/* RET */
	876Eh,	0,	4,	0,	K$INRDCR,	0,	/* INR */
	0BEE1h,	0,	20h,	0,	K$SINGLE,	2,	/* RIM */
	0BFFBh,	0,	0E0h,	0,	K$SINGLE,	0,	/* RPO */
	0C6CDh,	0E100h,	2,	28h,	K$LDSTAX,	0,	/* STAX */
	988Dh,	0,	3Ah,	98h,	K$IMM16,	0,	/* LDA */
	7000h,	0BF90h,	0,	0,	K$EXTRN,	0,	/* EXTRN */
	8774h,	0,	3,	90h,	K$REG16,	0,	/* INX */
	61B5h,	0,	2Fh,	90h,	K$SINGLE,	0,	/* CMA */
	876Ch,	5449h,	1,	0,	K$SPECIAL,	0,	/* INPAGE */
	9A47h,	5500h,	0,	98h,	K$LOCAL,	0,	/* LOCAL */
	0E5BDh,	0,	0A8h,	8,	K$ARITH,	0,	/* XRA */
	80E0h,	0,	76h,	0,	K$SINGLE,	0,	/* HLT */
	8DE0h,	0,	0F2h,	0,	K$IMM16,	0,	/* JP */
	9A5Bh,	0,	0,	0,	K$LOW,		0,	/* LOW */
	6D88h,	0,	0FBh,	0,	K$SINGLE,	0,	/* EI */
	623Bh,	0,	0E4h,	0,	K$IMM16,	0,	/* CPO */
	6676h,	0,	5,	68h,	K$INRDCR,	0,	/* DCR */
	0E5C5h,	0,	0EEh,	0,	K$IMM8,		0,	/* XRI */
	555Dh,	0,	0A0h,	0,	K$ARITH,	0,	/* ANA */
	62A9h,	76C0h,	0,	0,	K$CSEG,		0,	/* CSEG */
	8D68h,	0,	0FAh,	0,	K$IMM16,	0,	/* JM */
	5560h,	0,	0,	0,	K$AND,		0,	/* AND */
	5140h,	0,	7,	58h,	K$REGNAME,	0,	/* A */
	0BE44h,	0C800h,	0,	0,	K$REPT,		0,	/* REPT */
	8DF1h,	0,	0EAh,	0,	K$IMM16,	0,	/* JPE */
	880Ch,	0,	0,	0,	K$IRP,		0,	/* IRP */
	5565h,	0,	0E6h,	0,	K$IMM8,		0,	/* ANI */
	9B00h,	0,	0,	0,	K$LT,		0,	/* LT */
	61B7h,	0,	3Fh,	0,	K$SINGLE,	0,	/* CMC */
	8DFBh,	0,	0E2h,	0,	K$IMM16,	0,	/* JPO */
	7BC0h,	0,	0,	0,	K$GT,		0,	/* GT */
	6978h,	0,	0,	78h,	K$DW,		0,	/* DW */
	6EC8h,	0,	0,	0,	K$EQ,		0,	/* EQ */
	68D8h,	0,	0,	48h,	K$DS,		0,	/* DS */
	7968h,	0,	0,	0A0h,	K$GE,		0,	/* GE */
	0A6D4h,	0,	0,	0,	K$SINGLE,	0,	/* NOP */
	9F01h,	0AD95h,	0,	0,	K$SPECIAL,	1Ch,	/* MEMORY */
	5FE0h,	9600h,	0CDh,	0,	K$IMM16,	0,	/* CALL */
	0BDD8h,	0,	0D8h,	0,	K$SINGLE,	0,	/* RC */
	53ADh,	0,	0CEh,	80h,	K$IMM8,		0,	/* ACI */
	0BF9Fh,	0,	0D0h,	0,	K$SINGLE,	0,	/* RNC */
	0E36Ch,	76C0h,	0EBh,	0,	K$SINGLE,	0,	/* XCHG */
	61C4h,	0,	0B8h,	8,	K$ARITH,	0,	/* CMP */
	667Ch,	0,	0BH,	0,	K$REG16,	0,	/* DCX */
	0C620h,	0,	6,	0,	K$SP,		0,	/* SP */
	9C40h,	0,	6,	0,	K$REGNAME,	0,	/* M */
	98A8h,	0,	0,	38h,	K$LE,		0,	/* LE */
	6018h,	0,	0DCh,	0,	K$IMM16,	0,	/* CC */
	7D00h,	0,	4,	50h,	K$REGNAME,	0,	/* H */
	0C03Fh,	0,	0Fh,	50h,	K$SINGLE,	0,	/* RRC */
	0C4F8h,	0,	0,	0,	K$SHL,		0,	/* SHL */
	5DC0h,	0,	1,	0,	K$REGNAME,	0,	/* C */
	0C170h,	0,	0C8h,	0,	K$SINGLE,	0,	/* RZ */
	0E556h,	0,	0,	0,	K$XOR,		0,	/* XOR */
	6E1Fh,	6A40h,	0,	0,	K$ELSE,		0,	/* ELSE */
	0A6D8h,	0,	0,	0,	K$NOT,		0,	/* NOT */
	0C4FEh,	0,	0,	0,	K$SHR,		0,	/* SHR */
	9BB5h,	0,	1,	0,	K$LXI,		0,	/* LXI */
	8D84h,	0,	0C3h,	0,	K$IMM16,	0,	/* JMP */
	61DFh,	0,	0D4h,	0,	K$IMM16,	0	/* CNC */
);


end;
makefile
ISIS=..\..\thames
V4=../../plm80v4/
V3=../../plm80v3/
TOOLS=../../tools/
F0=./
F2=.\list

PEXFILE=asm80.pex
PLMFLAGS=code print(:f2:$*.lst)

OVERLAY=6D4Ch

# bulk obj names
BASEOBJS = glb.obj asm801.obj asm82.obj asm83.obj asm46.obj asm85.obj\
	asm851.obj asm86.obj asm861.obj pcktkn.obj close.obj delete.obj error.obj\
       	exit.obj load.obj open.obj read.obj rescan.obj seek.obj write.obj

OBJS4 =	glb4.obj asm41.obj pcktkn.obj asm43.obj asm44.obj asm45.obj asm46.obj\
	asm47.obj asm48.obj asm49.obj asm4A.obj asm4B.obj asm4C.obj asm4D.obj asm4E.obj\
	close.obj delete.obj error.obj exit.obj\
	load.obj open.obj read.obj rescan.obj\
	seek.obj write.obj

OBJS5 =	glb5.obj asm51.obj pcktkn.obj asm82.obj asm83.obj asm55.obj asm46.obj\
	asm57.obj asm86.obj asm861.obj asmov0.obj asmov2.obj asmov1.obj asm5D.obj\
	close.obj delete.obj error.obj exit.obj\
	load.obj open.obj read.obj rescan.obj\
	seek.obj write.obj

P4SRCS = asm41.plm asm44.plm asm45.plm asm4e.plm asm51.plm asm55.plm asm5d.plm\
	asm801.plm asm83.plm asm851.plm asm861.plm asmov3.plm close.plm delete.plm\
	error.plm exit.plm glb.plm glb4.plm glb5.plm key4.plm keywrd.plm load.plm\
	open.plm read.plm rescan.plm seek.plm write.plm

P3SRCS = asm43.pl3 asm46.pl3 asm47.pl3 asm48.pl3 asm49.pl3 asm4a.pl3 asm4B.pl3 asm4c.pl3\
	asm4d.pl3 asm57.pl3 asm82.pl3 asm85.pl3 asm86.pl3 asmov0.pl3 asmov1.pl3 asmov2.pl3

ASRCS = pcktkn.asm cprite.asm memory.asm

TARGETS = asm80 asm80.ov0 asm80.ov1 asm80.ov2 asm80.ov3 asm80.ov4 asm80.ov5

#
# compilation and assembly rules
.SUFFIXES: .plm .pl3
.plm.obj:
	@SET ISIS_F0=$(F0)
	@SET ISIS_F1=$(V4)
	@SET ISIS_F2=$(F2)
	$(ISIS) :F1:PLM80 $< $(PLMFLAGS)
	@if not exist $*.obj exit /b 1

.pl3.obj:
	@SET ISIS_F0=$(F0)
	@SET ISIS_F1=$(V3)
	@SET ISIS_F2=$(F2)
	$(ISIS) :F1:PLM80 $< $(PLMFLAGS)
	@find $(F2)\$*.lst "     0 PROGRAM ERROR(S)" >nul || (del $*.obj & exit /b 1)

.plm.ipx:
	@SET ISIS_F0=$(F0)
	$(TOOLS:/=\)ngenpex $(PEXFILE) $<

.pl3.ipx:
	@SET ISIS_F0=$(F0)
	$(TOOLS:/=\)ngenpex $(PEXFILE) $<
	
.asm.obj:
	@SET ISIS_F0=$(F0)
	@SET ISIS_F1=$(V4)
	@SET ISIS_F2=$(F2)
	$(ISIS) :F1:ASM80 $< PRINT(:f2:$*.lst)
	@find $(F2)\$*.lst "ASSEMBLY COMPLETE,   NO ERRORS" >nul || (del $*.obj & exit /b 1)

# the default rule will force the makefile to be up to date
all: source

all:
	$(MAKE) $(TARGETS)

rebuild: uclean all

.extract: asm80_all.plm
	..\..\unpack.pl
	date /t >.extract


source: .extract $(ASRCS) $(P3SRCS) $(P4SRCS) $(P3SRCS:.pl3=.ipx) $(P4SRCS:.plm=.ipx)

# checking targets
# note if you change these two rules then you should do a nmake all or namke .extract first
# otherwise whilst the build will be ok the old verify/compare rules will be run

verify: all
	for %i in ($(TARGETS)) do $(TOOLS:/=\)diffbin %i $(V4)\%i

compare: all
	for %i in ($(TARGETS)) do fc /b %i $(V4)%i


# source files generated from shared code
asm43.pl3 asm82.pl3: asm4382.plx
	@SET ISIS_F0=$(F0)
	$(TOOLS:/=\)plmpp -sOVL4 -o asm43.pl3 $**
	$(TOOLS:/=\)plmpp -sBASE -o asm82.pl3 $**

asm48.pl3 asm86.pl3: asm4886.plx
	@SET ISIS_F0=$(F0)
	$(TOOLS:/=\)plmpp -sOVL4 -o asm48.pl3 $**
	$(TOOLS:/=\)plmpp -sBASE -o asm86.pl3 $**

asm49.pl3 asm861.plm: asm49861.plx
	@SET ISIS_F0=$(F0)
	$(TOOLS:/=\)plmpp -sOVL4 -o asm49.pl3 $**
	$(TOOLS:/=\)plmpp -sBASE -o asm861.plm $**

asm44.plm asm83.plm: as4483.plx
	@SET ISIS_F0=$(F0)
	$(TOOLS:/=\)plmpp -sOVL4 -o asm44.plm $**
	$(TOOLS:/=\)plmpp -sBASE -o asm83.plm $**

asm45.plm asm55.plm asm851.plm: as4555851.plx
	@SET ISIS_F0=$(F0)
	$(TOOLS:/=\)plmpp -sOVL4 -o asm45.plm $**
	$(TOOLS:/=\)plmpp -sOVL5 -o asm55.plm $**
	$(TOOLS:/=\)plmpp -sBASE -o asm851.plm $**

asm4a.pl3 asmov0.pl3: asm4aov0.plx
	@SET ISIS_F0=$(F0)
	$(TOOLS:/=\)plmpp -sOVL4 -o asm4a.pl3 $**
	$(TOOLS:/=\)plmpp -sOVL0 -o asmov0.pl3 $**

asm4d.pl3 asmov1.pl3: asm4dov1.plx
	@SET ISIS_F0=$(F0)
	$(TOOLS:/=\)plmpp -sOVL4 -o asm4d.pl3 $**
	$(TOOLS:/=\)plmpp -sOVL1 -o asmov1.pl3 $**

asm4c.pl3 asmov2.pl3: asm4cov2.plx
	@SET ISIS_F0=$(F0)
	$(TOOLS:/=\)plmpp -sOVL4 -o asm4c.pl3 $**
	$(TOOLS:/=\)plmpp -sOVL2 -o asmov2.pl3 $**

asm47.pl3 asm57.pl3 asm85.pl3: asm475785.plx
	@SET ISIS_F0=$(F0)
	$(TOOLS:/=\)plmpp -sOVL4 -o asm47.pl3 $**
	$(TOOLS:/=\)plmpp -sOVL5 -o asm57.pl3 $**
	$(TOOLS:/=\)plmpp -sBASE -o asm85.pl3 $**

asm41.plm asm51.plm asm801.plm: start.plx
	@SET ISIS_F0=$(F0)
	$(TOOLS:/=\)plmpp -sOVL4 -o asm41.plm $**
	$(TOOLS:/=\)plmpp -sOVL5 -o asm51.plm $**
	$(TOOLS:/=\)plmpp -sBASE -o asm801.plm $**

glb.plm glb4.plm glb5.plm: global.plx
	@SET ISIS_F0=$(F0)
	$(TOOLS:/=\)plmpp -sOVL4 -o glb4.plm $**
	$(TOOLS:/=\)plmpp -sOVL5 -o glb5.plm $**
	$(TOOLS:/=\)plmpp -sBASE -o glb.plm $**

asm4e.plm asm5d.plm asmov3.plm: init.plx
	@SET ISIS_F0=$(F0)
	$(TOOLS:/=\)plmpp -sOVL4 -o asm4e.plm $**
	$(TOOLS:/=\)plmpp -sOVL5 -o asm5d.plm $**
	$(TOOLS:/=\)plmpp -sOVL3 -o asmov3.plm $**

# build rules to make the program and overlays

asm80: base.abs asmov0.abs asmov1.abs asmov2.abs asmov3.abs keywrd.abs 
	@SET ISIS_F0=$(F0)
	@SET ISIS_F1=$(V4)
	$(ISIS) :F1:link base.abs,publics(asmov0.abs,asmov1.abs,asmov2.abs), "&" < <<
asmov3.abs,keywrd.abs to $*.rel &
map print(:f2:$*.lin)
<<NOKEEP
	$(ISIS) :F1:locate $*.rel to $@ SYMBOLS MAP PUBLICS print(:f2:$*.map) "&" < <<
STACKSIZE(0) PURGE NAME(ASM80)
exit
<<NOKEEP
	del $*.rel
	@find $(F2)\$*.lin "LINK MAP" >nul || (del $@ & exit /b 1)
	@(find $(F2)\$*.map "UNSATISFIED EXTERNAL" >nul && (del $@ & exit /b 1)) || exit /b 0)

asm80.ov0: asmov0.abs 
	@SET ISIS_F0=$(F0)
	@SET ISIS_F1=$(V4)
	$(ISIS) :F1:locate $** to $@ SYMBOLS MAP PUBLICS print(:f2:asmov0.map) "&" < <<
STACKSIZE(0) PURGE NAME(A80O0)
<<NOKEEP
	@(find $(F2)\$*.mo0 "UNSATISFIED EXTERNAL" >nul && (del $@ & exit /b 1)) || exit /b 0)

asm80.ov1: asmov1.abs 
	@SET ISIS_F0=$(F0)
	@SET ISIS_F1=$(V4)
	$(ISIS) :F1:locate $** to $@ SYMBOLS MAP PUBLICS print(:f2:asmov1.map) "&" < <<
STACKSIZE(0) PURGE NAME(A80O1)
<<NOKEEP	
	@(find $(F2)\$*.mo1 "UNSATISFIED EXTERNAL" >nul && (del $@ & exit /b 1)) || exit /b 0)


asm80.ov2: asmov2.abs 
	@SET ISIS_F0=$(F0)
	@SET ISIS_F1=$(V4)
	$(ISIS) :F1:locate $** to $@ SYMBOLS MAP PUBLICS print(:f2:asmov2.map) "&" < <<
STACKSIZE(0) PURGE NAME(A80O2)
<<NOKEEP	
	@(find $(F2)\$*.mo2 "UNSATISFIED EXTERNAL" >nul && (del $@ & exit /b 1)) || exit /b 0)

asm80.ov3: asmov3.abs
	@SET ISIS_F0=$(F0)
	@SET ISIS_F1=$(V4)
	$(ISIS) :F1:locate $** to $@ SYMBOLS MAP PUBLICS print(:f2:asmov3.map) "&" < <<
STACKSIZE(0) PURGE NAME(A80O3)
<<NOKEEP
	@(find $(F2)\$*.mo3 "UNSATISFIED EXTERNAL" >nul && (del $@ & exit /b 1)) || exit /b 0)


asm80.ov4: $(OBJS4) key4.obj
	@SET ISIS_F0=$(F0)
	@SET ISIS_F1=$(V4)
	$(ISIS) :F1:link "&" < <<
$(OBJS4: =, & 
),:f1:plm80.lib,key4.obj to asmov4.rel map print(:f2:asmov4.lin)
<<NOKEEP
	$(ISIS) :F1:locate asmov4.rel to $@ SYMBOLS NAME(A80O4) PURGE "&" < <<
MAP PUBLICS code(3780h) STACKSIZE(144) print(:f2:asmov4.map)
exit
<<NOKEEP
	@find $(F2)\asmov4.lin "LINK MAP" >nul || (del $@ & exit /b 1)
	@(find $(F2)\asmov4.map "UNSATISFIED EXTERNAL" >nul && (del $@ & exit /b 1)) || exit /b 0)


asm80.ov5: $(OBJS5) keywrd.obj
	@SET ISIS_F0=$(F0)
	@SET ISIS_F1=$(V4)
	$(ISIS) :F1:link "&" < <<
$(OBJS5: =, &
),:f1:plm80.lib,keywrd.obj to asmov5.rel map print(:f2:asmov5.lin)
<<NOKEEP
	$(ISIS) :F1:locate asmov5.rel to $@ SYMBOLS NAME(A80O5) PURGE "&" < <<
MAP PUBLICS code(3780h) STACKSIZE(144) print(:f2:asmov5.map)
exit
<<NOKEEP
	@find $(F2)\asmov5.lin "LINK MAP" >nul || (del $@ & exit /b 1)
	@(find $(F2)\asmov5.map "UNSATISFIED EXTERNAL" >nul && (del $@ & exit /b 1)) || exit /b 0)



# rules for intermediate files

base.abs: $(BASEOBJS)
	@SET ISIS_F0=$(F0)
	@SET ISIS_F1=$(V4)
	$(ISIS) :F1:link "&" < <<
$(BASEOBJS: =, & 
),:f1:plm80.lib to $*.rel print(:f2:$*.lin)
<<NOKEEP
	$(ISIS) :F1:locate $*.rel to $@ SYMBOLS MAP PUBLICS STACKSIZE(120) print(:f2:$*.map)
	del $*.rel
	@find $(F2)\$*.lin "UNRESOLVED EXTERNAL" >nul || (del $@ & exit /b 1)


keywrd.abs: keywrd.obj memory.obj
	@SET ISIS_F0=$(F0)
	@SET ISIS_F1=$(V4)
	$(ISIS) :F1:link $(**: =,) to $*.rel map print(:f2:$*.lin)
	$(ISIS) :F1:locate $*.rel to $@ SYMBOLS MAP PUBLICS CODE(075A2h) STACKSIZE(0) print(:f2:$*.map)
	del $*.rel
	@find $(F2)\$*.lin "LINK MAP" >nul || (del $@ & exit /b 1)
	@(find $(F2)\$*.map "UNSATISFIED EXTERNAL" >nul && (del $@ & exit /b 1)) || exit /b 0)

asmov0.abs: base.abs cprite.obj asmov0.obj
	@SET ISIS_F0=$(F0)
	@SET ISIS_F1=$(V4)
	$(ISIS) :F1:link publics(base.abs),cprite.obj,asmov0.obj to $*.rel map print(:f2:$*.la0)
	$(ISIS) :F1:locate $*.rel to $@ SYMBOLS MAP PUBLICS CODE($(OVERLAY)) STACKSIZE(0) print(:f2:$*.ma0)
	del $*.rel
	@find $(F2)\$*.la0 "LINK MAP" >nul || (del $@ & exit /b 1)


asmov1.abs: base.abs cprite.obj asmov1.obj
	@SET ISIS_F0=$(F0)
	@SET ISIS_F1=$(V4)
	$(ISIS) :F1:link publics(base.abs),cprite.obj,asmov1.obj,:F1:plm80.lib "&" < <<
to $*.rel map print(:f2:$*.la1)
<<NOKEEP
	$(ISIS) :F1:locate $*.rel to $@ SYMBOLS MAP PUBLICS CODE($(OVERLAY)) STACKSIZE(0) print(:f2:$*.ma1)
	del $*.rel
	@find $(F2)\$*.la1 "LINK MAP" >nul || (del $@ & exit /b 1)


asmov2.abs: base.abs cprite.obj asmov2.obj
	@SET ISIS_F0=$(F0)
	@SET ISIS_F1=$(V4)
	$(ISIS) :F1:link publics(base.abs),cprite.obj,asmov2.obj to $*.rel map print(:f2:$*.la2)
	$(ISIS) :F1:locate $*.rel to $@ SYMBOLS MAP PUBLICS CODE($(OVERLAY)) STACKSIZE(0) print(:f2:$*.ma2)
	del $*.rel
	@find $(F2)\$*.la2 "LINK MAP" >nul || (del $@ & exit /b 1)


asmov3.abs: base.abs cprite.obj asmov3.obj keywrd.abs
	@SET ISIS_F0=$(F0)
	@SET ISIS_F1=$(V4)
	$(ISIS) :F1:link publics(base.abs),cprite.obj,asmov3.obj,publics(keywrd.abs) "&" < <<
to $*.rel map print(:f2:$*.la3)
<<NOKEEP
	$(ISIS) :F1:locate $*.rel to $@ SYMBOLS MAP PUBLICS CODE($(OVERLAY)) STACKSIZE(0) print(:f2:$*.ma3)
	del $*.rel
	@find $(F2)\$*.la3 "LINK MAP" >nul || (del $@ & exit /b 1)

# pex file and makefile dependencies
$(P3SRCS:.pl3=.ipx) $(P3SRCS:.pl3=.obj): $(PEXFILE) makefile
$(P4SRCS:.plm=.ipx) $(P4SRCS:.plm=.obj): $(PEXFILE) makefile
$(ASRCS:.asm=.obj): makefile 

# housekeeping rules
clean:
	del /q *.obj *.abs *.rel *.*~ *~ *.ipx *.*~ 
	del /q $(F2)\*.*~ $(F2)\*.???

vclean: clean
	del asm80 asm80.ov?

uclean: vclean
	del ??????.* makefile *.plx .extract

gitprep: uclean
	..\..\unpack.pl



# auto generated

close.plm
close: DO;
$include(close.ipx)

close: procedure(conn, status$p) public;
    declare (conn, status$p) address;
    call Isis(ICLOSE, .conn);
end close;
end;
Delete.plm
Delete: DO;
$include(Delete.ipx)

Delete: procedure (path$p, status$p) public;
    declare (path$p, status$p) address;
    call Isis(IDELETE, .path$p);
end Delete;
end;
Error.plm
Error: DO;
$include(Error.ipx)

Error: procedure (Error$num) public;
    declare (Error$num) address;
    declare status address;
    status = .status;
    call Isis(IERROR, .Error$num);
end Error;
end;
Exit.plm
Exit: DO;
$include(Exit.ipx)

Exit: procedure public;
    declare tmp address;
    tmp = .tmp;
    call Isis(IEXIT, .tmp);
end Exit;
end;
Load.plm
Load: DO;
$include(Load.ipx)

Load: procedure (path$p, Load$offset, switch, entry$p, status$p) public;
    declare (path$p, Load$offset, switch, entry$p, status$p) address;
    call Isis(ILOAD, .path$p);
end Load;
end;
Open.plm
Open: DO;
$include(Open.ipx)

Open: procedure (conn$p, path$p, access, echo, status$p) public;
    declare (conn$p, path$p, access, echo, status$p) address;
    call Isis(IOPEN, .conn$p);
end Open;
end;
Read.plm
Read: DO;
$include(Read.ipx)

Read: procedure (conn, buff$p, count, actual$p, status$p) public;
    declare (conn, buff$p, count, actual$p, status$p) address;
    call Isis(IREAD, .conn);
end Read;
end;
Rescan.plm
Rescan: DO;
$include(Rescan.ipx)
Rescan: procedure (conn, status$p) public;
    declare (conn, status$p) address;
    call Isis(IRESCAN, .conn);
end Rescan;
end;
Seek.plm
Seek: DO;
$include(Seek.ipx)

Seek: procedure (conn, mode, block$p, byte$p, status$p) public;
    declare (conn, mode, block$p, byte$p, status$p) address;
    call Isis(ISEEK, .conn);
end Seek;
end;
Write.plm
Write: DO;
$include(Write.ipx)

Write: procedure (conn, buff$p, count, status$p) public;
    declare (conn, buff$p, count, status$p) address;
    call Isis(IWRITE, .conn);
end Write;
end;
pcktkn.asm
	public PckTkn
	public Isis
	extrn toksiz
	extrn tokst;

	aseg
Isis	equ	40h	; definition of Isis entry, here to avoid another asm file

; pckTkn - packs the token pointed by tokst, with length toksiz into 4 bytes
; packed version replaces original and toksize set to 4 bytes

	CSEG
PckTkn: lhld	tokst	; pointer to the token to pack
	xchg
	lxi	h, toksiz
	mov	c, m	; unpacked length
	mvi	m, 4	; new packed length is 4 bytes
	call pack3	; pack 3 chars into hl
	push	h
	call pack3
	pop	b
	xchg		; put the packed data into the first 4 bytes
	dcx	h
	dcx	h
	dcx	h
	mov	m, d
	dcx	h
	mov	m, e
	dcx	h
	mov	m, b
	dcx	h
	mov	m, c
	ret
pack3:
	lxi	h, 0	; get 3 chars packed into 2 bytes
	mvi	b, 3

L6291:
	push	d	; pointer to next char
	mov	d, h	; hl x 40
	mov	e, l
	dad	h
	dad	h
	dad	d
	dad	h
	dad	h
	dad	h
	pop	d	
	call pack1	; add in next char
	add	l
	mov	l, a
	mvi	a, 0
	adc	h
	mov	h, a
	dcr	b	; get the 3 chars
	jnz	L6291
	ret

pack1:	ldax	d		; pick up next character
	inx	d		; advance for next time
	dcr	c		; check it is valid
	jm	L62B7
	sui	2Fh		; /012345678  (0-9)
				; 9?@ABCDEFG  (10-19)
				; HIJKLMNOPQ  (20-29)
				; RSTUVWXYZ[  (30-39)
	cpi	10h		; digit so return
	rc
	sui	5		; exclude : ; < = >
	ret

L62B7:
	sub	a		; 0 no char
	ret

	end
cprite.asm
	CSEG
cprite:	db '(C) 1976,1977,1979,1980 INTEL CORP'
	end;
memory.asm
	public EDATA
	DSEG
EDATA	equ	$
	end



