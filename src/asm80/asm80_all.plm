src/asm80.pex
/* assembler routines & linkage */
Isis            P(B syscall,A param$p)
PckTok          P
EDATA        B

packToken       'PckTok'
tokenSize       'toksiz'
tokStart        'tokst'


lit             'literally'
TRUE            '0FFh'
FALSE           '0'
CR              '0Dh'
FF              '0Ch'
LF              '0Ah'
ESC		'1Bh'
TAB             '9'
MACROEOB    '0FEh'

# primiative types
bool             'byte'
word             'address'
pointer          'address'

/* character classes */
CC$BAD          '0'
CC$WS           '1'
CC$SEMI         '2'
CC$COLON        '3'
CC$CR           '4'
CC$PUN        '5'
CC$DOLLAR       '6'
CC$QUOTE        '7'
CC$DIG        '8'
CC$LET          '9'
CC$MAC		'10'
CC$ESC          '11'

TT$ID           '0'
TT$NUM          '2'
TT$STR          '4'

/* Isis syscall ids */
IOPEN           '0'
ICLOSE          '1'
IDELETE         '2'
IREAD           '3'
IWRITE          '4'
ISEEK           '5'
ILOAD           '6'
IEXIT           '9'
IRESCAN         '11'
IERROR          '12'
/* Seek operations */
SEEKTELL        '0'
SEEKBACK        '1'
SEEKABS         '2'
SEEKFWD         '3'
SEEKEND         '4'
/* segments */
SEG$ABS         '0'
SEG$CODE        '1'
SEG$DATA        '2'
SEG$STACK       '3'
SEG$MEMORY      '4'

/* relocatable record types */
OMF$MODHDR      '2'
OMF$MODEND      '4'
OMF$CONTENT     '6'
OMF$LINENO      '8'
OMF$EOF            '0EH'
OMF$ANCESTOR    '10H'
OMF$LOCALS      '12H'
OMF$PUBLICS     '16H'
OMF$EXTNAMES    '18H'
OMF$EXTREF      '20H'
OMF$RELOC       '22H'
OMF$INTERSEG    '24H'
OMF$LIBLOCS     '26H'
OMF$LIBNAMES    '28H'
OMF$LIBDICT     '2AH'
OMF$LIBHDR      '2CH'
OMF$COMDEF      '2EH'

/* Op types */
T$CR            '1'
T$LPAREN        '2'
T$RPAREN        '3'
T$STAR          '4'
T$PLUS          '5'
T$COMMA         '6'
T$MINUS         '7'
T$UPLUS         '8'
T$SLASH         '9'
T$UMINUS        '0Ah'
O$NONE          '0'
O$TARGET        '2'
O$LABEL         '3'
O$REF    '6'
O$ID            '9'
O$STRING        '0Ah'
O$DATA          '0Bh'
O$NUMBER        '0Ch'
K$SPECIAL       '5'
K$REGNAME       '7'
K$SP            '8'
K$EQ            '0Bh'
K$LT            '0Ch'
K$LE            '0Dh'
K$GT            '0Eh'
K$GE            '0Fh'
K$NE            '10h'
K$NOT           '11h'
K$AND           '12h'
K$OR            '13h'
K$XOR           '14h'
K$MOD           '15h'
K$SHL           '16h'
K$SHR           '17h'
K$HIGH          '18h'
K$LOW           '19h'
K$DB            '1Ah'
K$DW            '1Bh'
K$DS            '1Ch'
K$EQU           '1Dh'
K$SET           '1Eh'
K$ORG           '1Fh'
K$END           '20h'
K$IF            '21h'
K$ELSE          '22h'
K$ENDIF         '23h'
K$LXI           '24h'
K$REG16         '25h'
K$LDSTAX        '26h'
K$ARITH         '27h'
K$IMM8          '28h'
K$MVI           '29h'
K$INRDCR        '2Ah'
K$MOV           '2Bh'
K$IMM16         '2Ch'
K$SINGLE        '2Dh'
K$RST           '2Eh'
K$ASEG          '2Fh'
K$CSEG          '30h'
K$DSEG          '31h'
K$PUBLIC        '32h'
K$EXTRN         '33h'
K$NAME          '34h'
K$STKLN         '35h'
K$MACRO         '36h'
O$37            '37h'
K$ENDM          '38h'
K$EXITM         '39h'
O$3A            '3Ah'
K$IRP           '3Bh'
K$IRPC          '3Ch'
O$3D            '3Dh'
K$REPT          '3Eh'
K$LOCAL         '3Fh'
O$OPTVAL		'40h'
K$NUL           '41h'
O$MACROID       '64h'

/* sym flags */
UF$SEGMASK    '7'
UF$LOW          '8'
UF$HIGH         '10h'
UF$BOTH         '18h'
UF$PUBLIC       '20h'
UF$EXTRN        '40h'

/* xref types */
XREF$DEF    '0'
XREF$REF    '1'
XREF$FIN    '2'

/* symbol table ids */
TID$KEYWORD    '0'
TID$SYMBOL    '1'
TID$MACRO    '2'

/* user defined types */
TOKENSYM$T      'structure(tok(2) address, line address, type byte, flags byte)'
FILE$T          'structure(name(15) byte, blk address, byt address, b19 byte)'
MACRO$T1    'macroCondSP byte, ifDepth byte, mtype byte, b3 byte,w4 address'
MACRO$T2        'buf$p address, blk address, w10 address, w12 address, w14 address'
MACRO$T         'structure(MACRO$T1,MACRO$T2)'
CONTENT$T       'structure(type byte, len address, segid byte, offset address, dta(121) byte, crc byte)'
EOF$T           'structure(type byte, len address, crc byte)'
EXTNAMES$T    'structure(type byte, len address, dta(124) byte, crc byte)'
EXTREF$T        'structure(type byte, len address, hilo byte, dta(30) address, crc byte)'
INTERSEG$T      'structure(type byte, len address, segid byte, hilo byte, dta(29) address, crc byte)'
MODEND$T        'structure(type byte, len address, modtyp byte, segid byte, offset address, crc byte)'
MODHDR$T    'structure(type byte, len address, dta(26) byte)'
PUBLICS$T       'structure(type byte, len address, segid byte, dta(124) byte, crc byte)'
RELOC$T         'structure(type byte, len address, hilo byte, dta(62) address)'
KEYWORD$T    'structure(tok(2) address, base byte, delta byte, type byte, flags byte)'

/* common based variables */
curTokenSym     "TOKENSYM$T"..curTokenSym$p

$file(startm.plm)
b$3782          B
b$3783          B
w$3780          A
IsGT            PB
IsLT            PB
InsertByteInMacroTbl        P(B c)
InsertCharInMacroTbl        P(B c)

$file(startm.plm,startb.plm,starts.plm)
aBadSyntax      BS
aCo             BS
aCommand        BS
aEof            BS
aError          BS
aError$0        BS
aFile           BS
asmHeader BS
aMemory         BS
aModulePage     BS
ascCRLF         BS
aStack          BS
aTable          BS
bTRUE           B
bZERO           B
errStrs         AS
errStrsLen      BS
signonMsg       BS
spaces15        BS
spaces2         BS
spaces24        BS
spaces4         BS
spaces5         BS
spaces6         BS
BlankAsmErrCode PB
BlankMorPAsmErrCode PB
ChkGenObj       PB
CloseF          P(A conn)
Flushout        P
GetNibble       P(A bp,B idx)B
InitialControls P
InOpen          P(A path$p,A access)A
IoErrChk        P
IoError         P("pointer" s)
IsComma         PB
IsCR            PB
IsPhase1        PB
IsPhase2Print   PB
IsRParen        PB
IsSpace         PB
IsTab           PB
IsWhite         PB
Nibble2Ascii    P(B n)B
GetCmdCh        PB
Outch           P(B c)
OutStrN         P(A s,B n)
Physmem         PA
ParseControlLines P
Put2Hex         P(A pfunc,B val)
RuntimeError    P(B errCode)
Skip2EOL        P
SourceError     P(B errCh)
InitLine        P
WrConsole       P(A buf$p,A count)


$file(asm1m.plm)
ReadM           P(A blk)
nonHiddenSymbol        PB
FlushM        P
WriteM          P

$file(asm1m.plm,asm1n.plm)
Skip2NextLine   P
SkipWhite       P
SkipWhite$2     P
Tokenise        P

/* $file(asm2m.plm) */

$file(asm2m.plm,asm2n.plm)
opFlags           BS
GetPrec         P(B topOp)B
IsReg        P(B topOp)"bool"
ChkInvalidRegOperand        P
Sub4291        P
SetExpectOperands        P
GetNumVal        PA
MkCode        P(B arg1b)
NxtTokI        PB
ShowLine        PB
EmitXref        P(B xrefMode,A name)
SwapAccBytes    P
TestBit         P(B bitIdx,"pointer" bitVector)"bool"

/* $file(asm4m.plm) */

$file(asm4m.plm,asm8m.plm,asm4s.plm)
IsSkipping      PB
StrUcEqu        P("pointer" s,"pointer" t)"bool"
FinishLine    P
Sub546F        P

$file(rdsrc.plm)
needToOpenFile   "bool"
includeOnCmdLine "bool"
missingEnd      "bool"
lineChCnt           B
fileIdx         B
files           "FILE$T"S
srcfd       A
endInBuf$p         A
inCh$p         "pointer"
startLine$p         A
rootfd          A
CloseSrc          P
ReadF           P(B conn,A buff$p,A count)
ReadSrc           P(A bufLoc)
SeekI           P(B seekOP)
GetSrcCh        PB
OpenSrc        P

/* $file(asm3m.plm) */

$file(asm3m.plm,asm3s.plm)
Cond2Acc        P(B cond)
ChkSegAlignment        P(B seg)
UpdateHiLo        P(B hilo)
DoPass        P

$file(asm5m.plm)
Sub5CAD        P(A val,B type)
Sub65D9        P

$file(asm5m.plm,asm5n.plm)
labelUse          B
GetCh           PB
GetChClass      PB
Lookup          P(B tableId)B
UpdateSymbolEntry        P(A val,B type)
UnpackToken     P("pointer" src,"pointer" dst)

/* $file(asm6m.plm) */

$file(asm6m.plm,asm6n.plm)
BalanceError    P
CollectByte     P(B rc)
CommandError    P
DoubleDefError  P
ExpressionError P
FileError       P
GetId           P(B type)
GetNum          P
GetStr          P
HaveTokens      PB
IllegalCharError P
LocationError   P
MultipleDefError P
NameError       P
Nest         P(B arg1b)
NestingError    P
OPcodeOperandError P
OperandError    P
PhaseError      P
PopToken        P
PushToken       P(B type)
StackError      P
SyntaxError     P
UndefinedSymbolError P
UnNest        P(B arg1b)
ValueError      P

/* $file(cntrlm.plm) */
$file(cntrlm.plm,cntrln.plm)
ParseControls   P

$file(asm8m.plm)
b9C77          B
Sub72A4        P(B arg1b)
Sub7327        P
Sub73AD        P
Sub7517        P
Sub753E        P
Sub75FF        P
Sub76CE        P
Sub770B        P
Sub7844        P
Sub787A        P
Sub78CE        P

/* $file(emitm.plm) */

$file(emitm.plm,emitn.plm)
Ovl11           P
Ovl8            P
ReinitFixupRecs        P
WriteExtName    P
WriteModend     P
WriteModhdr     P
WriteRec        P(A rec$p)

/* $file(listm.plm) */

$file(listm.plm,listn.plm)
AsmComplete     P
NewPage         P
NewPageHeader   P
OutStr          P(A s)
PrintLine            P
FinishPrint            P
FinishAssembly           P
PrintCmdLine    P
PrintDecimal    P(A n)
SkipToEOP       P
DoEject        P
Sub7041$8447    P
MoreBytes        PB
PrintCodeBytes        P
PrintErrorLineChain        P

/* $file(initm.plm) */

$file(initm.plm,initb.plm,inits.plm)
aDebug          BS
aExtents        BS
AddExtents      P
CmdSkipWhite    P
GetAsmFile      P
GetDrive        PB
ResetData       P
InitRecTypes        P



/* $file(startb.plm) */

/* $file(asm52.plm) */

/* $file(asm8m.plm) */

/* $file(asm3b.plm) */
$file(asm3b.plm,asm3s.plm)
HandleOp        P
Parse        P

/* $file(initb.plm) */


$file(starts.plm)
ovlFile         BS
OvlMgr          P(B ovl)

/* $file(asm1n.plm) */
/* $file(asm2n.plm) */
/* $file(asm3s.plm) */
/* $file(asm4s.plm) */

$file(asm5n.plm)
ChkLF           P
InsertSym       P

/* $file(asm6n.plm) */

/* $file(cntrln.plm) */

/* $file(listn.plm) */

/* $file(emitn.plm) */

/* $file(inits.plm) */

$file(close.plm)
Close           P(A conn,A status$p)

$file(Delete.plm)
Delete          P(A path$p,A status$p)

$file(Error.plm)
Error           P(A Error$num)

$file(Exit.plm)
Exit            P

/* these share a common file with build controlled by $IF statements */
$file(globls.plm,globlm.plm,globlb.plm)
accum1          A
accum1$hb       B
accum1$lb       B
accum2          A
accum2$hb       B
accum2$lb       B
activeSeg       B
actRead         "pointer"
asmax$ref    BS
asxref       BS
asxref$tmp   BS
alignTypes      BS
argNestCnt      B        /* globlm */
asciiLineNo     BS
asmErrCode      B
azero           A
fixupSeg        B
curFixupHiLoSegId B
curFixupType    B
fixIdxs         BS
initFixupReq    "bool"S
firstContent    "bool"
inComment           "bool"
noOpsYet           "bool"
nameLen         B
inPublic           B
inExtrn           B
segHasData           BS
badExtrn           B
acc1Flags           B
acc2Flags           B
hasVarRef           B
acc1ValType           B
acc2ValType           B
gotLabel           B
name         BS
savName           BS
lhsUserSymbol           "bool"
rhsUserSymbol  "bool"
xRefPending           "bool"
passCnt           B
createdUsrSym           "bool"
usrLookupIsID           "bool"
needsAbsValue           "bool"
b6897           "bool"
tokI           B
errorOnLine    "bool"
atStartLine           B
showAddr        "bool"
lineNumberEmitted           "bool"
b68AE           "bool"
inBuf           BS
b6A00           B
spIdx           B
lastErrorLine           BS
ctlLISTChanged           "bool"
isControlLine      B        
inDB           B
inDW           B
inExpression           "bool"
curOpFlags           B
effectiveToken           B
topOp              B
b6B2C           "bool"
nextTokType           B
inNestedParen           B
expectingOperands     "bool"
expectingOpcode       "bool"
condAsmSeen           "bool"
b6B33           "bool"
isInstr           "bool"
expectOp           "bool"
b6B36           "bool"
b6BD9           "bool"
b6BDA           "bool"
jj           B
macroLine          BS        /* globlm */
b9058          "bool"        /* globlm */
b9059          "bool"        /* globlm */
b905A          B        /* globlm */
expandingMacro B        /* globlm */
b905C          B        /* globlm */
b905D          "bool"        /* globlm */
b905E          B        /* globlm */
b9060          "bool"        /* globlm */
b9061          "bool"        /* globlm */
b9062          B        /* globlm */
macroDepth          B        /* globlm */
b9064          B        /* globlm */
b9065          B        /* globlm */
b9066          B        /* globlm */
b91A1          B        /* globlm */
b91A2          B        /* globlm */
b91A3          B        /* globlm */
b91A4          BS        /* globlm */
accFixFlags          BS
cmdch$p         "pointer"
cmdLineBuf      BS
controlId       B
controls        BS
controlSeen     "bool"S
controls$p      A
ctlCOND         "bool"
ctlDEBUG        "bool"
ctlEJECT        B
ctlGEN          "bool"
ctlLIST         "bool"
ctlMACRODEBUG   "bool"
ctlMACROFILE    "bool"
ctlMOD85        "bool"
ctlOBJECT       "bool"
ctlPAGELENGTH   B
ctlPAGEWIDTH    B
ctlPAGING       "bool"
ctlPRINT        "bool"
ctlSYMBOLS      "bool"
ctlTITLE        "bool"
ctlTITLESTR     BS
ctlTTY          "bool"
ctlXREF         "bool"
curChar         B
curCol          B
curFileName$p   A
curMacroBlk     A        /* globlm */
curTokenSym$p   "pointer"
tokPtr          "pointer"
endLineBuf      A
endOutBuf       A
endSymTab       AS
errCnt          A
extNamIdx       B
finished        "bool"
fix20Idx        B
fix22Idx        B
fix24Idx        B
fix6Idx         B
has16bitOperand B
ifDepth         B
ii              B
inElse          "bool"S
infd            A
kk              B
lineBuf         BS
pageLineCnt         A
lookAhead       B
lstFile         BS
macroBuf        BS        /* globlm */
macroCondSP     B        /* globlm */
macroCondStk    BS        /* globlm */
MacroDebugOrGen B        /* globls & globlb */
macrofd         A
macroStk        "MACRO$T"S    /* globlm */
maxMacroBlk     A        /* globlm */
maxSegSize      AS
byteAt          BS        /* globlm */
moduleNameLen   B
nxtMacroBlk     A        /* globlm */
objfd           A
objFile         BS
macro$p         "pointer"    /* globlm */
openStatus      A
opSP            B
opStack         BS
newOp          B
outbuf          BS
outfd           A
out$p           "pointer"
pageCnt         A
phase           B
primaryValid    B
r$content       "CONTENT$T"
reget           B
r$eof           "EOF$T"
r$extnames     "EXTNAMES$T"
r$extref        "EXTREF$T"
r$interseg      "INTERSEG$T"
r$modend        "MODEND$T"
r$publics       "PUBLICS$T"
r$reloc         "RELOC$T"
saveIdx         B
saveStack       BS
scanCmdLine     B
segSize         AS
skipIf        "bool"S
startDefined    B
startOffset     A
startSeg        B
statusIO        A
symTab          AS
titleLen        B
tmac$b3         B        /* globlm */
tmac$blk        A        /* globlm */
tmac$buf$p      "pointer"    /* globlm */
tmac$ifDepth    B        /* globlm */
tmac$macroCondSP B        /* globlm */
tmac$mtype      B        /* globlm */
tmac$w10        A        /* globlm */
tmac$w12        A        /* globlm */
tmac$w14        A        /* globlm */
tmac$w4         A        /* globlm */
tokBuf          BS
tokBufIdx       B
tokBufLen       B
tokenAttr       BS
tokenIdx         B
tokStr          BS
tokenSym        AS
tokenSymId      AS
tokenType       BS
toksiz          BS
tokst           AS
tokType         B
contentBytePtr  "pointer"
fixOffset           A
externId           A
itemOffset           A
acc1NumVal           A
acc2NumVal           A
symHighMark           A
baseMacroTbl           "pointer"
endItem           A
startItem           A
effectiveAddr           A
sizeInBuf           A
srcLineCnt           A
tokNumVal           A
w6BCE           A
pAddr          "pointer" 
controlFileType           A
endMacroLine   BS        /* globlm */
w9068          "pointer"    /* globlm */
macroInPtr          "pointer"    /* globlm */
macroBlkCnt          A        /* globlm */
w9197          A        /* globlm */
w9199          A        /* globlm */
w919B          A        /* globlm */
w919D          A        /* globlm */
w919F          A        /* globlm */
wZERO           A
xreffd          A

$file(keym.plm)
extKeywords     AS

$file(keyn.plm)
stdKeywords     AS

$file(Load.plm)
Load            P(A path$p,A Load$offset,A switch,A entry$p,A status$p)

$file(Open.plm)
Open            P(A conn$p,A path$p,A access,A echo,A status$p)

$file(Read.plm)
Read            P(A conn,A buff$p,A count,A actual$p,A status$p)

$file(Rescan.plm)
Rescan          P(A conn,A status$p)

$file(Seek.plm)
Seek            P(A conn,A mode,A block$p,A byte$p,A status$p)

$file(Write.plm)
Write           P(A conn,A buff$p,A count,A status$p)

notes.txt
symbol table format
tok(2) address - packed symbol 3 chars per address field
val address - keywords - high byte is link to next entry
          user - offset of symbol
          macro - 
type byte
flags byte keywords xxxxxxrx    r = rim/sim
       user - xeph lsss    e = external p = public h = high l = low sss = seg
       macro table


src/globl.plx
$IF SMALL
globls: do;
$include(:f3:globls.ipx)
$ELSEIF MACRO
globlm: do;
$include(:f3:globlm.ipx)
$ELSE
globlb: do;
$include(:f3:globlb.ipx)
$ENDIF

/* force rescan to be included from system.lib */
rescan: procedure (conn, status$p) external;
    declare (conn, status$p) address;
end rescan;

$IF MACRO
declare IN$BUF$SIZE lit '512',
        OUT$BUF$SIZE lit '512';
$ELSEIF BIG
declare IN$BUF$SIZE lit '2048',
        OUT$BUF$SIZE lit '2048';
$ELSE
declare IN$BUF$SIZE lit '200',
        OUT$BUF$SIZE lit '128';
$ENDIF

$IF MACRO
declare    byteAt(1) byte public at(0),
    macroLine(127) byte public,
    endMacroLine(2) byte public,            /* space for 0 and a guard byte */
    macro$p pointer public initial(.macroLine),
    b9058 bool public initial(FALSE),
    b9059 bool public,
    b905A byte public,
    expandingMacro byte public,
    b905C byte public,
    b905D bool public initial(FALSE),
    b905E byte public,
    b905F byte,
    b9060 bool public,
    b9061 bool public,
    b9062 byte public,
    macroDepth byte public,
    b9064 byte public,
    b9065 byte public,
    b9066 byte public,
    argNestCnt byte public initial(0),
    w9068 pointer public,
    macroInPtr pointer public,
    /*
        mtype has the following values
        1 -> IRP
        2 -> IRPC
        3 -> REPT
        4 -> ???
        5 -> ???
    */
        
    macroStk(10) MACRO$T public,
    (tmac$macroCondSP, tmac$ifDepth,  tmac$mtype, tmac$b3) byte public at (.macroStk(0)),
    (tmac$w4, tmac$buf$p) address public at (.macroStk(0).w4),
    tmac$blk address public  at (.macroStk(0).blk) initial(0FFFFh),
    (tmac$w10, tmac$w12, tmac$w14) address public at (.macroStk(0).w10),
    w910C address,
    curMacroBlk address public initial(0FFFFh),
    nxtMacroBlk address public initial(0),
    maxMacroBlk address public initial(0),
    macroBlkCnt address public,
    macroBuf(129) byte public,
    w9197 address public,
    w9199 address public,
    w919B address public,
    w919D address public,
    w919F address public,
    b91A1 byte public initial(0),
    b91A2 byte public initial(0),

    b91A3 byte public initial(81h),
    b91A4(*) byte public initial(3Fh, 3Fh, 0, 0, 0, 0, 80h);
$ENDIF
/* ov4 compat 2C8C */
declare    contentBytePtr pointer public,
    fixupSeg byte public,
    fixOffset address public,
    curFixupHiLoSegId byte public,
    curFixupType byte public,
    fixIdxs(4) byte public initial(0, 0, 0, 0),
    (fix22Idx, fix24Idx, fix20Idx, fix6Idx) byte public at (.fixIdxs),
    extNamIdx byte public initial(0),
    initFixupReq(4) bool public initial(TRUE, TRUE, TRUE, TRUE),
    firstContent byte public initial(TRUE),
    r$eof EOF$T public initial(0Eh, 0),
    r$extnames EXTNAMES$T public initial(18h, 0, 0),
    moduleNameLen byte public initial(6),
    r$content CONTENT$T public initial(18h, 0, 0),	/* seems odd would expect 6 not 18h */
    r$publics PUBLICS$T public initial (16h, 1, 0, 0, 0),
    r$reloc RELOC$T public at(.r$publics),
    r$interseg INTERSEG$T public,
    r$extref EXTREF$T public,
    r$modend MODEND$T public initial( 4, 4, 0),
    wZERO address public initial(0),
    pad6741 byte initial(0ah),
    inComment bool public initial(FALSE),
    noOpsYet bool public initial(FALSE),
    nameLen byte public,
    startSeg byte public initial(1),
    padb6746 byte,
    activeSeg byte public,
    inPublic byte public initial(0),
    inExtrn byte public initial(0),
    segHasData(2) byte public,
    alignTypes(4) byte public initial(3, 3, 3, 3),
    externId address public,
    itemOffset address public,
    badExtrn byte public initial(0),
    startDefined byte public initial(0),
    startOffset address public initial(0),
    tokenIdx byte public initial(0),
    lineBuf(128) byte public,
    tokStart(9) address public initial(.lineBuf),
    tokPtr pointer public at(.tokStart),
    tokenSym(9) address public initial(0),
    curTokenSym$p pointer public at(.tokenSym(0)),
    tokenType(9) byte public,
    tokenSize(9) byte public initial(0),
    tokenAttr(9) byte public,
    tokenSymId(9) address public,
/* end */
    endLineBuf address public initial(.tokStart),
    ifDepth byte public initial(0),
    skipIf(9) bool public,
    inElse(9) bool public;
$IF MACRO
declare    macroCondSP byte public initial(0),
    macroCondStk(17) byte public,
    b94DD(2) byte;
$ENDIF
declare    opSP byte public,
    opStack(17) byte public,
/* ov4 compat 2CA0 */
    (accum1, accum2) address public,
    (accum1$lb, accum1$hb, accum2$lb, accum2$hb) byte public at(.accum1),
    acc1Flags byte public,
    acc2Flags byte public,
    hasVarRef byte public,
    acc1ValType byte public,
    acc2ValType byte public,
    acc1NumVal address public,
    acc2NumVal address public,
    curChar byte public initial(0),
    reget byte public initial(0),
    lookAhead byte public,
    pad6861 byte initial(0),
    symTab(3) address public,
    endSymTab(3) address public,
    symHighMark address public,
    baseMacroTbl pointer public,
    gotLabel byte public initial(0),
    name(6) byte public,
    savName(6) byte public,
    lhsUserSymbol bool public,
    rhsUserSymbol bool public,
    xRefPending bool public initial(FALSE),
    passCnt byte public initial(0),
    createdUsrSym bool public initial(FALSE),
    usrLookupIsID bool public initial(FALSE),
    needsAbsValue bool public initial(FALSE),
    objfd address public,
    xreffd address public,
    infd address public,
    outfd address public,
    macrofd address public,
    statusIO address public,
    openStatus address public,
    pad6894 address initial(0FFFFh),
    asmErrCode byte public initial(' '), 
    b6897 bool public initial(FALSE),
    primaryValid byte public initial(TRUE);
/* end */
$IF SMALL
declare    pad6899 byte initial(0);
$ENDIF
/* ov4 compat 2C9F */
declare    tokI byte public,
    errorOnLine bool public,
    atStartLine byte public,
    pad689D(2) byte,
    curCol byte public initial(1),
    endItem address public,
    startItem address public,
    pageLineCnt address public,
    effectiveAddr address public,
    pageCnt address public,
    pad68AA byte,
    showAddr bool public,
    pad68AC byte,
    lineNumberEmitted bool public initial(FALSE),
    b68AE bool public initial(FALSE),
    tokStr(7) byte public initial(0, 0, 0, 0, 0, 0, 0),
    sizeInBuf address public initial(IN$BUF$SIZE),
    inBuf(IN$BUF$SIZE) byte public,
    outbuf(OUT$BUF$SIZE) byte public,
/* end */
    b6A00 byte public,
/* ov4 compat 2F57 */
    out$p pointer public initial(.outbuf),
    endOutBuf address public,
    pad6A05 address initial(.outbuf),
    pad6A07 byte initial(0),
    objFile(15) byte public initial('               '), /* 15 spaces */
    lstFile(15) byte public initial('               '), /* 15 spaces */
    asxref$tmp(*) byte public initial(':F0:ASXREF.TMP '),
    asxref(*) byte public initial(':F0:ASXREF '),
    asmax$ref(*) byte public initial(':F0:ASMAC.TMP '),
    srcLineCnt address public initial(1),
    pad6A50(2) byte initial('  '),        /* protects for very big files */
    asciiLineNo(4) byte public initial('   0'),
    spIdx byte public,
    lastErrorLine(4) byte public initial('   0'),
    ctlDEBUG bool public initial(FALSE),    /* DEBUG */
    controls(1) byte public at(.ctlDEBUG),
    ctlMACRODEBUG bool public initial(FALSE),    /* MACRODEBUG */
    ctlXREF bool public initial(FALSE),    /* XREF */
    ctlSYMBOLS bool public initial(TRUE),    /* SYMBOLS */
    ctlPAGING bool public initial(TRUE),    /* PAGING */
    ctlTTY bool public initial(FALSE),    /* TTY */
    ctlMOD85 bool public initial(FALSE),    /* MOD85 */
    ctlPRINT bool public initial(TRUE),    /* PRINT */
    ctlOBJECT bool public initial(TRUE),    /* OBJECT */
    ctlMACROFILE bool public initial(FALSE),    /* MACROFILE */
    ctlPAGEWIDTH byte public initial(120),    /* PAGEWIDTH */
    ctlPAGELENGTH byte public initial(66),    /* PAGELENGTH */
    ctlINLCUDE byte initial(0),        /* INCLUDE */
    ctlTITLE bool public initial(FALSE),    /* TITLE */
    ctlSAVE byte,                /* SAVE */
    ctlRESTORE byte,            /* RESTORE */
    ctlEJECT byte public initial(0),    /* EJECT */
    ctlLIST bool public initial(TRUE),    /* LIST */    /* SAVE/RESTORE act on next 3 opts */
    ctlGEN bool public initial(TRUE),    /* GEN */
    ctlCOND bool public initial(TRUE),    /* COND */
    ctlLISTChanged bool public initial(TRUE),
    titleLen byte public initial(0),
    pad6A71 byte,
    pad6A72(3) byte initial(120, TRUE),
    controlSeen(12) bool public initial(0,0,0,0,0,0,0,0,0,0,0,0),
    saveStack(24) byte public,
    saveIdx byte public initial(0),
    ctlTITLESTR(64) byte public,
    tokBufLen byte public,
    tokType byte public,
    controlId byte public,
    tokBuf(64) byte public,
    tokBufIdx byte public initial(0),
    tokNumVal address public,
/* end */
    isControlLine byte public initial(FALSE);
$IF NOT MACRO
declare    MacroDebugOrGen byte public initial(0);
$ENDIF
/* ov4 compat 2F56 */
declare    scanCmdLine byte public,
    inDB byte public,
    inDW byte public,
    inExpression bool public,
    has16bitOperand byte public,
    phase byte public,
    curOpFlags byte public,
    effectiveToken byte public,
    newOp byte public,
    topOp byte public,
    b6B2C bool public,
    nextTokType byte public,
    finished bool public,
    inNestedParen byte public,
    expectingOperands bool public,
    expectingOpcode bool public,
    condAsmSeen bool public,    /* true when IF, ELSE, ENDIF seen (also macro to check) */
    b6B33 bool public,
    isInstr bool public initial(TRUE),
    expectOp bool public initial(TRUE),
    b6B36 bool public initial(FALSE),
    segSize(5) address public initial(0, 0, 0, 0, 0),    /* ABS, CODE, DATA, STACK, MEMORY */
    maxSegSize(3) address public initial(0, 0, 0),        /* seg is only ABS, CODE or DATA */
    cmdLineBuf(129) byte public,
    actRead pointer public,
    errCnt address public,
    padw6BCB address,    /* not used */
    w6BCE address public,
    pad6BD0(3) byte initial(0),
    azero address public initial(0),
    cmdch$p pointer public initial(.cmdLineBuf),
    controls$p address public,
    b6BD9 bool public initial(FALSE),
    b6BDA bool public,
    ii byte public,
    jj byte public,
    kk byte public;
/* end */
$IF MACRO
declare    b9B34 byte initial(0);
$ENDIF
/* ov4 compat 2F57 */
declare    curFileName$p address public,
    pAddr pointer public,
    accFixFlags(2) byte public at(.pAddr),
    controlFileType address public;     /* 1->INCLUDE 2->PRINT, 3->OBJECT or MACROFILE */
/* end */
end;
src/asm3.plx
$IF MACRO
asm3m: do;
$include(:f3:asm3m.ipx)
$ELSEIF BIG
asm3b: do;
$include(:f3:asm3b.ipx)
$ELSE
asm3s: do;
$include(:f3:asm3s.ipx)
$ENDIF

$IF SMALL
declare    CHKOVL$2 lit    'call OvlMgr(2)';
$ELSE
declare    CHKOVL$2 lit    ' ';
$ENDIF

            /* 0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F */
declare isExprOrMacroMap(*) bool data(
               0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,
               0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0,   0,   0,   0,   0,   0,
               0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
               0,   0,   0,   0,   0,   0,   0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh, 0,  0FFh,
               0FFh,0FFh),
   isInstrMap(*) bool data(
               0,   0FFh,0FFh,0FFh,0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
               0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0FFh,0FFh,0,   0,   0,   0,
               0,   0,   0,   0,   0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0,
               0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
               0FFh,0FFh);

declare pad byte;

declare    accum(4) byte at(.accum1);


ChkSegAlignment: procedure(seg) public;    /* seg = 0 => CSEG, seg = 1 => DSEG */
    declare seg byte;

    if segHasData(seg) then
    do;
        if HaveTokens then
        do;
            accum1 = GetNumVal;
            if alignTypes(seg) <> accum1$lb then
                call ExpressionError;
        end;
        else if alignTypes(seg) <> 3 then    /* no speficier - check byte algined */
            call ExpressionError;
    end;
    else
    do;
        segHasData(seg) = TRUE;
        if HaveTokens then
        do;
            accum1 = GetNumVal;
            if accum1 = 1 or accum1 = 2 then    /* only allow inPage and Page */
                alignTypes(seg) = low(accum1);
            else
                call ExpressionError;
        end;
    end;
end;


Cond2Acc: procedure(cond) public;    /* convert conditional result to accum1 */
    declare cond byte;        /* 0 or 0ffffh */

    accum1 = cond;
    if accum1 then
        accum1 = 0FFFFh;
end;

UpdateHiLo: procedure(hilo) public;
    declare hilo byte;

    if (acc1Flags and (UF$EXTRN + UF$SEGMASK)) <> 0 then
        acc1Flags = (acc1Flags and not UF$BOTH) or hilo;
end;

HandleOp: procedure public;
    do case topOp;
/* 0 */        ;
/* 1 */        call FinishLine;        /* CR */
/* 2 */        goto case3;            /* ( */
/* 3 */ case3:    do;                /* ) */
            if not (topOp = T$LPAREN and newOp = T$RPAREN) then
                call BalanceError;

            if tokenType(0) = O$DATA then
            do;
                tokenSize(0) = 1;
                tokenAttr(0) = 0;
                b6B36 = TRUE;
            end;

            expectOp = inNestedParen;
            if newOp = T$RPAREN then
                b6B2C = TRUE;
        end;
/* 4 */        accum1 = accum1 * accum2;    /* * */
/* 5 */        accum1 = accum1 + accum2;    /* + */
/* 6 */        do;                /* , */
            call SyntaxError;
            call PopToken;
        end;
/* 7 */        accum1 = accum1 - accum2;    /* - */
/* 8 */        ;                /* unary + */
/* 9 */        do;                /* / */
            if accum2 = 0 then
                call ValueError;

            accum1 = accum1 / accum2;
        end;
/* 10 */    accum1 = -accum1;            /* unary - */
/* 11 */    call Cond2Acc(accum1 = accum2);        /* EQ */
/* 12 */    call Cond2Acc(accum1 < accum2);        /* LT */
/* 13 */    call Cond2Acc(accum1 <= accum2);    /* LE */
/* 14 */    call Cond2Acc(accum1 > accum2);        /* GT */
/* 15 */    call Cond2Acc(accum1 >= accum2);    /* GE */
/* 16 */    call Cond2Acc(accum1 <> accum2);    /* NE */
/* 17 */    accum1 = not accum1;            /* NOT */
/* 18 */    accum1 = accum1 and accum2;        /* AND */
/* 19 */    accum1 = accum1 or accum2;        /* OR */
/* 20 */    accum1 = accum1 xor accum2;        /* XOR */
/* 21 */    do;                    /* MOD */
            if accum2 = 0 then
                call ValueError;
            accum1 = accum1 mod accum2;
        end;
/* 22 */    do;                    /* SHL */
            if accum2$lb <> 0 then
                accum1 = shl(accum1, accum2);
        end;
/* 23 */    do;                    /* SHR */
            if accum2$lb <> 0 then
                accum1 = shr(accum1, accum2);
        end;
/* 24 */    do;                    /* HIGH */
            accum1 = high(accum1);
            call UpdateHiLo(UF$HIGH);
        end;
/* 25 */    do;                    /* LOW */
            accum1 = low(accum1);
            call UpdateHiLo(UF$LOW);
        end;
/* 26 */    do;                    /* DB ? */
            if tokenType(0) <> O$STRING then
            do;
                accum1 = GetNumVal;
                if accum1$hb - 1 < 0FEh then    /* not 0 or FF */
                    call ValueError;
                curOpFlags = 22h;	/* never used -- getnum to acc1 & collect high(acc2) */
                if (acc1Flags and UF$BOTH) = UF$BOTH then
                do;
                    call ValueError;
                    acc1Flags = (acc1Flags and not UF$BOTH) or UF$LOW;
                end;
            end;
            else
            do;
                acc1Flags = 0;
                tokenType(0) = O$DATA;
            end;

            if IsReg(acc1ValType) then
                call OperandError;
            nextTokType = O$DATA;
            inDB = TRUE;
        end;
/* 27 */    do;                    /* DW ? */
            nextTokType = O$DATA;
            inDW = TRUE;
        end;
/* 28 */    do;                    /* DS ? */
            segSize(activeSeg) = segSize(activeSeg) + accum1;
            showAddr = TRUE;
        end;
/* 29 */ case29:                    /* EQU ? */
        do;
            showAddr = TRUE;
            if (acc1Flags and UF$EXTRN) = UF$EXTRN then    /* cannot SET or EQU to external */
            do;
                call ExpressionError;
                acc1Flags = 0;
            end;
            labelUse = 1;
            call UpdateSymbolEntry(accum1, (K$SET + 4) - topOp);    /* 4 for set, 5 for equ */
            expectingOperands = FALSE;
        end;
/* 30 */    goto case29;                /* SET ? */
/* 31 */    do;                    /* ORG ? */
            showAddr = TRUE;
            if (acc1Flags and UF$EXTRN) <> UF$EXTRN then
            do;
                if (acc1Flags and UF$BOTH) <> 0 then
                    if (acc1Flags and UF$SEGMASK) <> activeSeg
                        or (acc1Flags and UF$BOTH) <> UF$BOTH then
                        call ExpressionError;
            end;
            else
                call ExpressionError;

            if ctlOBJECT then
                if segSize(activeSeg) > maxSegSize(activeSeg) then
                    maxSegSize(activeSeg) = segSize(activeSeg);
            segSize(activeSeg) = accum1;
        end;
/* 32 */    do;                    /* END ? */
            if tokenIdx > 0 then
            do;
                startOffset = GetNumVal;
                startDefined = 1;
                startSeg = acc1Flags and 7;
                if (acc1Flags and UF$EXTRN) = UF$EXTRN then
                    call ExpressionError;
                if IsReg(acc1ValType) then
                    call OperandError;

                showAddr = TRUE;
            end;
$IF MACRO
            kk = b905E;
            b905E = 0;

            if macroCondSP > 0 or kk then
$ELSE
            if ifDepth > 0 then
$ENDIF
                call NestingError;
            if newOp <> T$CR then
                call SyntaxError;
            if expectOp then
                b6B33 = TRUE;
            else
                call SyntaxError;

        end;
/* 33 */    do;                    /* IF ? */
            if expectOp then
            do;
                condAsmSeen = TRUE;
                call Nest(2);        /* push current skip/else status */
                xRefPending = TRUE;        /* push current skip/else status */
                if skipIf(0) = FALSE then    /* if not skipping set new status */
                    skipIf(0) = not ((low(accum1) and 1) = 1);
                inElse(0) = FALSE;        /* not in else at this nesting level */
            end;
        end;
/* 34 */    do;                    /* ELSE ? */
            condAsmSeen = TRUE;
$IF MACRO
            if macroCondStk(0) <> 2 then	/* check not mid macro nest */
$ELSE
            if ifDepth = 0 then			/* invalid if not in if */
$ENDIF
                call NestingError;
            else if not inElse(0) then    /* shouldn't be in else at this level */
            do;
                if not skipIf(0) then    /* IF was active so ELSE forces skip */
                    skipIf(0) = TRUE;
                else            /* IF inactive so revert to previous skipping status */
                    skipIf(0) = skipIf(ifDepth);
                inElse(0) = TRUE;    /* in else at this nesting level */
            end;
            else
                call NestingError;    /* multiple else !! */
        end;
/* 35 */    do;                    /* ENDIF ? */
            if expectOp then
            do;
                condAsmSeen = TRUE;
                call UnNest(2);    /* revert to previous status */
            end;
        end;
        /* in the following topOp = 36 and nextTokType = O$DATA
           except where noted on return from MkCode */
/* 36 */    do;                    /* LXI ? */
            if nameLen = 1 then
                if name(0) = 'M' then
                    call SyntaxError;
            call MkCode(85h);    /* topOp = 2Ch on return */
        end;
/* 37 */    do;                /* POP DAD PUSH INX DCX ? */
            if nameLen = 1 then
                if name(0) = 'M' then
                    call SyntaxError;
            call MkCode(5);
        end;
/* 38 */    call MkCode(7);        /* LDAX STAX ? */
/* 39 */    call MkCode(2);        /* ADC ADD SUB ORA SBB XRA ANA CMP ? */
/* 40 */    call MkCode(8);        /* ADI OUT SBI ORI IN CPI SUI XRI ANI ACI ? */
/* 41 */    call MkCode(46h);    /* MVI ?  topOp = 40 on return */
/* 42 */    call MkCode(6);        /* INR DCR ? */
/* 43 */    call MkCode(36h);    /* MOV   topOp = 39 on return*/
/* 44 */    call MkCode(0);        /* CZ CNZ JZ STA JNZ JNC LHLD */
                        /* CP JC SHLD CPE CPO CM LDA JP JM JPE */
                        /* CALL JPO CC CNC JMP */
/* 45 */    call MkCode(0);        /* RNZ STC DAA DI SIM SPHL RLC */
                        /* RP RAL HLT RM RAR RPE RET RIM */
                        /* PCHL CMA CNC RPO EI XTHL NOP */
                        /* RC RNX XCHG RZ RRC */
/* 46 */    call MkCode(6);        /* RST */
/* 47 */    activeSeg = 0;            /* ASEG ? */
/* 48 */    do;                /* CSEG ? */
            activeSeg = 1;
            call ChkSegAlignment(0);
        end;
/* 49 */    do;                /* DSEG ? */
            activeSeg = 2;
            call ChkSegAlignment(1);
        end;

/* 50 */    do;                /* PUBLIC */
            inPublic = TRUE;
            labelUse = 0;
            call UpdateSymbolEntry(0, O$REF);
        end;
/* 51 */    do;                /* EXTRN ? */
            inExtrn = TRUE;
            if externId = 0 and IsPhase1 and ctlOBJECT then
            do;
                CHKOVL$2;
                call WriteModhdr;
            end;
            labelUse = 0;
            call UpdateSymbolEntry(externId, O$TARGET);
            if IsPhase1 and ctlOBJECT and not badExtrn then
            do;
                CHKOVL$2;
                call WriteExtName;
            end;
            if not badExtrn then
                externId = externId + 1;
            badExtrn = 0;
        end;
/* 52 */    do;                /* NAME */
            if tokenIdx <> 0 and noOpsYet then
            do;
                /* set the module name in the header - padded to 6 chars */
                call move(6, .spaces6, .aModulePage);
                call move(moduleNameLen := nameLen, .name, .aModulePage);
            end;
            else
                call SourceError('R');

            call PopToken;
        end;
/* 53 */    segSize(SEG$STACK) = accum1;    /* STKLN ? */
$IF MACRO
/* 54 */    call Sub7517;            /* MACRO ? */
/* 55 */    call Sub753E;
/* 56 */    call Sub75FF;            /* ENDM */
/* 57 */    call Sub76CE;            /* EXITM */
/* 58 */    do;
            tmac$mtype = 4;
            call Sub7327;
        end;
/* 59 */    call Sub72A4(1);        /* IRP ? */
/* 60 */    call Sub72A4(2);        /* IRPC */
/* 61 */    call Sub770B;
/* 62 */    call Sub7844;            /* REPT ? */
/* 63 */    call Sub787A;            /* LOCAL */
/* 64 */    call Sub78CE;
/* 65 */    do;                /* NUL */
            call Cond2Acc(tokenType(0) = K$NUL);
            call PopToken;
            acc1Flags = 0;
        end;
$ENDIF
    end;

    if topOp <> T$CR then
        noOpsYet = FALSE;
end;

Parse: procedure public;

    IsExpressionOp: procedure byte;
        if effectiveToken > T$RPAREN then
            if effectiveToken <> T$COMMA then
                if effectiveToken < K$DB then
                    return TRUE;
        return FALSE;
    end;

    IsVar: procedure(type) byte;
        declare type byte;
        return type = O$ID or type = O$MACROID;
    end;


    UpdateIsInstr: procedure;
        if not isInstrMap(topOp) then
            isInstr = FALSE;
    end;



    do while 1;
        if not (effectiveToken = T$CR or effectiveToken >= K$END and effectiveToken <= K$ENDIF)
           and skipIf(0)
$IF MACRO
               or (opFlags(effectiveToken) < 128 or b9058) and b905E

$ENDIF
            then
        do;
            needsAbsValue = FALSE;
            call PopToken;
            return;
        end;
        
        if phase <> 1 then
            if inExpression then
                if IsExpressionOp then
                    if GetPrec(effectiveToken) <= GetPrec(opStack(opSP)) then
                        call ExpressionError;

        if GetPrec(newOp := effectiveToken) > GetPrec(topOp := opStack(opSP)) or newOp = T$LPAREN then
        do;    /* SHIFT */
            if opSP >= 16 then
            do;
                opSP = 0;
                call StackError;
            end;
            else
                opStack(opSP := opSP + 1) = newOp;
            if newOp = T$LPAREN then
            do;
                inNestedParen = expectOp;
                expectOp = TRUE;
            end;
            if phase > 1 then
                inExpression = IsExpressionOp;
            return;
        end;

	/* REDUCE */
        inExpression = 0;
        if not expectOp and topOp > T$RPAREN then
            call SyntaxError;

        if topOp = O$NONE then	/* topOp used so set to newOp */
            topOp = newOp;
        else
            opSP = opSP - 1;	/* pop Op */
        

        if (curOpFlags := opFlags(topOp)) then		/* -------x -> getnum to acc1 & copy to acc2 */
        do;
            accum2 = GetNumVal;
            acc2Flags = acc1Flags;
            acc2NumVal = acc1NumVal;
            acc2ValType = acc1ValType;
        end;

        if (curOpFlags := ror(curOpFlags, 1)) then	/* ------x- -> getnum to acc1 */
            accum1 = GetNumVal;

        if not hasVarRef then
            hasVarRef = IsVar(acc1ValType) or IsVar(acc2ValType);

        nextTokType = O$NUMBER;
        if topOp > T$RPAREN and topOp < K$DB then    /* expression topOp */
            call Sub4291;
        else
        do;
            call UpdateIsInstr;
            call ChkInvalidRegOperand;
        end;

        call HandleOp;
        if not isExprOrMacroMap(topOp) then
            expectOp = FALSE;

        if b6B2C then
        do;
            b6B2C = FALSE;
            return;
        end;

        if topOp <> K$DS and showAddr then
            effectiveAddr = accum1;

        if (curOpFlags and 1Eh) <> 0 then		/* -xxxxx-- -> collect list or bytes */
            call PushToken(nextTokType);

        do ii = 0 to 3;
            if (curOpFlags := ror(curOpFlags, 1)) then	/* --xxxx-- -> collect high/low acc1/acc2 */
                call CollectByte(accum(ii));
        end;

        tokenAttr(0) = acc1Flags;
        tokenSymId(0) = acc1NumVal;
        if ror(curOpFlags, 1) then			/* -x------ -> list */
            if newOp = T$COMMA then
            do;
                effectiveToken = topOp;
                expectOp = TRUE;
            end;
    end;
end;



DoPass: procedure public;
    do while finished = FALSE;
        call Tokenise;
        call Parse;
    end;
end;

end;
src/emit.plx
$IF MACRO
emitm: do;
$include(:f3:emitm.ipx)
$ELSE
emitn: do;
$include(:f3:emitn.ipx)
$ENDIF

declare    fixupInitialLen(*) byte data(1, 2, 1, 3),
    fixupRecLenPtrs(*) address data(.r$publics.len, .r$interseg.len, .r$extref.len, .r$content.len),
    fixupRecLenChks(*) byte data(123, 58, 57, 124),
    b6D7E(*) byte data(10, 12h, 40h); /* 11 bits 00010010010 index left to right */


declare    r$modhdr MODHDR$T initial(2),
    (dta$p, recSym$p) pointer;



WriteRec: procedure(rec$p) public;
    declare rec$p address,
        len$p pointer, recLen address,
        i byte, crc byte;
    declare len based len$p address;
    declare ch based len$p byte;

    len$p = rec$p + 1;
    recLen = (len := len + 1) + 3;    /* include crc byte + type + len word */
    crc = 0;            /* crc */
    len$p = len$p - 1;
    do i = 2 to recLen;
        crc = crc - ch;
        len$p = len$p + 1;
    end;
    ch = crc;            /* insert crc byte */
    call Write(objfd, rec$p, recLen, .statusIO);
    call IoErrChk;
end;


GetFixupType: procedure byte;
    declare attr byte;
    if ((attr := tokenAttr(spIdx)) and 5Fh) = 0 then
        return 3;
    if (attr and UF$EXTRN) <> 0 then    /* external */
        return 2;
    if (fixupSeg := attr and UF$SEGMASK) = 0 then    /* absolute */
        return 3;
    return (fixupSeg <> activeSeg) and 1;
end;


ReinitFixupRecs: procedure public;
    declare i byte;
    declare wrd based dta$p address;
    do i = 0 to 3;
        ii = (i - 1) and 3;	/* order as content, publics, interseg, externals */
        dta$p = fixupRecLenPtrs(ii);
        if wrd > fixupInitialLen(ii) then
            call WriteRec(dta$p - 1);

        wrd = fixupInitialLen(ii);
        fixIdxs(ii) = 0;
        if curFixupType <>  ii then
            initFixupReq(ii) = TRUE;
    end;
    r$content.offset = itemOffset + segSize(r$content.segid := activeSeg);
    r$publics.segid = curFixupHiLoSegId;
    r$interseg.segid = tokenAttr(spIdx) and 7;
    r$interseg.hilo, r$extref.hilo = curFixupHiLoSegId;
end;



AddFixupRec: procedure;
    declare effectiveOffset address;

    declare wrd based dta$p address;

    dta$p = fixupRecLenPtrs(curFixupType := GetFixupType);
    if wrd > fixupRecLenChks(curFixupType) or r$content.len + tokenSize(spIdx) > 124 then
        call ReinitFixupRecs;

    if firstContent then
    do;
        firstContent = FALSE;
        r$content.offset = segSize(r$content.segid := activeSeg) + itemOffset;
    end;
    else if r$content.segid <> activeSeg
          or (effectiveOffset := r$content.offset + fix6Idx) <> segSize(activeSeg) + itemOffset
          or effectiveOffset < r$content.offset then
        call ReinitFixupRecs;


    do case curFixupType;
/* 0 */        do;
            if initFixupReq(0) then
            do;
                initFixupReq(0) = FALSE;
                r$publics.segid = curFixupHiLoSegId;
            end;
            else if r$publics.segid <> curFixupHiLoSegId then
                call ReinitFixupRecs;
        end;
/* 1 */        do;
            if initFixupReq(1) then
            do;
                initFixupReq(1) = FALSE;
                r$interseg.segid = tokenAttr(spIdx) and 7;
                r$interseg.hilo = curFixupHiLoSegId;
            end;
            else if r$interseg.hilo <> curFixupHiLoSegId or (tokenAttr(spIdx) and 7) <> r$interseg.segid then
                call ReinitFixupRecs;
        end;
/* 2 */        do;
            if initFixupReq(2) then
            do;
                initFixupReq(2) = FALSE;
                r$extref.hilo = curFixupHiLoSegId;
            end;
            else if r$extref.hilo <> curFixupHiLoSegId then
                call ReinitFixupRecs;

        end;
/* 3 */        ;        /* abs no fixup */
    end;
end;


RecAddContentBytes: procedure;
    declare i byte;

    declare ch based contentBytePtr byte;

    do i = 1 to tokenSize(spIdx);
        r$content.dta(fix6Idx) = ch;
        fix6Idx = fix6Idx + 1;
        contentBytePtr = contentBytePtr + 1;
    end;
    r$content.len = r$content.len + tokenSize(spIdx);
end;



IntraSegFix: procedure;
    r$reloc.len = r$reloc.len + 2;
    r$reloc.dta(fix22Idx) = fixOffset;
    fix22Idx = fix22Idx + 1;
end;


InterSegFix: procedure;
    r$interseg.len = r$interseg.len + 2;
    r$interseg.dta(fix24Idx) = fixOffset;
    fix24Idx = fix24Idx + 1;
end;

ExternalFix: procedure;
    r$extref.dta(fix20Idx) = tokenSymId(spIdx);
    r$extref.dta(fix20Idx + 1) = fixOffset;
    r$extref.len = r$extref.len + 4;
    fix20Idx = fix20Idx + 2;
end;

Sub7131: procedure;
    curFixupHiLoSegId = shr(tokenAttr(spIdx) and 18h, 3);
    fixOffset = segSize(activeSeg) + itemOffset;
    if not (inDB or inDW) and (tokenSize(spIdx) = 2 or tokenSize(spIdx) = 3) then
        fixOffset = fixOffset + 1;
    call AddFixupRec;
    contentBytePtr = startItem;
    call RecAddContentBytes;
    do case GetFixupType;
/* 0 */     call IntraSegFix;
/* 1 */        call InterSegFix;
/* 2 */        call ExternalFix;
/* 3 */        ;            /* no fixup as absolute */
    end;
end;


WriteExtName: procedure public;
    declare i byte;

    if r$extnames.len + 9 > 125 then    /* check room for name */
    do;
        call WriteRec(.r$extnames);    /* flush existing extNam Record */
        r$extnames.type = OMF$EXTNAMES;
        r$extnames.len = 0;
        extNamIdx = 0;
    end;
    r$extnames.len = r$extnames.len + nameLen + 2;    /* update length for this ref */
    r$extnames.dta(extNamIdx) = nameLen;        /* Write len */
    extNamIdx = extNamIdx + 1;
    do i = 0 to nameLen;            /* and name */
        r$extnames.dta(extNamIdx + i) = name(i);
    end;

    r$extnames.dta(extNamIdx + nameLen) = 0;    /* and terminating 0 */
    extNamIdx = extNamIdx + nameLen + 1;    /* update where next ref writes */
end;

WriteSymbols: procedure(isPublic);            /* isPublic= TRUE -> PUBLICs else LOCALs */
    declare isPublic byte;
    declare segId byte;
    declare symb based curTokenSym$p (1) byte;

    AddSymbol: procedure;
        declare offsetInSeg$p pointer;
        declare symNam based dta$p (1) byte;
        declare len based recSym$p byte;
        declare symOffset based recSym$p address;
        declare offsetInSeg based offsetInSeg$p address;

        if (symb(1) and 40h) <> 0 then
            return;
        offsetInSeg$p = curTokenSym$p - 2;
        symOffset = offsetInSeg; 
        call UnpackToken(curTokenSym$p - 6, (dta$p := (recSym$p := recSym$p + 2) + 1));
        symNam(6) = ' ';    /* trailing space to ensure end */
        len = 0;

        do while symNam(0) <> ' ';    /* find length of name */
            len = len + 1;
            dta$p = dta$p + 1;
        end;
        symNam(0) = 0;            /* terminate name with 0 */
        recSym$p = dta$p + 1;
    end;

    flushSymRec: procedure;
        if (r$publics.len := recSym$p - .r$publics.segid) > 1 then    /* something to Write */
            call WriteRec(.r$publics);
        r$publics.type = (isPublic and 4) or OMF$LOCALS;        /* PUBLIC or LOCAL */
        r$publics.segid = segId;
        recSym$p = .r$publics.dta;
    end;

    recSym$p = .r$publics.dta;
    do segId = 0 to 4;
        call FlushSymRec;    /* also sets up segid for new record */
        curTokenSym$p = symTab(TID$SYMBOL) - 2;        /* point to type byte of user symbol (-1) */

        do while (curTokenSym$p := curTokenSym$p + 8) < endSymTab(TID$SYMBOL);
            if recSym$p > .r$publics.crc - 10 then        /* make sure there is room */
                call FlushSymRec;

            if (symb(1) and UF$SEGMASK) = segId
$IF MACRO
               and symb(0) <> O$3A and nonHiddenSymbol
$ENDIF
               and not TestBit(symb(0), .b6D7E) and
               (not isPublic or (symb(1) and UF$PUBLIC) <> 0) then
                   call AddSymbol;
        end;
        call FlushSymRec;
    end;
end;



WriteModhdr: procedure public;
    declare w based dta$p address;
    declare b based dta$p byte;
    declare i byte;

    /* fill the module name */
    call move((r$modhdr.dta(0) := moduleNameLen), .aModulePage, .r$modhdr.dta(1));
    dta$p = .r$modhdr + moduleNameLen + 4;
    w = 0;    /* the two xx bytes */
    dta$p = dta$p + 1;    /* past first x byte */

    if segSize(SEG$CODE) < maxSegSize(SEG$CODE) then    /* code segment */
        segSize(SEG$CODE) = maxSegSize(SEG$CODE);
    if segSize(SEG$DATA) < maxSegSize(SEG$DATA) then    /* data segment */
        segSize(SEG$DATA) = maxSegSize(SEG$DATA);

    do i = 1 to 4;
        dta$p = dta$p + 1;
        b = i;        /* seg id */
        dta$p = dta$p + 1;
        w = segSize(i);    /* seg size */
        dta$p = dta$p + 2;
        b = alignTypes(i - 1);    /* aln typ */
    end;
    r$modhdr.len = moduleNameLen + 19;    /* set record length */
    call WriteRec(.r$modhdr);
end;

WriteModend: procedure public;
    declare lenb byte at (.r$eof.len);
    r$modend.modtyp = startDefined;
    r$modend.segid = startSeg;
    r$modend.offset = startOffset;
    call WriteRec(.r$modend);
    lenb = 0;
    call WriteRec(.r$eof);
end;

Ovl8: procedure public;
    itemOffset = 0;
    tokI = 1;
    spIdx = 1;
    if b6B33 then
        ;
    else
    do while spIdx <> 0;
        spIdx = NxtTokI;
        endItem = tokStart(spIdx) + tokenSize(spIdx);
        startItem = tokStart(spIdx);
        if IsSkipping or not isInstr then
            endItem = startItem;
        if endItem > startItem then
        do;
            call Sub7131;
            itemOffset = itemOffset + tokenSize(spIdx);
        end;
        if not(inDB or inDW) then
            spIdx = 0;
    end;
end;


Ovl11: procedure public;
    if externId <> 0 then
    do;
        call Seek(objfd, SEEKABS, .azero, .azero, .statusIO);    /* rewind */
        call WriteModhdr;
        call Seek(objfd, SEEKEND, .azero, .azero, .statusIO);    /* back to end */
    end;
    r$publics.type = OMF$PUBLICS;          /* public declarations record */
    r$publics.len = 1;
    r$publics.segid = SEG$ABS;
    r$publics.dta(0) = 0;
    call WriteSymbols(TRUE);      /* EMIT PUBLICS */
    if ctlDEBUG then
        call WriteSymbols(FALSE); /* EMIT LOCALS */
end;
end;
src/keyn.plm
keyn: do;
$include(:f3:keyn.ipx)

declare copyright(*) byte data('(C) 1976,1977,1979,1980 INTEL CORP');
declare stdKeywords(151) KEYWORD$T public initial(
/*
    4 byte packed keyword
    byte opcode base
    byte offset to next entry or 0 if end
    byte type
    byte flags
*/
    /* token	        opBase	offset	type		flags */
    0A528h,	0,	0,	0,	K$NE,		0,	/* NE */
    63B0h,	0,	0CCh,	0,	K$IMM16,	0,	/* CZ */
    0,	        0,	0,	0,	0,		0,	/* */
    0BFB6h,	0,	0C0h,	0,	K$SINGLE,	0,	/* RNZ */
    0B354h,	0,	0C1h,	0,	K$REG16,	0,	/* POP */
    6EE9h,	0,	0,	0,	K$EQU,		0,	/* EQU */
    0AD70h,	0,	0,	0E8h,	K$OR,		0,	/* OR */
    0A1A5h,	0,	6,	0E8h,	K$MVI,		0,	/* MVI */
    0C6CFh,	0,	37h,	0,	K$SINGLE,	0,	/* STC */
    0C6CDh,	6158h,	0,	0,	K$SPECIAL,	1Bh,	/* STACK */
    6615h,	0,	27h,	0,	K$SINGLE,	0,	/* DAA */
    988Dh,	0E100h,	0Ah,	0,	K$LDSTAX,	0,	/* LDAX */
    61F6h,	0,	0C4h,	0,	K$IMM16,	0,	/* CNZ */
    53CFh,	0,	88h,	0D8h,	K$ARITH,	0,	/* ADC */
    53D0h,	0,	80h,	0,	K$ARITH,	0,	/* ADD */
    6748h,	0,	0F3h,	0D0h,	K$SINGLE,	0,	/* DI */
    0,	0,	0,	0,	0,		0,	/* */
    0,	0,	0,	0,	0,		0,	/* */
    0,	0,	0,	0,	0,		0,	/* */
    53D5h,	0,	0C6h,	0C8h,	K$IMM8,		0,	/* ADI */
    6A40h,	0,	3,	0F0h,	K$REGNAME,	0,	/* E */
    0,	0,	0,	0,	0,		0,	/* */
    0,	0,	0,	0,	0,		0,	/* */
    0,	0,	0,	0,	0,		0,	/* */
    0A088h,	0,	0,	0,	K$MOD,		0,	/* MOD */
    0AD83h,	0,	0,	0,	K$ORG,		0,	/* ORG */
    0,	0,	0,	0,	0,		0,	/* */
    8F70h,	0,	0CAh,	0E8h,	K$IMM16,	0,	/* JZ */
    68E9h,	76C0h,	0,	0,	K$DSEG,		0,	/* DSEG */
    0C488h,	0,	0,	0,	K$SET,		0,	/* SET */
    0,	0,	0,	0,	0,		0,	/* */
    0C521h,	0,	30h,	0,	K$SINGLE,	2,	/* SIM */
    0,	0,	0,	0,	0,		0,	/* */
    0,	0,	0,	0,	0,		0,	/* */
    0A4A1h,	6A40h,	0,	0,	K$NAME,		0,	/* NAME */
    0C6CDh,	0,	32h,	0,	K$IMM16,	0,	/* STA */
    0AE08h,	0,	0D3h,	0,	K$IMM8,		0,	/* OUT */
    6630h,	0,	0,	0,	K$DB,		0,	/* DB */
    8DB6h,	0,	0C2h,	0,	K$IMM16,	0,	/* JNZ */
    0,	0,	0,	0,	0,		0,	/* */
    6618h,	0,	9,	0C0h,	K$REG16,	0,	/* DAD */
    8D9Fh,	0,	0D2h,	0,	K$IMM16,	0,	/* JNC */
    0A09Ah,	0,	40h,	0C0h,	K$MOV,		0,	/* MOV */
    8610h,	0,	0,	0C0h,	K$IF,		0,	/* IF */
    6E60h,	0,	0,	0A8h,	K$END,		0,	/* END */
    9938h,	6400h,	2Ah,	0B8h,	K$IMM16,	0,	/* LHLD */
    9600h,	0,	5,	0C0h,	K$REGNAME,	0,	/* L */
    0C6F6h,	0,	90h,	0,	K$ARITH,	0,	/* SUB */
    0C634h,	9600h,	0F9h,	0,	K$SINGLE,	0,	/* SPHL */
    0C405h,	0,	0DEh,	0,	K$IMM8,		0,	/* SBI */
    0B3FBh,	0,	6,	0,	K$REGNAME,	0,	/* PSW */
    0BF4Fh,	0,	7,	0,	K$SINGLE,	0,	/* RLC */
    5780h,	0,	0,	0,	K$REGNAME,	0,	/* B */
    0,	0,	0,	0,	0,		0,	/* */
    6220h,	0,	0F4h,	0F0h,	K$IMM16,	0,	/* CP */
    0,	0,	0,	0,	0,		0,	/* */
    0AD85h,	0,	0F6h,	0,	K$IMM8,		0,	/* ORI */
    0B11Bh,	6A40h,	2,	0,	K$SPECIAL,	0,	/* PAGE */
    0,	0,	0,	0,	0,		0,	/* */
    0,	0,	0,	0,	0,		0,	/* */
    5629h,	76C0h,	0,	0,	K$ASEG,		0,	/* ASEG */
    8750h,	0,	0DBh,	0,	K$IMM8,		0,	/* IN */
    6E60h,	8610h,	0,	0D0h,	K$ENDIF,	0,	/* ENDIF */
    0,	0,	0,	0,	0,		0,	/* */
    8BD8h,	0,	0DAh,	0F0h,	K$IMM16,	0,	/* JC */
    0AD7Dh,	0,	0B0h,	0,	K$ARITH,	0,	/* ORA */
    0C3FEh,	0,	98h,	0,	K$ARITH,	0,	/* SBB */
    0C6D7h,	9A10h,	0,	0,	K$STKLN,	0,	/* STKLN */
    0BFE0h,	0,	0F0h,	0,	K$SINGLE,	0,	/* RP */
    0C4F8h,	6400h,	22h,	0,	K$IMM16,	0,	/* SHLD */
    0C078h,	0,	0C7h,	0,	K$RST,		0,	/* RST */
    6231h,	0,	0ECh,	0,	K$IMM16,	0,	/* CPE */
    0B436h,	9957h,	0,	0E8h,	K$PUBLIC,	0,	/* PUBLIC */
    0BDA0h,	0,	17h,	0E8h,	K$SINGLE,	0,	/* RAL */
    80E0h,	0,	76h,	0E8h,	K$SINGLE,	0,	/* HLT */
    6235h,	0,	0FEh,	0,	K$IMM8,		0,	/* CPI */
    0BF68h,	0,	0F8h,	0,	K$SINGLE,	0,	/* RM */
    0,	0,	0,	0,	0,		0,	/* */
    0,	0,	0,	0,	0,		0,	/* */
    0BDA6h,	0,	1Fh,	0,	K$SINGLE,	0,	/* RAR */
    805Bh,	7D00h,	0,	0D0h,	K$HIGH,		0,	/* HIGH */
    623Bh,	0,	0E4h,	0D8h,	K$IMM16,	0,	/* CPO */
    0B447h,	7D00h,	0C5h,	0E0h,	K$REG16,	0,	/* PUSH */
    0,	0,	0,	0,	0,		0,	/* */
    0C6FDh,	0,	0D6h,	0F0h,	K$IMM8,		0,	/* SUI */
    61A8h,	0,	0FCh,	0,	K$IMM16,	0,	/* CM */
    0,	0,	0,	0,	0,		0,	/* */
    0,	0,	0,	0,	0,		0,	/* */
    0BFF1h,	0,	0E8h,	0,	K$SINGLE,	0,	/* RPE */
    62A9h,	76C0h,	0,	0,	K$CSEG,		0,	/* CSEG */
    0BE48h,	0,	0C9h,	0,	K$SINGLE,	0,	/* RET */
    876Eh,	0,	4,	0,	K$INRDCR,	0,	/* INR */
    0BEE1h,	0,	20h,	0,	K$SINGLE,	2,	/* RIM */
    0,	0,	0,	0,	0,		0,	/* */
    0B16Ch,	9600h,	0E9h,	0,	K$SINGLE,	0,	/* PCHL */
    988Dh,	0,	3Ah,	0,	K$IMM16,	0,	/* LDA */
    7000h,	0BF90h,	0,	0,	K$EXTRN,	0,	/* EXTRN */
    8774h,	0,	3,	0B0h,	K$REG16,	0,	/* INX */
    61B5h,	0,	2Fh,	0,	K$SINGLE,	0,	/* CMA */
    0,	0,	0,	0,	0,		0,	/* */
    61B7h,	0,	3Fh,	0,	K$SINGLE,	0,	/* CNC */
    0BFFBh,	0,	0E0h,	0,	K$SINGLE,	0,	/* RPO */
    0C6CDh,	0E100h,	2,	70h,	K$LDSTAX,	0,	/* STAX */
    0E5BDh,	0,	0A8h,	0,	K$ARITH,	0,	/* XRA */
    9A5Bh,	0,	0,	0,	K$LOW,		0,	/* LOW */
    6D88h,	0,	0FBh,	0,	K$SINGLE,	0,	/* EI */
    8DE0h,	0,	0F2h,	0,	K$IMM16,	0,	/* JP */
    6676h,	0,	5,	0D0h,	K$INRDCR,	0,	/* DCR */
    6400h,	0,	2,	0,	K$REGNAME,	0,	/* D */
    555Dh,	0,	0A0h,	0,	K$ARITH,	0,	/* ANA */
    0E5C5h,	0,	0EEh,	0,	K$IMM8,		0,	/* XRI */
    8D68h,	0,	0FAh,	0,	K$IMM16,	0,	/* JM */
    5560h,	0,	0,	0,	K$AND,		0,	/* AND */
    5140h,	0,	7,	38h,	K$REGNAME,	0,	/* A */
    0E614h,	9600h,	0E3h,	0,	K$SINGLE,	0,	/* XTHL */
    0,	0,	0,	0,	0,		0,	/* */
    876Ch,	5449h,	1,	0,	K$SPECIAL,	0,	/* INPAGE */
    5565h,	0,	0E6h,	0,	K$IMM8,		0,	/* ANI */
    9B00h,	0,	0,	0,	K$LT,		0,	/* LT */
    8DF1h,	0,	0EAh,	0,	K$IMM16,	0,	/* JPE */
    61C4h,	0,	0B8h,	20h,	K$ARITH,	0,	/* CMP */
    7BC0h,	0,	0,	0,	K$GT,		0,	/* GT */
    6978h,	0,	0,	78h,	K$DW,		0,	/* DW */
    6EC8h,	0,	0,	0,	K$EQ,		0,	/* EQ */
    667Ch,	0,	0Bh,	50h,	K$REG16,	0,	/* DCX */
    6E1Fh,	6A40h,	0,	0A0h,	K$ELSE,		0,	/* ELSE */
    0A6D4h,	0,	0,	0,	K$SINGLE,	0,	/* NOP */
    9F01h,	0AD95h,	0,	0,	K$SPECIAL,	1Ch,	/* MEMORY */
    5FE0h,	9600h,	0CDh,	0,	K$IMM16,	0,	/* CALL */
    0BDD8h,	0,	0D8h,	0,	K$SINGLE,	0,	/* RC */
    53ADh,	0,	0CEh,	80h,	K$IMM8,		0,	/* ACI */
    0BF9Fh,	0,	0D0h,	0,	K$SINGLE,	0,	/* RNC */
    0E36Ch,	76C0h,	0EBh,	0,	K$SINGLE,	0,	/* XCHG */
    8DFBh,	0,	0E2h,	0,	K$IMM16,	0,	/* JPO */
    68D8h,	0,	0,	0,	K$DS,		0,	/* DS */
    0C620h,	0,	6,	0,	K$SP,		0,	/* SP */
    9C40h,	0,	6,	0,	K$REGNAME,	0,	/* M */
    98A8h,	0,	0,	38h,	K$LE,		0,	/* LE */
    6018h,	0,	0DCh,	0,	K$IMM16,	0,	/* CC */
    7D00h,	0,	4,	50h,	K$REGNAME,	0,	/* H */
    61DFh,	0,	0D4h,	50h,	K$IMM16,	0,	/* CNC */
    0C4F8h,	0,	0,	0,	K$SHL,		0,	/* SHL */
    5DC0h,	0,	1,	0,	K$REGNAME,	0,	/* C */
    0C170h,	0,	0C8h,	0,	K$SINGLE,	0,	/* RZ */
    0E556h,	0,	0,	0,	K$XOR,		0,	/* XOR */
    7968h,	0,	0,	0,	K$GE,		0,	/* GE */
    0A6D8h,	0,	0,	0,	K$NOT,		0,	/* NOT */
    0C4FEh,	0,	0,	0,	K$SHR,		0,	/* SHR */
    9BB5h,	0,	1,	0,	K$LXI,		0,	/* LXI */
    8D84h,	0,	0C3h,	0,	K$IMM16,	0,	/* JMP */
    0C03Fh,	0,	0Fh,	0,	K$SINGLE,	0	/* RRC */
);


end;
src/start.plx
$IF SMALL
starts: do;
$include(:f3:starts.ipx)
$ELSEIF MACRO
startm: do;
$include(:f3:startm.ipx)
$ELSE
startb: do;
$include(:f3:startb.ipx)
$ENDIF

$IF SMALL
declare CHKOVL$0 lit    'call OvlMgr(0)',
    CHKOVL$1 lit    'call OvlMgr(1)',
    CHKOVL$2 lit    'call OvlMgr(2)',
    CHKOVL$3 lit    'call OvlMgr(3)';
$ELSE
declare CHKOVL$0 lit    ' ',
    CHKOVL$1 lit    ' ',
    CHKOVL$2 lit    ' ',
    CHKOVL$3 lit    ' ';
$ENDIF

$IF MACRO
declare w$3780 address public data(0),
    b$3782 byte public data(80h),
    b$3783 byte public data(81h);
$ENDIF

declare    spaces24(*) byte public data('         '),
    spaces15(*) byte public data('         '),
    spaces6(*) byte public data(' '),
    spaces5(*) byte public data(' '),
    spaces4(*) byte public data('  '),
    spaces2(*) byte public data('  ', 0),
    ascCRLF(*) byte public data(CR, LF, 0),
    signonMsg(*) byte public data(CR, LF),
    asmHeader(*) byte public data('ISIS-II 8080/8085 MACRO ASSEMBLER, V4.1', TAB, TAB),
    aModulePage(*) byte public data('MODULE ', TAB, ' PAGE ', 0),
    bZERO byte public data(0),
    bTRUE byte public data(TRUE),
    copyright(*) byte data('(C) 1976,1977,1979,1980 INTEL CORP'),
    aStack(*) byte public data(CR, LF, 'STACK', 0),
    aTable(*) byte public data(CR, LF, 'TABLE', 0),
    aCommand(*) byte public data(CR, LF, 'COMMAND', 0),
    aEof(*) byte public data(CR, LF, 'EOF', 0),
    aFile(*) byte public data(CR, LF, 'FILE', 0),
    aMemory(*) byte public data(CR, LF, 'MEMORY', 0),
    aError(*) byte public data(' ERROR', CR, LF, 0),
    aError$0(*) byte public data(' ERROR, ', CR,LF, 0),
    errStrs(*) address public data(.aStack, .aTable, .aCommand, .aEof, .aFile, .aMemory),
    errStrsLen(*) byte public data(7, 7, 9, 5, 6, 8),
    aBadSyntax(*) byte public data('BAD SYNTAX', CR, LF),
    aCo(*) byte public data(':CO:', 0);

$IF SMALL
declare    loadedOvl byte initial(4),
    ovlFile(*) byte public initial(':F0:ASM80.OV0 ');
$ENDIF

Physmem: procedure address public;
    declare top address at(4);

    return (top - 100h) and 0FF00h;
end;


GetCmdCh: procedure byte public;
    declare cmdch based cmdch$p byte;
    declare ch byte;

    ch = cmdch;
    cmdch$p = cmdch$p + 1;
    if 'a' <= ch and ch <= 'z' then
        ch = ch and 5Fh;
    return ch;
end;    


IoErrChk: procedure public;
    if statusIO = 0 then
        return;
    call Error(statusIO);
    call Exit;
end;


Flushout: procedure public;
    call Write(outfd, .outbuf, out$p - .outbuf, .statusIO);
    out$p = .outbuf;
end;

Outch: procedure(c) public;
    declare c byte;
    declare outc based out$p byte;

    if out$p = endOutBuf then
        call Flushout;
    outc = c;
    out$p = out$p + 1;
end;

OutStrN: procedure(s, n) public;
    declare s pointer, n byte;
    declare ch based s byte;

    do while n > 0;
        call Outch(ch);
        s = s + 1;
        n = n - 1;
    end;
end;

$IF SMALL
OvlMgr: procedure(ovl) public;
    declare ovl byte;
    declare entry$p address;

    if ovl > 4 then
    do;
        statusIO = 0Dh;
        call IoErrChk;
    end;
    if ovl <> loadedOvl then
    do;
        ovlFile(12) = ovl + '0';
        call Load(.ovlFile, 0, 0, .entry$p, .statusIO);
        call IoErrChk;
        loadedOvl = ovl;
    end;
end;
$ENDIF

CloseF: procedure(conn) public;
    declare conn address;

    call Close(conn, .statusIO);
end;

IsSpace: procedure byte public;
    return curChar = ' ';
end;

IsTab: procedure byte public;
    return curChar = TAB;
end;

IsWhite: procedure byte public;
    return IsSpace or IsTab;
end;

IsRParen: procedure byte public;
    return curChar = ')';
end;

IsCR: procedure byte public;
    return curChar = CR;
end;

IsComma: procedure byte public;
    return curChar = ',';
end;

$IF MACRO
IsLT: procedure byte public;
    return curChar = '<';
end;


IsGT: procedure byte public;
    return curChar = '>';
end;

$ENDIF

IsPhase1: procedure byte public;
    return phase = 1;
end;

Skip2EOL: procedure public;
    if not IsCR then
        do while GetCh <> 0Dh;
        end;
end;


ChkGenObj: procedure byte public;
$IF SMALL
    return (phase > 2) and ctlOBJECT;
$ELSE
    return (phase = 2) and ctlOBJECT;
$ENDIF
end;


IsPhase2Print: procedure byte public;
    return phase = 2 and ctlPRINT;
end;


WrConsole: procedure(buf$p, count) public;
    declare (buf$p, count) address;

    call Write(0, buf$p, count, .statusIO);
    call IoErrChk;
end;


RuntimeError: procedure(errCode) public;
    declare errCode byte;

    if b6BD9 then
        return;

    if IsPhase1 and errCode = 0 then
    do;
        b6B33 = TRUE;
        return;
    end;

    pAddr = .aError;        /* assume " ERROR\r\n" */
    if errCode = 4 then        /* file Error */
        pAddr = .aError$0;    /* replace with " ERROR, " */

    call WrConsole(errStrs(errCode), errStrsLen(errCode));    /* Write the ERROR type */
    call WrConsole(pAddr, 8);    /* Write the ERROR string */
    if IsPhase2Print then        /* repeat to the print file if required */
    do;
        call OutStrN(errStrs(errCode), errStrsLen(errCode));
        call OutStrN(pAddr, 8);
    end;

    if errCode = 4 or errCode = 3 then    /* file or EOF Error */
    do;
        if tokBufIdx = 0 then
        do;
            call WrConsole(.aBadSyntax, 12);
            if not scanCmdLine then
            do;
                call Skip2NextLine;
                outfd = 0;
                CHKOVL$1;
                call PrintDecimal(srcLineCnt);    /* overlay 1 */
                call Outch(LF);
            end;
        end;
        else
        do;
            call WrConsole(curFileName$p, tokBufIdx);
            call WrConsole(.ascCRLF, 2);
        end;
    end;

    if errCode = 0 then    /* stack Error */
    do;
        b6BD9 = TRUE;
        return;
    end;

    call Exit;
end;

IoError: procedure(s) public;
    declare s pointer;
    declare ch based s byte;

    tokBufIdx = 0;
    curFileName$p = s;

    do while ch <> ' ' and ch <> CR and ch <> TAB;
        tokBufIdx = tokBufIdx + 1;
        s = s + 1;
    end;
    if missingEnd then
        call RuntimeError(3);    /* EOF Error*/
    call RuntimeError(4);        /* file Error */
end;

InOpen: procedure(path$p, access) address public;
    declare (path$p, access) address;
    declare Open$infd address;

    call Open(.Open$infd, path$p, access, 0, .openStatus);
    if openStatus <> 0 then
        call IoError(path$p);
    return Open$infd;
end;


Nibble2Ascii: procedure(n) byte public;
    declare n byte;
    n = (n and 0Fh) + '0';
    if n > '9' then
        n = n + 7;
    return n;
end;

Put2Hex: procedure(pfunc, val) public;
    declare pfunc address, val byte;

    call pfunc(Nibble2Ascii(ror(val, 4)));
    call pfunc(Nibble2Ascii(val));
end;

BlankAsmErrCode: procedure byte public;
    return asmErrCode = ' ';
end;

BlankMorPAsmErrCode: procedure byte public;
    return BlankAsmErrCode or asmErrCode = 'M' or asmErrCode = 'P';
end;


GetNibble: procedure(bp, idx) byte public;
    declare bp pointer, idx byte;
    declare b based bp byte;
    declare n byte;

    bp = bp + shr(idx, 1);    /* index into buffer the number of nibbles */
    n = b;            /* pick up the byte there */
    if not idx then        /* pick up the right nibble */
        n = ror(n, 4);
    return n and 0Fh;    /* mask to leave just the nibble */
end;

SourceError: procedure(errCh) public;
    declare errCh byte;

    if not IsSkipping or topOp = K$ELSE then    /* ELSE */
    do;
        if inExtrn then
            badExtrn = TRUE;
        if BlankAsmErrCode then
            errCnt = errCnt + 1;

        if BlankMorPAsmErrCode or errCh = 'L' or errCh = 'U' then    /* no Error or M, P L or U */
            if asmErrCode <> 'L' then    /* override unless already location counter Error */
                asmErrCode = errCh;

    end;
end;

$IF MACRO

InsertByteInMacroTbl: procedure(c) public;
    declare c byte;
    declare ch based macroInPtr byte;

    ch = c;
    if (macroInPtr := macroInPtr + 1) > baseMacroTbl then
        call RuntimeError(1);    /* table Error */
end;


InsertCharInMacroTbl: procedure(c) public;
    declare c byte;

    call InsertByteInMacroTbl(c);
    if c = CR then
        call InsertByteInMacroTbl(LF);
end;

$ENDIF


ParseControlLines: procedure public;

    do while GetCh = '$';
        if IsSkipping then
        do;
            call Skip2NextLine;
            isControlLine = TRUE;
$IF MACRO
            if b905E = 1 then
                b6897 = TRUE;
$ENDIF
        end;
        else
        do;
            CHKOVL$0;
            call ParseControls;
        end;
        call FinishLine;
    end;
    reget = 1;    /* push back character */
end;


InitialControls: procedure public;
    cmdch$p = controls$p;
    scanCmdLine = TRUE;
    CHKOVL$0;
    call ParseControls;
    if IsPhase2Print then
    do;
        CHKOVL$1;
        call PrintCmdLine;
    end;
    if needToOpenFile then
        call OpenSrc;

    needToOpenFile, isControlLine, scanCmdLine = bZERO;
    call ParseControlLines;            /* initial control lines allow primary controls */
    primaryValid = FALSE;            /* not allowed from now on */
    ctlDEBUG = ctlDEBUG and ctlOBJECT;    /* debug doesn't make sense if no object code */
    ctlXREF = ctlXREF and ctlPRINT;        /* disable controls if not printing */
    ctlSYMBOLS = ctlSYMBOLS and ctlPRINT;
    ctlPAGING = ctlPAGING and ctlPRINT;
end;


InitLine: procedure public;
    startLine$p = inCh$p + 1;    
    lineChCnt = 0;
    if needToOpenFile then
        call OpenSrc;

    lineNumberEmitted, has16bitOperand, isControlLine, errorOnLine, lhsUserSymbol,
    inExpression, expectingOperands, xRefPending, gotLabel, rhsUserSymbol,
    inDB, inDW, condAsmSeen, showAddr, usrLookupIsID,
$IF MACRO
    b9059, b9060, 
$ENDIF
    needsAbsValue = bZERO;

    atStartLine, expectingOpcode, isInstr, expectOp = bTRUE;
    ctlEJECT, hasVarRef, tokenIdx,
$IF MACRO
    b9058, argNestCnt,
$ENDIF
    tokenSize(0), tokenType(0), acc1ValType, acc2ValType, inComment, acc1Flags = bZERO;

    asmErrCode = ' ';
$IF MACRO
    macro$p = .macroLine;
    w919D = macroInPtr;
    expandingMacro = expandingMacro > 0;
$ENDIF
    tokI = 1;
    srcLineCnt = srcLineCnt + 1;
$IF MACRO
    macro$p = .macroLine;
$ENDIF
    skipIf(0) = skipIf(0) > 0;
end;


start:
    call GetAsmFile;
    phase = 1;
    call ResetData;
    call InitialControls;
$IF SMALL
    if ctlMACROFILE then
    do;
        if Physmem < 8001h then
            call RuntimeError(5);     /* memory Error */
        if srcfd <> rootfd then
            call CloseF(srcfd);
        call CloseF(infd);
        ovlFile(12) = '4';        /* use macro asm version */
        call Load(.ovlFile, 0, 1, 0, .statusIO);
        call IoErrChk;
    end;
    if Physmem > 8001h then
    do;
        if srcfd <> rootfd then
            call CloseF(srcfd);
        call CloseF(infd);
        ovlFile(12) = '5';        /* use big edata.asm version */
        call Load(.ovlFile, 0, 1, 0, .statusIO);
        call IoErrChk;
    end;

    if MacroDebugOrGen then            /* attempt to use macro features */
        call RuntimeError(2);        /* command Error */
$ELSEIF MACRO
    macrofd = InOpen(.asmax$ref, 3);
$ENDIF

    if ctlOBJECT then
    do;
        call Delete(.objFile, .statusIO);
        objfd = InOpen(.objFile, 3);
    end;

    if ctlXREF then
    do;
        xreffd = InOpen(.asxref$tmp, 2);
        outfd = xreffd;
    end;

    call DoPass;
    phase = 2;
    if ctlOBJECT then
    do;
        CHKOVL$2;    /* for small version Load in overlay 2 for writeRec & WriteModhdr */
        if r$extnames.len > 0 then
            call WriteRec(.r$extnames);    /* in overlay 2 */

        if externId = 0 then
            call WriteModhdr;        /* in overlay 2 */
$IF NOT SMALL
        call InitRecTypes;
$ENDIF
    end;
$IF SMALL
    if not ctlOBJECT or ctlPRINT then
$ENDIF
    do;
        if ctlPRINT then
            outfd = InOpen(.lstFile, 2);
        CHKOVL$3;
        call ResetData;
        call InitialControls;
        call DoPass;
    end;
    if ctlPRINT then
    do;
        CHKOVL$1;
        call AsmComplete;
        call Flushout;
    end;

    if ctlOBJECT then
    do;
$IF SMALL
        phase = 3;
        CHKOVL3;
        call ResetData;
        call InitRecTypes;
        call InitialControls;
        call DoPass;
        CHKOVL2;
$ENDIF
        call Ovl11;
        call WriteModend;
    end;

    if not StrUcEqu(.aCo, .lstFile) then
    do;
        CHKOVL$1;
        call FinishPrint;
    end;
    CHKOVL$1;
    call FinishAssembly;
end;

src/asm1.plx
$IF MACRO
asm1m: do;
$include(:f3:asm1m.ipx)
$ELSE
asm1n: do;
$include(:f3:asm1n.ipx)
$ENDIF

declare tokReq(*) byte data(
            /* 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
               0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,
               0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
               0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,
               0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
               0, 0),
    b3EA0(*) byte data(36h, 0, 0, 0, 6, 0, 0, 2),
        /* bit vector 55 -> 0 x 24 00000110 0 x 16 0000001 */
        /* 29, 30, 55 */
    absValueReq(*) bool data(
        /* 0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F */
           0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
           0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0FFh,0,   0,   0FFh,
           0,   0FFh,0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
           0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0FFh,0FFh,0FFh,0,   0FFh,0,
           0,   0);
    /* true for DS, ORG, IF, 3A?, IRP, IRPC REPT */ 
$IF MACRO
declare    b$3F88(*) byte data(41h, 90h, 0, 0, 0, 0, 0, 0, 0, 40h);
    /* bit vector 66 -> 10010000 0 x 56 01 */

SkipWhite$2: procedure public;
    do while GetCh = ' ' or IsTab;
    end;
end;


nonHiddenSymbol: procedure byte public;
    declare name$p pointer,
        name based name$p address;

    name$p = curTokenSym$p - 6;
    /* check name < '??0' or '??9' < name */
    return (name < 4679h) or ctlMACRODEBUG or (4682h < name);
end;



SeekM: procedure(blk);
    declare blk address;

    if (pAddr := blk - nxtMacroBlk) <> 0 then
    do;
        kk = SEEKFWD;
        if blk < nxtMacroBlk then
        do;
            pAddr = - pAddr;
            kk = SEEKBACK;
        end;

        call Seek(macrofd, kk, .pAddr, .w$3780, .statusIO);
        call IoErrChk;
    end;
    nxtMacroBlk = blk + 1;
end;



/* read in macro from disk - located at given block */
ReadM: procedure(blk) public;
    declare blk address;
    declare actual address;

    if blk >= maxMacroBlk then
        actual = 0;
    else if blk = curMacroBlk then
        return;
    else
    do;
        call SeekM(blk);
        call Read(macrofd, .macroBuf, 128, .actual, .statusIO);
        call IoErrChk;
    end;

    tmac$blk, curMacroBlk = blk;
    macroBuf(actual) = 0FEh;    /* flag end of macro buffer */
end;

/* write the macro to disk */
WriteM: procedure public;
    if phase = 1 then
    do;
        call SeekM(maxMacroBlk);
        maxMacroBlk = maxMacroBlk + 1;
        call Write(macrofd, symHighMark, 128, .statusIO);
        call IoErrChk;
    end;
    macroBlkCnt = macroBlkCnt + 1;
end;



FlushM: procedure public;
    declare bytesLeft address;

    if b905E then
    do;	/* spool macros to disk in 128 byte blocks */
        do while (bytesLeft := macroInPtr - symHighMark) >= 128;
            call WriteM;
            symHighMark = symHighMark + 128;
        end;
    /* move the remaining bytes to start of macro buffer */
        if bytesLeft <> 0 then
            call move(bytesLeft, symHighMark, endSymTab(TID$MACRO));
        macroInPtr = (symHighMark := endSymTab(TID$MACRO)) + bytesLeft;
    end;
end;

$ENDIF

SkipWhite: procedure public;
    do while IsWhite;
        curChar = GetCh;
    end;
end;


$IF NOT MACRO
SkipWhite$2: procedure public;
    do while GetCh = ' ' or IsTab;
    end;
end;
$ENDIF

Skip2NextLine: procedure public;
    call Skip2EOL;
    call ChkLF;
end;



Tokenise: procedure public;

    Sub416B: procedure;
        if newOp = O$NONE then
            call ExpressionError;
        inExpression = 0;
        newOp = O$NONE;
    end;


    do while 1;
    if atStartLine then
    do;
        call ParseControlLines;
        atStartLine = 0;
    end;

    do case GetChClass;
        case0:    call IllegalCharError;        /* CC$BAD */
        ;                /* CC$WS */
        do;                /* CC$SEMI */
$IF MACRO
            if not b9058 then
$ENDIF
            do;
                inComment = TRUE;
$IF MACRO
                if GetChClass = CC$SEMI and b905E then
                do;
                    b9059 = TRUE;
                    macroInPtr = macroInPtr - 2;
                end;
$ENDIF
                call Skip2NextLine;
                effectiveToken = T$CR;
                return;
            end;
        end;
        do;                /* CC$COLON */
            if not gotLabel then
            do;
                if skipIf(0)
$IF MACRO
                   or b905E
$ENDIF
                then
                    call PopToken;
                else
                do;
                    labelUse = 2;
                    call UpdateSymbolEntry(segSize(activeSeg), O$TARGET);
                end;

                expectingOperands = FALSE;
                gotLabel, expectingOpcode = bTRUE;
            end;
            else
            do;
                call SyntaxError;
                call PopToken;
            end;

            call EmitXref(XREF$DEF, .name);
            rhsUserSymbol = FALSE;
            newOp = O$LABEL;
        end;
        do;                /* CC$CR */
            call ChkLF;
            effectiveToken = T$CR;
$IF MACRO
            b9058 = FALSE;
$ENDIF
            return;
        end;
        do;                /* CC$PUN */
            if curChar = '+' or curChar = '-' then
$IF MACRO
                if not TestBit(newOp, .b$3F88) then /* not 0, 3 or 41h */
$ELSE
                if newOp <> O$NONE and newOp <> T$RPAREN then
$ENDIF
                    curChar = curChar + (T$UPLUS - T$PLUS);    /* make unary versions */
            effectiveToken = curChar - '(' + T$LPAREN;
            return;
        end;
        do;                /* CC$DOLLAR */
            call PushToken(O$NUMBER);
            call CollectByte(low(segSize(activeSeg)));
            call CollectByte(high(segSize(activeSeg)));
            if activeSeg <> SEG$ABS then
                tokenAttr(0) = tokenAttr(0) or activeSeg or 18h;
            call Sub416B;
        end;
        do;                /* CC$QUOTE */
$IF MACRO
            if effectiveToken = 37h then
            do;
                call IllegalCharError;
                return;
            end;
            if b905E then
                b9058 = not b9058;
            else
$ENDIF
            do;
                call GetStr;
                if expectingOpcode then
                    call SetExpectOperands;
                call Sub416B;
            end;
        end;
        do;                /* CC$DIG */
            call GetNum;
            if expectingOpcode then
                call SetExpectOperands;
            call Sub416B;
        end;
        do;                /* CC$LET */
$IF MACRO
            w919F = macroInPtr - 1;
$ENDIF
            call GetId(O$ID);    /* assume it's an id */
            if tokenSize(0) > 6 then    /* cap length */
                tokenSize(0) = 6;

            if ctlXREF then
            do;
                call move(6, .name, .savName);
                call move(6, .spaces6, .name);
            end;
            /* copy the token to name */
            call move(tokenSize(0), tokPtr, .name);
            nameLen = tokenSize(0);
            call PackToken;        /* make into 4 byte name */
            if rhsUserSymbol then
            do;
                lhsUserSymbol = TRUE;
                rhsUserSymbol = FALSE;
            end;


$IF MACRO
            if Lookup(TID$MACRO) <> O$ID and b905E then
            do;
                if not b9058 or (kk := tokenType(0) = 0) and (curChar = '&' or byteAt(w919F-1) = '&') then
                do;
                    macroInPtr = w919F;
                    call InsertCharInMacroTbl(kk + 81h);
                    call InsertByteInMacroTbl(GetNumVal);
                    call InsertCharInMacroTbl(curChar);
                    effectiveToken = O$ID;
                end;
            end;
            else if effectiveToken <> O$37 and not b905E = 2 then
$ENDIF
            do;
                if Lookup(TID$KEYWORD) = O$ID then        /* not a key word */
                do;
                    tokenType(0) = Lookup(TID$SYMBOL);    /* look up in symbol space */
                    rhsUserSymbol = TRUE;        /* note we have a used symbol */
                end;

                effectiveToken = tokenType(0);
                needsAbsValue = absValueReq(tokenType(0)); /* DS, ORG, IF, O$3A, IRP, IRPC REPT */
                if not tokReq(tokenType(0)) then /* i.e. not instruction, reg or O$37 or 1,2,3,4,6,A */
                    call PopToken;

                if lhsUserSymbol then
                do;               /* EQU, SET or O$37 */
                    call EmitXref((not TestBit(effectiveToken, .b3EA0)) and 1, .savName);
                    lhsUserSymbol = FALSE;
                end;
            end;
$IF MACRO
            if b905E = 1 then
            do;
                if effectiveToken = K$LOCAL then
                do;
                    b905E = 2;
                    if b6897 then
                        call SyntaxError;
                    b6897 = FALSE;
                end;
                else
                do;
                    b6897 = FALSE;
                    b905E = 0FFh;
                end;
            end;

            if effectiveToken = K$NUL then
                call PushToken(O$OPTVAL);
$ENDIF
            if effectiveToken < 10 or effectiveToken = 9 or 80h then /* !! only first term contributes */
            do;
                call Sub416B;
                if expectingOpcode then
                    call SetExpectOperands;
            end;
            else
            do;
                expectingOpcode = FALSE;
                return;
            end;
        end;
$IF MACRO
        do;                /* 10? */
            b6BDA = FALSE;
            call Sub73AD;
            if b6BDA then
                return;
        end;
        do;                /* CC$ESC */
            if expandingMacro then
            do;
                skipIf(0) = FALSE;
                effectiveToken = 40h;
                return;
            end;
            else
                goto case0;
        end;
$ENDIF
    end;
    end;
end;

end;
src/asm2.plx
$IF MACRO
asm2m: do;
/* force the non standard code generation of outStrN and put2Hex */
OutStrN: procedure(s, n) external; declare s address, n address; end;
Put2Hex: procedure(arg1w, arg2w) external; declare arg1w address, arg2w address; end;
$include(:f3:asm2m.ipx)
$ELSE
asm2n: do;
OutStrN: procedure(s, n) external; declare s address, n address; end;
$include(:f3:asm2n.ipx)
$ENDIF
/* 
    0    -> ?
    1    -> start single word expression
    5    -> single byte opcode no operand
    7    -> reg operand
    0Fh    -> binary topOp
    0Dh    -> unary topOp
    17h    -> IMM8 operand
    37h    -> imm16 operand
    40h    -> list
    47h    -> 2 operand topOp
    4Dh    -> start word list
    80h    -> end expression
    81h    -> rept operand
    0C0h    -> local operand

    -------x    -> getnum to acc1 & copy to acc2
    ------x-    -> getnum to acc1
    -----x--    -> collect low(acc1)
    ----x---    -> collect high(acc1)
    ---x----    -> collect low(acc2)
    --x-----    -> collect high(acc2)
    -x------    -> list
*/

declare opFlags(*) byte public data(
       /* 0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F */
          0, 80h,   0,   0, 0Fh, 0Fh, 80h, 0Fh, 0Dh, 0Fh, 0Dh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh,
        0Fh, 0Dh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Dh, 0Dh, 40h, 4Dh,   1,   1,   1,   1,
        80h,   1,   0,   0, 47h,   7,   7,   7, 17h, 47h,   7, 47h, 37h,   5,   7,   0,
          0,   0, 40h, 40h,   0,   1
$IF MACRO
                                    , 80h, 40h, 80h,   0, 40h, 80h, 80h, 40h, 81h,0C0h,
        80h, 0Dh
$ENDIF
       ),

    noRegOperand(*) byte data(41h, 0, 0, 0, 19h, 40h, 0, 1Ch, 0, 0),
    /* bit vector 66 -> 0 x 24 00011001 01000000 00000000 00011100 00000000 00 */
    b41C1(*) byte data(1Ah, 5, 80h, 0, 0C0h),
    /* bit vector 27 -> 00000101 10000000 00000000 110 */
    opCompat(*) byte data(57h, 71h, 0F4h, 57h, 76h, 66h, 66h, 67h, 77h, 77h, 77h, 55h),
    /* bit vector 88 -> 01110001 11110100 01010111 01110110
                        01100110 01100110 01100111 01110111
                        01110111 01110111 01010101 */
    propagateFlags(*) byte data(57h, 6, 2, 20h, 0, 0, 0, 0, 0, 0, 0, 22h),
    /* bit vector 88 -> 00000110 00000010 00100000 00000000
                    00000000 00000000 00000000 00000000
                    00000000 00000000 00100010 */ 
    typeHasValue(*) byte data(3Ah, 0FFh, 80h, 0, 0, 0Fh, 0FEh, 0, 20h),
    /* bit vector 59 -> 11111111 10000000 00000000 00000000
                        00001111 11111110 00000000 001 */
    /* O$NONE, T$CR, T$LPAREN, T$RPAREN/O$LABEL, T$STAR, T$PLUS/K$SPECIAL, T$COMMA, */
    /* T$MINUS/K$REGNAME, T$UPLUS/K$SP */
    /* K$LXI, K$REG16, K$LDSTAX, K$ARITH, K$IMM8, K$MVI, K$INRDCR. K$MOV, K$IMM16, K$SINGLE */
    /* K$RST
/* precedence table */
/*
   10 - NULL
    9 - HIGH, LOW
    8 - *, /, MOD, SHL, SHR
    7 - +, -, UPLUS, UMINUS
    6 - =, <, <=, >, >=, <>
    5 - NOT
    4 - AND
    3 - OR, XOR,
    2 - not used
    1 - COMMA, DB - STKLEN, O$37, ENDM, EXITM, O$3D, REPT, LOCAL
    0 - all others
*/
    precedence(*) byte data(
     /* 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
        0, 0, 0, 0, 8, 7, 1, 7, 7, 8, 7, 6, 6, 6, 6, 6,
        6, 5, 4, 3, 3, 8, 8, 8, 9, 9, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1
$IF MACRO 
/* for macro ver */     , 0, 1, 1, 1, 0, 0, 0, 1, 1, 1,
        0, 0Ah
$ENDIF
     );


TestBit: procedure(bitIdx, bitVector) bool public;
    declare bitIdx byte, bitVector pointer;
    declare ch based bitVector byte;

    if ch < bitIdx then
        return FALSE;
    
    bitVector = bitVector + shr(bitIdx, 3) + 1;
    return (ch and ROR(1, (bitIdx and 7) + 1)) <> 0;
end;

IsReg: procedure(topOp) bool public;
    declare topOp byte;

    return topOp = K$REGNAME or topOp = K$SP;
end;

ChkInvalidRegOperand: procedure public;
    if TestBit(topOp, .noRegOperand) then
        if IsReg(acc1ValType) then
            call OperandError;
end;

Sub4291: procedure public;
    if IsReg(acc1ValType) then
        call OperandError;
    if (opFlags(topOp) and 2) = 0 then
        acc2Flags = 0;
    else if IsReg(acc2ValType) then
        call OperandError;

    acc1ValType = O$NUMBER;
    accFixFlags(0) = (acc1Flags and UF$BOTH) <> 0;
    accFixFlags(1) = (acc2Flags and UF$BOTH) <> 0;
    if (acc1Flags and UF$SEGMASK) <> SEG$ABS then
        if (acc2Flags and UF$SEGMASK) <> SEG$ABS then
            if ((acc1Flags xor acc2Flags) and 1Fh) <> 0 then
                call ExpressionError;
    if (ii := (acc1Flags and UF$EXTRN) <> 0) or (jj := (acc2Flags and UF$EXTRN) <> 0) then
    do;
        if topOp = K$SPECIAL then    /* +? (PAGE INPAGE)? */
            if not (ii or accFixFlags(0)) then
            do;
                acc1NumVal = acc2NumVal;
                acc1Flags = acc2Flags;
                return;
            end;
        if jj or accFixFlags(1) or not TestBit(topOp, .b41C1) then
            goto L4394;
        else
            return;
    end;
    kk = shl(topOp - 4, 2) or (accFixFlags(0) and 2) or (accFixFlags(1) and 1);
    if TestBit(kk, .opCompat) then
L4394:    do;
        call ExpressionError;
        acc1Flags = 0;
        return;
    end;
    if TestBit(kk, .propagateFlags) then
    do;
        if not accFixFlags(0) then
            acc1Flags = acc2Flags;
        return;
    end;
    acc1Flags = 0;
end;


SwapAccBytes: procedure public;
    declare tmp byte;
    tmp = accum1$lb;
    accum1$lb = accum1$hb;
    accum1$hb = tmp;
end;



SetExpectOperands: procedure public;
    expectingOperands = TRUE;
    expectingOpcode = FALSE;
end;



GetNumVal: procedure address public;
    declare tokByte based tokPtr (1) byte,    /* ptr into token info */
        val$p pointer,
        val based val$p address;
$IF MACRO
    LogError: procedure(ch);
        declare ch byte;

        if tokenType(tokenIdx) <> O$OPTVAL then
        do;
            call SourceError(ch);
            return;
        end;
        if tokenSize(0) = 0 then
            tokenType(tokenIdx) = K$NUL;
    end;
$ENDIF

    acc1Flags = 0;
    accum1 = 0;
    acc1ValType = O$ID;
$IF MACRO
    if tokenType(0) = O$OPTVAL then
        call PushToken(CR);
$ENDIF
    if tokenIdx = 0 or tokenType(0) = O$DATA and not b6B36 then
$IF MACRO
        call LogError('Q');
$ELSE
        call SyntaxError;
$ENDIF
    else
    do;
        if tokenType(0) = O$ID or tokenType(0) = T$COMMA then
$IF MACRO
            call LogError('U');
$ELSE
            call UndefinedSymbolError;
$ENDIF
        else
        do;
            acc1ValType = tokenType(0);
            if TestBit(acc1ValType, .typeHasValue) then
            do;
                tokPtr = curTokenSym$p + 7;    /* point to flags */
                acc1Flags = tokByte(0) and not UF$PUBLIC; /* remove public attribute */
                tokPtr, val$p = curTokenSym$p + 4;    /* point to value */
                acc1NumVal = val;            /* pick up value */
                tokenSize(0) = 2;        /* word value */

            end;
            else if tokenSize(0) = 0 then
$IF MACRO
                call LogError('V');
$ELSE
                call ValueError;
$ENDIF
            else
            do;
                if tokenSize(0) > 2 then
$IF MACRO
                    call LogError('V');
$ELSE
                    call ValueError;
$ENDIF
                acc1Flags = tokenAttr(0) and not UF$PUBLIC;    /* remove public attribute */
                acc1NumVal = tokenSymId(0);        /* use the symbol Id */
            end;

            if tokenSize(0) > 0 then    /* get low byte */
                accum1$lb = tokByte(0);
            if tokenSize(0) > 1 then    /* and high byte if not a register */
                accum1$hb = tokByte(1) and tokenType(0) <> 7;
        end;    

        if has16bitOperand then
            if tokenSize(0) = 2 then
                if tokenType(0) = O$STRING then
                    call SwapAccBytes;

        if (acc1Flags and UF$EXTRN) <> 0 then
            if tokenType(0) < 9 then
                accum1 = 0;

        call PopToken;
    end;

    b6B36 = FALSE;
    return accum1;
end;


GetPrec: procedure(topOp) byte public;
    declare topOp byte;
    return precedence(topOp);
end;

/*
   arg1b
   xxxxxxx1    acc2 -> 16 bit reg
   xxxxxx1x    acc1 = acc1 | acc2
   xxxxx1xx    acc2 <<= 3
   xxxx1xxx    acc2 -> 8 bit value
   nnnnxxxx    topOp = 24h + nnnn
   
*/   
MkCode: procedure(arg1b) public;
    declare arg1b byte;

    if (arg1b and 3) <> 0 then    /* lxi, ldax, stax, regarith, mvi, mov, rst */
    do;
        if accum2$hb <> 0    /* reg or rst num <= 7 */
           or accum2$lb > 7     
           or arg1b and accum2$lb    /* only B D H SP if lxi, ldax or stax */
           or (arg1b and 3) = 3 and accum2$lb > 2    /* B or D if ldax or stax */
           or (not IsReg(acc2ValType) and topOp <> K$RST) then    /* reg unless rst */
            call OperandError;
        else if IsReg(acc2ValType) and topOp = K$RST then         /* cannot be reg for rst */
            call OperandError;
        if ror(arg1b, 2) then
            accum2$lb = rol(accum2$lb, 3);
        accum1$lb = accum1$lb or accum2$lb;
    end;
    else if topOp <> K$SINGLE then        /* single byte topOp */
        if IsReg(acc2ValType) then
            call OperandError;

    if shr(arg1b, 3) then
    do;
        if (acc2Flags and UF$BOTH) = UF$BOTH then
        do;
            call ValueError;
            acc2Flags = (acc2Flags and not UF$BOTH)  or UF$LOW;
        end;
        if accum2$hb + 1 > 1 then    /* Error if not FF or 00 */
            call ValueError;
    end;
    if topOp = K$IMM8 or topOp = K$IMM16 then    /* Imm8 or imm16 */
    do;
        acc1Flags = acc2Flags;
        acc1NumVal = acc2NumVal;
    end;
    else
        acc1Flags = 0;

    if topOp <> K$SINGLE then             /* single byte topOp */
        if accum1$lb = 76h then         /* mov m,m is actually Halt */
            call OperandError;
    if (topOp := shr(arg1b, 4) + 24h) = 24h then
        nextTokType = O$DATA;
end;

NxtTokI: procedure byte public;
    if tokI >= tokenIdx then
        return 0;
    return (tokI := tokI + 1);
end;



ShowLine: procedure byte public;
    return ((not isControlLine) and ctlLIST or ctlLISTChanged and isControlLine)
$IF MACRO
            and (not (expandingMacro > 1) or ctlGEN)
$ENDIF
        and (not(condAsmSeen or skipIf(0)) or ctlCOND);
end;

/*
    xrefMode= 0 -> defined
        = 1 -> used
        = 2 -> finalise
*/
EmitXref: procedure(xrefMode, name) public;
    declare xrefMode byte, name address;
    declare (i, byteval) byte;
    declare (srcLineLow, srcLineHigh) byte at(.srcLineCnt);

    if not IsPhase1 or not ctlXREF or IsSkipping and not xRefPending then
        return;

    call Outch(xrefMode + '0');    /* convert to hex char */
    if xrefMode <> XREF$FIN then    /* not finalise */
    do;
        call OutStrN(name, 6);        /* label ref */
        xRefPending = FALSE;
        byteval = srcLineHigh;    /* line number in hex - high byte first */
        i = 0;
        do while i < 4;
            i = i + 1;
            if i then    /* high nibble ? */
            do;
                if i = 3 then    /* get low byte */
                    byteval = srcLineLow;
                /* emit high nibble */
                call Outch(Nibble2Ascii(shr(byteval, 4)));
            end;
            else    /* emit low nibble */
                call Outch(Nibble2Ascii(byteval));
        end;
    end;
    else    /* finalise */
    do;
        call OutStrN(.lstFile, 15);    /* listing file name */
        if ctlPAGING then        /* whether paging '1' or '0' */
            call Outch('1');
        else
            call Outch('0');
        /* page length and page width as 2 hex chars */
        call Outch(Nibble2Ascii(ror(ctlPAGELENGTH, 4)));
        call Outch(Nibble2Ascii(ctlPAGELENGTH));
        call Outch(Nibble2Ascii(ror(ctlPAGEWIDTH, 4)));
        call Outch(Nibble2Ascii(ctlPAGEWIDTH));
        call Outch('3');    /* end of file */
        call Flushout;
        call CloseF(xreffd);
    end;
end;
end;
src/asm4.plx
$IF MACRO
asm4m: do;
$include(:f3:asm4m.ipx)
$ELSEIF BIG
asm4b: do;
$include(:f3:asm4b.ipx)
$ELSE
asm4s: do;
$include(:f3:asm4s.ipx)
$ENDIF

$IF SMALL
declare CHKOVL$1 lit    'call OvlMgr(1)',
    CHKOVL$2 lit    'call OvlMgr(2)';
$ELSE
declare CHKOVL$1 lit    ' ',
    CHKOVL$2 lit    ' ';
$ENDIF

declare pad1 address data(40h),
    pad2 address;


StrUcEqu: procedure(s, t) bool public;
    declare (s, t) pointer;
    declare sCh based s byte,
        tCh based t byte;

    do while sCh <> 0;
        if sCh <> tCh and sCh <> (tCh and 5Fh) then
            return FALSE;
        s = s + 1;
        t = t + 1;
    end;
    return TRUE;
end;


IsSkipping: procedure byte public;
    return 
$IF MACRO
        b905E or
$ENDIF
        skipIf(0);
end;

Sub546F: procedure public;
    spIdx = NxtTokI;
    if expectingOperands then
        call SyntaxError;
    if HaveTokens then
        if not(tokenType(spIdx) = O$DATA or lineNumberEmitted) then
            call SyntaxError;
    if inDB or inDW then
    do;
        if tokenIdx = 1 and not BlankAsmErrCode and tokenSize(0) <> 1 then
            tokenSize(0) = 2;
    end;
    else if not BlankAsmErrCode and HaveTokens then
        if tokenSize(spIdx) > 3 then
            tokenSize(spIdx) = 3;
end;


FinishLine: procedure public;
    declare lineno$p pointer,
        updating byte,
        ch based lineno$p byte;

    call Sub546F;
    if IsPhase2Print then
    do;    /* update the ascii line number */
        lineno$p = .asciiLineNo(3);    /* point to last digit */
        updating = TRUE;

        do while updating;        /* adjust the line number */
            if ch = '9' then    /* if 9 then roll over to 0 */
                ch = '0';
            else
            do;
                if ch = ' ' then    /* new digit */
                    ch = '1';
                else            /* just increment */
                    ch = ch + 1;
                updating = FALSE;
            end;
            lineno$p = lineno$p - 1;
        end;

        if ShowLine or not BlankAsmErrCode then
        do;
            CHKOVL$1;
            call PrintLine;
        end;
    end;

    if b6BD9 then
    do;
        out$p = out$p + 1;
        call Flushout;
        call Exit;
    end;

    if not isControlLine then
    do;
        ii = 2;
        if tokenIdx < 2 or inDB or inDW then
            ii = 0;

        w6BCE = tokStart(ii) + tokenSize(ii);
        if IsSkipping or not isInstr then
            w6BCE = .lineBuf;

        if ChkGenObj then
        do;
            CHKOVL$2;
            call Ovl8;
        end;
        b6B2C = TRUE;
        segSize(activeSeg), effectiveAddr = segSize(activeSeg) + (w6BCE - .lineBuf);
    end;

    if ctlXREF and rhsUserSymbol then
        if phase = 1 then
            call EmitXref(XREF$REF, .name);

$IF MACRO
    call FlushM;
$ENDIF

    do while tokenIdx > 0;
        call PopToken;
    end;

    call InitLine;
    if b6B33 then
    do;
        finished = TRUE;
        if IsPhase2Print and ctlSYMBOLS then
        do;
            CHKOVL$1;
            call Sub7041$8447;
        end;

        call EmitXref(XREF$FIN, .name);    /* finalise xref file */
        if ChkGenObj then
        do;
            CHKOVL$2;
            call ReinitFixupRecs;
        end;
    end;
end;

end;
src/rdsrc.plm
rdsrc: do;
$include(:f3:rdsrc.ipx)

declare    needToOpenFile bool public initial(FALSE),
    includeOnCmdLine bool public initial(FALSE),
    padb6C23 byte,
    fileIdx byte public initial(0),
    endInBuf$p address public initial(.inBuf),
    missingEnd bool public initial(FALSE),
    srcfd address public,
    rootfd address public,
    inCh$p pointer public initial(.inBuf - 1),
    startLine$p address public initial(.inBuf),
    lineChCnt byte public initial(0), 
    files(6) FILE$T public,
    seekIBlk address,
    seekIByte address,
    pad6CAD byte,  
    savInBuf$p address,
    savEndInBuf$p address,
    pad6CB2(4) address,
    readFActual address,
    pad6CBC address;


ReadF: procedure(conn, buff$p, count) public;
    declare conn byte, (buff$p, count) address;
    call Read(conn, buff$p, count, .readFActual, .statusIO);
    call IoErrChk;
end;

SeekI: procedure(seekOp) public;
    declare seekOP byte;
    call Seek(srcfd, seekOp, .seekIBlk, .seekIByte, .statusIO);
    call IoErrChk;
end;


ReadSrc: procedure(bufLoc) public;
    declare bufLoc address;
    declare pad byte;

    call ReadF(srcfd, bufLoc, .inBuf(sizeInBuf) - bufLoc);
    endInBuf$p = bufLoc + readFActual;
end;



CloseSrc: procedure public;
    call Close(srcfd, .statusIO);
    call IoErrChk;
    if fileIdx = 0 then
    do;
        missingEnd = TRUE;
        call IoError(.files(0).name);
        return;
    end;
    fileIdx = fileIdx - 1;
    /* Open the previous file */
    if fileIdx = 0 then
        srcfd = rootfd;
    else
        srcfd = InOpen(.files(fileIdx).name, 1);

    seekIByte = files(fileIdx).byt;    /* move to saved location */
    seekIBlk = files(fileIdx).blk;
    call SeekI(SEEKABS);
    endInBuf$p = .inBuf;        /* force Read */
    inCh$p = .inBuf - 1;
end;


GetSrcCh: procedure byte public;
    declare ch based inCh$p byte;
    declare insertPt address;
    loop:
    inCh$p = inCh$p + 1;

    if inCh$p = endInBuf$p then    /* buffer all used */
    do;
        savInBuf$p = startLine$p;
        savEndInBuf$p = endInBuf$p;
        /* copy the current line down to start of buffer */
        if savEndInBuf$p - savInBuf$p > 0 then
            call move(savEndInBuf$p - savInBuf$p, startLine$p, .inBuf);
        startLine$p = .inBuf;
        /* Read in  characters to rest of inBuf */
        call ReadSrc(insertPt := startLine$p + (savEndInBuf$p - savInBuf$p));
        inCh$p = insertPt;
    end;

    if readFActual = 0 then
    do;
        call CloseSrc;
        goto loop;
    end;

    lineChCnt = lineChCnt + 1;
    return ch and 7Fh;
end;


OpenSrc: procedure public;
    declare curByteLoc byte, curBlkLoc address;

    needToOpenFile = 0;
    call SeekI(SEEKTELL);
    if seekIByte = 128 then        /* adjust for 128 boundary */
    do;
        seekIBlk = seekIBlk + 1;
        seekIByte = 0;
    end;

    curBlkLoc = endInBuf$p - startLine$p;    /* un-used characters */
x:                        /* forces code alignment */
    if (curByteLoc := curBlkLoc mod 128) > seekIByte then
    do;
        seekIByte = seekIByte + 128;    /* adjust to allow for un-used chars */
        seekIBlk = seekIBlk - 1;
    end;
    /* save the current file location */
    files(fileIdx - 1).byt = seekIByte - curByteLoc;
    files(fileIdx - 1).blk = seekIBlk - curBlkLoc / 128;
    if srcfd <> rootfd then        /* close if include file */
    do;
        call Close(srcfd, .statusIO);
        call IoErrChk;
    end;

    endInBuf$p = .inBuf;            /* force Read */
    inCh$p = endInBuf$p - 1;
    startLine$p = .inBuf;
    files(fileIdx).blk = 0;            /* record at start of file */
    files(fileIdx).byt = 0;    
    srcfd = InOpen(.files(fileIdx).name, 1);    /* Open the file */
end;
end;
src/asm5.plx
$IF MACRO
asm5m: do;
$include(:f3:asm5m.ipx)
$ELSE
asm5n: do;
$include(:f3:asm5n.ipx)
$ENDIF
declare    b5666(*) byte data(9, 2Dh, 80h), /* bit vector 10 -> 00101101 10 */
    b5669(*) byte data(3Ah, 8, 80h, 0, 0, 0, 0, 0, 20h),
        /* bit vector 59 -> 00001000 1000000 00000000 0000000
                            00000000 0000000 00000000 001 */
    op16(*) byte data(
       /* 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
          0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1),
    chClass(*) byte data(
     /*    0       1       2       3       4       5       6       7
           8       9       A       B       C       D       E       F */
/*00*/ CC$BAD, CC$BAD, CC$BAD, CC$BAD, CC$BAD, CC$BAD, CC$BAD, CC$BAD,
/*08*/ CC$BAD,  CC$WS, CC$BAD, CC$BAD,  CC$WS,  CC$CR, CC$BAD, CC$BAD,
/*10*/ CC$BAD, CC$BAD, CC$BAD, CC$BAD, CC$BAD, CC$BAD, CC$BAD, CC$BAD,
$IF MACRO
/*18*/ CC$BAD, CC$BAD, CC$BAD, CC$ESC, CC$BAD, CC$BAD, CC$BAD, CC$BAD,
$ELSE
/*18*/ CC$BAD, CC$BAD, CC$BAD, CC$BAD, CC$BAD, CC$BAD, CC$BAD, CC$BAD,
$ENDIF
/*20*/ CC$WS, CC$BAD, CC$BAD, CC$BAD, CC$DOLLAR, CC$BAD, CC$BAD, CC$QUOTE,
/*28*/ CC$PUN, CC$PUN, CC$PUN, CC$PUN, CC$PUN, CC$PUN, CC$BAD, CC$PUN,
/*30*/ CC$DIG, CC$DIG, CC$DIG, CC$DIG, CC$DIG, CC$DIG, CC$DIG, CC$DIG,
/*38*/ CC$DIG, CC$DIG, CC$COLON, CC$SEMI, CC$BAD, CC$BAD, CC$BAD, CC$LET,
/*40*/ CC$LET, CC$LET, CC$LET, CC$LET, CC$LET, CC$LET, CC$LET, CC$LET,
/*48*/ CC$LET, CC$LET, CC$LET, CC$LET, CC$LET, CC$LET, CC$LET, CC$LET, 
/*50*/ CC$LET, CC$LET, CC$LET, CC$LET, CC$LET, CC$LET, CC$LET, CC$LET,
/*58*/ CC$LET, CC$LET, CC$LET, CC$BAD, CC$BAD, CC$BAD, CC$BAD, CC$BAD,
/*60*/ CC$BAD, CC$LET, CC$LET, CC$LET, CC$LET, CC$LET, CC$LET, CC$LET,
/*68*/ CC$LET, CC$LET, CC$LET, CC$LET, CC$LET, CC$LET, CC$LET, CC$LET,
/*70*/ CC$LET, CC$LET, CC$LET, CC$LET, CC$LET, CC$LET, CC$LET, CC$LET,
/*78*/ CC$LET, CC$LET, CC$LET, CC$BAD, CC$BAD, CC$BAD, CC$BAD, CC$BAD);

UnpackToken: procedure(src, dst) public;
    declare (src, dst) pointer;
    declare wrd based src address;
    declare ch based dst byte;
    declare packedword address;

    Unpack1: procedure;
        ch = packedword mod 40;    
        if ch = 0 then
            ch = ' ';
        else if ch <= 10 then
            ch = ch + 2Fh;    /* digit */
        else 
            ch = ch + 34h;    /* ? @ and letters */
        packedword = packedword / 40;
        dst = dst - 1;
    end;


    src = src + 2;
    dst = dst + 5;
    packedword = wrd;
    call Unpack1;
    call Unpack1;
    call Unpack1;
    src = src - 2;
    packedword = wrd;
    call Unpack1;
    call Unpack1;
    call Unpack1;
end;


InsertSym: procedure public;
    declare (p, q) pointer;
    declare pCh based p byte;
    declare qCh based q byte;

    /* move up the top block of the symbol tables to make room */
    symHighMark, p = (q := symHighMark) + 8;
    if baseMacroTbl < p then
        call RuntimeError(1);    /* table Error */

    do while q > curTokenSym$p;    /* byte coqy */
        p = p - 1;
        q = q - 1;
        pCh = qCh;
    end;
    /* insert the new symbol name */
    call move(4, tokPtr, curTokenSym$p);
$IF MACRO
    endSymTab(TID$MACRO) = endSymTab(TID$MACRO) + 8;    /* mark new top of macro table */
$ENDIF
    curTokenSym.type = 0;            /* clear the type */
end;

$IF MACRO
OutSideTable: procedure(tableId) bool;        /* check if curTokenSym$p is outside table bounds */
    declare tableId byte;

    if endSymTab(tableId) >= curTokenSym$p and curTokenSym$p >= symTab(tableId) then
        return FALSE;

    call SyntaxError;
    return TRUE;
end;


Sub5CAD: procedure(line, type) public;
    declare line address, type byte;

    if OutSideTable(TID$MACRO) then
        return;
    call InsertSym;
    curTokenSym.line = line;        /* fill in the rest of the new entry */
    curTokenSym.type = type;
    curTokenSym.flags = 0;
    call PopToken;
end;
$ENDIF

declare labelUse byte public;

UpdateSymbolEntry: procedure(line, type) public;
    declare line address, type byte;
    declare (flags, absFlag) byte,
        (lineSet, isSetOrEqu) bool,
        origType byte;

    /* type = 2 -> target
          4 -> set
          5 -> equ
          6 -> public
          9 -> address ref
         3ah-> ??
             8xh-> needs absolute value
    */

    SetTokenType: procedure;
        tokenType(0) = type;
        if (acc1ValType = K$REGNAME or acc1ValType = K$SP) and isSetOrEqu then
            tokenType(0) = 12 - type;    /* set-> K$SP, equ->K$REGNAME */
    end;

    origType = tokenType(0);
    isSetOrEqu = type = 5 or type = 4;
    absFlag = 0;
    flags = curTokenSym.flags;
    lineSet = FALSE;
$IF MACRO
    if OutSideTable(TID$SYMBOL) then        /* oops if outside normal symbol table */
    do;
$ELSE                    /* same for non macro version */
    if curTokenSym$p > endSymTab(TID$SYMBOL) or curTokenSym$p < symTab(TID$SYMBOL) then
    do;
        call SyntaxError;
$ENDIF
        return;
    end;

    if tokenIdx > 1 then
        call SyntaxError;

    if IsPhase1 then
        if tokenType(0) = O$ID then
        do;
            if createdUsrSym then
            do;
                if curTokenSym.type >= 80h
$IF MACRO
                     or type = O$3A and curTokenSym.line <> srcLineCnt
$ENDIF
                then
                do;
                    call LocationError;
                    absFlag = 80h;
                end;
            end;
            else
            do;
                call InsertSym;
$IF MACRO
                symTab(TID$MACRO) = symTab(TID$MACRO) + 8;        /* adjust the base of the macro table */
$ENDIF
                endSymTab(TID$SYMBOL) = endSymTab(TID$SYMBOL) + 8;    /* adjust the end of the user symbol table */
                flags = 0;
            end;

            flags = (activeSeg <> SEG$ABS and UF$BOTH)
                or (inPublic and UF$PUBLIC)
                or (inExtrn and (UF$EXTRN + UF$BOTH));
            if labelUse = 1 then    /* set or equ */
                flags = acc1Flags;

            if labelUse = 2 then    /* label: */
                flags = flags or activeSeg;

            if hasVarRef and isSetOrEqu then
                tokenType(0) = O$MACROID;
            else
                call SetTokenType;

            goto endUpdateSymbol;
        end;

    if passCnt = 2 then
        if tokenType(0) = O$ID then
            if acc1ValType <> O$ID then
                if isSetOrEqu then
                do;
                    call SetTokenType;
                    if curTokenSym.type < 128 then
                    do;
                        curTokenSym.type = tokenType(0);
                        curTokenSym.line = line;
                        flags = acc1Flags;
                        lineSet = TRUE;
                    end;
                    goto endUpdateSymbol;
                end;

    if IsPhase1 then
        if tokenType(0) = O$REF then
            if TestBit(type, .b5666) then
            do;
                if inExtrn then
                    tokenType(0) = 3;
                else
                do;
                    tokenType(0) = type;
                    flags = flags and 0E0h;    /* mask off seg, low, high */
                    if labelUse = 1 then /* set or equ */
                        flags = acc1Flags or UF$PUBLIC;

                    if labelUse = 2 then /* label: */
                        if activeSeg <> 0 then
                            flags = flags or activeSeg or (UF$PUBLIC + UF$BOTH);
                end;
                goto endUpdateSymbol;
            end;

    if IsPhase1 then
        if type = O$REF then
            if TestBit(tokenType(0), .b5666) then
            do;
                if (flags and 60h) <> 0 then
                    tokenType(0) = O$LABEL;
                else
                    flags = flags or UF$PUBLIC;
                goto endUpdateSymbol;
            end;

    if IsPhase1 then
        if tokenType(0) <> type and tokenType(0) <> 8 or type = 5 then
            tokenType(0) = 3;

    if not inPublic and TestBit(tokenType(0), .b5669) then
        flags = (flags and UF$PUBLIC) and tokenType(0) <> O$3A or acc1Flags;
    else
    do;
        if IsPhase1 then
            tokenType(0) = 3;

        if not (inPublic or inExtrn) then
            if curTokenSym.line <> line then
                call PhaseError;
    end;

endUpdateSymbol:
    absFlag = absFlag or (curTokenSym.type and 80h);

    if IsPhase1 and (type = 9 or type = 6 or origType <> tokenType(0)) then
        curTokenSym.type = tokenType(0) or absFlag;

    kk = curTokenSym.type;
    if tokenType(0) = 3 or kk = 3 then
        call MultipleDefError;

    if kk >= 80h then
        call LocationError;

    if IsPhase1 and (tokenType(0) = type or type = 5 and tokenType(0) = 7)
       or type = 4 and BlankAsmErrCode or lineSet
$IF MACRO
       or type = O$3A
$ENDIF
    then
        curTokenSym.line = line;

    curTokenSym.flags = flags;
    inPublic = 0;
    inExtrn = 0;
    if curTokenSym.type = 6 then
        call UndefinedSymbolError;

    hasVarRef = 0;
    if createdUsrSym then
        call PopToken;

end;

/*
    two different tables are used in lookup
    table 0: static keyword lookup the individual entries are coded as
        packed keyword - byte * 4 - 3 chars per word
        opcode base - byte
        offset to next entry or 0 if end - byte
        type - byte
        flags - byte
    initial entry is determined by hashing the name

    table 1: is a dynamic symbol table 8 bytes per entry kept sorted to allow binary chop search
    individual entries encoded as
        

    table 2: is a dynamic macro table 8 bytes per entry kept sorted to allow binary chop search

*/    

Lookup: procedure(tableId) byte public;
    declare tableId byte;
    declare (lowOffset, highOffset, midOffset, deltaToNext) address,
        (entryOffset, packedTok$p) pointer,
        (i, gt) byte;
    declare symEntry based entryOffset KEYWORD$T,
        packedTok based packedTok$p (2) address;
    declare addr based pAddr address;

    packedTok$p = tokPtr;
    if tableId = TID$KEYWORD then        /* hash chain look up key word */
    do;
        entryOffset = 0;    /* offset to current symbol to compare */
                    /* offset of first to use - hashes packed symbol name */
        deltaToNext = symTab(TID$KEYWORD) + ((packedTok(0) + packedTok(1)) mod 151) * 8;

        do while deltaToNext <> 0;    /* while not end of chain */
            entryOffset = entryOffset + deltaToNext;    /* point to the next in chain */
            if symEntry.tok(0) = packedTok(0) then        /* check for exact match */
                if symEntry.tok(1) = packedTok(1) then
                do;
                    curTokenSym$p = entryOffset;
                    tokenType(0) = curTokenSym.type;
                    if tokenType(0) < K$SINGLE then    /* instruction with arg */
                        if op16(tokenType(0)) then
                            has16bitOperand = TRUE;

                    if curTokenSym.flags = 2 and not ctlMOD85 then    /* RIM/SIM only valid on 8085 */
                        call SourceError('O');

                    if tokenType(0) = K$SP then        /* SP */
                    do;
                        if not(newOp = K$LXI or newOp = K$REG16) then 
                            call SourceError('X');
                        tokenType(0) = K$REGNAME;    /* reg */
                    end;
                    return tokenType(0) and 7Fh;
                end;
            deltaToNext = symEntry.delta;
        end;
        return O$ID;
    end;

    lowOffset = symTab(tableId);
    highOffset, entryOffset = endSymTab(tableId);

    /* binary chop search for id */

    do while (midOffset := lowOffset + shr((highOffset - lowOffset) and 0FFF0h, 1)) <> entryOffset;
        entryOffset = midOffset;
        if packedTok(0) = symEntry.tok(0) then
        do;
            if packedTok(1) = symEntry.tok(1) then
            do;
                curTokenSym$p = entryOffset;
                tokenType(0) = curTokenSym.type;
                if tokenType(0) = O$MACROID then
                    tokenType(0) = O$ID;

                if (usrLookupIsID := (kk := (tokenType(0) and 7Fh)) = O$ID) then
                    if needsAbsValue then
                        curTokenSym.type = 89h;
                return kk;
            end;
            else
                gt = symEntry.tok(1) > packedTok(1);
        end;
        else
            gt = symEntry.tok(0) > packedTok(0);

        entryOffset = midOffset;
        if gt then
            highOffset = entryOffset;
        else
            lowOffset = entryOffset;
    end;

    curTokenSym$p = highOffset;
    if tableId = TID$SYMBOL and not IsSkipping then
    do;
        createdUsrSym = FALSE;
        labelUse = 0;
        call UpdateSymbolEntry(srcLineCnt, (needsAbsValue and 80h) or O$ID);
        /* update symbol stack to adjust pointers for entries above insert point */
        pAddr = .tokenSym;
        do i = 1 to tokenIdx;
            pAddr = pAddr + 2;
            if addr >= curTokenSym$p then
                addr = addr + 8;
        end;

        createdUsrSym = TRUE;
    end;
    return O$ID;
end;



GetCh: procedure byte public;
    declare (curCH, prevCH) byte;
$IF MACRO
    declare ch based tmac$buf$p byte;
    declare ch1 based macro$p byte;
$ENDIF

reGetCh:
    if not reget then
    do;
        prevCH = curCH;

    nextCh:
        curCH = lookAhead;
$IF MACRO
        if expandingMacro then
        do;
            do while (lookAhead := ch) = MACROEOB;
                call ReadM(curMacroBlk + 1);
                tmac$buf$p = .macroBuf;
            end;

            tmac$buf$p = tmac$buf$p + 1;
        end;
        else
$ENDIF
            if scanCmdLine then
            lookAhead = GetCmdCh;
        else
            lookAhead = GetSrcCh;

        if chClass(curCH) = CC$BAD then
            if curCH = 0 or curCH = 7Fh or curCH = FF then
                goto nextCh;
$IF MACRO
        if expandingMacro then
        do;
            if curCH = ESC then
            do;
                goto doneGetCh;
            end;
            else if curCH = '&' then
            do;
                if not prevCH < 80h or lookAhead = 80h then
                    goto reGetCh;
            end;
            else if curCH = '!' and prevCH <> 0 then
            do;
                if not (b905D or b905E) and b905C then
                do;
                    curCH = 0;
                    goto reGetCh;
                end;
            end;
            else if curCH >= 128 then
            do;
                if not (b905C := not b905C) then
                    tmac$buf$p = w9197;
                else
                do;
                    w9197 = tmac$buf$p;
                    if curCH = 80h then
                    do;
                        tmac$buf$p = tmac$w12;
                        if b9062 = 2 then
                        do;
                            b91A2 = ch;
                            tmac$buf$p = .b91A2;
                            if ch = '!' then
                            do;
                                b91A1 = 21h;
                                b91A2 = byteAt(tmac$w12 + 1);
                                tmac$buf$p = tmac$buf$p - 1;
                            end;
                        end;
                        else
                        do;
                            do while (lookAhead := lookAhead - 1) <> 0FFh;
                                tmac$buf$p = tmac$buf$p - (ch and 7Fh);
                            end;

                            tmac$buf$p = tmac$buf$p + 1;
                        end;
                    end;
                    else
                    do;
                        tmac$buf$p = .b91A4;
                        pAddr = lookAhead + tmac$w4;
                        do ii = 1 to 4;
                            b91A4(6 - ii) = pAddr mod 10 + '0';
                            pAddr = pAddr / 10;
                        end;
                    end;
                end;

                lookAhead = 0;
                goto reGetCh;
            end;
        end;

        if expandingMacro > 1 then
            if IsPhase2Print then
                if macro$p < .endMacroLine then    /* append character */
                do;
                    ch1 = curCH;    
                    macro$p = macro$p + 1;
                end;

        if b905E then
            if w919D <> macroInPtr and curCH = CR or not b9059 then
            call InsertCharInMacroTbl(curCH);

        if not(prevCH = '!' or inComment) then
        do;
            if curCH = '>' then
                argNestCnt = argNestCnt - 1;

            if curCH = '<' then
                argNestCnt = argNestCnt + 1;
        end;
$ENDIF
    end;
doneGetCh:
    reget = 0;
    return (curChar := curCH);
end;

GetChClass: procedure byte public;
    curChar = GetCh;
$IF MACRO
    if b905D then
        return CC$MAC;
$ENDIF

    return chClass(curChar);
end;



ChkLF: procedure public;
    if lookAhead = LF then
        lookAhead = 0;
    else
    do;
$IF MACRO 
        b905E = b905E and 0FEh;
$ENDIF
        call IllegalCharError;
$IF MACRO
        b905E = b905E > 0;
$ENDIF
    end;
end;

end;

src/asm6.plx
$IF MACRO
asm6m: do;
$include(:f3:asm6m.ipx)
$ELSE
asm6n: do;
$include(:f3:asm6n.ipx)
$ENDIF

SyntaxError: procedure public;
    call SourceError('Q');
end;

DoubleDefError: procedure public;
    call SourceError('D');
end;

ExpressionError: procedure public;
    call SourceError('E');
end;

CommandError: procedure public;
    call SourceError('C');
end;

OpcodeOperandError: procedure public;
    call SourceError('O');
end;

NameError: procedure public;
    call SourceError('R');
end;

MultipleDefError: procedure public;
    call SourceError('M');
end;

ValueError: procedure public;
    call SourceError('V');
end;

NestingError: procedure public;
    call SourceError('N');
end;

PhaseError: procedure public;
    call SourceError('P');
end;

StackError: procedure public;
    call RuntimeError(0);
end;

FileError: procedure public;
    call RuntimeError(4);
end;

IllegalCharError: procedure public;
    call SourceError('I');
end;

BalanceError: procedure public;
    call SourceError('B');
end;

UndefinedSymbolError: procedure public;
    call SourceError('U');
end;

LocationError: procedure public;
    call SourceError('L');
end;

OperandError: procedure public;
    call SourceError('X');
end;

HaveTokens: procedure byte public;
    return tokenIdx <> 0;
end;


PopToken: procedure public;
    tokStart(0) = tokStart(tokenIdx);
    tokenSym(0) = tokenSym(tokenIdx);
    tokenType(0) = tokenType(tokenIdx);
    tokenAttr(0) = tokenAttr(tokenIdx);
    tokenSize(0) = tokenSize(tokenIdx);
    tokenSymId(0) = tokenSymId(tokenIdx);
    if HaveTokens then
        tokenIdx = tokenIdx - 1;
end;



/* nest - sw = 1 -> nest macro sw = 2 -> nest if */
Nest: procedure(sw) public;
    declare sw byte;
$IF MACRO
    macroCondStk(macroCondSP := macroCondSP + 1) = macroCondStk(0);
    /* record whether current nest is macro of if */
    if (macroCondStk(0) := sw) = 1 then
    do;
        if (macroDepth := macroDepth + 1) > 9 then
        do;
            call StackError;
            macroDepth = 0;
        end;
        else
        do;
            call move(16, .macroStk(0), .macroStk(macroDepth));
            tmac$macroCondSP = macroCondSP;
            tmac$ifDepth = ifDepth;
            b9061 = TRUE;
        end;
    end;
    else
$ENDIF
    do;
        if (ifDepth := ifDepth + 1) > 8 then
        do;
            call StackError;
            ifDepth = 0;
        end;
        else
        do;
            skipIf(ifDepth) = skipIf(0);
            inElse(ifDepth) = inElse(0);
        end;
    end;
end;


UnNest: procedure(sw) public;
    declare sw byte;

$IF MACRO
    if sw <> macroCondStk(0) then	/* check for unbalanced unnest */
    do;
        call NestingError;
        if sw = 2 then			/* not macro unnest */
            return;
        macroCondSP = tmac$macroCondSP;
        ifDepth = tmac$ifDepth;
    end;

    macroCondStk(0) = macroCondStk(macroCondSP);	/* restore macro stack */
    macroCondSP = macroCondSP - 1;
    if sw = 1 then			/* is unnest macro */
    do;
        call move(16, .macroStk(macroDepth), .macroStk(0));
        call ReadM(tmac$blk);
        b9062 = tmac$mtype;
        if (macroDepth := macroDepth - 1) = 0 then	/* end of macro nest */
        do;
            expandingMacro = 0;		/* not expanding */
            baseMacroTbl = Physmem + 0BFh;
        end;
    end;
$ELSE
    if ifDepth = 0 then			/* nothing to unnest */
        call NestingError;
$ENDIF
    else
    do;
        skipIf(0) = skipIf(ifDepth);	/* pop skipIf and inElse status */
        inElse(0) = inElse(ifDepth);
        ifDepth = ifDepth - 1;
    end;
end;

PushToken: procedure(type) public;
    declare type byte;

    if tokenIdx >= 8 then
        call StackError;
    else
    do;
        tokenIdx = tokenIdx + 1;
        tokStart(tokenIdx) = tokStart(0);
        tokenSym(tokenIdx) = tokenSym(0);
        tokenType(tokenIdx) = tokenType(0);
        tokenAttr(tokenIdx) = tokenAttr(0);
        tokenSize(tokenIdx) = tokenSize(0);
        tokenSymId(tokenIdx) = tokenSymId(0);    
        tokStart(0) = tokStart(0) + tokenSize(0);    /* advance for next token */
        tokenType(0) = type;
        tokenAttr(0), tokenSize(0) = bZERO;
        tokenSym(0) = wZERO;
$IF MACRO
        tokenSymId(0) = wZERO;
$ELSE
        tokenSymId(0) = tokenSym(0);
$ENDIF
    end;
end;

CollectByte: procedure(c) public;
    declare c byte;
    declare s pointer;
    declare ch based s byte;


    if (s := tokPtr + tokenSize(0)) < endLineBuf then    /* check for lineBuf overrun */
    do;
        ch = c;
        tokenSize(0) = tokenSize(0) + 1;
    end;
    else
        call StackError;
end;

GetId: procedure(type) public;
    declare type byte;

    call PushToken(type);    /* save any previous token and initialise this one */
    reget = 1;        /* force re get of first character */

    do while (type := GetChClass) = CC$DIG or type = CC$LET;    /* digit or letter */
        if curChar > 60h then    /* make sure upper case */
            curChar = curChar and 0DFh;
        call CollectByte(curChar);
    end;
    reget = 1;        /* force re get of Exit char */
end;


GetNum: procedure public;
    declare accum address,
        (radix, digit, i) byte;
    declare chrs based tokPtr (1) byte;

    call GetId(O$NUMBER);
    radix = chrs(tokenSize(0):= tokenSize(0) - 1);
    if radix = 'H' then
        radix = 16;

    if radix = 'D' then
        radix = 10;

    if radix = 'O' or radix = 'Q' then
        radix = 8;

    if radix = 'B' then
        radix = 2;

    if radix > 16 then
        radix = 10;
    else
        tokenSize(0)= tokenSize(0) - 1;

    accum = 0;
    do i = 0 to tokenSize(0);
        if chrs(i) = '?' or chrs(i) = '@' then
        do;
            call IllegalCharError;
            digit = 0;
        end;
        else
        do;
            if (digit := chrs(i) - '0') > 9 then
                digit = digit - 7;
            if digit >= radix then
                if not (tokenType(2) = 40h) then /* risk that may be uninitialised */
                do;
                    call IllegalCharError;
                    digit = 0;
                end;
        end;

        accum = accum * radix + digit;
    end;
    /* replace with packed number */
    tokenSize(0) = 0;
    call CollectByte(low(accum));
    call CollectByte(high(accum));
end;

GetStr: procedure public;
    call PushToken(O$STRING);

    do while GetCh <> CR;
        if curChar = '''' then
            if GetCh <> '''' then
                goto L6268;
        call CollectByte(curChar);
    end;

    call BalanceError;

L6268:
    reget = 1;
end;

end;
src/cntrl.plx
$IF MACRO
cntrlm: do;
$include(:f3:cntrlm.ipx)
$ELSE
cntrln: do;
$include(:f3:cntrln.ipx)
$ENDIF

declare controlTable(*) byte data(
            35h, 'DEBUG', 3Ah, 'MACRODEBUG',
            34h, 'XREF', 37h, 'SYMBOLS',
            36h, 'PAGING', 33h, 'TTY',
            25h, 'MOD85', 35h, 'PRINT',
            36h, 'OBJECT', 39h, 'MACROFILE',
            29h, 'PAGEWIDTH', 2Ah, 'PAGELENGTH',
              7, 'INCLUDE', 5, 'TITLE',
              4, 'SAVE', 7, 'RESTORE',
              5, 'EJECT', 14h, 'LIST',
            13h, 'GEN', 14h, 'COND');

declare (tokVal, savedCtlLIST, savedCtlGEN) byte,
    controlError bool;


ChkParen: procedure(arg1b) bool;
    declare arg1b byte;
    call SkipWhite;
    reget = 0;
    return arg1b + '(' = curChar;
end;



GetTok: procedure byte;
    tokBufLen = 0;
    tokType = O$NONE;
    if IsCR then
        return curChar;

    call SkipWhite$2;
    if curChar > 'A'-1 and 'Z'+1 > curChar or curChar > 'a'-1 and 'z'+1 > curChar then
    do;                            /* letter */
        call GetId(1);
        if BlankAsmErrCode and tokenSize(0) < 14 then
            call move(tokBufLen := tokenSize(0), .lineBuf, .tokBuf);
    end;
    else if curChar > '0'-1  and  '9'+1 > curChar then    /* digit ? */
    do;
        call GetNum;
        if BlankAsmErrCode then
        do;
            tokNumVal = GetNumVal;
            tokType = TT$NUM;
            tokBuf(0) = ' ';
        end;
    end;
    else if curChar = '''' then    /* string ? */
    do;
        call GetStr;
        if BlankAsmErrCode then
        do;
            tokBufLen = 64;
            if tokenSize(0) < 64 then
                tokBufLen = tokenSize(0);
            tokType = TT$STR;
            if tokBufLen > 0 then
                call move(tokBufLen, .lineBuf, .tokBuf);
        end;
    end;
    else
    do;
        tokBufLen = 1;
        tokBuf(0) = curChar;
        return curChar;
    end;

    call PopToken;
    return tokBuf(0);
end;



Sub6F07: procedure(arg1w) bool;
    declare arg1w address;
    declare pad address;

    if tokBufIdx = 0 then
        return FALSE;

    tokBuf(tokBufIdx) = ' ';
    tokBufLen = tokBufIdx;
    if IsWhite then
        return ChkParen(1);
    return TRUE;
end;

Sub6F39: procedure;
    call SkipWhite$2;

    do while 1;
        if IsRParen or IsWhite then
        do;
            if Sub6F07(.tokBuf(0)) then
                return;
            goto done;
        end;

        tokBuf(tokBufIdx) = curChar;
        tokBufIdx = tokBufIdx + 1;
        if tokBufIdx > 14 then
            goto done;
        curChar = GetCh;
    end;
done:
    curFileName$p = .tokBuf;
    call FileError;
end;


GetFileParam: procedure;
    tokBufIdx = 0;
    if not ChkParen(0) then    /* ( */
        call FileError;
    else
    do;
        call Sub6F39;
        call move(tokBufIdx + 1, .tokBuf, curFileName$p);
        if not ChkParen(1) then    /* ) */
            call FileError;
    end;
end;


GetMacroFileDrive: procedure;
    call SkipWhite$2;
    tokBufIdx = 0Dh;
    ii = 0;

    do while not IsRParen and ii < 4;
        asmax$ref(ii) = curChar;
        ii = ii + 1;
        curChar = GetCh;
    end;

    if IsRParen or IsWhite then
        if Sub6F07(.asmax$ref) then
            return;
    curFileName$p = .asmax$ref;
    tokBufIdx = 0;
    call FileError;
end;




GetControlNumArg: procedure bool;
    if ChkParen(0) then    /* ( */
    do;
        tokVal = GetTok;
        if tokType = TT$NUM then
            return ChkParen(1);    /* ) */
    end;
    return FALSE;
end;


LookupControl: procedure byte;
    declare (cmdIdx, cmdStartIdx) byte, 
        ctlVal bool,
        (cmdLen, ctlFlags, noInvalid) byte,
        (control$p, nextControl$p, ctlSeen$p) pointer;
    declare twoch address at(.tokBuf);
    declare ch based control$p byte;
    declare ctlSeen based ctlSeen$p byte;

    SetControl: procedure;
        if not noInvalid then
        do;
            controls(controlId) = ctlVal;
            if not ctlVal then
                controlId = 17;    /* no action needed */
        end;
    end;


    cmdLen = tokBufLen;
    cmdStartIdx = 0;
    ctlVal = TRUE;
    if twoch = 'ON' then    /* NO stored with bytes swapped */
    do;
        cmdStartIdx = 2;    /* don't match the NO in the table */
        ctlVal = FALSE;        /* control will be set as false */
        cmdLen = tokBufLen - 2;    /* length of string to match excludes the NO */
    end;

    control$p = .controlTable;
    controlId = 0;
    cmdIdx = cmdStartIdx;

    do while controlId < 20;
        nextControl$p = control$p + (ch and 0Fh) + 1;
        if (ch and 0Fh) = cmdLen then
        do;
            ctlFlags = ch;
            do while cmdIdx < tokBufLen;
                control$p = control$p + 1;
                if ch <> tokBuf(cmdIdx) then
                    cmdIdx = tokBufLen + 1;    /* cause early Exit */
                else
                    cmdIdx = cmdIdx + 1;    /* check next character */
            end;

            if cmdIdx = tokBufLen then        /* found it */
                goto found;
        end;
        control$p = nextControl$p;
        controlId = controlId + 1;
        cmdIdx = cmdStartIdx;
    end;
    return 255;                        /* not found */

found:
$IF NOT MACRO 
    if controlId = 1 or controlId = 12h then    /* MACRODEBUG or GEN */
    do;
        if scanCmdLine then            /* only valid on command line not $ line */
            MacroDebugOrGen = TRUE;
        else
            return 255;            /* Error otherwise */
    end;
$ENDIF
    if (noInvalid := (ctlFlags and 10h) <> 10h) and not ctlVal then
        return 255;    /* NO not supported */

    if (ctlFlags and 20h) <> 20h then        /* GENERAL control */
    do;
        call SetControl;
        return controlId;
    end;

    if not primaryValid then            /* is a PRIMARY control */
        return 255;

    ctlSeen$p = .controlSeen(controlId);        /* make sure we only see a primary once */
    if ctlSeen then
        return 255;
    ctlSeen = TRUE;
    call SetControl;
    return controlId;
end;

ProcessControl: procedure;
    if controlId >= 17 or controlId < 5 then
        return;

    do case controlId - 5;
/* 0 */        do;            /* TTY */
            ctlTTY = TRUE;
            return;
        end;
/* 1 */        do;            /* MOD85 */
            ctlMOD85 = TRUE;
            return;
        end;
/* 2 */        do;            /* PRINT */
            controlFileType = 2;
            curFileName$p = .lstFile;
            call GetFileParam;
            return;
        end;
/* 3 */        do;            /* OBJECT */
            controlFileType = 3;
            curFileName$p = .objFile;
            call GetFileParam;
            return;
        end;
/* 4 */        do;            /* MACROFILE */
            controlFileType = 3;
            if ChkParen(0) then    /* optional drive for tmp file */
                call GetMacroFileDrive;
            else
                reget = 1;
            ctlMACROFILE = TRUE;
            return;
        end;
/* 5 */        do;            /* PAGEWIDTH */
            if GetControlNumArg then
            do;
                ctlPAGEWIDTH = tokNumVal;
                if ctlPAGEWIDTH > 132 then
                    ctlPAGEWIDTH = 132;
                if ctlPAGEWIDTH < 72 then
                    ctlPAGEWIDTH = 72;
                return;
            end;
        end;
/* 6 */        do;            /* PAGELENGTH */
            if GetControlNumArg then
            do;
                ctlPAGELENGTH = tokNumVal;
                if ctlPAGELENGTH < 15 then
                    ctlPAGELENGTH = 15;
                return;
            end;
        end;
/* 7 */        do;            /* INCLUDE */
            if not needToOpenFile then
            do;
                controlFileType = 1;
                if fileIdx = 5 then
                    call StackError;
                else
                do;
                    fileIdx = fileIdx + 1;
                    curFileName$p = .files(fileIdx);
                    call GetFileParam;
                    needToOpenFile = TRUE;
                    if scanCmdLine then
                        includeOnCmdLine = TRUE;
                    return;
                end;
            end;
        end;
/* 8 */        do;            /* TITLE */
            if ChkParen(0) then
            do;
                tokVal = GetTok;
                if tokType = TT$STR and tokBufLen <> 0 then
                do;
                    if phase <> 1 or IsPhase1 and primaryValid then
                    do;
                        call move(tokBufLen, .tokBuf, .ctlTITLESTR);
                        ctlTITLESTR(titleLen := tokBufLen) = 0;
                        if ChkParen(1) then
                        do;
                            ctlTITLE = TRUE;
                            return;
                        end;
                    end;
                end;
            end;
        end;
/* 9 */        do;            /* SAVE */
            if saveIdx > 7 then
                call StackError;
            else
            do;
                call move(3, .ctlLIST, .saveStack + saveIdx * 3);
                saveIdx = saveIdx + 1;
                return;
            end;
        end;
/* 10 */    do;            /* RESTORE */
            if saveIdx > 0 then
            do;
                call move(3, .saveStack + (saveIdx := saveIdx - 1) * 3, .ctlLIST);
                return;
            end;
        end;
/* 11 */    do;            /* EJECT */
            ctlEJECT = ctlEJECT + 1;
            return;
        end;
    end;
    controlError = TRUE;
end;

ParseControls: procedure public;
    isControlLine = TRUE;
    ctlLISTChanged, savedCtlLIST = ctlLIST;
$IF MACRO
    savedCtlGEN = ctlGEN;
$ENDIF
    controlError = FALSE;

    do while GetTok <> CR and not controlError;
        if tokBuf(0) = ';' then        /* skip comments */
            call Skip2EOL;
        else if LookupControl = 255 then    /* Error ? */
            controlError = TRUE;
        else
            call ProcessControl;
    end;

    if controlError then
    do;
        if tokBuf(0) <> CR then
        do;
            reget = 0;
            call Skip2EOL;
        end;

        if scanCmdLine then
            call RuntimeError(2);    /* command Error */
        else
            call CommandError;
    end;

    call ChkLF;            /* eat the LF */
    if ctlLIST <> savedCtlLIST then
        ctlLISTChanged = TRUE;
$IF MACRO
    else if ctlGEN <> savedCtlGEN and expandingMacro then
        ctlLISTChanged = FALSE;
$ENDIF

    reget = 0;
end;

end;
src/asm8m.plm
asm8m: do;
$include(:f3:asm8m.ipx)

declare b7183(*) byte data(3Fh, 0, 4, 0, 0, 0, 8, 0, 10h);
    /* bit vector 64 - 00000000 00000100 00000000 00000000 00000000 00001000 00000000 00010000 */
    /*                 CR, COMMA, SEMI */                                  

declare w9C75 address,
    b9C77 byte public;


Sub7192: procedure byte;
    if IsCR then
    do;
        b905A = 0;
        return TRUE;
    end;

    if b905A then
        return argNestCnt = b9066;

    if IsLT or (not (tmac$mtype = 1) and IsGT) then
    do;
        call IllegalCharError;
        return TRUE;
    end;

    return IsWhite or IsComma or IsGT or curChar = ';';
end;



Sub71F2: procedure;
    symTab(TID$MACRO), endSymTab(TID$MACRO) = symHighMark;
    b9065, tmac$b3 = bZERO;
    effectiveToken = 37h;
end;


Sub720A: procedure;

    b9062 = tmac$mtype;
    if not expandingMacro then
        expandingMacro = 1;

    if macroDepth = 0 then
        expandingMacro = 0FFh;

    if b9061 then
        call move(4, .macroStk(0).buf$p, .macroStk(macroDepth).buf$p);

    b9061 = FALSE;
    tmac$w12 = w9199;
    tmac$w4 = w919B;
    w919B = w919B + tmac$b3;
    call ReadM(tmac$w10);
    tmac$buf$p = .macroBuf;
end;


Sub727F: procedure bool;
    if not b905E then
        return TRUE;
    b9064 = b9064 + 1;
    b6B2C = topOp <> K$REPT;
    effectiveToken = 37h;
    return FALSE;
end;


Sub72A4: procedure(arg1b) public;    /* 1 -> IRP, 2 -> IRPC */
    declare arg1b byte;

    if Sub727F then
    do;
        call Sub71F2;
        call Nest(1);
        tmac$w14 = 0;
        tmac$mtype = arg1b;
    end;
end;

Acc1ToDecimal: procedure;
    declare buf(6) byte;

    call PushToken(CR);
    kk = 0;
    /* build number in reverse digit order */
loop:
    buf(kk := kk + 1) = accum1 mod 10 + '0';
    if (accum1 := accum1 / 10) > 0 then
        goto loop;

    /* insert in collect buffer in order */
    do while kk > 0;
        call CollectByte(buf(kk));
        kk = kk - 1;
    end;
end;


Sub7327: procedure public;
    w9199 = baseMacroTbl;
    effectiveToken = 3Dh;
    b905D = TRUE;
    b9060 = FALSE;
end;


EnterMacro: procedure(lowAddr, highAddr) address;
    declare (lowAddr, highAddr) pointer;
    declare ch1 based baseMacroTbl byte,
        ch2 based highAddr byte;

    do while lowAddr <= highAddr;
        if baseMacroTbl <= symHighMark then
            call RuntimeError(1);    /* table Error */
        ch1 = ch2;
        baseMacroTbl = baseMacroTbl - 1;
        highAddr = highAddr - 1;
    end;
    return baseMacroTbl;
end;


Sub7383: procedure;
    b9064 = 1;
    macroInPtr = symHighMark;
    b905E = 1;
    w9C75 = macroBlkCnt;
end;



Sub739A: procedure;
    if usrLookupIsID then
        if asmErrCode <> 'U' then
            call LocationError;
end;


Sub73AD: procedure public;
    declare isPercent byte;

    b9C77 = tokenIdx;
    call SkipWhite;
    if not (isPercent := curChar = '%') then
    do;
        b9066 = argNestCnt - 1;
        if (b905A := IsLT) then
            curChar = GetCh;

        call PushToken(CR);

    L73E2:    do while not Sub7192;
            if curChar = '''' then
            do;
                if (curChar := GetCh) = '''' then
                do;
                    curChar = GetCh;
                    call SkipWhite;
                    if Sub7192 then
                        goto L7463;
                    else
                    do;
                        call CollectByte('''');
                        call CollectByte('''');
                    end;
                end;
                else
                do;
                    call CollectByte('''');
                    goto L73E2;
                end;
            end;
            call CollectByte(curChar);
            if tmac$mtype = 2 then
                tmac$w14 = tmac$w14 + 1;

            if curChar = '!' and GetCh <> CR then
            do;
                call CollectByte(curChar);
                curChar = GetCh;
            end;
        end;

    L7463:    if b905A then
            curChar = GetCh;

        call SkipWhite;
        if IsGT then
        do;
            curChar = GetCh;
            call SkipWhite;
        end;

        reget = 1;
    end;

    b905D = FALSE;
    if tmac$mtype = 4 then
    do;
        if not b905A and tokenSize(0) = 5 then
            if StrUcEqu(.('MACRO', 0), tokPtr) then
            do;
                effectiveToken = K$MACRO;
                call PopToken;
                w9199 = tmac$w12;
                opSP = opSP - 1;
                reget = 1;
                call EmitXref(XREF$DEF, .name);
                rhsUserSymbol = FALSE;
                b6BDA = TRUE;
                return;
            end;
        tmac$mtype = b9062;
        call Nest(1);
        tmac$mtype = 0;
    end;

    if not isPercent then
        if not TestBit(curChar, .b7183) then    /* not CR, COMMA or SEMI */
        do;
            call Skip2EOL;
            call SyntaxError;
            reget = 1;
        end;
end;



Sub7517: procedure public;
    if Sub727F then
    do;
        expectingOperands = FALSE;
        w9068 = curTokenSym$p + 4;
        call UpdateSymbolEntry(0, O$3A);
        tmac$mtype = 0;
        call Sub71F2;
    end;
end;

Sub753E: procedure public;
    declare ch based w9068 byte;

    if HaveTokens then
    do;
        if tokenType(0) = 0 then
            call MultipleDefError;

        call Sub5CAD((b9065 := b9065 + 1), 0);
    end;
    else if not (tmac$mtype = 0) then
        call SyntaxError;

    if not tmac$mtype = 0 then
    do;
        call SkipWhite;
        if IsComma then
        do;
            reget = 0;
            newOp = O$NONE;
            call Sub7327;
            if tmac$mtype = 1 then
            do;
                curChar = GetCh;
                call SkipWhite;
                if not IsLT then
                do;
                    call SyntaxError;
                    reget = 1;
                end;
            end;
        end;
        else
        do;
            call SyntaxError;
            call Sub7383;
        end;
    end;
    else if newOp = T$CR then
    do;
        if not BlankMorPAsmErrCode then
        do;
            tmac$mtype = 5;
            w9068 = w9068 + 2;
            if (ch and 7Fh) = 3Ah then
                ch = (asmErrCode = 'L') and 80h or 9;
        end;
        call Sub7383;
    end;
end;

Sub75FF: procedure public;
    declare ch based macroInPtr byte;
    declare ch2 based w9068 byte;
    declare wrd based w9068 address;

    if b905E then
    do;
        if (b9064 := b9064 - 1) = 0 then
        do;
            b905E = 0;
            if not (tmac$mtype = 5) then
            do;
                if tmac$mtype = 2 then
                    w9199 = baseMacroTbl + 3;

                do pAddr = w919D to w919F - 1;
                    curChar = byteAt(pAddr);
                    if not IsWhite then
                        call SyntaxError;
                end;

                macroInPtr = w919D;
                ch = 1Bh;
                call FlushM;
                call WriteM;
                symHighMark, endSymTab(TID$MACRO) = symTab(TID$MACRO);
                if tmac$mtype = 0 then
                do;
                    wrd = w9C75;
                    w9068 = w9068 + 3;
                    ch2 = tmac$b3;
                end;
                else
                do;
                    tmac$w10 = w9C75;
                    call Sub720A;
                    if tmac$w14 = 0 then
                        call UnNest(1);
                end;
            end;
        end;
    end;
    else
        call NestingError;
end;


Sub76CE: procedure public;
    if expandingMacro then
    do;
        if newOp = T$CR then
        do;
            condAsmSeen = TRUE;
            macroCondSP = tmac$macroCondSP;
            ifDepth = tmac$ifDepth;
            tmac$w14 = 1;
            lookAhead = 1Bh;
            macroCondStk(0) = 1;
        end;
        else
            call SyntaxError;
    end;
    else
        call NestingError;
end;


Sub770B: procedure public;
    if b9C77 + 1 <> tokenIdx then
        call SyntaxError;
    else if not b9060 then
    do;
        if tokenType(0) <> 0Dh then
        do;
            accum1 = GetNumVal;
            call Acc1ToDecimal;
        end;

        if tmac$mtype = 2 then
            tmac$w14 = tokenSize(0) - (tokenSize(0) = 0);

        call CollectByte((tokenSize(0) + 1) or 80h);
        baseMacroTbl = EnterMacro(tokPtr, tokPtr + tokenSize(0) - 1);
        call PopToken;

        if tmac$mtype = 0 or tmac$mtype = 1 and argNestCnt > 0 then
            b905D = TRUE;
        else
            b9060 = TRUE;

        if tmac$mtype = 1 then
            tmac$w14 = tmac$w14 + 1;
    end;
    else
        call SyntaxError;

    if newOp = T$CR then
    do;
        b905D = FALSE;
        if argNestCnt > 0 then
            call BalanceError;

        if not BlankMorPAsmErrCode then
        do;
            call Sub739A;
            if tmac$mtype = 0 then
            do;
                call Sub720A;
                call UnNest(1);
                return;
            end;
            else
                tmac$w14 = 0;
        end;
        else
        do;
            baseMacroTbl = EnterMacro(.b$3782, .b$3783);
            if tmac$mtype = 0 then
            do;
                tmac$b3 = curTokenSym.flags;
                tmac$w10 = GetNumVal;
                call Sub720A;
            end;
            else if tmac$w14 = 0 then
                call SyntaxError;
        end;

        if not (tmac$mtype = 0) then
            call Sub7383;
    end;
end;



Sub7844: procedure public;
    call Sub72A4(3);
    if (effectiveToken := newOp) <> T$CR then
        call SyntaxError;

    if not b905E then
    do;
        tmac$w14 = accum1;
        if not BlankMorPAsmErrCode then
        do;
            call Sub739A;
            tmac$w14 = 0;
        end;

        call Sub7383;
    end;
end;


Sub787A: procedure public;
    if b905E = 2 then
    do;
        if HaveTokens then
        do;
            if (tmac$b3 := tmac$b3 + 1) = 0 then
                call StackError;

            if tokenType(0) <> 9 then
                call MultipleDefError;

            call Sub5CAD(tmac$b3, 1);
            macroInPtr = symHighMark;
        end;
        if newOp = T$CR then
        do;
            b905E = 1;
            macroInPtr = symHighMark;
        end;
    end;
    else
        call SyntaxError;
end;



Sub78CE: procedure public;
    kk = byteAt(tmac$w12);
    accFixFlags(0) = 1 - (kk = 21h and b9062 = 2);
    if b9062 = 0 or (tmac$w14 := tmac$w14 - accFixFlags(0)) = 0 then
        call UnNest(1);
    else
    do;
        if b9062 = 1 then
            w9199 = tmac$w12 - (kk and 7Fh);
        else
            w9199 = tmac$w12 + accFixFlags(0);

        tmac$mtype = b9062;
        call Sub720A;
    end;
    lookAhead = 0;
    b6B2C, atStartLine = bTRUE;
end;

end;
src/list.plx
$IF MACRO
listm: do;
/* to force the code generation this needs a non-standard definition of put2Hex */
Put2Hex: procedure(arg1w, arg2w) external; declare arg1w address, arg2w address; end;
$include(:f3:listm.ipx)
$ELSE
listn: do;
Put2Hex: procedure(arg1w, arg2w) external; declare arg1w address, arg2w address; end;
$include(:f3:listn.ipx)
$ENDIF

declare aAssemblyComple(*) byte initial(CR, LF, 'ASSEMBLY COMPLETE,'),
    aNoErrors(*) byte initial('   NO ERRORS'),
    spaceLP(*) byte initial(' ('),
    space5RP(*) byte initial('     )'),
    aPublicSymbols(*) byte initial(CR, LF, 'PUBLIC SYMBOLS', CR, LF, 0),
    aExternalSymbol(*) byte initial(CR, LF, 'EXTERNAL SYMBOLS', CR, LF, 0),
    pad754E address,

    aUserSymbols(*) byte data(CR, LF, 'USER SYMBOLS', CR, LF, 0),
    lstHeader(*) byte data('  LOC  OBJ         LINE        SOURCE STATEMENT', CR, LF, LF, 0),
    symbolMsgTable(*) address data(.aPublicSymbols, .aExternalSymbol, .aUserSymbols),
    aCRLFLF(*) byte data(CR, LF, LF, 0),
    aCR(*) byte data(CR),
    topLFs(*) byte data(LF, LF, LF, 0),
    b6DC1(2) byte data(20h, 40h),
    ascLParen(*) byte data(' (', 0),
    ascRParen(*) byte data(')', 0),
    a1234(*) byte data('  1234');


Out2Hex: procedure(n);
    declare n byte;
    call Put2Hex(.outch, n);
end;


Print2Hex: procedure(n);
    declare n byte;
    call Put2Hex(.printChar, n);
end;



PrintStr: procedure(str) reentrant;
    declare str pointer;
    declare ch based str byte;

    do while ch <> 0;
        call PrintChar(ch);
        str = str + 1;
    end;
end;

PrintNStr: procedure(cnt, str) reentrant;
    declare cnt byte, str pointer;
    declare ch based str byte;

    do while cnt > 0;
        call PrintChar(ch);
        str = str + 1;
        cnt = cnt - 1;
    end;
end;


PrintCRLF: procedure reentrant;
    call PrintChar(CR);
    call PrintChar(LF);
end;

declare aNumStr(*) byte initial('     ', 0);


Itoa: procedure(n, buf);
    declare n address, buf pointer;
    declare ch based buf byte;

    call move(5, .spaces5, buf);
    buf = buf + 4;

    do while 1;
        ch = n mod 10 + '0';
        buf = buf - 1;
        if (n := n /10) = 0 then
            return;
    end;
end;


PrintDecimal: procedure(n) reentrant public;
    declare n address;
    call Itoa(n, .aNumStr);
    call PrintStr(.aNumStr(1));
end;

SkipToEOP: procedure public;
    do while pageLineCnt <= ctlPAGELENGTH;
        call Outch(LF);
        pageLineCnt = pageLineCnt + 1;
    end;
end;


NewPageHeader: procedure public;
    call PrintStr(.topLFs);
    call PrintStr(.asmHeader);
    call PrintDecimal(pageCnt);
    call PrintCRLF;
    if ctlTITLE then
        call PrintNStr(titleLen, .ctlTITLESTR);

    call PrintCRLF;
    call PrintCRLF;
    if not b68AE then
        call PrintStr(.lstHeader);
    pageCnt = pageCnt + 1;
end;


NewPage: procedure public;
    if ctlTTY then
        call SkipToEOP;
    else
        call Outch(FF);

    pageLineCnt = 1;
    if not scanCmdLine then
        call NewPageHeader;
end;


DoEject: procedure public;
    if ShowLine then
    do while ctlEJECT > 0;
        call NewPage;
        ctlEJECT = ctlEJECT - 1;
    end;
end;




PrintChar: procedure(c) reentrant;
    declare c byte;
    declare cnt byte;

    if c = FF then
    do;
        call NewPage;
        return;
    end;

    if c = LF then
        if ctlPAGING then
        do;
            if (pageLineCnt := pageLineCnt + 1) >= ctlPAGELENGTH - 2 then
            do;
                if ctlTTY then
                    call Outch(LF);
                if ctlEJECT > 0 then
                    ctlEJECT = ctlEJECT - 1;
                call NewPage;
                return;
            end;
        end;

    if c = CR then
        curCol = 0;

    cnt = 1;
    if c = TAB then
    do;
        cnt = 8 - (curCol and 7);
        c = ' ';
    end;

    do while cnt <> 0;
        if curCol < 132 then
        do;
            if c >= ' ' then
                curCol = curCol + 1;
            if curCol > ctlPAGEWIDTH then
            do;
                call PrintCRLF;
                call PrintStr(.spaces24);
                curCol = curCol + 1;
            end;
            call Outch(c);
        end;
        cnt = cnt - 1;
    end;
end;

declare segChar(*) byte initial(' CDSME');    /* seg id char */

Sub7041$8447: procedure public;
    declare symGrp byte,
        flagsAndType address,
        (type, flags) byte at(.flagsAndType),
        zeroAddr byte;
    declare tokBytePair based curTokenSym$p address;

    PrintAddr2: procedure(printFunc);
        declare printFunc address;
        declare ch based curTokenSym$p byte;

        curTokenSym$p = curTokenSym$p - 1;    /* backup into value */
        call printFunc(ch and not zeroAddr);    /* print address or 0 */
    end;


    b68AE = TRUE;
    if not ctlSYMBOLS then
        return;

    segChar(0) = 'A';        /* show A instead of space for absolute */
    do symGrp = 0 to 2;
        kk = IsPhase2Print and ctlSYMBOLS;
$IF MACRO
        ctlDEBUG = ctlDEBUG or ctlMACRODEBUG;
$ENDIF
        curTokenSym$p = symTab(TID$SYMBOL) - 2;        /* address user sym(-1).type */
        call PrintCRLF;
        call PrintStr(symbolMsgTable(symGrp));

        do while (curTokenSym$p := curTokenSym$p + 8) < endSymTab(TID$SYMBOL);
            flagsAndType = tokBytePair;
            if type <> 9 then
                if type <> 6 then
$IF MACRO
                    if nonHiddenSymbol then
$ENDIF
                        if symGrp <> 0 or type <> 3 then
                            if symGrp = 2 or (flags and b6DC1(symGrp)) <> 0 then
                            do;
                                call UnpackToken(curTokenSym$p - 6, .tokStr);
                                if kk then
                                do;
                                    if (ctlPAGEWIDTH - curCol) < 17 then
                                        call PrintCRLF;

                                    call PrintStr(.tokStr);
                                    call PrintChar(' ');
$IF MACRO
                                    if type = O$3A then
                                        call PrintChar('+');
                                    else
$ENDIF
                    if (zeroAddr := (flags and UF$EXTRN) <> 0) then
                                        call PrintChar('E');
                                    else
                                        call PrintChar(segChar(flags and UF$SEGMASK));

                                    call PrintChar(' ');
                                    call PrintAddr2(.print2Hex);
                                    call PrintAddr2(.print2Hex);
                                    curTokenSym$p = curTokenSym$p + 2;
                                    call PrintStr(.spaces4);
                                end;
                            end;
        end;
    end;

    if ctlDEBUG then
        b68AE = FALSE;

    if kk then
        call PrintCRLF;
end;

PrintCmdLine: procedure public;
    declare ch based actRead byte;

    call Outch(FF);
    call DoEject;
    ch = 0;
    call PrintStr(.cmdLineBuf);
    call NewPageHeader;
end;


OutStr: procedure(s) reentrant public;
    declare s address;
    declare ch based s byte;

    do while ch <> 0;
        call Outch(ch);
        s = s + 1;
    end;
end;

OutNStr: procedure(cnt, s) reentrant;
    declare cnt byte, s address,
        ch based s byte;

    do while cnt > 0;
        call Outch(ch);
        s = s + 1;
        cnt = cnt - 1;
    end;
end;


MoreBytes: procedure byte public;
    return startItem < endItem;
end;



PrintCodeBytes: procedure public;
    declare ch based startItem byte;
    declare i byte;

    if (showAddr := MoreBytes or showAddr) then
    do;    /* print the address */
        call Out2Hex(high(effectiveAddr));
        call Out2Hex(low(effectiveAddr));
    end;
    else
        call OutStr(.spaces4);

    call Outch(' ');
    do  i = 1 to 4;
        if MoreBytes and isInstr then
        do;
            effectiveAddr = effectiveAddr + 1;
            call Out2Hex(ch);
        end;
        else
            call OutStr(.spaces2);

        startItem = startItem + 1;
    end;

    call Outch(' ');
    if shr(kk := tokenAttr(spIdx), 6) then    /* UF$EXTRN */
        call Outch('E');
    else if not showAddr then
        call Outch(' ');
    else
        call Outch(segChar(kk and 7));
end;


PrintErrorLineChain: procedure public;
    if not errorOnLine then
        return;

    call PrintStr(.ascLParen);    /* " (" */
    call PrintNStr(4, .lastErrorLine);
    call PrintStr(.ascRParen);    /* ")" */
    call PrintCRLF;
    call move(4, .asciiLineNo, .lastErrorLine);
end;



PrintLine: procedure public;
    declare ch based inCh$p byte;
$IF MACRO
    declare ch1 based macro$p byte;
$ENDIF
loop:
    endItem = (startItem := tokStart(spIdx)) + tokenSize(spIdx);
    if IsSkipping then
        endItem = startItem;

    call Outch(asmErrCode);
$IF MACRO
    if b905E = 0FFh then
        call Outch('-');
    else
$ENDIF
        call Outch(' ');

    if not BlankAsmErrCode then
    do;
        asmErrCode = ' ';
        errorOnLine = TRUE;
    end;
    if isControlLine then
        call OutStr(.spaces15);
    else
        call PrintCodeBytes;

    if fileIdx > 0 then
    do;
    /* note byte arith used so needToOpenFile = TRUE(255) treated as -1 */
        call Outch(a1234(ii := needToOpenFile + fileIdx));
        if ii > 0 then    
            call Outch('=');
        else
            call Outch(' ');
    end;
    else
        call OutStr(.spaces2);

    if lineNumberEmitted then
    do;
        call OutStr(.spaces4);
        call PrintCRLF;
    end;
    else
    do;
        lineNumberEmitted = TRUE;
        call OutNStr(4, .asciiLineNo);
$IF MACRO
        if expandingMacro > 1 then
            call Outch('+');
        else
$ENDIF
            call Outch(' ');
$IF MACRO
        if expandingMacro > 1 then
        do;
            curCol = 24;
            ch1 = 0;
            call PrintStr(.macroLine);
            call PrintChar(LF);
        end;
        else
        do;
$ENDIF
            curCol = 24;
            call PrintNStr(lineChCnt, startLine$p);
        if ch <> LF then
                 call PrintChar(LF);
$IF MACRO
        end;
$ENDIF
    end;

    if isControlLine then
    do;
        if ctlPAGING then
            call DoEject;
    end;
    else
    do;
        do while MoreBytes;
            call OutStr(.spaces2);
            call PrintCodeBytes;
            call PrintCRLF;
        end;

        if spIdx > 0 and (inDB or inDW) then
        do;
            call Sub546F;
            goto loop;
        end;
    end;

    call PrintErrorLineChain;
end;

AsmComplete: procedure public;
    if errCnt > 0 then
        call Itoa(errCnt, .aNoErrors);
    call PrintNStr((errCnt = 1) + 32, .aAssemblyComple);
    if errCnt > 0 then
    do;
        call move(4, .lastErrorLine, .space5RP);
        call PrintNStr(8, .spaceLP);
    end;
    call Outch(CR);
    call Outch(LF);
end;

FinishPrint: procedure public;
    if ctlPRINT then
        call CloseF(outfd);
    outfd = 0;
    pageLineCnt = 1;
    call AsmComplete;
    call Flushout;
end;

FinishAssembly: procedure public;
    declare drive based effectiveAddr byte;

    call CloseF(infd);
$IF MACRO
    call CloseF(macrofd);
    call Delete(.asmax$ref, .statusIO);
    if ctlOBJECT then	/* ?? why only for MACRO version */
        call CloseF(objfd);
$ENDIF
    if ctlXREF then	/* invoke asxref ?? */
    do;
        effectiveAddr = Physmem - 1;
        drive = '0';	/* put drive in a known location */
        if asxref$tmp(0) = ':' then
            drive = asxref$tmp(2);
    
        call Load(.asxref, 0, 1, 0, .statusIO);
        call IoErrChk;
    end;

    call Exit;
end;
end;
src/init.plx
$IF MACRO
initm: do;
$include(:f3:initm.ipx)
$ELSEIF BIG
initb: do;
$include(:f3:initb.ipx)
$ELSE
inits: do;
$include(:f3:inits.ipx)
$ENDIF

declare aExtents(*) byte public initial(' LSTOBJ'),
    aDebug(*) byte public initial('DEBUG');


CmdSkipWhite: procedure public;
    declare cmdch based cmdch$p byte;
    
    do while (cmdch = ' ' or cmdch = TAB) and cmdch$p <> actRead;
        cmdch$p = cmdch$p + 1;
    end;
end;

GetDrive: procedure byte public;
    declare cmdch based cmdch$p byte;

    if cmdch = ':' then
    do;
        cmdch$p = cmdch$p + 2;
        return cmdch;
    end;
    else
        do ii = 0 to 4;        /* case insensitive compare to DEBUG */
        if cmdch <> aDebug(ii) and aDebug(ii) + 20h <> cmdch then
                return '0';    /* must be a file name so drive 0 */
            cmdch$p = cmdch$p + 1;
        end;
    call CmdSkipWhite;
    if cmdch <> ':' then
        return '0';
    cmdch$p = cmdch$p + 2;
    return cmdch;
end;

AddExtents: procedure public;
    do ii = 1 to 3;
        lstFile(kk + ii) = aExtents(ii);
        objFile(kk + ii) = aExtents(ii+3);
    end;
end;


/* inits usage include overlay file initiatisation */

GetAsmFile: procedure public;
    declare cmdch based cmdch$p byte;

    CmdIsWhite: procedure byte;
        declare cmdch based cmdch$p byte;
        return cmdch = ' ' or cmdch = TAB or cmdch = CR;
    end;

$IF MACRO
    symTab(TID$KEYWORD) = .extKeywords;    /* extended key words */
$ELSE
    symTab(TID$KEYWORD) = .stdKeywords;    /* no extended key words */
$ENDIF
    symHighMark, endSymTab(TID$KEYWORD), symTab(TID$SYMBOL), endSymTab(TID$SYMBOL) =
$IF NOT SMALL
                         .MEMORY;
$ELSE
                         .EDATA;
$ENDIF
    call Rescan(1, .statusIO);    /* get the command line */
    call IoErrChk;
    call Read(1, .cmdLineBuf, 128, .actRead, .statusIO);
    call IoErrChk;
    actRead = actRead + .cmdLineBuf;    /* convert to pointer */
    scanCmdLine = TRUE;        /* scanning command line */
$IF SMALL
    call Write(0, .signonMsg, 29h, .statusIO);
    call Write(0, .signonMsg, 2, .statusIO);
    call IoErrChk;
$ENDIF
    call CmdSkipWhite;
$IF SMALL
    ovlFile(2),
$ENDIF
    asxref(2) = GetDrive;     /* tem defaults to current drive */

    do while not CmdIsWhite;
        cmdch$p = cmdch$p + 1;
    end;

    call CmdSkipWhite;
    if cmdch = CR then        /* no name !! */
        call RuntimeError(4);

    infd = InOpen(cmdch$p, 1);    /* Open file for reading */
    rootfd, srcfd = infd;
    ii = TRUE;
    kk = 0;

    do while not CmdIsWhite;    /* copy file name over to the files list */
        files(0).name(kk) = cmdch;
        if ii then        /* and the name for the lst and obj files */
            lstFile(kk), objFile(kk) = cmdch;
        if cmdch = '.' then
        do;
            ii = FALSE;
            call AddExtents;    /* add lst and obj file extents */
        end;
        kk = kk + 1;
        cmdch$p = cmdch$p + 1;
    end;
    controls$p = cmdch$p;        /* controls start after file name */
    if ii then            /* no extent in source file */
    do;
        lstFile(kk) = '.';    /* add the . and the extents */
        objFile(kk) = '.';
        call AddExtents;
    end;

    files(0).name(kk) = ' ';    /* override current drive for tmp if explict in source file */
    if lstFile(0) = ':' and lstFile(2) <> '0' then
$IF MACRO
        asmax$ref(2),
$ENDIF
        asxref$tmp(2) = lstFile(2);
end;


ResetData: procedure public;    /* extended initialisation */

    call InitLine;

    b6B33, scanCmdLine, skipIf(0), b6B2C, inElse(0), finished, segHasData(0), segHasData(1), inComment,
$IF MACRO
    expandingMacro, b905C, b905E,
$ENDIF
    hasVarRef, needToOpenFile = bZERO;
    noOpsYet, primaryValid, ctlLIST, ctlLISTChanged,
$IF MACRO
    ctlGEN,
$ENDIF
    ctlCOND = bTRUE;
$IF MACRO
    macroDepth, b9064, macroCondStk(0), macroCondSP, 
$ENDIF
    saveIdx, lookAhead, activeSeg, ifDepth, opSP, opStack(0) = bZERO;
$IF MACRO
    macroBlkCnt,
$ENDIF
    segSize(SEG$ABS), segSize(SEG$CODE), segSize(SEG$DATA),
    maxSegSize(SEG$ABS), maxSegSize(SEG$CODE), maxSegSize(SEG$DATA), effectiveAddr,
$IF MACRO
    w919B,
$ENDIF
    externId, errCnt = wZERO;
    passCnt = passCnt + 1;
    srcLineCnt, newOp, pageCnt, pageLineCnt = 1;
    b68AE = FALSE;
    curChar = ' ';
    do ii = 0 to 11;        /* reset all the control seen flags */
        controlSeen(ii) = 0;
    end;
$IF MACRO
    curMacroBlk = 0FFFFh;
$ENDIF
    if not IsPhase1 then    /* close any Open include file */
    do;
        if fileIdx <> 0 then
        do;
            call CloseF(srcfd);
            call IoErrChk;
            srcfd = rootfd;
        end;

        fileIdx = bZERO;    /* reset files for another pass */
        endInBuf$p = .inBuf;
        inCh$p = endInBuf$p - 1;
        startLine$p = .inBuf;
        call Seek(infd, SEEKABS, .azero, .azero, .statusIO);    /* rewind */
        call IoErrChk;
    end;

    baseMacroTbl = Physmem + 0BFh;
    endOutBuf = .b6A00;
end;

InitRecTypes: procedure public;
    r$content.type = OMF$CONTENT;
    r$content.len = 3;
    r$publics.type = OMF$RELOC;
    r$publics.len = 1;
    r$interseg.type = OMF$INTERSEG;
    r$interseg.len = 2;
    r$extref.type = OMF$EXTREF;
    r$extref.len = 1;
end;
end;
src/keym.plm
keym: do;
$include(:f3:keym.ipx)

declare copyright(*) byte data('(C) 1976,1977,1979,1980 INTEL CORP');
declare extKeywords(151) KEYWORD$T public initial(
/*
    4 byte packed keyword
    byte opcode base
    byte offset to next entry or 0 if end
    byte type
    byte flags
*/
    /* token		opBase	offset	type		flags */
    0A528h,	0,	0,	0,	K$NE,		0,	/* NE */
    63B0h,	0,	0CCh,	0,	K$IMM16,	0,	/* CZ */
    6E60h,	9C40h,	0,	0,	K$ENDM,		0,	/* ENDM */
    0BFB6h,	0,	0C0h,	0,	K$SINGLE,	0,	/* RNZ */
    0B354h,	0,	0C1h,	0,	K$REG16,	0,	/* POP */
    6EE9h,	0,	0,	0,	K$EQU,		0,	/* EQU */
    0C6CDh,	0,	32h,	80h,	K$IMM16,	0,	/* STA */
    0A1A5h,	0,	6,	80h,	K$MVI,		0,	/* MVI */
    0C6CFh,	0,	37h,	0,	K$SINGLE,	0,	/* STC */
    0C6CDh,	6158h,	0,	0,	K$SPECIAL,	1Bh,	/* STACK */
    6615h,	0,	27h,	0,	K$SINGLE,	0,	/* DAA */
    988Dh,	0E100h,	0Ah,	0,	K$LDSTAX,	0,	/* LDAX */
    61F6h,	0,	0C4h,	0,	K$IMM16,	0,	/* CNZ */
    53CFh,	0,	88h,	88h,	K$ARITH,	0,	/* ADC */
    53D0h,	0,	80h,	0,	K$ARITH,	0,	/* ADD */
    8D9Fh,	0,	0D2h,	0A0h,	K$IMM16,	0,	/* JNC */
    0,	0,	0,	0,	0,		0,	/*  */
    0,	0,	0,	0,	0,		0,	/*  */
    0,	0,	0,	0,	0,		0,	/*  */
    6E60h,	0,	0,	88h,	K$END,		0,	/* END */
    6A40h,	0,	3,	0A0h,	K$REGNAME,	0,	/* E */
    0,	0,	0,	0,	0,		0,	/*  */
    0AD70h,	0,	0,	0,	K$OR,		0,	/* OR */
    0AE08h,	0,	0D3h,	0,	K$IMM8,		0,	/* OUT */
    0A088h,	0,	0,	0,	K$MOD,		0,	/* MOD */
    0AD83h,	0,	0,	0,	K$ORG,		0,	/* ORG */
    0,	0,	0,	0,	0,		0,	/*  */
    8F70h,	0,	0CAh,	70h,	K$IMM16,	0,	/* JZ */
    68E9h,	76C0h,	0,	0,	K$DSEG,		0,	/* DSEG */
    0C488h,	0,	0,	0,	K$SET,		0,	/* SET */
    8BD8h,	0,	0DAh,	10h,	K$IMM16,	0,	/* JC */
    0C521h,	0,	30h,	0,	K$SINGLE,	2,	/* SIM */
    6618h,	0,	9,	8,	K$REG16,	0,	/* DAD */
    0B16Ch,	9600h,	0E9h,	0,	K$SINGLE,	0,	/* PCHL */
    0A4A1h,	6A40h,	0,	0,	K$NAME,		0,	/* NAME */
    6748h,	0,	0F3h,	0,	K$SINGLE,	0,	/* DI */
    53D5h,	0,	0C6h,	18h,	K$IMM8,		0,	/* ADI */
    6630h,	0,	0,	0,	K$DB,		0,	/* DB */
    8DB6h,	0,	0C2h,	0,	K$IMM16,	0,	/* JNZ */
    0AD7Dh,	0,	0B0h,	0,	K$ARITH,	0,	/* ORA */
    0B3FBh,	0,	6,	0,	K$REGNAME,	0,	/* PSW */
    0AD85h,	0,	0F6h,	0,	K$IMM8,		0,	/* ORI */
    0A09Ah,	0,	40h,	0B8h,	K$MOV,		0,	/* MOV */
    8610h,	0,	0,	0B8h,	K$IF,		0,	/* IF */
    0,	0,	0,	0,	0,		0,	/*  */
    9938h,	6400h,	2Ah,	0B0h,	K$IMM16,	0,	/* LHLD */
    9600h,	0,	5,	0B0h,	K$REGNAME,	0,	/* L */
    0C6F6h,	0,	90h,	0,	K$ARITH,	0,	/* SUB */
    0C634h,	9600h,	0F9h,	0,	K$SINGLE,	0,	/* SPHL */
    0C405h,	0,	0DEh,	0,	K$IMM8,		0,	/* SBI */
    0,	0,	0,	0,	0,		0,	/*  */
    0BF4Fh,	0,	7,	0,	K$SINGLE,	0,	/* RLC */
    5780h,	0,	0,	0,	K$REGNAME,	0,	/* B */
    0,	0,	0,	0,	0,		0,	/*  */
    0E614h,	9600h,	0E3h,	0E8h,	K$SINGLE,	0,	/* XTHL */
    0,	0,	0,	0,	0,		0,	/*  */
    0,	0,	0,	0,	0,		0,	/*  */
    0B11Bh,	6A40h,	2,	0,	K$SPECIAL,	0,	/* PAGE */
    0,	0,	0,	0,	0,		0,	/*  */
    0,	0,	0,	0,	0,		0,	/*  */
    0A7C0h,	0,	0,	0D8h,	K$NUL,		0,	/* NUL */
    8750h,	0,	0DBh,	0,	K$IMM8,		0,	/* IN */
    6E60h,	8610h,	0,	0D0h,	K$ENDIF,	0,	/* ENDIF */
    0,	0,	0,	0,	0,		0,	/*  */
    0,	0,	0,	0,	0,		0,	/*  */
    0C3FEh,	0,	98h,	0,	K$ARITH,	0,	/* SBB */
    0C6D7h,	9A10h,	0,	0,	K$STKLN,	0,	/* STKLN */
    0BFE0h,	0,	0F0h,	0,	K$SINGLE,	0,	/* RP */
    0C078h,	0,	0C7h,	0,	K$RST,		0,	/* RST */
    0C4F8h,	6400h,	22h,	0,	K$IMM16,	0,	/* SHLD */
    9E57h,	0BFB8h,	0,	0,	K$MACRO,	0,	/* MACRO */
    6231h,	0,	0ECh,	0,	K$IMM16,	0,	/* CPE */
    0B436h,	9957h,	0,	0A8h,	K$PUBLIC,	0,	/* PUBLIC */
    0BDA0h,	0,	17h,	0A8h,	K$SINGLE,	0,	/* RAL */
    6FF5h,	0CBE8h,	0,	0D8h,	K$EXITM,	0,	/* EXITM */
    6235h,	0,	0FEh,	0,	K$IMM8,		0,	/* CPI */
    0BF68h,	0,	0F8h,	0,	K$SINGLE,	0,	/* RM */
    0,	0,	0,	0,	0,		0,	/*  */
    0,	0,	0,	0,	0,		0,	/*  */
    0BDA6h,	0,	1Fh,	0,	K$SINGLE,	0,	/* RAR */
    805Bh,	7D00h,	0,	0B8h,	K$HIGH,		0,	/* HIGH */
    6400h,	0,	2,	0C8h,	K$REGNAME,	0,	/* D */
    0B447h,	7D00h,	0C5h,	0D0h,	K$REG16,	0,	/* PUSH */
    0C6FDh,	0,	0D6h,	8,	K$IMM8,		0,	/* SUI */
    6220h,	0,	0F4h,	0,	K$IMM16,	0,	/* CP */
    61A8h,	0,	0FCh,	0,	K$IMM16,	0,	/* CM */
    0,	0,	0,	0,	0,		0,	/*  */
    5629h,	76C0h,	0,	0,	K$ASEG,		0,	/* ASEG */
    0BFF1h,	0,	0E8h,	0,	K$SINGLE,	0,	/* RPE */
    880Ch,	5DC0h,	0,	0A8h,	K$IRPC,		0,	/* IRPC */
    0BE48h,	0,	0C9h,	0,	K$SINGLE,	0,	/* RET */
    876Eh,	0,	4,	0,	K$INRDCR,	0,	/* INR */
    0BEE1h,	0,	20h,	0,	K$SINGLE,	2,	/* RIM */
    0BFFBh,	0,	0E0h,	0,	K$SINGLE,	0,	/* RPO */
    0C6CDh,	0E100h,	2,	28h,	K$LDSTAX,	0,	/* STAX */
    988Dh,	0,	3Ah,	98h,	K$IMM16,	0,	/* LDA */
    7000h,	0BF90h,	0,	0,	K$EXTRN,	0,	/* EXTRN */
    8774h,	0,	3,	90h,	K$REG16,	0,	/* INX */
    61B5h,	0,	2Fh,	90h,	K$SINGLE,	0,	/* CMA */
    876Ch,	5449h,	1,	0,	K$SPECIAL,	0,	/* INPAGE */
    9A47h,	5500h,	0,	98h,	K$LOCAL,	0,	/* LOCAL */
    0E5BDh,	0,	0A8h,	8,	K$ARITH,	0,	/* XRA */
    80E0h,	0,	76h,	0,	K$SINGLE,	0,	/* HLT */
    8DE0h,	0,	0F2h,	0,	K$IMM16,	0,	/* JP */
    9A5Bh,	0,	0,	0,	K$LOW,		0,	/* LOW */
    6D88h,	0,	0FBh,	0,	K$SINGLE,	0,	/* EI */
    623Bh,	0,	0E4h,	0,	K$IMM16,	0,	/* CPO */
    6676h,	0,	5,	68h,	K$INRDCR,	0,	/* DCR */
    0E5C5h,	0,	0EEh,	0,	K$IMM8,		0,	/* XRI */
    555Dh,	0,	0A0h,	0,	K$ARITH,	0,	/* ANA */
    62A9h,	76C0h,	0,	0,	K$CSEG,		0,	/* CSEG */
    8D68h,	0,	0FAh,	0,	K$IMM16,	0,	/* JM */
    5560h,	0,	0,	0,	K$AND,		0,	/* AND */
    5140h,	0,	7,	58h,	K$REGNAME,	0,	/* A */
    0BE44h,	0C800h,	0,	0,	K$REPT,		0,	/* REPT */
    8DF1h,	0,	0EAh,	0,	K$IMM16,	0,	/* JPE */
    880Ch,	0,	0,	0,	K$IRP,		0,	/* IRP */
    5565h,	0,	0E6h,	0,	K$IMM8,		0,	/* ANI */
    9B00h,	0,	0,	0,	K$LT,		0,	/* LT */
    61B7h,	0,	3Fh,	0,	K$SINGLE,	0,	/* CMC */
    8DFBh,	0,	0E2h,	0,	K$IMM16,	0,	/* JPO */
    7BC0h,	0,	0,	0,	K$GT,		0,	/* GT */
    6978h,	0,	0,	78h,	K$DW,		0,	/* DW */
    6EC8h,	0,	0,	0,	K$EQ,		0,	/* EQ */
    68D8h,	0,	0,	48h,	K$DS,		0,	/* DS */
    7968h,	0,	0,	0A0h,	K$GE,		0,	/* GE */
    0A6D4h,	0,	0,	0,	K$SINGLE,	0,	/* NOP */
    9F01h,	0AD95h,	0,	0,	K$SPECIAL,	1Ch,	/* MEMORY */
    5FE0h,	9600h,	0CDh,	0,	K$IMM16,	0,	/* CALL */
    0BDD8h,	0,	0D8h,	0,	K$SINGLE,	0,	/* RC */
    53ADh,	0,	0CEh,	80h,	K$IMM8,		0,	/* ACI */
    0BF9Fh,	0,	0D0h,	0,	K$SINGLE,	0,	/* RNC */
    0E36Ch,	76C0h,	0EBh,	0,	K$SINGLE,	0,	/* XCHG */
    61C4h,	0,	0B8h,	8,	K$ARITH,	0,	/* CMP */
    667Ch,	0,	0BH,	0,	K$REG16,	0,	/* DCX */
    0C620h,	0,	6,	0,	K$SP,		0,	/* SP */
    9C40h,	0,	6,	0,	K$REGNAME,	0,	/* M */
    98A8h,	0,	0,	38h,	K$LE,		0,	/* LE */
    6018h,	0,	0DCh,	0,	K$IMM16,	0,	/* CC */
    7D00h,	0,	4,	50h,	K$REGNAME,	0,	/* H */
    0C03Fh,	0,	0Fh,	50h,	K$SINGLE,	0,	/* RRC */
    0C4F8h,	0,	0,	0,	K$SHL,		0,	/* SHL */
    5DC0h,	0,	1,	0,	K$REGNAME,	0,	/* C */
    0C170h,	0,	0C8h,	0,	K$SINGLE,	0,	/* RZ */
    0E556h,	0,	0,	0,	K$XOR,		0,	/* XOR */
    6E1Fh,	6A40h,	0,	0,	K$ELSE,		0,	/* ELSE */
    0A6D8h,	0,	0,	0,	K$NOT,		0,	/* NOT */
    0C4FEh,	0,	0,	0,	K$SHR,		0,	/* SHR */
    9BB5h,	0,	1,	0,	K$LXI,		0,	/* LXI */
    8D84h,	0,	0C3h,	0,	K$IMM16,	0,	/* JMP */
    61DFh,	0,	0D4h,	0,	K$IMM16,	0	/* CNC */
);


end;
src/pcktok.asm
    public PckTok
    public Isis
    extrn toksiz
    extrn tokst;

    aseg
Isis    equ    40h    ; definition of Isis entry, here to avoid another asm file

; pckTkn - packs the token pointed by tokst, with length toksiz into 4 bytes
; packed version replaces original and toksize set to 4 bytes

    CSEG
PckTok: lhld    tokst    ; pointer to the token to pack
    xchg
    lxi    h, toksiz
    mov    c, m    ; unpacked length
    mvi    m, 4    ; new packed length is 4 bytes
    call pack3    ; pack 3 chars into hl
    push    h
    call pack3
    pop    b
    xchg        ; put the packed data into the first 4 bytes
    dcx    h
    dcx    h
    dcx    h
    mov    m, d
    dcx    h
    mov    m, e
    dcx    h
    mov    m, b
    dcx    h
    mov    m, c
    ret
pack3:
    lxi    h, 0    ; get 3 chars packed into 2 bytes
    mvi    b, 3

L6291:
    push    d    ; pointer to next char
    mov    d, h    ; hl x 40
    mov    e, l
    dad    h
    dad    h
    dad    d
    dad    h
    dad    h
    dad    h
    pop    d    
    call pack1    ; add in next char
    add    l
    mov    l, a
    mvi    a, 0
    adc    h
    mov    h, a
    dcr    b    ; get the 3 chars
    jnz    L6291
    ret

pack1:    ldax    d        ; pick up next character
    inx    d        ; advance for next time
    dcr    c        ; check it is valid
    jm    L62B7
    sui    2Fh        ; /012345678  (0-9)
                ; 9?@ABCDEFG  (10-19)
                ; HIJKLMNOPQ  (20-29)
                ; RSTUVWXYZ[  (30-39)
    cpi    10h        ; digit so return
    rc
    sui    5        ; exclude : ; < = >
    ret

L62B7:
    sub    a        ; 0 no char
    ret

    end
src/cprite.asm
    cseg
cprite:
    db '(C) 1976,1977,1979,1980 INTEL CORP'
    end
src/edata.asm
    public EDATA
    DSEG
EDATA    equ    $
    end

src/asxref.plm
asxref: do;

declare    CR literally '0Dh',
    LF literally '0Ah',
    FF literally '0Ch',
    TRUE literally '0ffh',
    FALSE literally '0',
    bool literally 'byte',
    READONLY literally '1',        /* Open mode */
    WRITEONLY literally '2',
    READWRITE literally '3',
    SEEKEND literally '4',        /* seek mode */
    TYPEREF literally '1',    /* tmp file types */
    TYPEDEF literally '0',
    TYPEFILE literally '2',
    TYPEEOF literally '3';

declare cpyrite(*) byte data('(C) 1976, 1977,1979 INTEL CORP', 2, 1);
declare xrefComplete(*) byte data('CROSS REFERENCE COMPLETE');
declare headerMsg(*) byte data(CR, LF,
        'ISIS-II ASSEMBLER SYMBOL CROSS REFERENCE, V2.1                     PAGE ');
declare inputError(*) byte data('INPUT FILE FORMAT ERROR');
declare noMemory(*) byte data('NOT ENOUGH MEMORY');
declare isis address data(40h);
declare maxMem address at(4);

declare errStrs(*) byte data(
        0, 0,
        2, 'ILLEGAL AFTN ARGUMENT', 0,
        4, 'INCORRECTLY SPECIFIED FILE', 0,
        5, 'UNRECOGNIZED DEVICE NAME', 0,
        6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
        8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
        0Ah, 'NOT ON SAME DISK', 0,
        0Bh, 'FILE ALREADY EXISTS', 0,
        0Ch, 'FILE IS ALREADY OPEN', 0,
        0Dh, 'NO SUCH FILE', 0,
        0Eh, 'WRITE PROTECTED', 0,
        11h, 'NOT A DISK FILE', 0,
        12h, 'ILLEGAL ISIS COMMAND', 0,
        13h, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
        14h, 'ATTEMPTED BACK SEEK TOO FAR', 0,
        15h, 'CAN''T RESCAN', 0,
        16h, 'ILLEGAL ACCESS MODE TO OPEN', 0,
        17h, 'MISSING FILENAME', 0,
        19h, 'ILLEGAL ECHO FILE', 0,
        1Ah, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
        1Bh, 'ILLEGAL SEEK COMMAND', 0,
        1Ch, 'MISSING EXTENSION', 0,
        1Fh, 'CAN''T SEEK ON WRITE ONLY FILE', 0,
        20h, 'CAN''T DELETE OPEN FILE', 0,
        23h, 'SEEK PAST EOF', 0,
        0C9h, 'UNRECOGNIZED SWITCH', 0,
        0CAh, 'UNRECOGNIZED DELIMITER', 0,
        0CBh, 'INVALID SYNTAX', 0,
        0CCh, 'PREMATURE EOF', 0,
        0CEh, 'ILLEGAL DISKETTE LABEL', 0,
        0D0h, 'CHECKSUM ERROR', 0,
        0D1h, 'RELO FILE SEQUENCE ERROR', 0,
        0D2h, 'INSUFFICIENT MEMORY', 0,
        0D3h, 'RECORD TOO LONG', 0,
        0D4h, 'ILLEGAL RELO RECORD', 0,
        0D5h, 'FIXUP BOUNDS ERROR', 0,
        0D6h, 'ILLEGAL SUBMIT PARAMETER', 0,
        0D7h, 'ARGUMENT TOO LONG', 0,
        0D8h, 'TOO MANY PARAMETERS', 0,
        0D9h, 'OBJECT RECORD TOO SHORT', 0,
        0DAh, 'ILLEGAL RECORD FORMAT', 0,
        0DBh, 'PHASE ERROR', 0);





declare    
    topLowHeap address,
    startMarker address,
    tmpAFTN address,
    topHighHeap address, drive based topHighHeap byte,
    conn$p address,
    itemCount address,
    botHighHeap address,
    status address,
    outputLine(256) byte,
    col byte,
    path(15) byte,
    row byte,
    pageLength byte,
    pageWidth byte,
    recordType byte,
    haveFileInfo bool,
    paging bool,
    aF0AsxrefTmp(*) byte initial(':F0:ASXREF.TMP ');


declare    ISIS$OPEN    literally    '0',
    ISIS$CLOSE    literally    '1',
    ISIS$DELETE    literally    '2',
    ISIS$READ    literally    '3',
    ISIS$WRITE    literally    '4',
    ISIS$SEEK    literally    '5',
    ISIS$EXIT    literally    '9',
    ISIS$ERROR    literally    '12';

Open: procedure (conn$p, path, access, echo, status$p);
    declare (conn$p, path, access, echo, status$p) address;
    call isis(ISIS$OPEN, .conn$p);
end Open;

Read: procedure (conn, buff$p, count, actual$p, status$p);
    declare (conn, buff$p, count, actual$p, status$p) address;
    call isis(ISIS$READ, .conn);
end Read;

Seek: procedure (conn, mode, block$p, byte$p, status$p);
    declare (conn, mode, block$p, byte$p, status$p) address;
    call isis(ISIS$SEEK, .conn);
end Seek;

Write: procedure (conn, buff$p, count, status$p);
    declare (conn, buff$p, count, status$p) address;
    call isis(ISIS$WRITE, .conn);
end Write;

Close: procedure (conn, status$p);
    declare (conn, status$p) address;
    call isis(ISIS$CLOSE, .conn);
end Close;

Error: procedure (error$num);
    declare (error$num, status$p) address;
    status$p = .status$p;
    call isis(ISIS$ERROR, .error$num);
end Error;

Exit: procedure;
    declare status$p address;
    status$p = .status$p;
    call isis(ISIS$EXIT, .status$p);
end Exit;

Delete: procedure (path, status$p);
    declare (path, status$p) address;
    call isis(ISIS$DELETE, .path);
end Delete;

AvailMem: procedure address;
    return (maxMem - 100h) and 0ff00h;
end;


ReportError: procedure(scode);
    declare scode address;
    declare unknown(3) byte;
    declare i address, wstatus address;

    if scode <> 0 then
    do;
        i = 0;
        do while i < 38Fh;
            if scode = errStrs(i) and errStrs(i + 1) <> 0 then
            do;
                i = i + 1;
                call Write(0, .(' '), 1, .wstatus);    
                do while errStrs(i) <> 0;
                    call Write(0, .errStrs(i), 1, .wstatus);
                    i = i + 1;
                end;
                call Write(0, .(CR, LF), 2, .wstatus);
                return;
            end;
            else
            do;
                do while errStrs(i) <> 0;
                    i = i + 1;
                end;
                i = i + 1;
            end;
        end;
        call Error(scode);
    end;
end;

StatusChk: procedure(scode);
    declare scode address;

    if scode <> 0 then
    do;
        call ReportError(scode);
        call Close(tmpAFTN, .status);
        call Close(conn$p, .status);
        call Exit;
    end;
end;

OpenTmp: procedure;
    declare tstatus byte;    /* benign bug should be address but next data byte is dummy */

    call Open(.tmpAFTN, .aF0AsxrefTmp, READONLY, 0, .tstatus);
    call StatusChk(tstatus);    
end;


OpenListFile: procedure;
    declare dummy byte;

    if path(0) = ':' and (path(1) and 0dfh) <> 'F' then    /* test as UCase */
        call Open(.conn$p, .path, WRITEONLY, 0, .status);    /* device */
    else
        call Open(.conn$p, .path, READWRITE, 0, .status);    /* file */

    call StatusChk(status);
    call Seek(conn$p, SEEKEND, .dummy, .dummy, .status);    /* seek end */
    if status = 13h then    /* bad seek on non file is ok */
        return;
    call StatusChk(status);
end;

ReadTmp: procedure(buf, cnt) bool;
    declare buf address, cnt byte;
    declare actual address;

    call Read(tmpAFTN, buf, cnt, .actual, .status);
    call StatusChk(status);
    return actual = cnt;
end;


WriteStr: procedure(str, len);
    declare str address, len byte;
    call Write(conn$p, str, len, .status);
    call StatusChk(status);
end;

WriteCRLF: procedure;
    call WriteStr(.(CR, LF), 2);
end;


ToNextPage: procedure;
    call WriteStr(.(FF), 1);
    call WriteCRLF;
    call WriteCRLF;
    call WriteCRLF;
end;


OutStrCRLF: procedure(str, len);
    declare str address, len byte;
    call Write(0, str, len, .status);
    call Write(0, .(CR, LF), 2, .status);
end;


FatalError: procedure(err);
    declare err byte;

    if err = 0 then
        call OutStrCRLF(.inputError, 23);
    else
        call OutStrCRLF(.noMemory, 17);
    call Close(tmpAFTN, .status);
    call Exit;
end;


AllocLineRef: procedure address;
    topLowHeap = topLowHeap + 4;
    if  topLowHeap <= botHighHeap then
        return topLowHeap - 4;
    call FatalError(1);
end;

AllocXref: procedure address;
    botHighHeap = botHighHeap - 8;
    if botHighHeap >= topLowHeap then
        return botHighHeap + 1;
    call FatalError(1);
end;

FirstXref: procedure address;
    return (topHighHeap - 8) + 1;
end;


TestMoreXrefs: procedure(arg1w) byte;
    declare arg1w address;

    return arg1w > botHighHeap;
end;

NextXref: procedure(arg1w) address;
    declare arg1w address;
    return (arg1w - 8);
end;

CmpXrefNames: procedure(pstr1, pstr2) bool;
    declare (pstr1, pstr2) address;
    declare str1 based pstr1 (6) byte,
        str2 based pstr2 (6) byte;
    declare i byte;

    do i = 0 to 5;
        if str1(i) <> str2(i) then
            return FALSE;
    end;
    return TRUE;
end;
        
FindXref: procedure(pXref, pFound) address;
    declare (pXref, pFound) address;
    declare found based pFound bool;
    declare (pNewXref, pTestXref) address,
        i byte;
    declare item based pXref (8) byte,
        newXref based pNewXref (8) byte;

    found = FALSE;
    pTestXref = FirstXref;
    do while not found and TestMoreXrefs(pTestXref);
        if CmpXrefNames(pXref, pTestXref) then
            found = TRUE;
        else
            pTestXref = nextXref(pTestXref);
    end;

    if found then
        return pTestXref;
    else
    do;
        pNewXref = AllocXref;
        do i = 0 to 5;
            newXref(i) = item(i);
        end;
        itemCount = itemCount + 1;
        return pNewXref;
    end;
end;


InsertXref: procedure(isDef, pInRef, lineNum);
    declare isDef byte, (pInRef, lineNum) address,
        (pHeadLineRef, pPtr, pLineRef, qPtr, pXref) address,
        found byte;
    declare lineNumRef based pLineRef structure(lineNum address, next address),
        q based    qPtr address, p based pPtr address,
        headLineRef based pHeadLineRef address;

    pXref = FindXref(pInRef, .found);
    pHeadLineRef = pXref + 6;
    pLineRef = AllocLineRef;
    if isDef then
        lineNum = lineNum or 8000h;
    lineNumRef.lineNum = lineNum;
    qPtr = .lineNumRef.next;
    if found then
    do;
        pPtr = headLineRef + 2;
        q = p;
        p = pLineRef;
    end;
    else
        q = pLineRef;

    headLineRef = pLineRef;
end;

GetPLineRef: procedure(from, ptr, pMoreLineRefs) address;
    declare from byte, (ptr, pMoreLineRefs) address;
    declare (ppHead, pNext) address;
    declare pHead based ppHead address;
    declare next based pNext address;
    declare moreLineRefs based pMoreLineRefs bool;

    if from = 0 then    /* ptr -> Xref */
    do;
        ppHead = ptr + 6;
        pNext = pHead + 2;
        moreLineRefs = TRUE;
        return startMarker := next;
    end;
    else
    do;            /* ptr -> LineRef */
        pNext = ptr + 2;
        moreLineRefs = startMarker <> next;
        return next;
    end;
end;

GetLineNum: procedure(pLineRef, pIsDef) address;
    declare (pLineRef, pIsDef) address;
    declare isDef based pIsDef byte;
    declare lineNum based pLineRef address;

    isDef = ROL(high(lineNum), 1);
    return 7fffh and lineNum;
end;


CopyXref: procedure(pStr1, pStr2);
    declare (pStr1, pStr2) address;
    declare str1 based pStr1 (8) byte,
        str2 based pStr2 (8) byte;
    declare i byte;

    do i = 0 to 7;
        str2(i) = str1(i);    
    end;
end;


GetPXref: procedure(n) address;    /* get address of Xref(n) */
    declare n address;
    return topHighHeap - n * 8 + 1;
end;


GetTmpRecord: procedure byte;
    if not ReadTmp(.outputLine, 1) then
        return 3;
    if outputLine(0) = '0' or outputLine(0) = '1' then
    do;
        if not ReadTmp(.outputLine(1), 10) then
            call FatalError(0);
    end;
    else if outputLine(0) = '2' then
    do;
        if not ReadTmp(.outputLine(1), 20) then
            call FatalError(0);
    end;
    else
    do;
         if outputLine(0) = '3' then
            return TYPEEOF;
         call FatalError(0);
    end;
    return outputLine(0) - '0';
end;


Htoi: procedure(buf, n) address;
    declare buf address, n byte;
    declare (val, pCh) address;
    declare ch based pCh byte;

    val = 0;

    do pCh = buf to  buf + n - 1;
        if ch <= '9' then
            val = val * 16 + (ch - '0');
        else
            val = val * 16 + (ch - ('A' - 10));
    end;
    return val;
end;


GetPSymbol: procedure address;
    return .outputLine(1);
end;

GetLineNumber: procedure address;
    return Htoi(.outputLine(7), 4);
end;

ProcXrefRecord: procedure(isDef);
    declare isDef byte;
    call InsertXref(isDef, GetPSymbol, GetLineNumber);
end;

CopyFileName: procedure;
    declare (i, j) byte;

    j = 0;
    do i = 0 to 14;
        path(i) = outputLine(j := j + 1);
    end;
end;



ProcFileRecord: procedure;
    call CopyFileName;
    paging = outputLine(16);
    pageLength = htoi(.outputLine(17), 2);
    pageWidth = htoi(.outputLine(19), 2);
    haveFileInfo = TRUE;
end;

SortXrefs: procedure;
    declare (i, j, k, m, n) address,
        tmpXref(8) byte;

    IsLessThan: procedure byte;
        declare pstr address, i byte;
        declare str based pstr (6) byte;

        pstr = GetPXref(m);
        do i = 0 to 5;
            if tmpXref(i) <> str(i) then
                return tmpXref(i) < str(i);
        end;
        return 0;
    end;

    i, j, k = 1;

    do while k < itemCount;
        i = j;
        j = k;
        k = k * 3 + 1;
    end;

    k = i;

    do while k <> 0;
        n = k + 1;
        do while n <= itemCount;
            m = n - k;
            call CopyXref(GetPXref(n), .tmpXref);
            do while m > 0 and m < 8000h and IsLessThan;
                call CopyXref(GetPXref(m), GetPXref(m + k));
                m = m - k;
            end;
            call CopyXref(.tmpXref, GetPXref(m + k));
            n = n + 1;
        end;
        k = (k - 1) / 3;
    end;
end;


Num2Ascii: procedure(val, buf, len);
    declare (val, buf) address, len byte;
    declare pc address, c based pc byte;

    pc = buf + len - 1;
    do while pc >= buf;
        c = val mod 10 + '0';
        val = val / 10;
        pc = pc - 1;
    end;    
    pc = buf;
    do while c = '0' and pc < buf + len - 1;
        c = ' ';
        pc = pc + 1;
    end;
end;

blankOutputLine: procedure;
    declare i byte;
    do i = 0 to 255;
        outputLine(i) = ' ';
    end;
end;

PageHeader: procedure(pageNum);
    declare pageNum byte, asciiPageNum(3) byte;

    call Num2Ascii(pageNum, .asciiPageNum, 3);
    call ToNextPage;
    call WriteStr(.headerMsg+2, 72);
    call WriteStr(.asciiPageNum, 3);
    call writeCRLF;
    call writeCRLF;
    row = 7;
end;



NameToOutputLine: procedure(pName);
    declare pName address, i byte;
    declare name based pName (6) byte;

    do i = 0 to 5;
        outputLine(col) = name(i);
        col = col + 1;
    end;
end;

OutputLineRef: procedure(pLineRef);
    declare pLineRef address;
    declare lineNum address, isDefinition byte;

    lineNum = GetLineNum(pLineRef, .isDefinition);
    call Num2Ascii(lineNum, .outputLine(col), 4);
    col = col + 4;
    if isDefinition then
        outputLine(col) = '#';
    col = col + 3;
end;

OutputXref: procedure;
    declare (refsPerLine, refsCnt, pageNum) byte,
        (pLineRef, pXref) address, moreLineRefs byte;

    refsPerLine = (pageWidth - 6) / 7;
    pageNum = 1;
    call PageHeader(1);
    pXref = FirstXref;
    
    do while TestMoreXrefs(pXref);
        call blankOutputLine;
        col = 0;
        call NameToOutputLine(pXref);
        pLineRef = GetPLineRef(0, pXref, .moreLineRefs);
        do while moreLineRefs;
            col = 7;
            refsCnt = 0;
            do while (refsCnt := refsCnt + 1) <= refsPerLine and moreLineRefs;
                call OutputLineRef(pLineRef);
                pLineRef = GetPLineRef(1, pLineRef, .moreLineRefs);
            end;
            call WriteStr(.outputLine, col - 1);
            call writeCRLF;
            if paging then
                if (row := row + 1) = pageLength - 2 then
                    call PageHeader(pageNum := pageNum + 1);
            if moreLineRefs then
                call blankOutputLine;
        end;
        pXref = NextXref(pXref);
    end;
end;

main:
    itemCount = 0;
    topLowHeap = .Memory;
    botHighHeap, topHighHeap = AvailMem - 1;
    if drive <> '0' then
        aF0AsxrefTmp(2) = drive;
    haveFileInfo = FALSE;
    call OpenTmp;
    call outStrCRLF(.headerMsg, 51);

    do while 1 ;
        recordType = GetTmpRecord;
        if recordType = TYPEDEF or recordType = TYPEREF then
            call ProcXrefRecord(recordType = TYPEDEF);
        else if recordType = TYPEFILE then
            call ProcFileRecord;
        else
        do;
            if not haveFileInfo then        
                call FatalError(0);
            call SortXrefs;
            call OpenListFile;
            call OutputXref;
            call WriteCRLF;
            call WriteStr(.xrefComplete, 24);
            call WriteCRLF;
            call Close(tmpAFTN, .status);
            call Close(conn$p, .status);
            call Delete(.aF0AsxrefTmp, .status);
            call Exit;
        end;
    end;
end;
makefile
# path to root of build tree
ROOT:=../..
# path to build directories
SRCDIR:=src
LSTDIR:=lst
OBJDIR:=obj

TARGETS := asm80 asm80.ov0 asm80.ov1 asm80.ov2 asm80.ov3 asm80.ov4 asm80.ov5 asxref

# build options
LOCATEOPT:=SYMBOLS LINES
PLMFOPT:=DEBUG
LINKOPT:=

include $(ROOT)/tools/isistools.mk

# set default tools disk
TOOLDSK=$(V31DSK)

all: $(TARGETS)

# base address of the overlays and keyn.abs
SMALLOVL:=6D4Ch
BIGCODE:=3780h
KEYCODE:=075A2h

PEXFILE:=$(SRCDIR)/asm80.pex

# bulk obj names
ROOTOBJS := globls.obj starts.obj asm1n.obj asm2n.obj\
	rdsrc.obj asm3s.obj asm4s.obj asm5n.obj\
	asm6n.obj pcktok.obj

MACROOBJS := globlm.obj startm.obj pcktok.obj asm1m.obj\
	asm2m.obj asm4m.obj rdsrc.obj asm3m.obj\
	asm5m.obj asm6m.obj cntrlm.obj asm8m.obj\
	emitm.obj listm.obj initm.obj

BIGOBJS := globlb.obj startb.obj pcktok.obj asm1n.obj\
	asm2n.obj asm4b.obj rdsrc.obj asm3b.obj\
	asm5n.obj asm6n.obj cntrln.obj emitn.obj\
	listn.obj initb.obj

## build rules to make the program and overlays rel files are intermediate so let make delete them
.INTERMEDIATE: $(call objdir,asm80.rel asm800.rel asm801.rel asm802.rel asm803.rel asm804.rel asm805.rel root.rel keyn.rel)

# Symbols for overlays 0,1,2 and 3 are used in the build of asm80 so the apps are created by purging the symbols

$(call objdir,asm80.rel: root.abs keyn.abs asm80.ov0 asm80.ov1 asm80.ov2 asm80.ov3)
	$(call link,$(call objdir,asm80.rel),$(call objdir,root.abs keyn.abs asm80.ov3) publics($(call objdir,asm80.ov0 asm80.ov1 asm80.ov2)))
asm80: $(call objdir,asm80.rel)
	$(call locate,$@,$<,NAME(ASM80) STACKSIZE(0) $(PURGE))

$(call objdir,asm800.rel: cprite.obj cntrln.obj root.abs)
	$(call link,$@,$(call objdir,cprite.obj cntrln.obj) publics($(call objdir,root.abs)))
$(call objdir,asm80.ov0: asm800.rel)
	$(call locate,$@,$<,NAME(A80O0) STACKSIZE(0) CODE($(SMALLOVL)))
asm80.ov0: $(OBJDIR)/asm80.ov0 ; $(call rm-symbols,$@,$<)

$(call objdir,asm801.rel: cprite.obj listn.obj root.abs)
	$(call link,$@,$(call objdir,cprite.obj listn.obj) publics($(call objdir,root.abs)) $(call tools-v31,plm80.lib))
$(call objdir,asm80.ov1: asm801.rel)
	$(call locate,$@,$<,NAME(A80O1) STACKSIZE(0) CODE($(SMALLOVL)))
asm80.ov1: $(OBJDIR)/asm80.ov1 ; $(call rm-symbols,$@,$<)
	
$(call objdir,asm802.rel: cprite.obj emitn.obj root.abs)
	$(call link,$@,$(call objdir,cprite.obj emitn.obj) publics($(call objdir,root.abs)))
$(call objdir,asm80.ov2: asm802.rel)
	$(call locate,$@,$<,NAME(A80O2) STACKSIZE(0) CODE($(SMALLOVL)))
asm80.ov2: $(OBJDIR)/asm80.ov2 ; $(call rm-symbols,$@,$<)

$(call objdir,asm803.rel: cprite.obj inits.obj root.abs keyn.abs)
	$(call link,$@,$(call objdir,cprite.obj inits.obj) publics($(call objdir,root.abs keyn.abs)))
$(call objdir,asm80.ov3: asm803.rel)
	$(call locate,$@,$<,NAME(A80O3) STACKSIZE(0) CODE($(SMALLOVL)))
asm80.ov3: $(OBJDIR)/asm80.ov3 ; $(call rm-symbols,$@,$<)

$(call objdir,asm804.rel: $(MACROOBJS) keym.obj)
	$(call link,$@,$(call objdir,$(MACROOBJS)) $(call tools-v31,system.lib plm80.lib) $(call objdir,keym.obj))
asm80.ov4: $(call objdir,asm804.rel)
	$(call locate,$@,$<,NAME(A80O4) CODE($(BIGCODE)) STACKSIZE(144) $(PURGE))

$(call objdir,asm805.rel: $(BIGOBJS) keyn.obj)
	$(call link,$@,$(call objdir,$(BIGOBJS)) $(call tools-v31,system.lib plm80.lib) $(call objdir,keyn.obj))
asm80.ov5: $(call objdir,asm805.rel)
	$(call locate,$@,$<,NAME(A80O5) CODE($(BIGCODE)) STACKSIZE(144) $(PURGE))

asxref: $(call objdir,asxref.obj)
	$(call locate,$@,$<,CODE(3680h) STACKSIZE(32) $(PURGE))

#
## rules for intermediate files
#
$(call objdir,root.rel: $(ROOTOBJS))
	$(call link-nocheck,$@,$^ $(call tools-v31,system.lib plm80.lib))
$(call objdir,root.abs: root.rel)
	$(call locate-nocheck,$@,$<,STACKSIZE(120)) 

#
$(call objdir,keyn.rel: keyn.obj edata.obj)
	$(call link-nocheck,$@,$^)
$(call objdir,keyn.abs: keyn.rel)
	$(call locate-nocheck,$@,$<,CODE($(KEYCODE)) STACKSIZE(0)) 


# these are special build rules to preprocess the plx files
$(OBJDIR)/%m.plm: %.plx
	$(PLMPP) -sMACRO -o $(call mapdisk,$@ $<)

$(OBJDIR)/%n.plm: %.plx
	$(PLMPP) -o $(call mapdisk,$@ $<)

$(OBJDIR)/%s.plm: %.plx
	$(PLMPP) -sSMALL -o $(call mapdisk,$@ $<)

$(OBJDIR)/%b.plm: %.plx
	$(PLMPP) -sBIG -o $(call mapdisk,$@ $<)
