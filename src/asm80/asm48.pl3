asm48:
do;
/*$SET(ASM48=1)*/
$include(asm48.ipx)
declare	b5666(*) byte data(9, 2Dh, 80h),
	b5669(*) byte data(3Ah, 8, 80h, 0, 0, 0, 0, 0, 20h),
	op16(*) byte data(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0,
			   0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1),
			   /* 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
	chClass(*) byte data(0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 4, 0, 0,
			      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0Bh, 0, 0, 0, 0,	/* ESC maps to 0Bh */
			      1, 0, 0, 0, 6, 0, 0, 7, 5, 5, 5, 5, 5, 5, 0, 5,
			      8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 3, 2, 0, 0, 0, 9,
			      9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
			      9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0,
			      0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
			      9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0);

unpackToken: procedure(src, dst) public;
	declare (src, dst) address;
	declare wrd based src address;
	declare ch based dst byte;
	declare packedword address;

	unpack1: procedure;
		ch = packedword mod 40;	
		if ch = 0 then
			ch = ' ';
		else if ch <= 10 then
			ch = ch + 2Fh;	/* digit */
		else 
			ch = ch + 34h;	/* ? @ and letters */
		packedword = packedword / 40;
		dst = dst - 1;
	end;


	src = src + 2;
	dst = dst + 5;
	packedword = wrd;
	call unpack1;
	call unpack1;
	call unpack1;
	src = src - 2;
	packedword = wrd;
	call unpack1;
	call unpack1;
	call unpack1;
end;


insertSym: procedure;
	declare (w$9C32, w$9C34) address;
	declare ch1 based w$9C32 byte;
	declare ch2 based w$9C34 byte;

	w686E, w$9C32 = (w$9C34 := w686E) + 8;
	if w6870 < w$9C32 then
		call runtimeError(1);	/* table error */

	do while w$9C34 > curTokenSym$p;
		w$9C32 = w$9C32 - 1;
		w$9C34 = w$9C34 - 1;
		ch1 = ch2;
	end;

	call move(4, curTokStart, curTokenSym$p);
	w6868(2) = w6868(2) + 8;
	curTokenSym.type = 0;
end;


sub$5C73: procedure(arg1b) byte;
	declare arg1b byte;

	if w6868(arg1b) >= curTokenSym$p and curTokenSym$p >= symTab(arg1b) then
		return 0;

	call syntaxError;
	return 0FFh;
end;


sub$5CAD: procedure(arg1w, arg2b) public;
	declare arg1w address, arg2b byte;

	if sub$5C73(2) then
		return;
	call insertSym;
	curTokenSym.w4 = arg1w;
	curTokenSym.type = arg2b;
	curTokenSym.flags = 0;
	call popToken;
end;

declare b$9C3A byte public;

sub$5CE8: procedure(arg1w, arg2b) public;
	declare arg1w address, arg2b byte;
	declare (b6CE8, b6CE9, b6CEA, b6CEB, b6CEC) byte;

	sub$5B9A: procedure;
		tokenType(0) = arg2b;
		if (b6858 = 7 or b6858 = 8) and b6CEB then
			tokenType(0) = 12 - arg2b;
	end;

	b6CEC = tokenType(0);
	b6CEB = arg2b = 5 or arg2b = 4;
	b6CE9 = 0;
	b6CE8 = curTokenSym.flags;
	b6CEA = 0;
	if sub$5C73(1) then
		return;

	if tokenSP > 1 then
		call syntaxError;

	if isPhase1 then
		if tokenType(0) = 9 then
		do;
			if b6883 then
			do;
				if curTokenSym.type >= 80h or arg2b = 3Ah and curTokenSym.w4 <> w6A4E then
				do;
					call locationError;
					b6CE9 = 80h;
				end;
			end;
			else
			do;
				call insertSym;
				w6866 = w6866 + 8;
				w6868(1) = w6868(1) + 8;
				b6CE8 = 0;
			end;

			b6CE8 = (activeSeg <> 0 and 18h) or (b6748 and 20h) or (b6749 and 58h);
			if b$9C3A = 1 then
				b6CE8 = b6855;

			if b$9C3A = 2 then
				b6CE8 = b6CE8 or activeSeg;

			if b6857 and b6CEB then
				tokenType(0) = 64h;
			else
				call sub$5B9A;

			goto L5F82;
		end;

	if b6882 = 2 then
		if tokenType(0) = 9 then
			if b6858 <> 9 then
				if b6CEB then
				do;
					call sub$5B9A;
					if curTokenSym.type < 128 then
					do;
						curTokenSym.type = tokenType(0);
						curTokenSym.w4 = arg1w;
						b6CE8 = b6855;
						b6CEA = 0FFh;
					end;
					goto L5F82;
				end;

	if isPhase1 then
		if tokenType(0) = 6 then
			if testBit(arg2b, .b5666) then
			do;
				if b6749 then
					tokenType(0) = 3;
				else
				do;
					tokenType(0) = arg2b;
					b6CE8 = b6CE8 and 0E0h;
					if b$9C3A = 1 then
						b6CE8 = b6855 or 20h;

					if b$9C3A = 2 then
						if activeSeg <> 0 then
							b6CE8 = b6CE8 or activeSeg or 38h;
				end;
				goto L5F82;
			end;

	if isPhase1 then
		if arg2b = 6 then
			if testBit(tokenType(0), .b5666) then
			do;
				if (b6CE8 and 60h) <> 0 then
					tokenType(0) = 3;
				else
					b6CE8 = b6CE8 or 20h;
				goto L5F82;
			end;

	if isPhase1 then
		if tokenType(0) <> arg2b and tokenType(0) <> 8 or arg2b = 5 then
			tokenType(0) = 3;

	if not b6748 and testBit(tokenType(0), .b5669) then
		b6CE8 = (b6CE8 and 20h) and tokenType(0) <> 3Ah or b6855;
	else
	do;
		if isPhase1 then
			tokenType(0) = 3;

		if not (b6748 or b6749) then
			if curTokenSym.w4 <> arg1w then
				call phaseError;
	end;

L5F82:
	b6CE9 = b6CE9 or (curTokenSym.type and 80h);

	if isPhase1 and (arg2b = 9 or arg2b = 6 or b6CEC <> tokenType(0)) then
		curTokenSym.type = tokenType(0) or b6CE9;

	jj = curTokenSym.type;
	if tokenType(0) = 3 or jj = 3 then
		call multipleDefError;

	if jj >= 80h then
		call locationError;

	if isPhase1 and (tokenType(0) = arg2b or arg2b = 5 and tokenType(0) = 7) or arg2b = 4 and blankAsmErrCode
	   or b6CEA or arg2b = 3Ah then
		curTokenSym.w4 = arg1w;

	curTokenSym.flags = b6CE8;
	b6748 = 0;
	b6749 = 0;
	if curTokenSym.type = 6 then
		call undefinedSymbolError;

	b6857 = 0;
	if b6883 then
		call popToken;

end;



lookup: procedure(arg1b) byte public;
	declare arg1b byte;
	declare (lowOffset, highOffset, s6CF2$p, deltaToNext, entryOffset, packedTok$p) address,
		(i, b6CFB) byte;
	declare symEntry based entryOffset structure(tok(2) address, b4 byte, delta byte, type byte, flags byte),
		packedTok based packedTok$p (2) address;
	declare wrd based w6BE0 address;

	packedTok$p = curTokStart;
	if arg1b = 0 then		/* hash chain look up key word */
	do;
		entryOffset = 0;
		deltaToNext = symTab(0) + (packedTok(0) + packedTok(1)) mod 97h * 8;

		do while deltaToNext <> 0;
			entryOffset = entryOffset + deltaToNext;
			if symEntry.tok(0) = packedTok(0) then
				if symEntry.tok(1) = packedTok(1) then
				do;
					curTokenSym$p = entryOffset;
					tokenType(0) = curTokenSym.type;
					if tokenType(0) < 2Dh then
						if op16(tokenType(0)) then
							has16bitOperand = 0FFh;
					if curTokenSym.flags = 2 and not ctlMOD85 then
						call sourceError(4Fh);

					if tokenType(0) = 8 then	/* SP */
					do;
						if not (opType = 24h or opType = 25h) then /* lxi or push/pop/dad/inx/dcx */
							call sourceError(58h);
						tokenType(0) = 7;	/* reg */
					end;
					return (tokenType(0) and 7Fh);
				end;
			deltaToNext = symEntry.delta;
		end;
		return 9;
	end;

	lowOffset = symTab(arg1b);
	highOffset, entryOffset = w6868(arg1b);

	/* binary chop search for id */

	do while (s6CF2$p := lowOffset + shr((highOffset - lowOffset) and 0FFF0h, 1)) <> entryOffset;
		entryOffset = s6CF2$p;
		if packedTok(0) = symEntry.tok(0) then
		do;
			if packedTok(1) = symEntry.tok(1) then
			do;
				curTokenSym$p = entryOffset;
				tokenType(0) = curTokenSym.type;
				if tokenType(0) = 64h then
					tokenType(0) = 9;

				if (b6884 := (jj := (tokenType(0) and 7Fh)) = 9) then
					if b6885 then
						curTokenSym.type = 89h;
				return jj;
			end;
			else
				b6CFB = symEntry.tok(1) > packedTok(1);
		end;
		else
			b6CFB = symEntry.tok(0) > packedTok(0);

		entryOffset = s6CF2$p;
		if b6CFB then
			highOffset = entryOffset;
		else
			lowOffset = entryOffset;
	end;

	curTokenSym$p = highOffset;
	if arg1b = 1 and not isSkipping then
	do;
		b6883 = 0;
		b$9C3A = 0;
		call sub$5CE8(w6A4E, (b6885 and 80h) or 9);
		w6BE0 = .tokenSym;
		do i = 1 to tokenSP;
			w6BE0 = w6BE0 + 2;
			if wrd >= curTokenSym$p then
				wrd = wrd + 8;
		end;

		b6883 = 0FFh;
	end;
	return 9;
end;



getCh: procedure byte public;
	declare (curCH, prevCH) byte;
	declare ch based tmac$buf$p byte;
	declare ch1 based off$9056 byte;

L6339:
	if not reget then
	do;
		prevCH = curCH;

	L6347:
		curCH = lookAhead;
		if b$905B then
		do;
			do while (lookAhead := ch) = 0FEh;
				call readM(curMacroBlk + 1);
				tmac$buf$p = .macroBuf;
			end;

			tmac$buf$p = tmac$buf$p + 1;
		end;
		else if scanCmdLine then
			lookAhead = nxtCmdCh;
		else
			lookAhead = sub$4879;

		if chClass(curCH) = CC$BAD then
			if curCH = 0 or curCH = 7Fh or curCH = 0Ch then
				goto L6347;

		if b$905B then
		do;
			if curCH = 1Bh then
			do;
				goto L65B2;
			end;
			else if curCH = '&' then
			do;
				if not prevCH < 80h or lookAhead = 80h then
					goto L6339;
			end;
			else if curCH = '!' and prevCH <> 0 then
			do;
				if not (b$905D or b$905E) and b$905C then
				do;
					curCH = 0;
					goto L6339;
				end;
			end;
			else if curCH >= 128 then
			do;
				if not (b$905C := not b$905C) then
					tmac$buf$p = w$9197;
				else
				do;
					w$9197 = tmac$buf$p;
					if curCH = 80h then
					do;
						tmac$buf$p = tmac$w12;
						if b$9062 = 2 then
						do;
							b$91A2 = ch;
							tmac$buf$p = .b$91A2;
							if ch = '!' then
							do;
								b$91A1 = 21h;
								b$91A2 = mem(tmac$w12 + 1);
								tmac$buf$p = tmac$buf$p - 1;
							end;
						end;
						else
						do;
							do while (lookAhead := lookAhead - 1) <> 0FFh;
								tmac$buf$p = tmac$buf$p - (ch and 7Fh);
							end;

							tmac$buf$p = tmac$buf$p + 1;
						end;
					end;
					else
					do;
						tmac$buf$p = .b$91A4;
						w6BE0 = lookAhead + tmac$w4;
						do ii = 1 to 4;
							b$91A4(6 - ii) = w6BE0 mod 10 + '0';
							w6BE0 = w6BE0 / 10;
						end;
					end;
				end;

				lookAhead = 0;
				goto L6339;
			end;
		end;

		if b$905B > 1 then
			if isPhase2Print then
				if off$9056 < .w$9054 then
				do;
					ch1 = curCH;	
					off$9056 = off$9056 + 1;
				end;

		if b$905E then
			if w$919D <> w$906A and curCH = 0Dh or not b$9059 then
			call sub$3D55(curCH);

		if not(prevCH = '!' or b6742) then
		do;
			if curCH = '>' then
				argNestCnt = argNestCnt - 1;

			if curCH = '<' then
				argNestCnt = argNestCnt + 1;
		end;
	end;
L65B2:
	reget = 0;
	return (curChar := curCH);
end;

getChClass: procedure byte public;
	curChar = getCh;
	if b$905D then
		return 0Ah;

	return chClass(curChar);
end;



chkLF: procedure public;
	if lookAhead = 0Ah then
		lookAhead = 0;
	else
	do;
/* $IF ASM48 */
		b$905E = b$905E and 0FEh;
/* $ENDIF */
		call illegalCharError;
/* $IF ASM48 */
		b$905E = b$905E > 0;
/* $ENDIF */
	end;
end;

end;

