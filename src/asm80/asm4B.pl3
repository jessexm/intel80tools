asm4B: do;
$include(asm4b.ipx)

declare b7183(*) byte data(3Fh, 0, 4, 0, 0, 0, 8, 0, 10h),
	/* bit vector 64 - 00000000 00000100 00000000 00000000 00000000 00001000 00000000 00010000 */
	/*                 CR, COMMA, SEMI */                                  
	aMacro(*) byte data('MACRO', 0);

declare w9C75 address,
	b9C77 byte public;


Sub7192: procedure byte;
	if IsCR then
	do;
		b905A = 0;
		return TRUE;
	end;

	if b905A then
		return argNestCnt = b9066;

	if IsLT or (not (tmac$mtype = 1) and IsGT) then
	do;
		call IllegalCharError;
		return TRUE;
	end;

	return IsWhite or IsComma or IsGT or curChar = ';';
end;



Sub71F2: procedure;
	symTab(2), endSymTab(2) = symHighMark;
	b9065, tmac$b3 = bZERO;
	effectiveToken = 37h;
end;


Sub720A: procedure;

	b9062 = tmac$mtype;
	if not expandingMacro then
		expandingMacro = 1;

	if macroDepth = 0 then
		expandingMacro = 0FFh;

	if b9061 then
		call move(4, .macroStk(0).buf$p, .macroStk(macroDepth).buf$p);

	b9061 = FALSE;
	tmac$w12 = w9199;
	tmac$w4 = w919B;
	w919B = w919B + tmac$b3;
	call ReadM(tmac$w10);
	tmac$buf$p = .macroBuf;
end;


Sub727F: procedure bool;
	if not b905E then
		return TRUE;
	b9064 = b9064 + 1;
	b6B2C = leftOp <> K$REPT;
	effectiveToken = 37h;
	return FALSE;
end;


Sub72A4: procedure(arg1b) public;	/* 1 -> IRP, 2 -> IRPC */
	declare arg1b byte;

	if Sub727F then
	do;
		call Sub71F2;
		call NestIF(1);
		tmac$w14 = 0;
		tmac$mtype = arg1b;
	end;
end;

Sub72C4: procedure;
	declare b9C79(6) byte;

	call PushToken(0Dh);
	kk = 0;

L72CE:
	b9C79(kk := kk + 1) = accum1 mod 10 + '0';
	if (accum1 := accum1 / 10) > 0 then
		goto L72CE;

	do while kk > 0;
		call CollectByte(b9C79(kk));
		kk = kk - 1;
	end;
end;


Sub7327: procedure public;
	w9199 = topMacroTbl;
	effectiveToken = 3Dh;
	b905D = TRUE;
	b9060 = FALSE;
end;


EnterMacro: procedure(lowAddr, highAddr) address;
	declare (lowAddr, highAddr) pointer;
	declare ch1 based topMacroTbl byte,
		ch2 based highAddr byte;

	do while lowAddr <= highAddr;
		if topMacroTbl <= symHighMark then
			call RuntimeError(1);	/* table Error */
		ch1 = ch2;
		topMacroTbl = topMacroTbl - 1;
		highAddr = highAddr - 1;
	end;
	return topMacroTbl;
end;


Sub7383: procedure;
	b9064 = 1;
	macroInPtr = symHighMark;
	b905E = 1;
	w9C75 = macroBlkCnt;
end;



Sub739A: procedure;
	if usrLookupIsID then
		if asmErrCode <> 'U' then
			call LocationError;
end;


Sub73AD: procedure public;
	declare isPercent byte;

	b9C77 = tokenIdx;
	call SkipWhite;
	if not (isPercent := curChar = '%') then
	do;
		b9066 = argNestCnt - 1;
		if (b905A := IsLT) then
			curChar = GetCh;

		call PushToken(0Dh);

	L73E2:	do while not Sub7192;
			if curChar = '''' then
			do;
				if (curChar := GetCh) = '''' then
				do;
					curChar = GetCh;
					call SkipWhite;
					if Sub7192 then
						goto L7463;
					else
					do;
						call CollectByte('''');
						call CollectByte('''');
					end;
				end;
				else
				do;
					call CollectByte('''');
					goto L73E2;
				end;
			end;
			call CollectByte(curChar);
			if tmac$mtype = 2 then
				tmac$w14 = tmac$w14 + 1;

			if curChar = '!' and GetCh <> CR then
			do;
				call CollectByte(curChar);
				curChar = GetCh;
			end;
		end;

	L7463:	if b905A then
			curChar = GetCh;

		call SkipWhite;
		if IsGT then
		do;
			curChar = GetCh;
			call SkipWhite;
		end;

		reget = 1;
	end;

	b905D = FALSE;
	if tmac$mtype = 4 then
	do;
		if not b905A and tokenSize(0) = 5 then
			if StrUCequ(.aMacro, tokPtr) then
			do;
				effectiveToken = K$MACRO;
				call PopToken;
				w9199 = tmac$w12;
				opSP = opSP - 1;
				reget = 1;
				call EmitXref(0, .name);
				rhsUserSymbol = FALSE;
				b6BDA = TRUE;
				return;
			end;
		tmac$mtype = b9062;
		call NestIF(1);
		tmac$mtype = 0;
	end;

	if not isPercent then
		if not TestBit(curChar, .b7183) then	/* not CR, COMMA or SEMI */
		do;
			call Skip2EOL;
			call SyntaxError;
			reget = 1;
		end;
end;



Sub7517: procedure public;
	if Sub727F then
	do;
		expectingOperands = FALSE;
		w9068 = curTokenSym$p + 4;
		call UpdateSymbolEntry(0, O$3A);
		tmac$mtype = 0;
		call Sub71F2;
	end;
end;

Sub753E: procedure public;
	declare ch based w9068 byte;

	if HaveTokens then
	do;
		if tokenType(0) = 0 then
			call MultipleDefError;

		call Sub5CAD((b9065 := b9065 + 1), 0);
	end;
	else if not (tmac$mtype = 0) then
		call SyntaxError;

	if not tmac$mtype = 0 then
	do;
		call SkipWhite;
		if IsComma then
		do;
			reget = 0;
			rightOp = O$NONE;
			call Sub7327;
			if tmac$mtype = 1 then
			do;
				curChar = GetCh;
				call SkipWhite;
				if not IsLT then
				do;
					call SyntaxError;
					reget = 1;
				end;
			end;
		end;
		else
		do;
			call SyntaxError;
			call Sub7383;
		end;
	end;
	else if rightOp = T$CR then
	do;
		if not BlankMorPAsmErrCode then
		do;
			tmac$mtype = 5;
			w9068 = w9068 + 2;
			if (ch and 7Fh) = 3Ah then
				ch = (asmErrCode = 'L') and 80h or 9;
		end;
		call Sub7383;
	end;
end;

Sub75FF: procedure public;
	declare ch based macroInPtr byte;
	declare ch2 based w9068 byte;
	declare wrd based w9068 address;

	if b905E then
	do;
		if (b9064 := b9064 - 1) = 0 then
		do;
			b905E = 0;
			if not (tmac$mtype = 5) then
			do;
				if tmac$mtype = 2 then
					w9199 = topMacroTbl + 3;

				do w6BE0 = w919D to w919F - 1;
					curChar = byteAt(w6BE0);
					if not IsWhite then
						call SyntaxError;
				end;

				macroInPtr = w919D;
				ch = 1Bh;
				call Sub40B9;
				call WriteM;
				symHighMark, endSymTab(2) = symTab(2);
				if tmac$mtype = 0 then
				do;
					wrd = w9C75;
					w9068 = w9068 + 3;
					ch2 = tmac$b3;
				end;
				else
				do;
					tmac$w10 = w9C75;
					call Sub720A;
					if tmac$w14 = 0 then
						call UnnestIF(1);
				end;
			end;
		end;
	end;
	else
		call NestingError;
end;


Sub76CE: procedure public;
	if expandingMacro then
	do;
		if rightOp = T$CR then
		do;
			condAsmSeen = TRUE;
			macroCondSP = tmac$macroCondSP;
			ifDepth = tmac$ifDepth;
			tmac$w14 = 1;
			lookAhead = 1Bh;
			macroCondStk(0) = 1;
		end;
		else
			call SyntaxError;
	end;
	else
		call NestingError;
end;


Sub770B: procedure public;
	if b9C77 + 1 <> tokenIdx then
		call SyntaxError;
	else if not b9060 then
	do;
		if tokenType(0) <> 0Dh then
		do;
			accum1 = GetNumVal;
			call Sub72C4;
		end;

		if tmac$mtype = 2 then
			tmac$w14 = tokenSize(0) - (tokenSize(0) = 0);

		call CollectByte((tokenSize(0) + 1) or 80h);
		topMacroTbl = EnterMacro(tokPtr, tokPtr + tokenSize(0) - 1);
		call PopToken;

		if tmac$mtype = 0 or tmac$mtype = 1 and argNestCnt > 0 then
			b905D = TRUE;
		else
			b9060 = TRUE;

		if tmac$mtype = 1 then
			tmac$w14 = tmac$w14 + 1;
	end;
	else
		call SyntaxError;

	if rightOp = T$CR then
	do;
		b905D = FALSE;
		if argNestCnt > 0 then
			call BalanceError;

		if not BlankMorPAsmErrCode then
		do;
			call Sub739A;
			if tmac$mtype = 0 then
			do;
				call Sub720A;
				call UnnestIF(1);
				return;
			end;
			else
				tmac$w14 = 0;
		end;
		else
		do;
			topMacroTbl = EnterMacro(.b$3782, .b$3783);
			if tmac$mtype = 0 then
			do;
				tmac$b3 = curTokenSym.flags;
				tmac$w10 = GetNumVal;
				call Sub720A;
			end;
			else if tmac$w14 = 0 then
				call SyntaxError;
		end;

		if not (tmac$mtype = 0) then
			call Sub7383;
	end;
end;



Sub7844: procedure public;
	call Sub72A4(3);
	if (effectiveToken := rightOp) <> T$CR then
		call SyntaxError;

	if not b905E then
	do;
		tmac$w14 = accum1;
		if not BlankMorPAsmErrCode then
		do;
			call Sub739A;
			tmac$w14 = 0;
		end;

		call Sub7383;
	end;
end;


Sub787A: procedure public;
	if b905E = 2 then
	do;
		if HaveTokens then
		do;
			if (tmac$b3 := tmac$b3 + 1) = 0 then
				call StackError;

			if tokenType(0) <> 9 then
				call MultipleDefError;

			call Sub5CAD(tmac$b3, 1);
			macroInPtr = symHighMark;
		end;
		if rightOp = T$CR then
		do;
			b905E = 1;
			macroInPtr = symHighMark;
		end;
	end;
	else
		call SyntaxError;
end;



Sub78CE: procedure public;
	kk = byteAt(tmac$w12);
	accFixFlags(0) = 1 - (kk = 21h and b9062 = 2);
	if b9062 = 0 or (tmac$w14 := tmac$w14 - accFixFlags(0)) = 0 then
		call UnnestIF(1);
	else
	do;
		if b9062 = 1 then
			w9199 = tmac$w12 - (kk and 7Fh);
		else
			w9199 = tmac$w12 + accFixFlags(0);

		tmac$mtype = b9062;
		call Sub720A;
	end;
	lookAhead = 0;
	b6B2C, atStartLine = bTRUE;
end;

end;
