asm4B:
do;
$include(asm4b.ipx)

declare b$7183(*) byte data(3Fh, 0, 4, 0, 0, 0, 8, 0, 10h),
	aMacro(*) byte data('MACRO', 0);

declare w$9C75 address,
	b$9C77 byte public;


sub$7192: procedure byte;
	if isCR then
	do;
		b$905A = 0;
		return TRUE;
	end;

	if b$905A then
		return argNestCnt = b$9066;

	if isLT or (not (tmac$mtype = 1) and isGT) then
	do;
		call illegalCharError;
		return TRUE;
	end;

	return isWhite or isComma or isGT or curChar = ';';
end;



sub$71F2: procedure;
	symTab(2), endSymTab(2) = symHighMark;
	b$9065, tmac$b3 = bZERO;
	b6B29 = 37h;
end;


sub$720A: procedure;

	b$9062 = tmac$mtype;
	if not b$905B then
		b$905B = 1;

	if b$9063 = 0 then
		b$905B = 0FFh;

	if b$9061 then
		call move(4, .macroStk(0).buf$p, .macroStk(b$9063).buf$p);

	b$9061 = 0;
	tmac$w12 = w$9199;
	tmac$w4 = w$919B;
	w$919B = w$919B + tmac$b3;
	call readM(tmac$w10);
	tmac$buf$p = .macroBuf;
end;


sub$727F: procedure byte;
	if not b$905E then
		return TRUE;
	b$9064 = b$9064 + 1;
	b6B2C = b6B2B <> 3Eh;
	b6B29 = 37h;
	return FALSE;
end;


sub$72A4: procedure(arg1b) public;	/* 1 -> IRP, 2 -> IRPC */
	declare arg1b byte;

	if sub$727F then
	do;
		call sub$71F2;
		call nestIF(1);
		tmac$w14 = 0;
		tmac$mtype = arg1b;
	end;
end;

sub$72C4: procedure;
	declare b$9C79(6) byte;

	call pushToken(0Dh);
	jj = 0;

L72CE:
	b$9C79(jj := jj + 1) = accum1 mod 10 + '0';
	if (accum1 := accum1 / 10) > 0 then
		goto L72CE;

	do while jj > 0;
		call collectByte(b$9C79(jj));
		jj = jj - 1;
	end;
end;


sub$7327: procedure public;
	w$9199 = w6870;
	b6B29 = 3Dh;
	b$905D = TRUE;
	b$9060 = 0;
end;


sub$733D: procedure(arg1w, arg2w) address;
	declare (arg1w, arg2w) address;
	declare ch1 based w6870 byte,
		ch2 based arg2w byte;

	do while arg1w <= arg2w;
		if w6870 <= symHighMark then
			call runtimeError(1);	/* table error */
		ch1 = ch2;
		w6870 = w6870 - 1;
		arg2w = arg2w - 1;
	end;
	return w6870;
end;


sub$7383: procedure;
	b$9064 = 1;
	w$906A = symHighMark;
	b$905E = 1;
	w$9C75 = w$9114;
end;



sub$739A: procedure;
	if b6884 then
		if asmErrCode <> 55h then
			call locationError;
end;


sub$73AD: procedure public;
	declare b$9C83 byte;

	b$9C77 = tokenSP;
	call skipWhite;
	if not (b$9C83 := curChar = 25h) then
	do;
		b$9066 = argNestCnt - 1;
		if (b$905A := isLT) then
			curChar = getCh;

		call pushToken(0Dh);

	L73E2:	do while not sub$7192;
			if curChar = 27h then
			do;
				if (curChar := getCh) = 27h then
				do;
					curChar = getCh;
					call skipWhite;
					if sub$7192 then
						goto L7463;
					else
					do;
						call collectByte(27h);
						call collectByte(27h);
					end;
				end;
				else
				do;
					call collectByte(27h);
					goto L73E2;
				end;
			end;
			call collectByte(curChar);
			if tmac$mtype = 2 then
				tmac$w14 = tmac$w14 + 1;

			if curChar = 21h and getCh <> 0Dh then
			do;
				call collectByte(curChar);
				curChar = getCh;
			end;
		end;

	L7463:	if b$905A then
			curChar = getCh;

		call skipWhite;
		if isGT then
		do;
			curChar = getCh;
			call skipWhite;
		end;

		reget = 1;
	end;

	b$905D = FALSE;
	if tmac$mtype = 4 then
	do;
		if not b$905A and tokenSize(0) = 5 then
			if strUCequ(.aMacro, curTokStart) then
			do;
				b6B29 = 36h;
				call popToken;
				w$9199 = tmac$w12;
				opSP = opSP - 1;
				reget = 1;
				call sub$467F(0, .b6873);
				b6880 = 0;
				b6BDA = 0FFh;
				return;
			end;
		tmac$mtype = b$9062;
		call nestIF(1);
		tmac$mtype = 0;
	end;

	if not b$9C83 then
		if not testBit(curChar, .b$7183) then
		do;
			call skip2EOL;
			call syntaxError;
			reget = 1;
		end;
end;



sub$7517: procedure public;
	if sub$727F then
	do;
		b6B30 = 0;
		w$9068 = curTokenSym$p + 4;
		call sub5819$5CE8(0, 3Ah);
		tmac$mtype = 0;
		call sub$71F2;
	end;
end;

sub$753E: procedure public;
	declare ch based w$9068 byte;

	if haveTokens then
	do;
		if tokenType(0) = 0 then
			call multipleDefError;

		call sub$5CAD((b$9065 := b$9065 + 1), 0);
	end;
	else if not (tmac$mtype = 0) then
		call syntaxError;

	if not tmac$mtype = 0 then
	do;
		call skipWhite;
		if isComma then
		do;
			reget = 0;
			opType = 0;
			call sub$7327;
			if tmac$mtype = 1 then
			do;
				curChar = getCh;
				call skipWhite;
				if not isLT then
				do;
					call syntaxError;
					reget = 1;
				end;
			end;
		end;
		else
		do;
			call syntaxError;
			call sub$7383;
		end;
	end;
	else if opType = 1 then
	do;
		if not blankMorPAsmErrCode then
		do;
			tmac$mtype = 5;
			w$9068 = w$9068 + 2;
			if (ch and 7Fh) = 3Ah then
				ch = (asmErrCode = 4Ch) and 80h or 9;
		end;
		call sub$7383;
	end;
end;

sub$75FF: procedure public;
	declare ch based w$906A byte;
	declare ch2 based w$9068 byte;
	declare wrd based w$9068 address;

	if b$905E then
	do;
		if (b$9064 := b$9064 - 1) = 0 then
		do;
			b$905E = 0;
			if not (tmac$mtype = 5) then
			do;
				if tmac$mtype = 2 then
					w$9199 = w6870 + 3;

				do w6BE0 = w$919D to w$919F - 1;
					curChar = mem(w6BE0);
					if not isWhite then
						call syntaxError;
				end;

				w$906A = w$919D;
				ch = 1Bh;
				call sub$40B9;
				call writeM;
				symHighMark, endSymTab(2) = symTab(2);
				if tmac$mtype = 0 then
				do;
					wrd = w$9C75;
					w$9068 = w$9068 + 3;
					ch2 = tmac$b3;
				end;
				else
				do;
					tmac$w10 = w$9C75;
					call sub$720A;
					if tmac$w14 = 0 then
						call unnestIF(1);
				end;
			end;
		end;
	end;
	else
		call nestingError;
end;


sub$76CE: procedure public;
	if b$905B then
	do;
		if opType = 1 then
		do;
			b6B32 = 0FFh;
			macroCondSP = tmac$macroCondSP;
			ifDepth = tmac$ifDepth;
			tmac$w14 = 1;
			lookAhead = 1Bh;
			macroCondStk(0) = 1;
		end;
		else
			call syntaxError;
	end;
	else
		call nestingError;
end;


sub$770B: procedure public;
	if b$9C77 + 1 <> tokenSP then
		call syntaxError;
	else if not b$9060 then
	do;
		if tokenType(0) <> 0Dh then
		do;
			accum1 = sub$43DD;
			call sub$72C4;
		end;

		if tmac$mtype = 2 then
			tmac$w14 = tokenSize(0) - (tokenSize(0) = 0);

		call collectByte((tokenSize(0) + 1) or 80h);
		w6870 = sub$733D(curTokStart, curTokStart + tokenSize(0) - 1);
		call popToken;

		if tmac$mtype = 0 or tmac$mtype = 1 and argNestCnt > 0 then
			b$905D = TRUE;
		else
			b$9060 = 0FFh;

		if tmac$mtype = 1 then
			tmac$w14 = tmac$w14 + 1;
	end;
	else
		call syntaxError;

	if opType = 1 then
	do;
		b$905D = FALSE;
		if argNestCnt > 0 then
			call balanceError;

		if not blankMorPAsmErrCode then
		do;
			call sub$739A;
			if tmac$mtype = 0 then
			do;
				call sub$720A;
				call unnestIF(1);
				return;
			end;
			else
				tmac$w14 = 0;
		end;
		else
		do;
			w6870 = sub$733D(.b$3782, .b$3783);
			if tmac$mtype = 0 then
			do;
				tmac$b3 = curTokenSym.flags;
				tmac$w10 = sub$43DD;
				call sub$720A;
			end;
			else if tmac$w14 = 0 then
				call syntaxError;
		end;

		if not (tmac$mtype = 0) then
			call sub$7383;
	end;
end;



sub$7844: procedure public;
	call sub$72A4(3);
	if (b6B29 := opType) <> 1 then
		call syntaxError;

	if not b$905E then
	do;
		tmac$w14 = accum1;
		if not blankMorPAsmErrCode then
		do;
			call sub$739A;
			tmac$w14 = 0;
		end;

		call sub$7383;
	end;
end;


sub$787A: procedure public;
	if b$905E = 2 then
	do;
		if haveTokens then
		do;
			if (tmac$b3 := tmac$b3 + 1) = 0 then
				call stackError;

			if tokenType(0) <> 9 then
				call multipleDefError;

			call sub$5CAD(tmac$b3, 1);
			w$906A = symHighMark;
		end;
		if opType = 1 then
		do;
			b$905E = 1;
			w$906A = symHighMark;
		end;
	end;
	else
		call syntaxError;
end;



sub$78CE: procedure public;
	jj = mem(tmac$w12);
	bp6BE0(0) = 1 - (jj = 21h and b$9062 = 2);
	if b$9062 = 0 or (tmac$w14 := tmac$w14 - bp6BE0(0)) = 0 then
		call unnestIF(1);
	else
	do;
		if b$9062 = 1 then
			w$9199 = tmac$w12 - (jj and 7Fh);
		else
			w$9199 = tmac$w12 + bp6BE0(0);

		tmac$mtype = b$9062;
		call sub$720A;
	end;
	lookAhead = 0;
	b6B2C, b689C = bTRUE;
end;

end;
