asm4B:
do;
$include(asm4b.ipx)

declare b7183(*) byte data(3Fh, 0, 4, 0, 0, 0, 8, 0, 10h),
	/* bit vector 64 - 00000000 00000100 00000000 00000000 00000000 00001000 00000000 00010000 */
	/*                 CR, COMMA, SEMI */                                  
	aMacro(*) byte data('MACRO', 0);

declare w9C75 address,
	b9C77 byte public;


sub$7192: procedure byte;
	if isCR then
	do;
		b905A = 0;
		return TRUE;
	end;

	if b905A then
		return argNestCnt = b9066;

	if isLT or (not (tmac$mtype = 1) and isGT) then
	do;
		call illegalCharError;
		return TRUE;
	end;

	return isWhite or isComma or isGT or curChar = ';';
end;



sub$71F2: procedure;
	symTab(2), endSymTab(2) = symHighMark;
	b9065, tmac$b3 = bZERO;
	effectiveToken = 37h;
end;


sub$720A: procedure;

	b9062 = tmac$mtype;
	if not expandingMacro then
		expandingMacro = 1;

	if macroDepth = 0 then
		expandingMacro = 0FFh;

	if b9061 then
		call move(4, .macroStk(0).buf$p, .macroStk(macroDepth).buf$p);

	b9061 = 0;
	tmac$w12 = w9199;
	tmac$w4 = w919B;
	w919B = w919B + tmac$b3;
	call readM(tmac$w10);
	tmac$buf$p = .macroBuf;
end;


sub$727F: procedure byte;
	if not b905E then
		return TRUE;
	b9064 = b9064 + 1;
	b6B2C = op <> 3Eh;
	effectiveToken = 37h;
	return FALSE;
end;


sub$72A4: procedure(arg1b) public;	/* 1 -> IRP, 2 -> IRPC */
	declare arg1b byte;

	if sub$727F then
	do;
		call sub$71F2;
		call nestIF(1);
		tmac$w14 = 0;
		tmac$mtype = arg1b;
	end;
end;

sub$72C4: procedure;
	declare b9C79(6) byte;

	call pushToken(0Dh);
	jj = 0;

L72CE:
	b9C79(jj := jj + 1) = accum1 mod 10 + '0';
	if (accum1 := accum1 / 10) > 0 then
		goto L72CE;

	do while jj > 0;
		call collectByte(b9C79(jj));
		jj = jj - 1;
	end;
end;


sub$7327: procedure public;
	w9199 = w6870;
	effectiveToken = 3Dh;
	b905D = TRUE;
	b9060 = 0;
end;


enterMacro: procedure(arg1w, arg2w) address;
	declare (arg1w, arg2w) pointer;
	declare ch1 based w6870 byte,
		ch2 based arg2w byte;

	do while arg1w <= arg2w;
		if w6870 <= symHighMark then
			call runtimeError(1);	/* table error */
		ch1 = ch2;
		w6870 = w6870 - 1;
		arg2w = arg2w - 1;
	end;
	return w6870;
end;


sub$7383: procedure;
	b9064 = 1;
	w906A = symHighMark;
	b905E = 1;
	w9C75 = w9114;
end;



sub$739A: procedure;
	if b6884 then
		if asmErrCode <> 55h then
			call locationError;
end;


sub$73AD: procedure public;
	declare isPercent byte;

	b9C77 = tokenIdx;
	call skipWhite;
	if not (isPercent := curChar = '%') then
	do;
		b9066 = argNestCnt - 1;
		if (b905A := isLT) then
			curChar = getCh;

		call pushToken(0Dh);

	L73E2:	do while not sub$7192;
			if curChar = '''' then
			do;
				if (curChar := getCh) = '''' then
				do;
					curChar = getCh;
					call skipWhite;
					if sub$7192 then
						goto L7463;
					else
					do;
						call collectByte('''');
						call collectByte('''');
					end;
				end;
				else
				do;
					call collectByte('''');
					goto L73E2;
				end;
			end;
			call collectByte(curChar);
			if tmac$mtype = 2 then
				tmac$w14 = tmac$w14 + 1;

			if curChar = '!' and getCh <> CR then
			do;
				call collectByte(curChar);
				curChar = getCh;
			end;
		end;

	L7463:	if b905A then
			curChar = getCh;

		call skipWhite;
		if isGT then
		do;
			curChar = getCh;
			call skipWhite;
		end;

		reget = 1;
	end;

	b905D = FALSE;
	if tmac$mtype = 4 then
	do;
		if not b905A and tokenSize(0) = 5 then
			if strUCequ(.aMacro, tokPtr) then
			do;
				effectiveToken = 36h;
				call popToken;
				w9199 = tmac$w12;
				opSP = opSP - 1;
				reget = 1;
				call emitXref(0, .name);
				haveUserSymbol = FALSE;
				b6BDA = TRUE;
				return;
			end;
		tmac$mtype = b9062;
		call nestIF(1);
		tmac$mtype = 0;
	end;

	if not isPercent then
		if not testBit(curChar, .b7183) then	/* not CR, COMMA or SEMI */
		do;
			call skip2EOL;
			call syntaxError;
			reget = 1;
		end;
end;



sub$7517: procedure public;
	if sub$727F then
	do;
		expectingOperands = 0;
		w9068 = curTokenSym$p + 4;
		call sub5819$5CE8(0, O$3A);
		tmac$mtype = 0;
		call sub$71F2;
	end;
end;

sub$753E: procedure public;
	declare ch based w9068 byte;

	if haveTokens then
	do;
		if tokenType(0) = 0 then
			call multipleDefError;

		call sub$5CAD((b9065 := b9065 + 1), 0);
	end;
	else if not (tmac$mtype = 0) then
		call syntaxError;

	if not tmac$mtype = 0 then
	do;
		call skipWhite;
		if isComma then
		do;
			reget = 0;
			opType = 0;
			call sub$7327;
			if tmac$mtype = 1 then
			do;
				curChar = getCh;
				call skipWhite;
				if not isLT then
				do;
					call syntaxError;
					reget = 1;
				end;
			end;
		end;
		else
		do;
			call syntaxError;
			call sub$7383;
		end;
	end;
	else if opType = 1 then
	do;
		if not blankMorPAsmErrCode then
		do;
			tmac$mtype = 5;
			w9068 = w9068 + 2;
			if (ch and 7Fh) = 3Ah then
				ch = (asmErrCode = 'L') and 80h or 9;
		end;
		call sub$7383;
	end;
end;

sub$75FF: procedure public;
	declare ch based w906A byte;
	declare ch2 based w9068 byte;
	declare wrd based w9068 address;

	if b905E then
	do;
		if (b9064 := b9064 - 1) = 0 then
		do;
			b905E = 0;
			if not (tmac$mtype = 5) then
			do;
				if tmac$mtype = 2 then
					w9199 = w6870 + 3;

				do w6BE0 = w919D to w919F - 1;
					curChar = byteAt(w6BE0);
					if not isWhite then
						call syntaxError;
				end;

				w906A = w919D;
				ch = 1Bh;
				call sub$40B9;
				call writeM;
				symHighMark, endSymTab(2) = symTab(2);
				if tmac$mtype = 0 then
				do;
					wrd = w9C75;
					w9068 = w9068 + 3;
					ch2 = tmac$b3;
				end;
				else
				do;
					tmac$w10 = w9C75;
					call sub$720A;
					if tmac$w14 = 0 then
						call unnestIF(1);
				end;
			end;
		end;
	end;
	else
		call nestingError;
end;


sub$76CE: procedure public;
	if expandingMacro then
	do;
		if opType = 1 then
		do;
			b6B32 = TRUE;
			macroCondSP = tmac$macroCondSP;
			ifDepth = tmac$ifDepth;
			tmac$w14 = 1;
			lookAhead = 1Bh;
			macroCondStk(0) = 1;
		end;
		else
			call syntaxError;
	end;
	else
		call nestingError;
end;


sub$770B: procedure public;
	if b9C77 + 1 <> tokenIdx then
		call syntaxError;
	else if not b9060 then
	do;
		if tokenType(0) <> 0Dh then
		do;
			accum1 = sub$43DD;
			call sub$72C4;
		end;

		if tmac$mtype = 2 then
			tmac$w14 = tokenSize(0) - (tokenSize(0) = 0);

		call collectByte((tokenSize(0) + 1) or 80h);
		w6870 = enterMacro(tokPtr, tokPtr + tokenSize(0) - 1);
		call popToken;

		if tmac$mtype = 0 or tmac$mtype = 1 and argNestCnt > 0 then
			b905D = TRUE;
		else
			b9060 = 0FFh;

		if tmac$mtype = 1 then
			tmac$w14 = tmac$w14 + 1;
	end;
	else
		call syntaxError;

	if opType = 1 then
	do;
		b905D = FALSE;
		if argNestCnt > 0 then
			call balanceError;

		if not blankMorPAsmErrCode then
		do;
			call sub$739A;
			if tmac$mtype = 0 then
			do;
				call sub$720A;
				call unnestIF(1);
				return;
			end;
			else
				tmac$w14 = 0;
		end;
		else
		do;
			w6870 = enterMacro(.b$3782, .b$3783);
			if tmac$mtype = 0 then
			do;
				tmac$b3 = curTokenSym.flags;
				tmac$w10 = sub$43DD;
				call sub$720A;
			end;
			else if tmac$w14 = 0 then
				call syntaxError;
		end;

		if not (tmac$mtype = 0) then
			call sub$7383;
	end;
end;



sub$7844: procedure public;
	call sub$72A4(3);
	if (effectiveToken := opType) <> 1 then
		call syntaxError;

	if not b905E then
	do;
		tmac$w14 = accum1;
		if not blankMorPAsmErrCode then
		do;
			call sub$739A;
			tmac$w14 = 0;
		end;

		call sub$7383;
	end;
end;


sub$787A: procedure public;
	if b905E = 2 then
	do;
		if haveTokens then
		do;
			if (tmac$b3 := tmac$b3 + 1) = 0 then
				call stackError;

			if tokenType(0) <> 9 then
				call multipleDefError;

			call sub$5CAD(tmac$b3, 1);
			w906A = symHighMark;
		end;
		if opType = 1 then
		do;
			b905E = 1;
			w906A = symHighMark;
		end;
	end;
	else
		call syntaxError;
end;



sub$78CE: procedure public;
	jj = byteAt(tmac$w12);
	bp6BE0(0) = 1 - (jj = 21h and b9062 = 2);
	if b9062 = 0 or (tmac$w14 := tmac$w14 - bp6BE0(0)) = 0 then
		call unnestIF(1);
	else
	do;
		if b9062 = 1 then
			w9199 = tmac$w12 - (jj and 7Fh);
		else
			w9199 = tmac$w12 + bp6BE0(0);

		tmac$mtype = b9062;
		call sub$720A;
	end;
	lookAhead = 0;
	b6B2C, atStartLine = bTRUE;
end;

end;
