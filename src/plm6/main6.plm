plm6: DO;
declare lit literally 'literally',
	true lit '0ffh',
	false lit '0',
	cr lit '0dh',
	lf lit '0ah';

$nolist
$include(:f3:data.inc)

newPageNextChLst: procedure external; end;
xputStr2cLst: procedure(str, ch) external; declare str address, ch byte; end;
xwrnstrLst: procedure(str, cnt) external; declare str address, cnt byte; end;
$include(:f3:gisym.pex)
newlineLst: procedure external; end;
tabLst: procedure(ntab) external; declare ntab byte; end;
setSkipLst: procedure(arg1b) external; declare arg1b byte; end;
$include(:f3:deletf.pex)
$include(:f3:closef.pex)
$include(:f3:creatf.pex)
$include(:f3:fread.aex)
$include(:f3:endcom.pex)
$include(:f3:exit.pex)
$include(:f3:openf.pex)
$include(:f3:chain.pex)
lstModuleInfo: procedure external; end;
sub$6550: procedure external; end;
setMarkerInfo: procedure(arg1b, arg2b, arg3b) external; declare (arg1b, arg2b, arg3b) byte; end;
$include(:f3:initf.pex)
$include(:f3:tellf.pex)
$include(:f3:backup.pex)
flushLstBuf: procedure external; end;
emitError: procedure external; end;
sub$42E7: procedure external; end;


declare copyright(*) byte data('(C) 1976, 1977, 1982 INTEL CORP');
declare errCont label public;
declare b7AD9 byte external,
	b7ADA byte external,
	listing byte external,
	listOff byte external,
	codeOn byte external,
	ERRNum address external,
	w7AE0 address external,
	STMTNum address external,
	b7AE4 byte external,
	w7AE5 address external,
	lineNo address external,
	w7AE9 address external,
	w7AEB address external,
	offLastCh address external,
	offCurCh address external,
	b7AF1 byte external,
	b7AF2 byte external,
	lstLineLen byte external,
	lstbuf(130) byte external,
	srcbuf(2048) byte external;



	sub$3F96: procedure;
		declare cmd BASED cmdLine$p STRUCTURE(link ADDRESS, pstr(1) BYTE);
		if PRINT then
		do;
			call newPageNextChLst;
			call xputstr2cLst(.('ISIS-II PL/M-80 ', 0), 0);
			call xwrnstrLst(.version, 4);
			call xputstr2cLst(.(' COMPILATION OF MODULE ', 0), 0);
			curInfo$p = botInfo + procInfo(1);
			curSymbol$p = getSymbol;
			if curSymbol$p <> 0 then
				call xwrnstrLst(.sym.name(1), sym.name(0));
			call newLineLst;
			if OBJECT then
				call xputstr2cLst(.('NO OBJECT MODULE GENERATED', 0), 0);
			else
				call xputstr2cLst(.('NO OBJECT MODULE REQUESTED', 0), 0);
			call newLineLst;
			call xputstr2cLst(.('COMPILER INVOKED BY:  ', 0), 0);
			cmdLine$p = startCmdLine$p;
			do while cmdLine$p <> 0;
				call tabLst(-23);
				call xputstr2cLst(.cmd.pstr(1), cr);
				cmdLine$p = cmd.link;
			end;
			call newLineLst;
			call setSkipLst(3);
		end;
	end;



	sub$404A: procedure;
		declare tx2Buf(2048) byte,
			nmsBuf(2048) byte,
			lstBuf(2048) byte;

		if PRINT then
		do;
			lbuf$p = .lstBuf;
			lBufSz = 2047;
		end;
		b7AD9 = PRINT or OBJECT;
		if OBJECT then
			call deletF(.objFile);
		if not lfOpen and PRINTSet then
		do;
			call deletF(.lstFil);
			PRINTSet = false;
		end;
		call closeF(.tx1File);
		call deletF(.tx1File);
		call creatf(.tx2File, .tx2Buf, 800h, 1);
		if b7AD9 or IXREF then
			call creatf(.nmsFile, .nmsBuf, 800h, 1);
		w7AEB = 0;
		if PRINT then
		do;
			srcFileIdx = 0;
			call initF(.srcFil, .('SOURCE'), .srcFileTable(srcFileIdx)); /* note word array used */
			call openF(.srcFil, 1);
		end;
		curInfo$p = procInfo(1) + botInfo;
		call setSkipLst(3);
		call setMarkerInfo(11, '-', 15);
		if fatalErrorCode > 0 then
		do;
			STMTNum, w7AE0 = 0;
			ERRNum = fatalErrorCode;
			call emitError;
			call setSkipLst(2);
		end;
		listing = PRINT;
		listOff = false;
		codeOn = false;
		programErrCnt, linesRead, csegSize = 0;
	end;

	sub$4149: procedure;
		topSymbol = localLabels$p - 3;
		curSymbol$p = topSymbol - 1;
		call fread(.nmsFile, .b7ADA, 1);
		do while b7ADA <> 0;
			curSymbol$p = curSymbol$p - b7ADA - 1;
			sym.name(0) = b7ADA;
			call fread(.nmsFile, .sym.name(1), b7ADA);
			call fread(.nmsFile, .b7ADA, 1);
		end;
		botSymbol = curSymbol$p + 4;
		botMem = botSymbol;
	end;


	sub$41B6: procedure;
		call closeF(.atFile);
		call deletF(.atFile);
		call closeF(.tx2File);
		call deletF(.tx2File);
		if b7AD9 or IXREF then
		do;
			call closeF(.nmsFile);
			call deletF(.nmsFile);
		end;
		linesRead = w7AE5;
		if PRINT then
		do;
			call tellF(.srcFil, .srcFileTable(srcFileIdx + 8));
			call backup(.srcFileTable(srcFileIdx + 8), offLastCh - offCurCh);
			call closeF(.srcFil);
			call flushLstBuf;
		end;
	end;

/* 3F3B */
	call sub$404A;
	if b7AD9 or IXREF then
		call sub$4149;
	call sub$3F96;
	do while b7AE4;
		call sub$42E7;
	end;

	call sub$6550;

errCont:
	call sub$41B6;
	if PRINT or IXREF then
	do;
		if XREF or  SYMBOLS or IXREF then
			call chain(.overlay5);
		else
			call lstModuleInfo;
	end;
	call endCompile;
	call exit;
end;
/* split file */
