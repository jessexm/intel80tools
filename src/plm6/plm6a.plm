plm6a: DO;
declare lit literally 'literally',
	true lit '0ffh',
	false lit '0',
	cr lit '0dh',
	lf lit '0ah';

$nolist
$include(:f3:data.inc)
declare errCont label external;
declare b7AD9 byte external,
	b7ADA byte external,
	listing byte external,
	listOff byte external,
	codeOn byte external,
	ERRNum address external,
	w7AE0 address external,
	STMTNum address external,
	b7AE4 byte external,
	w7AE5 address external,
	lineNo address external,
	w7AE9 address external,
	w7AEB address external,
	offLastCh address external,
	offCurCh address external,
	b7AF1 byte external,
	b7AF2 byte external,
	lstLineLen byte external,
	lstbuf(130) byte external,
	srcbuf(2048) byte external;




sub$6550: procedure external; end;
getSourceLine: procedure external; end;
emitError: procedure external; end;
newPageNextChLst: procedure external; end;
$include(:f3:tellf.pex)
$include(:f3:backup.pex)
$include(:f3:fread.aex)
$include(:f3:closef.pex)
$include(:f3:initf.pex)
$include(:f3:openf.pex)
$include(:f3:movmem.aex)



declare b4222(*) byte data(
	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0Eh, 1, 1, 1, 1,
	1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 2, 1, 1, 1,
	1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 6, 1, 0, 0, 0,
	0, 3, 0, 9, 9, 8, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 2, 9, 0Bh, 0Bh, 81h,
	99h, 91h, 91h, 91h, 81h, 89h, 89h, 89h, 8Ah, 80h, 80h,
	80h, 80h, 80h, 80h, 90h, 0A1h, 0A3h, 0A0h, 0A1h, 0A2h,
	0B0h, 0A0h, 0A0h, 0A0h, 0A0h, 0A0h, 0A3h, 0A3h, 0,
	0, 0, 0, 0, 0, 0, 0, 41h, 41h, 41h, 40h, 0, 0, 0, 0,
	0, 0C0h, 0C0h, 0C0h, 0C0h, 0C0h, 0D8h, 41h, 41h, 41h,
	0C0h);


sub$42E7: procedure public;
	declare cfCode byte, itemArgs(4) address;

	sub$4396: procedure;
		declare i address;
		if itemArgs(1) > 0 or itemArgs(2) = 0 then
			itemArgs(3) = itemArgs(0);
		else
		do;
			itemArgs(3) = itemArgs(2);
			itemArgs(2) = 0;
		end;
		do i = itemArgs(0) to itemArgs(3);
			call sub$6550;
			w7AE5 = i;
			lineNo = itemArgs(1);
			w7AE9 = itemArgs(2);
			call getSourceLine;
		end;
	end;

	sub$4400: procedure;
		ERRNum = itemArgs(0);
		w7AE0 = 0;
		STMTNum = w7AEB;
		call emitError;
	end;


	sub$4416: procedure;
		ERRNum = itemArgs(0);
		w7AE0 = itemArgs(1);
		STMTNum = w7AEB;
		call emitError;
	end;


	sub$442C: procedure;
		ERRNum = itemArgs(0);
		w7AE0 = itemArgs(1);
		STMTNum = itemArgs(2);
		call emitError;
	end;


	sub$4442: procedure;
		declare name(19) byte;

		do case cfCode - 9dh;
			listOff = false;
			listOff = true;
			codeOn = PRINT;
			codeOn = false;
			if listing then
				call newPageNextChLst;
			do;
				call sub$6550;
				call tellF(.srcFil, .srcFileTable(srcFileIdx + 8));
				call backup(.srcFileTable(srcFileIdx + 8), offLastCh - offCurCh);
				srcFileIdx = srcFileIdx + 10;
				call fread(.tx2File, .name(13), 6);	/* read in name of include file */
				call fread(.tx2File, .name(6), 7);
				call fread(.tx2File, .name(0), 7);	/* overwrites the type byte */
				call movmem(16, .name(1), .srcFileTable(srcFileIdx));
				call closeF(.srcFil);
				call initF(.srcFil, .('SOURCE'), .name(1));
				call openF(.srcFil, 1);
				offCurCh = offLastCh;	/* force read next time	*/
			end;
		end;
	end;


/* sub$42E7 */
	itemArgs(0), itemArgs(1), itemArgs(2) = 0;
	call fread(.tx2File, .cfCode, 1);
	if cfCode <> 0a2h then
		call fread(.tx2File, .itemArgs, shl(b4222(cfCode) and 3,1));
	if cfCode = 98h then
		call sub$4396;
	else if cfCode = 97h then
		w7AEB = itemArgs(0);
	else if cfCode = 9Ah then
		call sub$4400;
	else if cfCode = 9Bh then
		call sub$4416;
	else if cfCode = 0A3h then
		call sub$442C;
	else if 9Dh <= cfCode and cfCode <= 0A2h then
		call sub$4442;
	else if cfCode = 9Ch then
		b7AE4 = 0;
end;
end;
