plm0d:
DO;
$include(plm0d.ipx)

getlin: PROCEDURE public;
	DECLARE tmp ADDRESS;

	getSrcLine: PROCEDURE;
		call writeLineInfo;
		inChr$p = .lineBuf;
		call ingetc;
		if inchr = 81H then	/* EOF */
			return;
		trunc = FALSE;
		call rsrcln;
		inchr = CR;
		inChr$p = inChr$p + 1;
		inChr = LF;
		inChr$p = .lineBuf;
		linfo.lineCnt = linfo.lineCnt + 1;
		linfo.stmtCnt, linfo.blkCnt = 0;
		lineInfoToWrite = TRUE;
	end;


	getCodeLine: PROCEDURE;
		DECLARE startOfLine ADDRESS;

		do while (1);
			call getSrcLine;
			if inchr <> ISISEOF then
			do;
				startOfLine = inChr$p + LEFTMARGIN - 1;
				do while inChr$p < startOfLine;
					if inchr = CR then
						return;
					inChr$p = inChr$p + 1;
				end;
				if skippingCOND then
					call doCONDCompile(inChr$p);
				else if inchr = '$' then
				do;
					call wrByte(L$STMTCNT);
					call wrWord(0);
					if trunc then
					do;
						call syntaxError(ERR86);	/* LIMIT EXCEEDED: SOURCE LINE LENGTH */
						trunc = FALSE;
					end;
					call do$Control(inChr$p);
				end;
				else
				do;
					isNonCtrlLine = TRUE;
					return;
				end;
			end;
			else if srcFileIdx = 0 then
			do;
				if ifDepth <> 0 then
					call syntaxError(ERR188);	/* MISPLACED RESTORE OPTION */
				inChr$p = .('/*',27h,'/**/EOF   ');
				return;
			end;
			else
			do;
				call closef(.srcFil);
				srcFileIdx = srcFileIdx - 10;
				call initf(.srcFil, .('SOURCE'), .srcFileTable(srcFileIdx));
				call openf(.srcFil, 1);
				call seekf(.srcFil, .srcFileTable(srcFileIdx + 8));
				ocurch = olstch;
			end;
		end;
	end;




	if macroDepth <> 0 then
	do;
		tmp = curInfo$p;
		curInfo$p = curMacroInfo$p;
		call setType(0);
		curMacroInfo$p = macroPtrs(macroDepth + 1);
		inChr$p = macroPtrs(macroDepth);
		macroDepth = macroDepth - 2;
		curInfo$p = tmp;
	end;
	else
		call getCodeLine;
end;


END;
