plm0d:
DO;
DECLARE LIT LITERALLY 'LITERALLY',
	CR LIT '0DH',
	LF LIT '0AH',
	TRUE LIT '0FFH',
	FALSE LIT '0',
	ISISEOF LIT '81h';

$include(:f3:err.inc)
$include(:f3:lex.inc)

DECLARE trunc BYTE EXTERNAL;

$include(:f3:data.inc)

DECLARE macroPtrs(1) ADDRESS EXTERNAL,	/* doesn't use structure here */
	macroDepth ADDRESS EXTERNAL,
	curMacroInfo$p ADDRESS EXTERNAL,
	inChr$p ADDRESS EXTERNAL,
	lineBuf(1) BYTE EXTERNAL,
	ifDepth ADDRESS EXTERNAL,
	isNonCtrlLine BYTE EXTERNAL,
	inChr BASED inChr$p BYTE,
	lineInfoToWrite BYTE EXTERNAL,
	ocurch ADDRESS EXTERNAL,
	olstch ADDRESS EXTERNAL,
	skippingCOND BYTE EXTERNAL,
	linfo STRUCTURE(type BYTE, lineCnt ADDRESS, stmtCnt ADDRESS, blkCnt ADDRESS) EXTERNAL;

ingetc: PROCEDURE EXTERNAL; end;
rsrcln: PROCEDURE EXTERNAL; end;
doCONDCompile: PROCEDURE(p) EXTERNAL; DECLARE p ADDRESS; end;
do$Control: PROCEDURE(p) EXTERNAL; DECLARE p ADDRESS; end;
wrByte: PROCEDURE(val) EXTERNAL; DECLARE val BYTE; end;
wrWord: PROCEDURE(val) EXTERNAL; DECLARE val ADDRESS; end;
writeLineInfo: PROCEDURE EXTERNAL; end;

$include(:f3:sitype.pex)
$include(:f3:initf.pex)
$include(:f3:openf.pex)
$include(:f3:closef.pex)
$include(:f3:seekf.pex)

syntaxError: PROCEDURE(err) EXTERNAL; DECLARE err BYTE; end;


getlin: PROCEDURE public;
	DECLARE tmp ADDRESS;

	getSrcLine: PROCEDURE;
		call writeLineInfo;
		inChr$p = .lineBuf;
		call ingetc;
		if inchr = 81H then	/* EOF */
			return;
		trunc = FALSE;
		call rsrcln;
		inchr = CR;
		inChr$p = inChr$p + 1;
		inChr = LF;
		inChr$p = .lineBuf;
		linfo.lineCnt = linfo.lineCnt + 1;
		linfo.stmtCnt, linfo.blkCnt = 0;
		lineInfoToWrite = TRUE;
	end;


	getCodeLine: PROCEDURE;
		DECLARE startOfLine ADDRESS;

		do while (1);
			call getSrcLine;
			if inchr <> ISISEOF then
			do;
				startOfLine = inChr$p + LEFTMARGIN - 1;
				do while inChr$p < startOfLine;
					if inchr = CR then
						return;
					inChr$p = inChr$p + 1;
				end;
				if skippingCOND then
					call doCONDCompile(inChr$p);
				else if inchr = '$' then
				do;
					call wrByte(L$STMTCNT);
					call wrWord(0);
					if trunc then
					do;
						call syntaxError(ERR86);	/* LIMIT EXCEEDED: SOURCE LINE LENGTH */
						trunc = FALSE;
					end;
					call do$Control(inChr$p);
				end;
				else
				do;
					isNonCtrlLine = TRUE;
					return;
				end;
			end;
			else if srcFileIdx = 0 then
			do;
				if ifDepth <> 0 then
					call syntaxError(ERR188);	/* MISPLACED RESTORE OPTION */
				inChr$p = .('/*',27h,'/**/EOF   ');
				return;
			end;
			else
			do;
				call closef(.srcFil);
				srcFileIdx = srcFileIdx - 10;
				call initf(.srcFil, .('SOURCE'), .srcFileTable(srcFileIdx));
				call openf(.srcFil, 1);
				call seekf(.srcFil, .srcFileTable(srcFileIdx + 8));
				ocurch = olstch;
			end;
		end;
	end;




	if macroDepth <> 0 then
	do;
		tmp = curInfo$p;
		curInfo$p = curMacroInfo$p;
		call setType(0);
		curMacroInfo$p = macroPtrs(macroDepth + 1);
		inChr$p = macroPtrs(macroDepth);
		macroDepth = macroDepth - 2;
		curInfo$p = tmp;
	end;
	else
		call getCodeLine;
end;


END;
