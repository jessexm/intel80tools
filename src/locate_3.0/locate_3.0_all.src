locate.pex
lit             'literally'

/* Seek modes */
SeekTELL        '0'
SeekBCK         '1'
SeekABS         '2'
SeekFWD         '3'
SeekEND         '4'

ERR2            '2' /* ILLEGAL AFTN ARGUMENT */
ERR3            '3' /* TOO MANY OPEN FILES */
ERR4            '4' /* INCORRECTLY SPECIFIED FILE */
ERR5            '5' /* UNRECOGNIZED DEVICE NAME */
ERR9            '9' /* DISK DIRECTORY FULL */
ERR12           '12' /* FILE IS ALREADY OPEN */
ERR13           '13' /* NO SUCH FILE */
ERR14           '14' /* WRITE PROTECTED */
ERR17           '17' /* NOT A DISK FILE */
ERR19           '19' /* ATTEMPTED SEEK ON NON-DISK FILE */
ERR20           '20' /* ATTEMPTED BACK SEEK TOO FAR */
ERR21           '21' /* CAN'T RESCAN */
ERR22           '22' /* ILLEGAL ACCESS MODE TO OPEN */
ERR23           '23' /* MISSING FILENAME */
ERR27           '27' /* ILLEGAL SEEK COMMAND */
ERR28           '28' /* MISSING EXTENSION */
ERR31           '31' /* CAN'T SEEK ON WRITE ONLY FILE */
ERR32           '32' /* CAN'T DELETE OPEN FILE */
ERR35           '35' /* SEEK PAST EOF */
ERR203          '203' /* INVALID SYNTAX */
ERR204          '204' /* PREMATURE EOF */
ERR208          '208' /* CHECKSUM ERROR */
ERR210          '210' /* INSUFFICIENT MEMORY */
ERR211          '211' /* RECORD TOO LONG */
ERR212          '212' /* ILLEGAL RELO RECORD */
ERR213          '213' /* FIXUP BOUNDS ERROR */
ERR218          '218' /* ILLEGAL RECORD FORMAT */
ERR224          '224' /* BAD RECORD SEQUENCE */
ERR225          '225' /* INVALID NAME */
ERR226          '226' /* NAME TOO LONG */
ERR227          '227' /* LEFT PARENTHESIS EXPECTED */
ERR228          '228' /* RIGHT PARENTHESIS EXPECTED */
ERR229          '229' /* UNRECOGNIZED CONTROL */
ERR233          '233' /* 'TO' EXPECTED */
ERR237          '237' /* COMMON NOT FOUND */
ERR238          '238' /* ILLEGAL STACK CONTENT RECORD */
ERR239          '239' /* NO MODULE HEADER RECORD */
ERR240          '240' /* PROGRAM EXCEEDS 64K */

/* Record types */
R$MODHDR        '2'
R$MODEND        '4'
R$MODDAT        '6'
R$LINNUM        '8'
R$MODEOF        '0EH'
R$ANCEST        '10H'
R$LOCDEF        '12H'
R$PUBDEF        '16H'
R$EXTNAM        '18H'
R$FIXEXT        '20H'
R$FIXLOC        '22H'
R$FIXSEG        '24H'
R$LIBLOC        '26H'
R$LIBNAM        '28H'
R$LIBDIC        '2AH'
R$LIBHDR        '2CH'
R$COMDEF        '2EH'

/* Segments */
SABS            '0'
SCODE           '1'
SDATA           '2'
SSTACK          '3'
SMEMORY         '4'
SRESERVED       '5'
SNAMED          '6'	/* through 254 */
SBLANK          '255'

/* Alignments  & Flags*/
AMASK           '0FH'
AABS            '0'
AUNKNOWN        '0'
AINPAGE         '1'
APAGE           '2'
ABYTE           '3'
FHASADDR        '080H'
FWRAP0          '40H'
FSEGSEEN        '10H'

/* Fixup type */
FLOW            '1'
FHIGH           '2'
FBOTH           '3'

TRUE            '0FFH'
FALSE           '0'

/* controls seen tags */
startSeen       'seen(0)'
stackSizeSeen   'seen(1)'
restart0Seen    'seen(2)'
MapSeen         'seen(3)'
PublicsSeen     'seen(4)'
SymbolsSeen     'seen(5)'
LinesSeen       'seen(6)'
PurgeSeen       'seen(7)'
moduleNameSeen  'seen(8)'


/* user types */
SPATH$T         'STRUCTURE (SPATH$T1,SPATH$T2)'
SPATH$T1        'deviceId BYTE, name(6) BYTE, ext(3) BYTE'
SPATH$T2        'deviceType BYTE, driveType BYTE'
DATAFRAG$T      'STRUCTURE (saddr ADDRESS, eaddr ADDRESS)'
SEGFRAG$T       'STRUCTURE (flags BYTE, seg BYTE, start ADDRESS, len ADDRESS)'
PAGE1$T         'STRUCTURE (state BYTE, mpage BYTE)'
PAGE2$T         'STRUCTURE (pageIdx BYTE, fileIdx BYTE)'
RECORD$T        'STRUCTURE (rectyp BYTE, reclen ADDRESS, record(1) BYTE)'

/* based vars */
cmdbuf          BS..cmd$p
cmdch           B..cmd$p
erec            B..erec$p
inRecord        "RECORD$T"..inRecord$p
lsout           "RECORD$T"..lsout$p
outRecord       "RECORD$T"..outRecord$p
pageTab1        "PAGE1$T"(256)..pageTab1$p
pageTab2        "PAGE2$T"(256)..pageTab2$p

$file(system.lib)
isis            P(B rectyp,A parameter$ptr)
memck           PA
rescan          P(A conn,A status$p)
spath           P(A path$p,A info$p,A status$p)

$file(isis.plm)
Close           P(A conn,A status$p)
Delete          P(A path$p,A status$p)
Error           P(A Error$num)
Exit            P
Open            P(A conn$p,A path$p,A access,A echo,A status$p)
Read            P(A conn,A buff$p,A count,A actual$p,A status$p)
Seek            P(A conn,A mode,A block$p,A byte$p,A status$p)
Write           P(A conn,A buff$p,A count,A status$p)

$file(loc1.plm)
actRead         A
aRecordType     BS
baseMemImage    A
botHeap         A
columns         B
crlf            BS
curDataFrag$p   A
curSegFrag$p    A
eibuf$p         A
eout$p          A
epbuf$p         A
erec$p          A
havePagingFile  B
ibuf$p          A
inBlk           A
inb$p           A
inByt           A
inCRC           B
inFileName      BS
inFragment      "DATAFRAG$T"
in$p            A
inRecord$p      A
isMain          B
modhdr$x1       B
modhdr$x2       B
moduleName      BS
nextDataFrag$p  A
nextSegFrag$p   A
npbuf           A
nxtPageNo       B
outFileName     BS
out$p           A
outputfd        A
outRealFile     B
outRecord$p     A
pageCacheSize   B
pageIndexTmpFil B
pageTab1$p      A
pageTab2$p      A
pbuf$p          A
printfd         A
printFileName   BS
Readfd          A
recLen          A
recNum          A
roundRobinIndex B
seen            BS
segBases        AS
segFlags        BS
segOrder        BS
segSizes        AS
sibuf$p         A
spbuf$p         A
startAddr       A
statusIO        A
tmpfd           A
tmpFileName     BS
topDataFrags    A
topHeap         A
usePrintBuf     B
VERSION         BS
AddDataFrag     P(A saddr,A eaddr)
AddrInCache     P(A addr)A
AddSegFrag      P(B flags,B seg,A start,A len)
Alloc           P(A cnt)
AllocNewPage    P(B page)A
AnotherPage     P(B page)
BadRecordSeq    P
ChkRead         P(A cnt)
ConAndPrint     P(A buf,A cnt)
ConStrOut       P(A buf,A cnt)
FatalErr        P(B errCode)
FlushPrintBuf   P
GetRecord       P
IllegalRecord   P
IllegalReloc    P
ObjSeek           P(A blk,A byt)
LoadModdat      P(B segId)
PageOut         P(B page,A bufp)
PrintCrLf       P
PrintString     P(A bufp,A cnt)
PStrcpy         P(A psrc,A pdst)
SeekPagingFile  P(B para)

$file(loc2a.plm)
Errmsg          P(A errCode)

$file(loc2b.plm)
alin            BS
aMod            BS
aPub            BS
aReadFromFile   BS
aReferenceToUns BS
aSym            BS
aSymbol         BS
aSymbolTableOfM BS
aUnsatisfiedExt BS
aValueType      BS
aWrittenToFile  BS
curcol          B
curColumn       A
curListField    A
loHiBoth        B
lsout$p         A
nameLen         B
outSegType      B
spc32           BS
unsatisfiedCnt  A
workingSegBase  A
x5              BS
EmitModDat      P(A curDataFrag$p)
EndRecord       P
FlushOut        P
ForceSOL        P
InitRecOut      P(B rectyp)
PrintColumn     P(A field,A pstr)
ProcModdat      P
ProcModend      P
SeekOutFile     P(A mode,A pblk,A pbyt)
SetWorkingSeg   P(B seg)B
WriteBytes      P(A buf$p,A cnt)

$file(loc3.plm)
FixupBoundsChk  P(A addr)
LocateFile      P
PrintListingHeader P(A buf,A len)
ProcAncest      P
ProcDefs        P(B list,A template)
ProcExtnam      P
ProcLinnum      P

$file(loc4.plm)
a0LengthSegment BS
aAddresses      BS
alignNames      BS
aMemoryMapOfMod BS
aMemOverlap     BS
aModuleIsNotAMa BS
aModuleStartAdd BS
aRestartControl BS
aStartControlIg BS
aStartStopLengt BS
segNames        BS
GetCommonName   P(B segid)A
PrintMemoryMap  P
SkipSpc         P(A pch)A

$file(loc4a.plm)
ErrChkReport    P(A errCode,A file,B errExit)

$file(loc5a.plm)
BinAsc          P(A number,B base,B pad,A bufp,B ndigits)
PastAFN         P(A pch)A

$file(loc5b.plm)
PastFileName    P(A pch)A

$file(loc6.plm)
aCommandTailErr BS
aInvokedBy      BS
cin             BS
cmd$p           A
controls        BS
cout            BS
mdebug          BS
mstar2          BS
mto             BS
mtoand          BS
scmd$p          A
signonMsg       BS
spathInfo       "SPATH$T"
tmpFileInfo     BS
CmdErr          P(A err)
ErrNotADisk     P
ExpectChar      P(B ch,B err)
ExpectLP        P
ExpectRP        P
ExpectSlash     P
GetFile         P
GetpstrName     P(A pstr)
InitSegOrder    P
ProcessControls P
SkipNonArgChars P(A pch)

$file(loc7.plm)
aInpageSegment2 BS
nxtSegOrder     B
pad7935         BS
segId           B
GetCommonSegId  PB
InsSegIdOrder   P(B seg)
ParseLPNumRP    PA
ProcArgsInit   P
ProcComdef      P
ProcHdrAndComDef P
ProcModhdr      P
ReadCmdLine     P

$file(loc8.plm)
MakeFullName    P(A pinfo,A pstr)
StrUpr          P(A pch)

$file(loc8a.plm)
ParseNumber     P(A ppstr)A
Strequ          P(A pstr1,A pstr2,B len)B

$file(loc9.plm)
ToUpper         P(B ch)B

$file(memmov.asm)
mem$mov         P(A cnt,A src,A dst)

isis.plm
isissub:
DO;
DECLARE LIT LITERALLY 'LITERALLY',
	IOpen LIT	'0',
	IClose LIT	'1',
	IDelete LIT	'2',
	IRead LIT	'3',
	IWrite LIT	'4',
	ISeek LIT	'5',
	ILOAD LIT	'6',
	IRENAME LIT	'7',
	ICONSOL LIT	'8',
	IExit LIT	'9',	
	IATTRIB LIT	'10',
	IRESCAN LIT	'11',
	IError LIT	'12',
	IWHOCON LIT	'13',
	ISPATH LIT	'14';

$include(isis.ipx)

Close: procedure (conn, status$p) public;
    declare (conn, status$p) address;
    CALL ISIS(IClose, .conn);
end Close;

Delete: procedure (path$p, status$p) public;
    declare (path$p, status$p) address;
    CALL ISIS(IDelete, .path$p);
end Delete;

Error: procedure (Error$num) public;
    declare (Error$num) address;
    declare err address;
    err = .err;
    CALL ISIS(IError, .Error$num);
end Error;

Exit: procedure public;
	DECLARE Exitarg ADDRESS;
	Exitarg = .Exitarg;
	CALL ISIS(IExit, .Exitarg);
end Exit;


Open: procedure (conn$p, path$p, access, echo, status$p) public;
    declare (conn$p, path$p, access, echo, status$p) address;
    CALL ISIS(IOpen, .conn$p);
end Open;


Read: procedure (conn, buff$p, count, actual$p, status$p) public;
    declare (conn, buff$p, count, actual$p, status$p) address;
    CALL ISIS(IRead, .conn);
end Read;

Seek: procedure (conn, mode, block$p, byte$p, status$p) public;
    declare (conn, mode, block$p, byte$p, status$p) address;
    CALL ISIS(ISeek, .conn);
end Seek;

Write: procedure (conn, buff$p, count, status$p) public;
    declare (conn, buff$p, count, status$p) address;
    CALL ISIS(IWrite, .conn);
end Write;



END;
loc1.plm
$LIST
$CODE
LOCATE:
DO;
$include(loc1.ipx)

DECLARE COPYRIGHT (*) BYTE DATA ('(C) 1976, 1977, 1979 INTEL CORP');
DECLARE VERSION (*) BYTE PUBLIC DATA ('V3.0');
DECLARE NULLREC (*) BYTE DATA (0,0,0);
DECLARE PageOutOffset ADDRESS DATA (0);
DECLARE PageOutOffset$b STRUCTURE (lobyt BYTE, hibyt BYTE) AT (.PageOutOffset);
DECLARE cachePageOffset ADDRESS DATA (0);
DECLARE cachePageOffset$b STRUCTURE (lobyt BYTE, hibyt BYTE) AT (.cachePageOffset);


DECLARE (Readfd, outputfd, printfd, tmpfd, statusIO, actRead) ADDRESS PUBLIC,
	inFileName (16) BYTE PUBLIC, outFileName (16) BYTE PUBLIC,
	printFileName (16) BYTE PUBLIC, tmpFileName (16) BYTE PUBLIC,
	columns BYTE PUBLIC,
	seen(9) BYTE PUBLIC,	/* START, STACK, RESTART0, MAP, PUBLICS, SYMBOLS, LINES, PURGE, NAME */
	moduleName(32) BYTE PUBLIC,
	isMain BYTE PUBLIC,
	modhdr$x1 BYTE PUBLIC,
	modhdr$x2 BYTE PUBLIC,
	startAddr ADDRESS PUBLIC,
	segOrder(255) BYTE PUBLIC,
	segBases(256) ADDRESS PUBLIC,	/* abs, code, data */
	segSizes(256) ADDRESS PUBLIC,
	segFlags(256) BYTE PUBLIC,
	inRecord$p ADDRESS PUBLIC,
	erec$p ADDRESS PUBLIC,
	in$p ADDRESS PUBLIC,
	recNum ADDRESS PUBLIC,
	recLen ADDRESS PUBLIC,
	npbuf ADDRESS PUBLIC,
	sibuf$p ADDRESS PUBLIC,
	ibuf$p ADDRESS PUBLIC,
	eibuf$p ADDRESS PUBLIC,
	outRecord$p ADDRESS PUBLIC,
	out$p ADDRESS PUBLIC,
	eout$p ADDRESS PUBLIC,
	spbuf$p ADDRESS PUBLIC,
	pbuf$p ADDRESS PUBLIC,
	epbuf$p ADDRESS PUBLIC,
	topHeap ADDRESS PUBLIC,
	topDataFrags ADDRESS PUBLIC,
	curSegFrag$p ADDRESS PUBLIC,
	nextSegFrag$p ADDRESS PUBLIC,
	botHeap ADDRESS PUBLIC,
	curDataFrag$p ADDRESS PUBLIC,
	nextDataFrag$p ADDRESS PUBLIC,
	inFragment DATAFRAG$T PUBLIC,
	usePrintBuf BYTE PUBLIC,
	outRealFile BYTE PUBLIC,
	baseMemImage ADDRESS PUBLIC,
	havePagingFile BYTE PUBLIC,
	pageCacheSize BYTE PUBLIC,
	roundRobinIndex BYTE PUBLIC,
	nxtPageNo BYTE PUBLIC,
	pageIndexTmpFil BYTE PUBLIC,
	pageTab1$p ADDRESS PUBLIC,
	pageTab2$p ADDRESS PUBLIC;

DECLARE	crlf(2) BYTE PUBLIC INITIAL(0DH, 0AH),
	aRecordType(*) BYTE PUBLIC INITIAL(' RECORD TYPE XXH, RECORD NUMBER *****', 0Dh, 0Ah),
	(inBlk, inByt) ADDRESS PUBLIC INITIAL(0,0),
	inb$p ADDRESS PUBLIC,
	inCRC BYTE PUBLIC;

/* explicit based vars as base is defined after include */
declare	inRecord based inRecord$p RECORD$T,
	pageTab1 based pageTab1$p (256) PAGE1$T,
	pageTab2 based pageTab2$p (256) PAGE2$T;

ConStrOut: PROCEDURE(buf, cnt) PUBLIC;
	DECLARE (buf, cnt) ADDRESS;
	CALL Write(0, buf, cnt, .statusIO);
END ConStrOut;


FlushPrintBuf: PROCEDURE PUBLIC;
	IF usePrintBuf THEN	/* only process if buffered print */
	DO;
		CALL Write(printfd, spbuf$p, pbuf$p - spbuf$p, .statusIO);
		CALL ErrChkReport(statusIO, .printFileName(1), TRUE);
	END;
	pbuf$p = spbuf$p;	/* rest buffer pointer */
END FlushPrintBuf;


FatalErr: PROCEDURE(errCode) PUBLIC;
	DECLARE errCode BYTE;

	CALL FlushPrintBuf;
	CALL ConStrOut(.(' '), 1);
	CALL ConStrOut(.inFileName(1), inFileName(0));
	CALL ConStrOut(.(','), 1);
	CALL Errmsg(errCode);
	CALL BinAsc(inRecord.rectyp, 16, '0', .aRecordType(13), 2);
	IF recNum > 0 THEN
		CALL BinAsc(recNum, 10, ' ', .aRecordType(32), 5);
	CALL ConStrOut(.aRecordType, 39); 
	CALL Exit;
END FatalErr;


IllegalRecord: PROCEDURE PUBLIC;
	CALL FatalErr(ERR218);	/* Illegal Record Format */
END IllegalRecord;


IllegalReloc: PROCEDURE PUBLIC;
	CALL FatalErr(ERR212);	/* Illegal Relo Record */
END IllegalReloc;


BadRecordSeq: PROCEDURE PUBLIC;
	CALL FatalErr(ERR224);	/* Bad Record Sequence */
END BadRecordSeq;


PStrcpy: PROCEDURE(psrc, pdst) PUBLIC;	/* copy pascal style string */
	DECLARE (psrc, pdst) ADDRESS;
	DECLARE src BASED psrc (1) BYTE;
	
	CALL mem$mov(src(0) + 1, psrc, pdst);
END PStrcpy;


PrintString: PROCEDURE(bufp, cnt) PUBLIC;
	DECLARE bufp ADDRESS;
	DECLARE cnt ADDRESS;
	DECLARE bcnt ADDRESS;

	IF usePrintBuf THEN	/* using buffer ? */
	DO;
		bcnt = epbuf$p - pbuf$p; 	/* space in buffer */
		DO WHILE cnt > bcnt;		/* not enough room for all chars */
			CALL mem$mov(bcnt, bufp, pbuf$p);	/* copy what we can */
			cnt = cnt - bcnt;	/* adjust what is left */
			bufp = bufp + bcnt;	/* advance position in the src string */
			pbuf$p = pbuf$p + bcnt;	/* and the print buffer position */
			CALL FlushPrintBuf;	/* Write the buffer */
			bcnt = npbuf;		/* reset to the buffer size */
		END;
		CALL mem$mov(cnt, bufp, pbuf$p); /* copy the remaining chars */
		pbuf$p = pbuf$p + cnt;		/* advance the print buf ptr */
	END;
	ELSE
	DO;	/* just use the operating system functions */
		CALL Write(printfd, bufp, cnt, .statusIO);
		CALL ErrChkReport(statusIO, .printFileName(1), TRUE);
	END;
END PrintString;


PrintCrLf: PROCEDURE PUBLIC;
	CALL PrintString(.crlf, 2);
END PrintCrLf;


ConAndPrint: PROCEDURE(buf, cnt) PUBLIC;
	DECLARE (buf, cnt) ADDRESS;
	CALL PrintString(buf, cnt);
	IF printfd > 0 THEN	/* make sure always seen on console */
		CALL ConStrOut(buf, cnt);
END ConAndPrint;


ChkRead: PROCEDURE(cnt) PUBLIC;
	DECLARE cnt ADDRESS;
	DECLARE bcnt ADDRESS;

	IF (bcnt := eibuf$p - ibuf$p) < cnt THEN	/* data alReady in buffer */
	DO;
		CALL mem$mov(bcnt, ibuf$p, sibuf$p);	/* move down bytes in buffer */
		CALL Read(Readfd, sibuf$p + bcnt, npbuf - bcnt, .actRead, .statusIO);
		CALL ErrChkReport(statusIO, .inFileName(1), TRUE);
		inBlk = inBlk + (inByt + ibuf$p - sibuf$p) / 128;
		inByt = (inByt + ibuf$p - sibuf$p) MOD 128;
		IF (bcnt := bcnt + actRead) < cnt THEN
			CALL ErrChkReport(ERR204, .inFileName(1), TRUE);  /* Premature EOF */
		eibuf$p = (ibuf$p := sibuf$p) + bcnt;
	END;
END ChkRead;

GetRecord: PROCEDURE PUBLIC;
	DECLARE ch BASED inb$p BYTE;
	DECLARE bcnt ADDRESS;
	DECLARE erec BASED erec$p BYTE;

	IF (bcnt := eibuf$p - ibuf$p) >= 4 THEN
	DO;
		inRecord$p = ibuf$p;
		erec$p = inRecord$p + inRecord.reclen + 2;
	END;
	ELSE
	DO;
		inRecord$p = .NULLREC;	/* scratch area */
		erec$p = 0FFFFH;
	END;
	IF erec$p >= eibuf$p THEN
	DO;
		IF inRecord.reclen <= 1025 THEN
		DO;
			CALL ChkRead(bcnt + 1);
			inRecord$p = ibuf$p;
			IF (erec$p := inRecord$p + inRecord.reclen + 2) >= eibuf$p THEN
				CALL ErrChkReport(ERR204, .inFileName(1), TRUE);	/* premature EOF */
		END;
	END;
	recLen = inRecord.reclen;
	in$p = inRecord$p + 3;
	ibuf$p = erec$p + 1;	/* update for next record */
	recNum = recNum + 1;
	IF inRecord.rectyp > R$COMDEF OR inRecord.rectyp THEN	/* > 2EH or odd */
		CALL IllegalReloc;
	IF inRecord.rectyp = R$MODDAT THEN
		RETURN;
	IF recLen > 1025 THEN
		CALL FatalErr(ERR211);	/* Record too long */
	inCRC = 0;
	DO inb$p = inRecord$p TO .erec;
		inCRC = inCRC + ch;
	END;
	IF inCRC <> 0 THEN
		CALL FatalErr(ERR208);	/* checksum Error */
END GetRecord;


ObjSeek: PROCEDURE(blk, byt) PUBLIC;
	DECLARE (blk, byt) ADDRESS;

	recNum = 0;		/* reset record number */
	IF  inBlk <= blk AND blk <= inBlk + (inByt + (eibuf$p - sibuf$p)) / 128 THEN
		IF (ibuf$p := sibuf$p + (blk - inBlk) * 128 + (byt - inByt)) >= sibuf$p
		    AND ibuf$p < eibuf$p THEN
			RETURN;
	CALL Seek(Readfd, SeekABS, .blk, .byt, .statusIO);
	CALL ErrChkReport(statusIO, .inFileName(1), TRUE);
	ibufp = eibufp;
	CALL ChkRead(1);	/* Read the buffer */
	inBlk = blk;
	inByt = byt;
END ObjSeek;



SeekPagingFile: PROCEDURE(para) PUBLIC;
	DECLARE para BYTE;
	DECLARE blk ADDRESS;
	
	blk = DOUBLE(para) + DOUBLE(para);
	CALL Seek(tmpfd, SeekABS, .blk, .(0,0), .statusIO);
	CALL ErrChkReport(statusIO, .tmpFileName(1), TRUE);
END SeekPagingFile;


PageOut: PROCEDURE(page, bufp) PUBLIC;
	DECLARE page BYTE;
	DECLARE bufp ADDRESS;
	DECLARE pt ADDRESS, t BASED pt STRUCTURE (pageIdx BYTE, fileIdx BYTE);

	pt = .pageTab2(page);
	IF t.fileIdx = 0FFH THEN	/* not used */
	DO;
		t.fileIdx = pageIndexTmpFil;	/* record location in tmp file */
		pageIndexTmpFil = pageIndexTmpFil + 1;
	END;
	CALL SeekPagingFile(t.fileIdx);
	CALL Write(tmpfd, bufp, 256, .statusIO);	/* Write the page out */
	CALL ErrChkReport(statusIO, .tmpFileName(1), TRUE);
	t.pageIdx = 0FEH;	/* flag as paged out */
END PageOut;


AnotherPage: PROCEDURE(page) PUBLIC;
	DECLARE page BYTE;
	DECLARE i BYTE;
	

	IF usePrintBuf THEN	/* use print buffer space */
	DO;
		CALL FlushPrintBuf;	/* flush the buffer */
		usePrintBuf = FALSE;	/* no longer available */
		/* move the heap up */
		CALL mem$mov(topHeap - botHeap, botHeap, botHeap + npbuf);
		/* adjust the topheap and the start/cur print buf addresses */
		spbuf$p, pbuf$p, topheap = epbuf$p;
		/* adjust the descriptor pointers */
		topDataFrags = topDataFrags + npbuf;
		curSegFrag$p = curSegFrag$p + npbuf;
		curDataFrag$p = curDataFrag$p + npbuf;
		/* page Allocated is first after the current max pageCacheSize */
		nxtPageNo = pageCacheSize + 1;
		/* increase the pageCacheSize available */
		pageCacheSize = HIGH((botHeap := botHeap + npbuf) - baseMemImage) - 1;
		RETURN;
	END;
	IF NOT havePagingFile THEN	/* have to page, create file if not done */
	DO;
		havePagingFile = TRUE;
		CALL Delete(.tmpFileName(1), .statusIO);
		CALL Open(.tmpfd, .tmpFileName(1), 3, FALSE, .statusIO);
		CALL ErrChkReport(statusIO, .tmpFileName(1), TRUE);
	END;

	pageTab1(page).state = 0FFH;	/* mark this page as now free */
	i = pageTab1(page).mpage;	/* get the current target page stored here */
	PageOutOffset$b.hibyt = page;
	CALL PageOut(i, baseMemImage + PageOutOffset);
END AnotherPage;


AllocNewPage: PROCEDURE(page) ADDRESS PUBLIC;
	DECLARE page BYTE;

	DO nxtPageNo = 0 TO pageCacheSize;		/* see if free page */
		IF pageTab1(nxtPageNo).state THEN	/* one is free */
			GOTO found;
	END;
	IF roundRobinIndex > pageCacheSize THEN		/* manage roundRobin for paging to disk */
		roundRobinIndex = 0;
	nxtPageNo = roundRobinIndex;
	CALL AnotherPage(roundRobinIndex);		/* get a page */
	IF nxtPageNo = roundRobinIndex  THEN	/* if the roundRobin page then we didn't get from printbuf reuse */
		roundRobinIndex = roundRobinIndex + 1;	/* so manage the roundRobin counter */
found:
	pageTab1(nxtPageNo).state = 0;	/* no longer free */
	pageTab1(nxtPageNo).mpage = page;	/* record the memory page located here */
	pageTab2(page).pageIdx = nxtPageNo;	/* save the mapping */
	cachePageOffset$b.hibyt = nxtPageNo;
	RETURN baseMemImage + cachePageOffset;		/* return the pointer in memory */
END AllocNewPage;


/* convert a target address into its current location in cache */
AddrInCache: PROCEDURE(addr) ADDRESS PUBLIC;
	DECLARE addr ADDRESS;
	DECLARE baddr ADDRESS;
	DECLARE (lobyt, hibyt) BYTE AT(.baddr);
	DECLARE pt ADDRESS;
	DECLARE t BASED pt STRUCTURE (pageIdx BYTE, fileIdx BYTE);

	pt = .pageTab2(HIGH(addr));
	IF t.pageIdx = 0FFH THEN	/* needs Allocating */
		RETURN AllocNewPage(HIGH(addr)) + LOW(addr);
	IF t.pageIdx = 0FEH THEN	/* on disk */
	DO;
		baddr = AllocNewPage(HIGH(addr));	/* Alloc page in cache */
		CALL SeekPagingFile(t.fileIdx);		/* Seek to its place in the paging file */
		CALL Read(tmpfd, baddr, 256, .actRead, .StatusIO);	/* Read in */
		CALL ErrChkReport(statusIO, .tmpFileName(1), TRUE);
		IF actRead <> 256 THEN			/* if problems and not :BB: out file then Error */
			IF outRealFile THEN
				CALL ErrChkReport(ERR204, .tmpFileName(1), TRUE);    /* premature EOF */
		RETURN baddr + LOW(addr);		/* return the mapped address */
	END;
	hibyt = t.pageIdx;		/* page offset in cache */
	lobyt = LOW(addr);		/* offset in page */
	RETURN baseMemImage + baddr;	/* mapped address */
END AddrInCache;


Alloc: PROCEDURE(cnt) PUBLIC;
	DECLARE cnt ADDRESS;

	/* Allocate but check whether we have crossed a page boundary */
	IF HIGH(botHeap - baseMemImage) <> HIGH((botHeap := botHeap - cnt) - baseMemImage) THEN
	DO;
		IF NOT pageTab1(pageCacheSize).state THEN	/* if current cache all used, try forcing using print buf */
			CALL AnotherPage(PageCacheSize);	/* or paging the last page to disk */

		IF (pageCacheSize := HIGH(botHeap - baseMemImage) - 1) = 0FFH THEN	/* check we haven't eliminated all cache */
			CALL ErrChkReport(ERR210, .inFileName(1), TRUE);	/* Insufficient memory */
	END;
END Alloc;


AddSegFrag: PROCEDURE(flags, seg, start, len) PUBLIC;
	DECLARE (flags, seg) BYTE;
	DECLARE (start, len) ADDRESS;
	DECLARE curSegFrag BASED curSegFrag$p SEGFRAG$T;
	DECLARE nextSegFrag BASED nextSegFrag$p SEGFRAG$T;

	curSegFrag$p = topHeap;

	DO WHILE curSegFrag$p <> topDataFrags;
		curSegFrag$p = curSegFrag$p - size(curSegFrag);
		IF curSegFrag.start > start THEN
			IF start + len = curSegFrag.start AND curSegFrag.seg = seg THEN /* does the new frag join the curfrag */
			DO;	/* merge the blocks */
				curSegFrag.start = start;
				curSegFrag.len = curSegFrag.len + len;
				RETURN;
			END;
			ELSE
				GOTO break;
		ELSE IF curSegFrag.start + curSegFrag.len = start THEN	/* does the curFrag join the new frag */
			IF curSegFrag.seg = seg THEN			/* segs must be same */
			DO;
				curSegFrag.len = curSegFrag.len + len;	/* merge the lengths */
				IF curSegFrag$p <> topDataFrags THEN	/* if not at the end of list see if this joins the next one */
				DO;
					nextSegFrag$p = curSegFrag$p - size(nextSegFrag);
					IF nextSegFrag.start = curSegFrag.start + curSegFrag.len AND nextSegFrag.seg = curSegFrag.seg THEN
					DO;
						curSegFrag.len = curSegFrag.len + nextSegFrag.len;	/* join and Delete extra frag */
						CALL mem$mov(nextSegFrag$p - botHeap, botHeap, botHeap + size(nextSegFrag));
						topDataFrags = topDataFrags + size(curSegFrag);
						botHeap = botHeap + size(curSegFrag);
					END;
				END;
				RETURN;
			END;
	END;
	curSegFrag$p = curSegFrag$p - size(curSegFrag);	/* will insert at end of list */
break:
	CALL Alloc(6);	/* reserve space for the segFrag */
	topDataFrags = topDataFrags - size(curSegFrag);
	CALL mem$mov(curSegFrag$p - botHeap, botHeap + size(curSegFrag), botHeap);	/* create the space in the list */
	curSegFrag.flags = flags;	/* set all of the values */
	curSegFrag.seg = seg;
	curSegFrag.start = start;
	curSegFrag.len = len;
END AddSegFrag;


AddDataFrag: PROCEDURE(saddr, eaddr) PUBLIC;
	DECLARE saddr ADDRESS;
	DECLARE eaddr ADDRESS;
	DECLARE curDataFrag BASED curDataFrag$p DATAFRAG$T;
	DECLARE nextDataFrag BASED nextDataFrag$p DATAFRAG$T;

	curDataFrag$p = topDataFrags;
	DO WHILE curDataFrag$p <> botHeap;
		curDataFrag$p = curDataFrag$p - size(curDataFrag);
		IF curDataFrag.saddr > saddr THEN	/* the curfrag starts above this one */
		DO;
			IF eaddr >= curDataFrag.saddr - 1 THEN	/* does the new frag join or overlap the curent one */
			DO;
				curDataFrag.saddr = saddr;		/* update the start */
				IF eaddr > curDataFrag.eaddr THEN	/* it overlaps */
				DO;
					curDataFrag.eaddr = eaddr;	/* extend the existing */
					nextDataFrag$p = curDataFrag$p - size(curDataFrag);	/* check if more are overlapped */
					DO WHILE curDataFrag$p <> botHeap;
						IF eaddr + 1 < nextDataFrag.saddr THEN	/* no there is a gap all done */
							RETURN;
						IF eaddr + 1 = nextDataFrag.saddr THEN	/* joins so update the end address */
							curDataFrag.eaddr = nextDataFrag.eaddr;
						/* remove the other descriptor if either joined or was overlapped */
						CALL mem$mov(nextDataFrag$p - botHeap, botHeap, botHeap + size(curDataFrag));
						botHeap = botHeap + size(nextDataFrag);
					END;
				END;
				RETURN;
			END;
			ELSE	/* we have a new fragment */
			DO;
				CALL Alloc(4);	/* Alloc more space and insert descriptor above this one */
				CALL mem$mov(curDataFrag$p - botHeap, botHeap + size(curDataFrag), botHeap);
				curDataFrag.saddr = saddr;
				curDataFrag.eaddr = eaddr;
				RETURN;
			END;
		END;
		ELSE	/* check if candidate frag to join / overlap */
		DO;
			IF curDataFrag.saddr = saddr OR saddr - 1 <= curDataFrag.eaddr THEN
			DO;
				IF curDataFrag.eaddr >= eaddr THEN	/* alReady overlapped */
					RETURN;
				curDataFrag.eaddr = eaddr;		/* set new end address */
				nextDataFrag$p = curDataFrag$p - size(curDataFrag);	/* Delete other join/overlapping frags */
				DO WHILE curDataFrag$p <> botHeap;
					IF nextDataFrag.saddr - 1 > eaddr THEN
						RETURN;
					IF nextDataFrag.saddr - 1 = eaddr THEN
						curDataFrag.eaddr = nextDataFrag.eaddr;
					CALL mem$mov(nextDataFrag$p - botHeap, botHeap, botHeap + size(curDataFrag));
					botHeap = botHeap + size(curDataFrag);
				END;
				RETURN;
			END;
		END;	/* IF ELSE */
	END;	/* DO WHILE */

	CALL Alloc(4);
	curDataFrag$p = botHeap;	/* Allocated at new botHeap */
	curDataFrag.saddr = saddr;	/* record the start and end address */
	curDataFrag.eaddr = eaddr;
END AddDataFrag;


LoadModdat: PROCEDURE(segId) PUBLIC;
	DECLARE segId BYTE;
	DECLARE rdata BASED in$p (1) BYTE;
	DECLARE (dataLen, bytes2Read, curLoadAddr) ADDRESS;
	DECLARE curLoadPage BYTE;

	DECLARE ch BASED inb$p BYTE;

	dataLen = recLen - 4;
	inCRC = HIGH(recLen) + 6 + LOW(recLen) + rdata(0) + rdata(1) + rdata(2);
	ibuf$p = ibuf$p + 3;
	IF LOW(curLoadAddr := inFragment.saddr) <> 0 THEN
	DO;
		IF HIGH(curLoadAddr + (bytes2Read := dataLen) - 1) <> HIGH(curLoadAddr) THEN
			bytes2Read = 256 - LOW(curLoadAddr);	/* don't go over page boundary */
		CALL ChkRead(bytes2Read);			/* make sure data is in the buffer */
		DO inb$p = ibuf$p TO ibuf$p + bytes2Read - 1;	/* add the data to the crc */
			inCRC = inCRC + ch;
		END;
		CALL mem$mov(bytes2Read, ibuf$p, AddrInCache(curLoadAddr));	/* copy to the pagecache location */
		dataLen = dataLen - bytes2Read;			/* adjust bytes Read */
		curLoadAddr = curLoadAddr + bytes2Read;
		ibuf$p = ibuf$p + bytes2Read;
	END;
	DO WHILE dataLen >= 256;				/* Read in whole pages */
		CALL ChkRead(256);				/* make sure data in buffer */
		DO inb$p = ibuf$p TO ibuf$p + 255;		/* add to crc */
			inCRC = inCRC + ch;
		END;
		IF segId = SABS AND havePagingFile THEN		/* if abs and paging Write it out to paging file */
								/* there is no fixup involved */
		DO;
			/* if a page cache entry exists then this would be trashed anyway so free up */
			IF pageTab2(curLoadPage := HIGH(curLoadAddr)).pageIdx <= 0FDH THEN
				pageTab1(pageTab2(curLoadPage).pageIdx).state = 0FFH;
			CALL PageOut(curLoadPage, ibuf$p);
		END;
		ELSE						/* copy to the page cache */
			CALL mem$mov(256, ibuf$p, AddrInCache(curLoadAddr));

		dataLen = dataLen - 256;			/* adjust and continue */
		curLoadAddr = curLoadAddr + 256;
		ibuf$p = ibuf$p + 256;
	END;
	IF dataLen > 0 THEN					/* load an remaining into the page cache */
	DO;
		CALL ChkRead(dataLen);
		DO inb$p = ibuf$p TO ibuf$p + dataLen - 1;
			inCRC = inCRC + ch;
		END;
		CALL mem$mov(dataLen, ibuf$p, AddrInCache(curLoadAddr));
		ibuf$p = ibuf$p + dataLen;
	END;
	CALL ChkRead(1);
	ibuf$p = (inb$p := ibuf$p) + 1;
	IF inCRC + ch <> 0 THEN					/* sanity check */
		CALL FatalErr(ERR208);	/* Checksum Error */
END LoadModdat;

main:
	baseMemImage, pageTab2$p = .controls;	/* once we have processed args overWrite area */
	CALL ProcArgsInit;
	CALL LocateFile;
	CALL FlushPrintBuf;
	CALL Close(printfd, .statusIO);
	CALL Exit;

END;
loc2a.plm
locate2a: DO;

$include(loc2a.ipx)

DECLARE	errTab(*) BYTE DATA (
	   2, 'ILLEGAL AFTN ARGUMENT', 0,
	   3, 'TOO MANY OPEN FILES', 0,
	   4, 'INCORRECTLY SPECIFIED FILE', 0,
	   5, 'UNRECOGNIZED DEVICE NAME', 0,
	   9, 'DISK DIRECTORY FULL', 0,
	 0Ch, 'FILE IS ALREADY OPEN', 0,
	 0Dh, 'NO SUCH FILE', 0,
	 0Eh, 'WRITE PROTECTED', 0,
	 11h, 'NOT A DISK FILE', 0,
	 13h, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
	 14h, 'ATTEMPTED BACK SEEK TOO FAR', 0,
	 15h, 'CAN''T RESCAN', 0,
	 16h, 'ILLEGAL ACCESS MODE TO OPEN', 0,
	 17h, 'MISSING FILENAME', 0,
	 1Bh, 'ILLEGAL SEEK COMMAND', 0,
	 1Ch, 'MISSING EXTENSION', 0,
	 1Fh, 'CAN''T SEEK ON WRITE ONLY FILE', 0,
	 20h, 'CAN''T DELETE OPEN FILE', 0,
	 23h, 'SEEK PAST EOF', 0,
	0CBh, 'INVALID SYNTAX', 0,
	0CCh, 'PREMATURE EOF', 0,
	0D0h, 'CHECKSUM ERROR', 0,
	0D2h, 'INSUFFICIENT MEMORY', 0,
	0D3h, 'RECORD TOO LONG', 0,
	0D4h, 'ILLEGAL RELO RECORD', 0,
	0D5h, 'FIXUP BOUNDS ERROR', 0,
	0DAh, 'ILLEGAL RECORD FORMAT', 0,
	0E0h, 'BAD RECORD SEQUENCE', 0,
	0E1h, 'INVALID NAME', 0,
	0E2h, 'NAME TOO LONG', 0,
	0E3h, 'LEFT PARENTHESIS EXPECTED', 0,
	0E4h, 'RIGHT PARENTHESIS EXPECTED', 0,
	0E5h, 'UNRECOGNIZED CONTROL', 0,
	0E9h, '''TO'' EXPECTED', 0,
	0EDh, 'COMMON NOT FOUND', 0,
	0EEh, 'ILLEGAL STACK CONTENT RECORD', 0,
	0EFh, 'NO MODULE HEADER RECORD', 0,
	0F0h, 'PROGRAM EXCEEDS 64K', 0);

Errmsg: PROCEDURE(errCode) PUBLIC;
	DECLARE errCode ADDRESS;
	DECLARE i ADDRESS;
	DECLARE status ADDRESS;
	
	IF LOW(errCode) <> 0 THEN
	DO;
		i = 0;
		DO WHILE i < LENGTH(errTab);
			IF LOW(errCode) = errTab(i) THEN
			DO;
				CALL Write(0, .(' '), 1, .status);
				DO WHILE errTab(i := i + 1) <> 0;
					CALL Write(0, .errTab(i), 1, .status);
				END;
				CALL Write(0, .(0DH, 0AH), 2, .status);
				RETURN;
			END;
			ELSE
			DO;
				DO WHILE errTab(i := i + 1) <> 0;
				END;
				i = i + 1;
			END;
		END;
		CALL Error(errCode);	/* ISIS Error code */
	END;
END Errmsg;

END locate2a;
loc2b.plm
locate2: DO;
$include(loc2b.ipx)

DECLARE aUnsatisfiedExt(*) BYTE PUBLIC INITIAL('UNSATISFIED EXTERNAL(XXXXX) '),

	aReferenceToUns(*) BYTE PUBLIC INITIAL('REFERENCE TO UNSATISFIED EXTERNAL(XXXXX) AT XXXXH', 0DH, 0AH),
	aSymbolTableOfM(*) BYTE PUBLIC INITIAL(0DH, 0AH, 'SYMBOL TABLE OF MODULE '),
	aReadFromFile(*) BYTE PUBLIC INITIAL(0DH, 0AH, 'READ FROM FILE '),
	aWrittenToFile(*) BYTE PUBLIC INITIAL(0DH, 0AH, 'WRITTEN TO FILE '),
	aValueType(*) BYTE PUBLIC INITIAL('VALUE TYPE '),
	aSymbol(*) BYTE PUBLIC INITIAL(6, 'SYMBOL'),
	aPub(*) BYTE PUBLIC INITIAL('XXXXH PUB  '),
	aSym(*) BYTE PUBLIC INITIAL('XXXXH SYM  '),
	alin(*) BYTE PUBLIC INITIAL('XXXXH LIN  '),
	aMod(*) BYTE PUBLIC INITIAL('      MOD  '),
	x5(*) BYTE PUBLIC INITIAL(5, 'XXXXX'),
	spc32(*) BYTE PUBLIC INITIAL('                                ');

DECLARE	loHiBoth BYTE PUBLIC,
	outSegType BYTE PUBLIC,
	unused(2) BYTE,
	curColumn ADDRESS PUBLIC,
	workingSegBase ADDRESS PUBLIC,
	unsatisfiedCnt ADDRESS PUBLIC INITIAL(0),
	curcol BYTE PUBLIC INITIAL(0),
	curListField ADDRESS PUBLIC INITIAL(0),
	nameLen BYTE PUBLIC INITIAL(0),
	lsout$p ADDRESS PUBLIC,
	lsout BASED lsout$p STRUCTURE (rectyp BYTE, reclen ADDRESS, record(1) BYTE);


SeekOutFile: PROCEDURE(mode, pblk, pbyt) PUBLIC;
	DECLARE (mode, pblk, pbyt) ADDRESS;
	CALL Seek(outputfd, mode, pblk, pbyt, .statusIO);
	CALL ErrChkReport(statusIO, .outFileName(1), TRUE);
END SeekOutFile;


FlushOut: PROCEDURE PUBLIC;
	CALL Write(outputfd, outRecord$p, out$p - outRecord$p, .statusIO);
	CALL ErrChkReport(statusIO, .outFileName(1), TRUE);
	out$p = outRecord$p;
END FlushOut;

WriteBytes: PROCEDURE(buf$p, cnt) PUBLIC;
	DECLARE (buf$p, cnt) ADDRESS;
	DECLARE bcnt ADDRESS;

	bcnt = eout$p - out$p;
	DO WHILE cnt > bcnt;
		CALL mem$mov(bcnt, buf$p, out$p);
		cnt = cnt - bcnt;
		buf$p = buf$p + bcnt;
		out$p = out$p + bcnt;
		CALL FlushOut;
		bcnt = npbuf;
	END;
	CALL mem$mov(cnt, buf$p, out$p);
	out$p = out$p + cnt;
END WriteBytes;


InitRecOut: PROCEDURE(rectyp) PUBLIC;
	DECLARE rectyp BYTE;
	DECLARE lsout BASED lsout$p STRUCTURE(rectyp BYTE, reclen ADDRESS);

	IF eout$p - out$p < 1028 THEN
		CALL FlushOut;
	lsout$p = out$p;
	lsout.rectyp = rectyp;
	out$p = out$p + size(lsout);	/* rectyp + length */
END InitRecOut;


EndRecord: PROCEDURE PUBLIC;
	DECLARE crc BYTE;
	DECLARE pch ADDRESS;
	DECLARE ch BASED pch BYTE;
	DECLARE outch BASED out$p BYTE;

	/* check record not too long */
	IF (lsout.reclen := out$p - .lsout.rectyp - 2) > 1025 THEN
		CALL ErrChkReport(ERR211, .outFileName(1), TRUE);	/* RECORD TOO LONG */
	/* for what is there generate the CRC */
	crc = 0;
	DO pch = .lsout TO out$p - 1;
		crc = crc + ch;
	END;
	outch = -crc;
	out$p = out$p + 1;
END EndRecord;


EmitModDat: PROCEDURE(curDataFrag$p) PUBLIC;
	DECLARE curDataFrag$p ADDRESS;
	DECLARE curDataFrag BASED curDataFrag$p DATAFRAG$T;
	DECLARE (len, bcnt, pmem, curPC, j) ADDRESS;
	DECLARE crc BYTE;
	DECLARE mem BASED pmem (1) BYTE;
	DECLARE	moddatOut BASED out$p STRUCTURE (segid BYTE, offset ADDRESS, dat(1) BYTE);

	CALL InitRecOut(R$MODDAT);
	len = curDataFrag.eaddr - curDataFrag.saddr + 1;
	lsout.reclen = len + 4;
	moddatOut.segid = SABS;		/* abs seg */
	curPC = (moddatOut.offset := curDataFrag.saddr);		/* load address */	
					/* initialise the CRC */
	crc = HIGH(lsout.reclen) + 6 + LOW(lsout.reclen) + HIGH(moddatOut.offset) + LOW(moddatOut.offset);
	out$p = out$p + 3;

	DO WHILE len > 0;
		bcnt = 256;	/* Write 256, or less if no page boundary or less bytes available */
		IF LOW(curPC) <> 0 THEN
			bcnt = 256 - LOW(curPC);
		IF bcnt > len THEN
			bcnt = len;
		pmem =  AddrInCache(curPC);	/* get a pointer to where the data is now */
		DO j = 0 TO bcnt - 1;		/* include the data in the CRC check */
			crc = crc + mem(j);
		END;
		CALL WriteBytes(pmem, bcnt);	/* add the bytes to the output record */
		IF bcnt = 256 THEN		/* if was a whole page then free it */
		DO;
			pageTab1(pageTab2(HIGH(curPC)).pageIdx).state = 0FFH;
			pageTab2(HIGH(curPC)).pageIdx = 0FFH;	/* mark page as free */
		END;
		curPC = curPC + bcnt;		/* account for written data */
		len = len - bcnt;
	END;	/* DO WHILE */

	crc = -crc;			/* Close off the record */
	CALL WriteBytes(.crc, 1);
END EmitModDat;


ForceSOL: PROCEDURE PUBLIC;
	IF curcol <> 0 THEN
		CALL PrintCrLf;
	curcol = 0;
END ForceSOL;



PrintColumn: PROCEDURE(field, pstr) PUBLIC;
	DECLARE field ADDRESS;
	DECLARE pstr ADDRESS;
	DECLARE str BASED pstr (1) BYTE;

	/* change of field type then force new line */
	IF field <> curListField THEN
		CALL ForceSOL;
	curListField = field;
	/* reached max of columns then force new line */
	IF curcol = columns THEN
		CALL ForceSOL;
	/* space to next column: 32 chars - length of previous name */
	IF curcol <> 0 THEN
		CALL PrintString(.spc32, 32 - nameLen);
	curcol = curcol + 1;
	nameLen = str(0);
	/* print out field lead */
	CALL PrintString(field, 11);
	/* and the name */
	CALL PrintString(.str(1), nameLen);
END PrintColumn;


SetWorkingSeg: PROCEDURE(seg) BYTE PUBLIC;	/* always returns 0 */
	DECLARE seg BYTE;
	workingSegBase = segBases(seg);
	RETURN SABS;
END SetWorkingSeg;


ProcModend: PROCEDURE PUBLIC;
	DECLARE rst0$p ADDRESS;
	DECLARE jmp BASED rst0$p STRUCTURE (inst BYTE, addr ADDRESS);
	DECLARE	inModend BASED in$p STRUCTURE (modtype BYTE, segid BYTE, offset ADDRESS);
	DECLARE	outModend BASED out$p STRUCTURE (modtype BYTE, segid BYTE, offset ADDRESS);

	DECLARE curDataFrag BASED curDataFrag$p DATAFRAG$T;	/* used for size below */

	IF inModend.modtype = 1 THEN	/* is main module */
	DO;
		isMain = 1;	/* flag as main module */
		outSegType = SetWorkingSeg(inModend.segid);
		IF NOT startSeen THEN	/* use the main module's address */
			startAddr = workingSegBase + inModend.offset;
		IF restart0Seen THEN	/* restart0 the put jump to startAddr */
		DO;
			rst0$p = AddrInCache(0);	/* location of address 0 in cache */
			jmp.inst = 0C3H;		/* insert the jump */
			jmp.addr = startAddr;
			CALL AddSegFrag(AABS, SABS, 0, 3);/* add to the frags */
			CALL AddDataFrag(0, 2);
		END;
	END;
	ELSE
		startAddr = 0;	/* 0 start address if not a main module */
	CALL FlushOut;			/* flush any data in the buffers */
	curDataFrag$p = topDataFrags;
	DO WHILE curDataFrag$p <> botHeap;	/* emit all of the data frags */
		curDataFrag$p = curDataFrag$p - size(curDataFrag);
		CALL EmitModDat(curDataFrag$p);
	END;

	CALL InitRecOut(R$MODEND);	/* generate the rectyp 4 record */
	outModend.modtype = isMain;
	outModend.segid = 0;
	outModend.offset = startAddr;
	out$p = out$p + 4;
	CALL WriteBytes(in$p + DOUBLE(4), recLen - DOUBLE(4) - 1);	/* copy rectyp 4 tail over */
	CALL EndRecord;					/* insert length and CRC */
	CALL InitRecOut(R$MODEOF);				/* EOF record */
	CALL EndRecord;
	CALL FlushOut;
END ProcModend;


ProcModdat: PROCEDURE PUBLIC;
	DECLARE (mark, endrec) STRUCTURE (blk ADDRESS, byt ADDRESS);
	DECLARE fixextUsed BYTE;
	DECLARE (fixRAddr, pad) ADDRESS;
	DECLARE (locRecLen, recSegBaseAddr) ADDRESS;
	DECLARE (fixLoc, fixLoc2) ADDRESS;
	DECLARE (loByt, hiByt) BYTE, bothByt ADDRESS AT (.loByt);	/* used to handle cross page fixup */

	DECLARE bfix BASED fixLoc BYTE;		/* fixup location of byte */
	DECLARE bfix2 BASED fixLoc2 BYTE;	/* fixup location of 2nd byte if cross page boundary */
	DECLARE wfix BASED fixLoc ADDRESS;
	DECLARE erec BASED erec$p(1) BYTE;
	DECLARE	moddatRec BASED in$p STRUCTURE (segid BYTE, offset ADDRESS, dat(1) BYTE);
	DECLARE	inLoHiBoth BASED in$p BYTE;
	DECLARE	outLoHiBoth BASED out$p BYTE;
	DECLARE	inExtfix BASED in$p STRUCTURE (namidx ADDRESS, offset ADDRESS);
	DECLARE	outExtfix BASED out$p STRUCTURE (namidx ADDRESS, offset ADDRESS);
	DECLARE	inFixOffset BASED in$p ADDRESS;
	DECLARE	inSegId BASED in$p BYTE;

	inRecord$p = .(R$MODDAT);		/* initialise to appear as a MODDAT record */
	ibuf$p = in$p;
	CALL ChkRead(3);		/* make sure the record and length are in the buffer */
	in$p = ibuf$p;
	IF moddatRec.segid = SSTACK THEN
		CALL FatalErr(ERR238);	/* ILLEGAL STACK CONTENT RECORD */

	outSegType = SetWorkingSeg(moddatRec.segid);	/* set to ABS and get working base address */
	recSegBaseAddr = workingSegBase;
	/* set the bounds for this moddat record checking for wrap round */
	inFragment.saddr = recSegBaseAddr + moddatRec.offset;
	IF (inFragment.eaddr := inFragment.saddr + recLen - 5) < inFragment.saddr THEN
		CALL IllegalRecord;	/* oops over 64k */
	IF moddatRec.segid = SABS THEN	/* add this as a new frag */
		CALL AddSegFrag(0, 0, inFragment.saddr, recLen - 4);
	ELSE IF (segFlags(moddatRec.segid) AND AMASK) = AUNKNOWN THEN
		CALL IllegalRecord;	/* align is invalid */
	IF (locRecLen := recLen) > 1025 THEN	/* long records only ok if ABS */
	DO;
		IF moddatRec.segid <> 0 THEN
			CALL FatalErr(ERR211);	/* RECORD TOO LONG */
		CALL AddDataFrag(inFragment.saddr, inFragment.eaddr);
	END;
	CALL LoadModdat(moddatRec.segid);	/* suck the data in */
	CALL GetRecord;
	IF locRecLen > 1025 THEN	/* can only happen for ABS blocks so no fixup */
		RETURN;

	fixextUsed = 0;

	DO WHILE inRecord.rectyp = R$FIXEXT OR inRecord.rectyp = R$FIXLOC OR inRecord.rectyp = R$FIXSEG;
		IF inRecord.rectyp = R$FIXEXT THEN
		DO;
			IF NOT fixextUsed THEN
			DO;
				CALL FlushOut;	/* make sure written to disk and record current location */
				CALL SeekOutFile(SeekTELL, .mark.blk, .mark.byt);
				endrec.blk = 0;
				endrec.byt = locRecLen + 3;
				CALL SeekOutFile(SeekFWD, .endrec.blk, .endrec.byt);	/* past where data will go */
			END;
			fixextUsed = TRUE;	/* note we have fixext record(s) */
			CALL InitRecOut(R$FIXEXT);	/* initialise the fixext record */
			IF (loHiBoth := inLoHiBoth) - 1 > FBOTH - 1 THEN	/* check fixup type valid */
				CALL IllegalRecord;

			outLoHiBoth = loHiBoth;	/* copy to the output */
			out$p = out$p + 1;
			in$p = in$p + 1;

			DO WHILE in$p < .erec;
				/* set the new offset but do bounds check also */
				CALL FixupBoundsChk(outExtfix.offset := recSegBaseAddr + inExtfix.offset);
				IF loHiBoth = FBOTH THEN
					CALL FixupBoundsChk(outExtfix.offset + 1);	/* check 2nd byte in range */
				IF (outExtfix.namidx := inExtfix.namidx) >= unsatisfiedCnt THEN
					CALL BadRecordSeq;	/* name index out of range */
				CALL ForceSOL;			/* make sure on new line to record the problem */
				CALL BinAsc(outExtfix.namidx, 10, ' ', .aReferenceToUns(34), 5);
				CALL BinAsc(outExtfix.offset, 16, '0', .aReferenceToUns(44), 4);
				/* print 'REFERENCE TO UNSATISFIED EXTERNAL(' */
				CALL ConAndPrint(.aReferenceToUns, 34);
				/* print the 'XXXXX) AT XXXXH\r\n' skipping leading spaces */
				CALL ConAndPrint((curColumn := SkipSpc(.aReferenceToUns(34))),
						17 - (curColumn - .aReferenceToUns(34)));
				out$p = out$p + 4;	/* advance out and in position */
				in$p = in$p + 4;
			END;	/* DO WHILE */

			CALL EndRecord;	/* finish off the record */
		END;
		ELSE
		DO;
			workingSegBase = recSegBaseAddr;			/* restore fixup seg base to the moddat's own */
			IF inRecord.rectyp = R$FIXSEG THEN				/* if different seg the set it up */
			DO;
				outSegType = SetWorkingSeg(inSegid);
				in$p = in$p + 1;				/* rest treat as rectyp FIXLOC */
			END;
			IF (loHiBoth := inLoHiBoth) - 1 > FBOTH - 1 THEN	/* is fixup valid */
				CALL IllegalRecord;
			in$p = in$p + 1;

			DO WHILE in$p < .erec;					/* process the record */
				/* set the fixup real address and check in range, both bytes for BOTH fixup type */
				CALL FixupBoundsChk(fixRaddr := recSegBaseAddr + inFixOffset);
				IF loHiBoth = FBOTH THEN
					CALL FixupBoundsChk(fixRaddr + 1);
				/* find the fixup location in memory */
				fixLoc = AddrInCache(fixRaddr);
				DO CASE loHiBoth - 1;
					bfix = bfix + LOW(workingSegBase);	/* LO add in low of target base address */
					bfix = bfix + HIGH(workingSegBase);	/* HI add in high of target base address */
										/* BOTH */
					IF LOW(fixRaddr) <> 0FFH THEN	/* doesn't span pages */
						wfix = wfix + workingSegBase;	/* simple add in to existing word value */
					ELSE
					DO;
						lobyt = bfix;			/* get the low byte */
						fixLoc2 = AddrInCache(fixRaddr + 1);	/* find address of high byte */
						hibyt = bfix2;
						bothbyt = bothbyt + workingSegBase;	/* add in the target base address */
						bfix = lobyt;			/* and put back in place */
						bfix2 = hibyt;
					END;
				END;
				in$p = in$p + 2;
			END;
		   END;
		CALL GetRecord;
	END;
	IF fixextUsed THEN
	DO;
		CALL FlushOut;	/* flush the extdef data */
		CALL SeekOutFile(SeekABS, .mark.blk, .mark.byt);	/* backup to the data record */
		CALL EmitModDat(.inFragment.saddr);			/* emit the data record fragment as it needs fixup */
		CALL FlushOut;
		CALL SeekOutFile(SeekEND, .endrec.blk, .endrec.byt);	/* back to end of file */
	END;
	ELSE
		CALL AddDataFrag(inFragment.saddr, inFragment.eaddr);	/* record the fragment */

END ProcModdat;

END locate2;

loc3.plm
locate3: DO;
$include(loc3.ipx)

FixupBoundsChk: PROCEDURE(addr) PUBLIC;
	DECLARE addr ADDRESS;
	IF addr < inFragment.saddr OR inFragment.eaddr < addr THEN
		CALL FatalErr(ERR213);	/* Fixup Bounds Error */
END FixupBoundsChk;


ProcLinnum: PROCEDURE PUBLIC;
	DECLARE	inSeg BASED in$p BYTE;
	DECLARE	inLinDef BASED in$p STRUCTURE (offset ADDRESS, linnum ADDRESS);
	DECLARE	outSeg BASED out$p BYTE;
	DECLARE	outLinDef BASED out$p STRUCTURE (offset ADDRESS, linnum ADDRESS);

	IF NOT PurgeSeen OR LinesSeen THEN	/* only process if not purge or lines requested */
	DO;
		outSegType =  SetWorkingSeg(inSeg);	/* get ABS seg and set working base address */
		IF NOT PurgeSeen THEN		/* need to create output record */
		DO;
			CALL InitRecOut(R$LINNUM);
			outSeg = outSegType;
			out$p = out$p + 1;
		END;
		in$p = in$p + 1;		/* past segid */
		DO WHILE in$p < .erec;		/* loop over all entries */
			IF NOT PurgeSeen THEN	/* emit to output record */
			DO;
				outLinDef.offset = workingSegBase + inLinDef.offset;	/* final location */
				outLinDef.linnum = inLinDef.linnum;	/* copy the line number */
				out$p = out$p + size(outLinDef);	/* past this entry */
				
			END;
			IF LinesSeen THEN	/* if required list the mapping */
			DO;
				CALL BinAsc(workingSegBase + inLinDef.offset, 16, '0', .alin, 4);
				CALL BinAsc(inLinDef.linnum, 10, ' ', .x5(1), 5);
				CALL PrintColumn(.alin, .x5);
			END;
			in$p = in$p + size(inLinDef);			/* to next entry */
		END;
		IF NOT PurgeSeen THEN		/* finish off output record */
			CALL EndRecord;
	END;
	CALL GetRecord;	/* prep next record */
END ProcLinnum;


ProcAncest: PROCEDURE PUBLIC;
	DECLARE str BASED in$p (1) BYTE;
	IF LinesSeen OR SymbolsSeen THEN	/* if lines or symbols */
	DO;
		CALL PrintColumn(.aMod, in$p);	/* print the ancestor */
		CALL ForceSOL;
	END;
	IF NOT PurgeSeen THEN			/* if needed in output */
	DO;
		CALL InitRecOut(R$ANCEST);	/* init record, copy the name and finalise */
		CALL WriteBytes(.str(0), str(0) + 1);
		CALL EndRecord;
	END;
	CALL GetRecord;	/* prep next record */
END ProcAncest;


ProcDefs: PROCEDURE(list, template) PUBLIC;
	DECLARE list BYTE;
	DECLARE template ADDRESS;
	DECLARE ritem BASED in$p STRUCTURE (len ADDRESS, name (1) BYTE);
	DECLARE owd BASED out$p ADDRESS;
	DECLARE buf BASED out$p (1) BYTE;
	DECLARE inSeg BASED in$p BYTE;
	DECLARE inDef BASED in$p STRUCTURE (offset ADDRESS, name(1) BYTE /*, 0 */);
	DECLARE outSeg BASED out$p BYTE;
	DECLARE outDef BASED out$p STRUCTURE (offset ADDRESS, name(1) BYTE /*, 0 */);

	IF NOT purgeseen OR list THEN	/* only process if not purged or list requested for these symbols */
	DO;
		IF inSeg = SSTACK THEN	/* stack ? */
		DO;
			outSegType = SSTACK;
			workingSegBase = 0;			/* stack base is 0 */
		END;
		ELSE
			outSegType = SetWorkingSeg(inSeg);	/* sets working base address * returns ABS Seg */
		IF NOT PurgeSeen THEN
		DO;
			CALL InitRecOut(inRecord.rectyp);	/* initialise the output record */
			outSeg = outSegType;
			out$p = out$p + 1;
		END;
		in$p = in$p + 1;			/* past segId */
		DO WHILE in$p < .erec;
			IF NOT PurgeSeen THEN
			DO;
				outDef.offset = workingSegBase + inDef.offset;	/* add in the base address */
				CALL PStrcpy(.inDef.name, .outDef.name);	/* copy the name over */
				outDef.name(inDef.name(0) + 1) = 0;		/* add the trailing 0 */
				out$p = out$p + 4 + inDef.name(0);		/* update output record past offset, name and extra 0 */
			END;
			IF list THEN			/* if required list the location */
			DO;
				CALL BinAsc(workingSegBase + inDef.offset, 16, '0', template, 4);
				CALL PrintColumn(template, .inDef.name);
			END;
			in$p = in$p + 4 + inDef.name(0);			/* to the next entry - past offset, name and extra 0 */
		END;
		IF NOT PurgeSeen THEN		/* if not purged finish off the output record */
			CALL EndRecord;
	END;
	CALL GetRecord;	/* prep for next record */
END ProcDefs;


ProcExtnam: PROCEDURE PUBLIC;
	DECLARE ch BASED in$p BYTE;
	DECLARE buf BASED out$p (1) BYTE;
	DECLARE inName BASED in$p STRUCTURE (len BYTE, name(1) BYTE /*, 0 */);
	DECLARE outName BASED out$p STRUCTURE (len BYTE, name(1) BYTE /*, 0 */);

	CALL InitRecOut(R$EXTNAM);	/* initialise the EXTNAM in the located file */
	DO WHILE in$p < .erec;		/* process each item in the input EXTNAM record */
		CALL ForceSOL;
		/* insert the index number of the unsatisfied external & print the Error message */
		CALL BinAsc((unsatisfiedCnt := unsatisfiedCnt + 1) - 1, 10, ' ', .aUnsatisfiedExt(21), 5);
		/* print to the start of the number */
		CALL ConAndPrint(.aUnsatisfiedExt, 21);
		/* print the rest of the message omitting leading spaces in the number */
		CALL ConAndPrint(curColumn := SkipSpc(.aUnsatisfiedExt(21)), 7 - (curColumn - .aUnsatisfiedExt(21)));
		/* print the name */
		CALL ConAndPrint(.inName.name, inName.len);
		CALL ConAndPrint(.crlf, 2);
		/* copy the name to the output record */
		CALL PStrcpy(.inName, .outName);
		outName.name(inName.len) = 0;	/* add the zero */
		out$p = out$p + 2 + inName.len;			/* skip past the name in out and in records */
		in$p = in$p + 2 + inName.len;
	END;
	CALL EndRecord;	/* finish off the record */
	CALL GetRecord; /* prep the next record */
END ProcExtnam;


PrintListingHeader: PROCEDURE(buf, len) PUBLIC;
	DECLARE buf ADDRESS;
	DECLARE len ADDRESS;
	CALL PrintString(buf, len);
	CALL PrintString(.moduleName(1), moduleName(0));
	CALL PrintString(.aReadFromFile, 17);	/* '\r\nREAD FROM FILE ' */
	CALL PrintString(.inFileName(1), inFileName(0));
	CALL PrintString(.aWrittenToFile, 18); /* '\r\nWRITTEN TO FILE ' */
	CALL PrintString(.outFileName(1), outFileName(0));
	CALL PrintCrLf;
END PrintListingHeader;


/* main procedure to locate the file */
LocateFile: PROCEDURE PUBLIC;
	DECLARE buf BASED out$p (1) BYTE;
	CALL ProcHdrAndComDef;		/* determine all of the segment base addresses */
	CALL InitRecOut(R$MODHDR);	/* create header record */
	CALL WriteBytes(.moduleName, moduleName(0)+1);	/* Write the name */
	buf(0) = modhdr$x1;	/* copy the passed in x field data */
	buf(1) = modhdr$x2;
	out$p = out$p + 2;
	CALL EndRecord;		/* located modhdrs don't have seg size info */
	/* print symbol table header message if required */
	IF PublicsSeen  OR SymbolsSeen OR LinesSeen THEN
	DO;
		CALL PrintListingHeader(.aSymbolTableOfM, 25);
		CALL PrintCrLf;
		/* print the column headings */
		DO curColumn = 1 TO columns;
			CALL PrintColumn(.aValueType, .aSymbol);
		END;
		CALL PrintCrLf;
	END;

	/* process the link file */
	DO WHILE inRecord.rectyp <> R$MODEND;
	    DO CASE SHR(inRecord.rectyp, 1);
		CALL IllegalReloc;	/* 0 */
		CALL BadRecordSeq;	/* 2 - modhdr alReady processed */
		;			/* 4 - modend Exited while alReady */
		CALL ProcModdat;		/* 6 - moddat */
		CALL ProcLinnum;		/* 8 - linnum */
		CALL IllegalReloc;	/* 0A */
		CALL IllegalReloc;	/* 0C */
		CALL ErrChkReport(ERR204, .inFileName(1), TRUE); /* 0E - modeof Premature EOF */
		CALL ProcAncest;		/* 10 - ancest */
		CALL ProcDefs(SymbolsSeen, .aSym);	/* 12 - locdef */
		CALL IllegalReloc;	/* 14 */
		CALL ProcDefs(PublicsSeen, .aPub);	/* 16 - pubdef */
		call ProcExtnam;		/* 18 - extnam - externals */
		CALL IllegalReloc;	/* 1A */
		CALL IllegalReloc;	/* 1C */
		CALL IllegalReloc;	/* 1E */
		CALL BadRecordSeq;	/* 20 - fixext link should have processed these */
		CALL BadRecordSeq;	/* 22 - fixloc link should have processed these */
		CALL BadRecordSeq;	/* 24 - fixseg link should have processed these */
		CALL BadRecordSeq;	/* 26 - libloc attempting to locate a library */
		CALL BadRecordSeq;	/* 28 - libnam attempting to locate a library */
		CALL BadRecordSeq;	/* 2A - libdic attempting to locate a library */
		CALL BadRecordSeq;	/* 2C - libhdr attempting to locate a library */
		CALL BadRecordSeq;	/* 2E - processed comdef alReady */
	    END;
	END;
	CALL ProcModend;		/* Read the modend and generate the rest of the located file */
	CALL Close(outputfd, .statusIO);
	CALL ErrChkReport(statusIO, .outFileName(1), TRUE);
	IF havePagingFile THEN		/* get rid of any paging file */
	DO;
		CALL Close(tmpfd, .statusIO);
		CALL Delete(.tmpFileName(1), .statusIO);
	END;
	CALL ForceSOL;		/* make sure at start of line if symbols listed */
	CALL PrintMemoryMap;	/* print the final memory map + any overlay Errors */
	CALL Close(Readfd, .statusIO);
	CALL ErrChkReport(statusIO, .inFileName(1), TRUE);
END LocateFile;

END locate3;
loc4.plm
locate4: DO;
$include(loc4.ipx)

DECLARE	aMemoryMapOfMod(*) BYTE PUBLIC INITIAL(0DH, 0AH, 'MEMORY MAP OF MODULE '),
	aStartStopLengt(*) BYTE PUBLIC INITIAL(0DH, 0AH, 0AH, 'START   STOP LENGTH REL NAME', 0DH, 0AH, 0AH),
	aModuleStartAdd(*) BYTE PUBLIC INITIAL('MODULE START ADDRESS XXXXH'),
	aModuleIsNotAMa(*) BYTE PUBLIC INITIAL('MODULE IS NOT A MAIN MODULE'),
	aStartControlIg(*) BYTE PUBLIC INITIAL(', START CONTROL IGNORED'),
	aRestartControl(*) BYTE PUBLIC INITIAL(', RESTART CONTROL IGNORED'),
	aAddresses(*) BYTE PUBLIC INITIAL('XXXXH  XXXXH  XXXXH  X  '),
	aMemOverlap(*) BYTE PUBLIC INITIAL('  (MEMORY OVERLAP FROM XXXXH THROUGH XXXXH)'),
	a0LengthSegment(*) BYTE PUBLIC INITIAL('  (0 LENGTH SEGMENT WRAPPED AROUND TO 0000H)'),
	segNames(*) BYTE PUBLIC INITIAL('ABSOLUTE', 'CODE    ', 'DATA    ', 'STACK   ', 'MEMORY  '),
	alignNames(*) BYTE PUBLIC INITIAL('AIPB');

GetCommonName: PROCEDURE(segid) ADDRESS PUBLIC;
	DECLARE segid BYTE;
	DECLARE cdef BASED in$p STRUCTURE (segid BYTE, name(1) BYTE);

	IF segid = SBLANK THEN
		RETURN .(0);	/* blank name */
	CALL ObjSeek(0,0);	/* Seek start of file */
	CALL GetRecord;		/* junk the modhdr record */
	DO WHILE 1;
		CALL GetRecord;	/* scan comdef records */
		IF inRecord.rectyp <> R$COMDEF THEN
			CALL BadRecordSeq;
		DO WHILE in$p < .erec;	/* look for the seg */
			IF segid = cdef.segid THEN
				RETURN .cdef.name(0);	/* return pointer to name */
			in$p = in$p + size(cdef) + cdef.name(0);	/* skip to next seg/name */
		END;
	END;
END GetCommonName;

PrintMemoryMap: PROCEDURE PUBLIC;
	DECLARE (minStart, q) ADDRESS;
	DECLARE (i, wrapped, addCRLF) BYTE;
	DECLARE curSegFrag BASED curSegFrag$p SEGFRAG$T;
	DECLARE omfName BASED in$p STRUCTURE(len BYTE, name(1) BYTE);

	IF MapSeen THEN		/* print map header info if asked for */
	DO;
		CALL PrintListingHeader(.aMemoryMapOfMod, size(aMemoryMapOfMod)); /* '\r\nMEMORY MAP OF MODULE ' */
		IF isMain THEN
		DO;
			CALL BinAsc(startAddr, 16, '0', .aModuleStartAdd(21), 4);  /* insert start address in string */
			CALL PrintString(.aModuleStartAdd, size(aModuleStartAdd)); /* 'MODULE START ADDRESS XXXXH' */
		END;
		ELSE
		DO;
			CALL PrintString(.aModuleIsNotAMa, size(aModuleIsNotAMa)); /* 'MODULE IS NOT A MAIN MODULE' */
			IF startSeen THEN
				CALL PrintString(.aStartControlIg, size(aStartControLIg)); /* ', START CONTROL IGNORED' */
			IF restart0Seen THEN
				CALL PrintString(.aRestartControl, size(aRestartControl)); /* ', RESTART CONTROL IGNORED' */
		END;
		CALL PrintString(.aStartStopLengt, 34);	/* '\r\nSTART   STOP LENGTH REL NAME\r\n\n' */
	END;

	segBases(SSTACK) = segBases(SSTACK) - segSizes(SSTACK);
	DO q = 1 TO 254;
		IF segSizes(i := segOrder(q)) > SABS  OR (segFlags(i) AND 20H) <> 0 THEN
			CALL AddSegFrag(segFlags(i), i, segBases(i), segSizes(i));
	END;

	minStart, wrapped = 0;
	/* emit information on all of the blocks */
	curSegFrag$p = topHeap;
	DO WHILE curSegFrag$p <> topDataFrags; 	/* done ? */
		curSegFrag$p = curSegFrag$p - size(curSegFrag);	/* point to start of block info */
		CALL BinAsc(curSegFrag.start, 16, '0', .aAddresses, 4);	/* start address */
		aAddresses(7) = '*';		/* assume no length so show **** for stop address */
		aAddresses(8) = '*';
		aAddresses(9) = '*';
		aAddresses(10) = '*';
		IF curSegFrag.len > 0 THEN		/* we have length so fill stop address */
			CALL BinAsc(curSegFrag.start + curSegFrag.len - 1, 16, '0', .aAddresses(7), 4);
		CALL BinAsc(curSegFrag.len, 16, ' ', .aAddresses(14), 4);	/* length */
		/* copy the start and stop into the memory overlap message */
		CALL mem$mov(4, .aAddresses, .aMemOverlap(23));
		CALL mem$mov(4, .aAddresses(7), .aMemOverlap(37));
		IF curSegFrag.start + curSegFrag.len > minStart THEN	/* none or not total overlap */
		DO;
			aMemOverlap(37) = '*';		/* clear out the through address */
			aMemOverlap(38) = '*';
			aMemOverlap(39) = '*';
			aMemOverlap(40) = '*';
			/* if we are overlap put in the end of the last block */
			IF curSegFrag.len > 0 AND (minStart > 0  OR wrapped <> 0) THEN
				CALL BinAsc(minStart - 1, 16, '0', .aMemOverlap(37), 4);
		END;
		addCRLF = 0;
		IF mapSeen THEN	/* if MAP is being produced */
		DO;
			aAddresses(21) = alignNames(curSegFrag.flags AND AMASK);	/* add the align type */
			CALL PrintString(.aAddresses, size(aAddresses));	/* and print the address info */
			IF curSegFrag.seg >= SNAMED THEN				/* seg is named common */
			DO;
				CALL PrintString(.('/'), 1);			/* print the / */
				in$p = GetCommonName(curSegFrag.seg);		/* look up the common name in the input file */
				CALL PrintString(.omfName.name, omfName.len);	/* print it and the closing / */
				CALL PrintString(.('/'), 1);
			END;
			ELSE							/* standard so used the canned names */
				CALL PrintString(.segNames(SHL(curSegFrag.seg, 3)), 8);	/* shl 3 is *8 */
		END;
		IF curSegFrag.start < minStart OR wrapped <> 0 THEN			/* emit any overlap notification */
		DO;
			addCRLF = TRUE;
			/* '  (MEMORY OVERLAP FROM XXXXH THROUGH XXXXH)'  values filled in above */
			CALL ConAndPrint(.aMemOverlap, size(aMemOverlap));
		END;
		IF (curSegFrag.flags AND FWRAP0) <> 0 THEN				/* and if wrapped to 0 */
		DO;
			addCRLF = TRUE;
			/* '  (0 LENGTH SEGMENT WRAPPED AROUND TO 0000H)' */
			CALL ConAndPrint(.a0LengthSegment, size(a0LengthSegment));
		END;
		IF addCRLF THEN							/* finish of any started line */
			CALL ConAndPrint(.crlf, 2);
		ELSE IF MapSeen THEN
			CALL PrintCrLf;
		IF curSegFrag.start + curSegFrag.len = 0 AND curSegFrag.len > 0 THEN		/* we wrapped to 0 */
		DO;
			minStart = 0;
			wrapped = FWRAP0;
		END;
		ELSE IF wrapped = 0 THEN
			IF curSegFrag.start + curSegFrag.len > minStart THEN		/* update the minStart */
				minStart = curSegFrag.start + curSegFrag.len;
	END;	/* DO WHILE */
END PrintMemoryMap;






SkipSpc: PROCEDURE(pch) ADDRESS PUBLIC;
	DECLARE pch ADDRESS;
	DECLARE ch BASED pch BYTE;
	
	DO WHILE ch = ' ';
		pch = pch + 1;
	END;
	RETURN pch;
END SkipSpc;




END locate4;
loc4a.plm
loc4a: DO;
$include(loc4a.ipx)

ErrChkReport: PROCEDURE(errCode, file, errExit) PUBLIC;
	DECLARE errCode ADDRESS;
	DECLARE file ADDRESS;
	DECLARE errExit BYTE;
	DECLARE status ADDRESS;
	
	IF errCode <> 0 THEN
	DO;
		file = SkipSpc(file);
		CALL Write(0, .(' '), 1, .status);
		CALL Write(0, file, PastAFN(file) - file, .status);	/* Write file name */
		CALL Write(0, .(','), 1, .status);
		CALL Errmsg(errCode);
		IF errExit THEN
			CALL Exit;
	END;
END ErrChkReport;
END;
loc5a.plm
locate5a: DO;
$include(loc5a.ipx)

DECLARE hexdigits(*) BYTE DATA ('0123456789ABCDEF');

BinAsc: PROCEDURE(number, base,	pad, bufp, ndigits) PUBLIC;
	DECLARE number ADDRESS, (base, pad) BYTE, bufp ADDRESS, ndigits BYTE;
	DECLARE i BYTE;
	DECLARE buf BASED bufp (1) BYTE;
	
	DO i = 1 TO ndigits;
		buf(ndigits - i) = hexdigits(number MOD base);
		number = number / base;
	END;

	i = 0;
	DO WHILE buf(i) = '0' AND i < ndigits - 1;
		buf(i) = pad;
		i = i + 1;
	END;
END BinAsc;


PastAFN: PROCEDURE(pch) ADDRESS PUBLIC;
	DECLARE pch ADDRESS;
	DECLARE ch BASED pch BYTE;

	DO WHILE 1;
		pch = PastFileName(pch);
		IF ch = '*' OR ch = '?' THEN
			pch = pch + 1;
		ELSE
			RETURN pch;
	END;
END PastAFN;

END locate5a;


loc5b.plm
locate5b: DO;

PastFileName: PROCEDURE(pch) ADDRESS PUBLIC;
	DECLARE pch ADDRESS;
	DECLARE ch BASED pch BYTE;

	DO WHILE ch = ':' OR ch = '.' OR ('0' <= ch AND ch <= '9') OR ('A' <= ch AND ch <= 'Z');
		pch = pch + 1;
	END;
	RETURN pch;
END PastFileName;


END locate5b;


loc6.plm
locate6: DO;
$include(loc6.ipx)



DECLARE spathInfo SPATH$T PUBLIC;
DECLARE signonMsg(*) BYTE PUBLIC INITIAL(0CH, 'ISIS-II OBJECT LOCATER '),
	aInvokedBy(*) BYTE PUBLIC INITIAL(' INVOKED BY:', 0Dh, 0Ah),
	aCommandTailErr(*) BYTE PUBLIC INITIAL('COMMAND TAIL ERROR NEAR #:'),
	tmpFileInfo(*) BYTE PUBLIC INITIAL(0, 'LOCATETMP'),
	scmd$p ADDRESS PUBLIC,
	cmd$p ADDRESS PUBLIC;
DECLARE nxtSegOrder BYTE EXTERNAL;

/* explicit declare of based variables as base defined after include */
declare	cmdch based cmd$p byte;



DECLARE controls(*) BYTE PUBLIC DATA(
		0, 0, 253,		/* 253 = -3 */
		1, 1, 4, 'CODE',
		1, 2, 4, 'DATA',
		1, 3, 5, 'STACK',
		1, 4, 6, 'MEMORY',
		2, 0, 5, 'START',
		3, 1, 9, 'STACKSIZE',
		4, 2, 8, 'RESTART0',
		4, 3, 3, 'MAP',
		4, 4, 7, 'PUBLICS',
		4, 5, 7, 'SYMBOLS',
		4, 6, 5, 'LINES',
		4, 7, 5, 'PURGE',
		5, 8, 4, 'NAME',
		6, 0, 5, 'PRINT',
		7, 0, 5, 'ORDER',
		8, 0, 7, 'COLUMNS');

DECLARE cin(*) BYTE PUBLIC DATA(':CI: ');
DECLARE cout(*) BYTE PUBLIC DATA(5,':CO: ');
DECLARE mdebug(*) BYTE PUBLIC DATA('DEBUG ');
DECLARE mstar2(*) BYTE PUBLIC DATA('**');
DECLARE mto(*) BYTE PUBLIC DATA('TO ');
DECLARE mtoand(*) BYTE PUBLIC DATA('TO&');




CmdErr: PROCEDURE(err) PUBLIC;
	DECLARE err ADDRESS;
	DECLARE scmdch BASED scmd$p BYTE;

	IF PastFileName(cmd$p) = cmd$p THEN
	DO;
		IF cmdch <> 0DH THEN
			cmd$p = cmd$p + 1;
	END;
	ELSE
		cmd$p = PastFileName(cmd$p);

	cmdch = '#';	/* put a marker in */
	CALL ConStrOut(.aCommandTailErr, 26);
	CALL Errmsg(err);
	CALL ConStrOut(.scmdch, cmd$p - .scmdch + 1);
	CALL ConStrOut(.crlf, 2);
	CALL Exit;
END CmdErr;


SkipNonArgChars: PROCEDURE(pch) PUBLIC;
	DECLARE pch ADDRESS;
	cmd$p = SkipSpc(pch);
	/* skip any continuation bits and leading space */
	DO WHILE cmdch = '&';
		cmd$p = SkipSpc(cmd$p + 5);
	END;
END SkipNonArgChars;


ExpectChar: PROCEDURE(ch, err) PUBLIC;
	DECLARE (ch, err) BYTE;
	CALL SkipNonArgChars(cmd$p);
	IF ch = cmdch THEN
		CALL SkipNonArgChars(cmd$p + 1);
	ELSE
		CALL CmdErr(err);
END ExpectChar;


ExpectLP: PROCEDURE PUBLIC;
	CALL ExpectChar('(', ERR227);	/* left parenthesis expected */
END ExpectLP;


ExpectRP: PROCEDURE PUBLIC;
	CALL ExpectChar(')', ERR228);	/* right parenthesis expected */
END ExpectRP;


ExpectSlash: PROCEDURE PUBLIC;
	CALL ExpectChar('/', ERR203);	/* invalid syntax */
END ExpectSlash;


GetFile: PROCEDURE PUBLIC;
	CALL spath(cmd$p, .spathInfo, .statusIO);	/* try to parse file */
	IF statusIO > 0 THEN
		CALL CmdErr(statusIO);
	CALL SkipNonArgChars(PastFileName(cmd$p));
END GetFile;


InitSegOrder: PROCEDURE PUBLIC;
	DECLARE i BYTE;
	segOrder(0) = SABS;
	segOrder(1) = SCODE;
	segOrder(2) = SSTACK;
	/* next come the common segs in order */
	DO i = 3 TO 252;
		segOrder(i) = i + 3;
	END;
	/* DATA is after these and MEMORY is last */
	segOrder(253) = SDATA;
	segOrder(254) = SMEMORY;
END InitSegOrder;


ErrNotADisk: PROCEDURE PUBLIC;
	CALL MakeFullName(.spathInfo, .inFileName(1));
	CALL ErrChkReport(ERR17, .inFileName(1), TRUE);	/* not a disk file */
END ErrNotADisk;


GetpstrName: PROCEDURE(pstr) PUBLIC;
	DECLARE pstr ADDRESS;
	DECLARE str BASED pstr (1) BYTE;

	IF cmdCh < '?' OR 'Z' < cmdCh THEN
		CALL CmdErr(ERR225);	/* invalid Name */
	str(0) = 0;			/* set length */
	DO WHILE '0' <= cmdCh AND cmdCh <= '9' OR '?' <= cmdCh and cmdCh <= 'Z';
		str(0) = str(0) + 1;
		IF str(0) > 31 THEN
			CALL CmdErr(ERR226);	/* name too long */
		str(str(0)) = cmdch;
		cmd$p = cmd$p + 1;
	END;
END GetpstrName;


ProcessControls: PROCEDURE PUBLIC;
	DECLARE (p, q, cwindex) ADDRESS;
	DECLARE cindex BYTE AT(.cwindex);
	DECLARE (cid, caux, clen, cSegId) BYTE;

	/* find the command length */
	clen = PastFileName(cmd$p) - cmd$p;
	cindex = 3;
	cid = 0;
	IF cmdch = '/' THEN	/* common seg address */
	DO;
		clen = 1;	/* treat specially */
		cid = 9;
	END;
	ELSE IF clen > 0 THEN	/* look up the control */
		DO WHILE cindex < length(controls);
			IF controls(cindex+2) = clen AND Strequ(cmd$p, .controls(cindex+3), clen) THEN
			DO;
				cid = controls(cindex);	
				caux = controls(cindex+1);
				cindex = length(controls);
			END;
			ELSE
				cindex = cindex + controls(cindex + 2) + 3;
		END;
	IF cid = 0 THEN		/* check we have a valid command */
		CALL CmdErr(ERR229);	/* unrecognised control */
	CALL SkipNonArgChars(cmd$p + clen);
	DO CASE cid - 1;
	    DO;		/* CODE, DATA, STACK, MEMORY */
		segFlags(caux) = FHASADDR;	/* note that the address is specified */
		segBases(caux) = ParseLPNumRP;	/* and its value */
	    END;
	    DO;		/* START */
	    	startSeen = TRUE;		/* got a start address */
		startAddr = ParseLPNumRP;	/* and its value */
	    END;
	    DO;		/* STACKSIZE */
	        stackSizeSeen = TRUE;		/* got a stack size */
		segSizes(SSTACK) = ParseLPNumRP;/* and its value */
	    END;
	    seen(caux) = TRUE; 		/* simple command seen - RESTART0, MAP, PUBLICS, SYMBOLS, LINES, PURGE */
	    DO;		/* NAME */
	    	moduleNameSeen = TRUE;		/* got a module name */
		CALL ExpectLP;
		CALL GetpstrName(.moduleName);	/* getand its value */
		CALL ExpectRP;
	    END;
	    DO;		/* PRINT */		/* get the print file */
		CALL ExpectLP;
		CALL GetFile;
		CALL MakeFullName(.spathInfo, .printFileName(1));
		printFileName(0) = PastFileName(.printFileName(1)) - .printFileName(1);
		CALL ExpectRP;
	    END;
	    DO;		/* ORDER */		/* process the order list */
	    	CALL InitSegOrder;
		nxtSegOrder = 0;
		CALL ExpectLP;
		DO WHILE cmdch <> ')';
			cindex = 3;			/* skip seg 0 */
			DO WHILE controls(cindex) = 1;	/* CODE DATA STACK MEMORY */
				IF Strequ(cmd$p, .controls(cindex + 3), controls(cindex + 2)) THEN
				DO;
					CALL InsSegIdOrder(controls(cindex + 1));
					cmd$p = cmd$p + controls(cindex + 2);
					cindex = 0;
				END;
				/* note if cindex = 0 then this keeps where we are & will terminate loop */
				cindex = cindex + controls(cindex + 2) + 3;
			END;
			IF cindex <> 0 THEN	/* check we haven't alReady processed */
			DO;			/* if not scan for /common/ names */
				CALL ExpectSlash;
				cSegId = GetCommonSegId;
				CALL ExpectSlash;
				CALL InsSegIdOrder(cSegId);
			END;
			CALL SkipNonArgChars(cmd$p);
			/* look for list of names */
			IF cmdch = ',' THEN
				CALL ExpectChar(',', ERR203); /* invalid syntax */
		END;
		CALL ExpectRP;
	    END;
	    DO;		/* COLUMNS */		/* get the number of columns */
	    	p = cmd$p;	/* mark where we are */
		CALL ExpectLP;	/* look for the ( */
		q = cmd$p;	/* mark start of number */
		cmd$p = p;	/* reset to start of (n) */
		columns = ParseLPNumRP;
		IF columns < 1 OR columns > 3 THEN	/* must be 1-3 */
		DO;
			cmd$p = q;	/* for Error reporting */
			CALL CmdErr(ERR203);	/* invalid syntax */
		END;
	    END;
	    DO;		/* / -> common */	/* find the common name or blank */
	    	cSegId = GetCommonSegId;	/* look up seg */
		CALL ExpectSlash;		/* end with a slash */
		segFlags(cSegId) = FHASADDR;	/* note we have an address */
		segBases(cSegId) = ParseLPNumRP; /* and its value */
	    END;
	END;
END ProcessControls;
END locate6;
loc7.plm
locate7: DO;
$include(loc7.ipx)

DECLARE cin(1) BYTE EXTERNAL;
DECLARE cout(1) BYTE EXTERNAL;
DECLARE mdebug(1) BYTE EXTERNAL;
DECLARE mstar2(1) BYTE EXTERNAL;
DECLARE mto(1) BYTE EXTERNAL;
DECLARE mtoand(1) BYTE EXTERNAL;

DECLARE nxtSegOrder BYTE PUBLIC;

ParseLPNumRP: PROCEDURE ADDRESS PUBLIC;
	DECLARE num ADDRESS;

	CALL ExpectLP;
	IF cmdCh < '0' OR '9' < cmdCh THEN	/* must have digit */
		CALL CmdErr(ERR203);	/* invalid syntax */
	num = ParseNumber(.cmd$p);
	IF PastFileName(cmd$p) <> cmd$p THEN	/* make sure not a filename or bad number */
		CALL CmdErr(ERR203);	/* invalid syntax */
	CALL ExpectRP;
	RETURN num;
END ParseLPNumRP;


GetCommonSegId: PROCEDURE BYTE PUBLIC;
	DECLARE name(32) BYTE;
	DECLARE	comdefRec BASED in$p STRUCTURE (segid BYTE, name(1) BYTE);

	IF cmdch = '/' THEN
		RETURN SBLANK;	/* blank common */
	CALL GetpstrName(.name);
	name(name(0) + 1) = ' ';	/* space at end */
	CALL ObjSeek(0, 0);
	CALL GetRecord;		/* skip modhdr record */

	DO WHILE 1;
		CALL GetRecord;
		IF inRecord.rectyp <> R$COMDEF THEN
			CALL ErrChkReport(ERR237, .name(1), TRUE);	/* common not found */
		DO WHILE in$p < .erec;
			IF Strequ(.name, .comdefRec.name, name(0)+1) THEN
				RETURN comdefRec.segid;
			in$p = in$p + 2 + comdefRec.name(0);
		END;
	END;
END GetCommonSegId;


InsSegIdOrder: PROCEDURE(seg) PUBLIC;
	DECLARE seg BYTE;
	DECLARE i BYTE;
	nxtSegOrder = nxtSegOrder + 1;
	IF segOrder(nxtSegOrder) = seg THEN	/* alReady in order */
		RETURN;
	DO i = 0 TO nxtSegOrder;
		IF segOrder(i) = seg THEN	/* alReady Allocated ? */
			CALL CmdErr(ERR203);	/* invalid syntax */
	END;
	DO i = nxtSegOrder + 1 TO SBLANK - 1;	/* find the current location of seg */
		IF segOrder(i) = seg THEN
			goto L6C93;
	END;
L6C93:
	DO WHILE i > nxtSegOrder;
		segOrder(i) = segOrder(i - 1);	/* make room for this seg */
		i = i - 1;
	END;
	segOrder(nxtSegOrder) = seg;		/* insert it */
END InsSegIdOrder;


ReadCmdLine: PROCEDURE PUBLIC;

	CALL Read(1, cmd$p, 128, .actRead, .statusIO);
	CALL ErrChkReport(statusIO, .cin, TRUE);
	cmdbuf(actRead) = 0DH;
	call StrUpr(cmd$p);
END ReadCmdLine;


ProcArgsInit: PROCEDURE PUBLIC;
	DECLARE scmdch BASED scmd$p BYTE;
	DECLARE (p, args$p) ADDRESS;

	/* work out a good io buf size */
	/* checks are for >= 32k of space, >= 16k of space */
	IF (pageCacheSize := HIGH(memck - baseMemImage) - 1) >= 128 THEN
		npbuf = 4096;
	ELSE IF pageCacheSize >= 64 THEN
		npbuf = 2048;
	ELSE
		npbuf = 1056;

	eibuf$p, ibuf$p = memck;	/* in buffer at top of memory */
	sibuf$p, eout$p = eibuf$p - npbuf;	/* output buffer is below this */
						/* and for now now print buffer */
	outRecord$p, out$p, spbuf$p, pbuf$p, epbuf$p = eout$p - npbuf;
	scmd$p = .MEMORY;		/* command line buffer */
	/* if >= 32k then also use a print buffer */
	IF (usePrintBuf := pageCacheSize >= 64) THEN
		scmd$p = outRecord$p;	/* seems odd to share output buf */
	scmdch = '-';
	CALL rescan(1, .statusIO);	/* rewind to get command line args */
	cmd$p = scmd$p + 1;
	CALL ReadCmdLine;		/* Read the command line args */
	cmd$p = SkipSpc(cmd$p);		/* skip leading space, DEBUG if present and loc command */
	IF Strequ(cmd$p, .mdebug, 6) THEN
		cmd$p = SkipSpc(cmd$p + 6);
	cmd$p, args$p = SkipSpc(PastFileName(cmd$p));	/* args$p marks start of real args */
	DO WHILE cmdch <> 0DH;		/* Read until end of args */
		IF cmdch = '&' THEN	/* handle continuation line */
		DO;
			p = cmd$p;	/* mark the & */
			cmd$p = SkipSpc(cmd$p + 1);	/* check we didn't have anything after */
			IF cmdch <> 0DH THEN
				CALL CmdErr(ERR203);	/* invalid syntax */
			cmd$p = p;	/* reset to & */
			CALL ConStrOut(.mstar2, 2);	/* emit ** to user */
			cmdbuf(1) = 0DH;	/* put the cr lf ** after the & */
			cmdbuf(2) = 0AH;
			cmdbuf(3) = '*';
			cmdbuf(4) = '*';
			cmd$p = cmd$p + 5;	/* position to Read the next line */
			CALL ReadCmdLine;	/* Read another line */
		END;
		ELSE	/* skip char */
			cmd$p = cmd$p + 1;
	END;	/* DO WHILE */

	/* display the sign on message skipping the form feed */
	CALL ConStrOut(.signonMsg + 1, 23);
	CALL ConStrOut(.VERSION, 4);
	CALL ConStrOut(.crlf, 2);
	/* if we have run into the in buffer then we have a problem */
	IF cmd$p > sibuf$p THEN
		CALL CmdErr(ERR210);	/* insufficient memory */
	/* skip the leading space of the command args */
	CALL SkipNonArgChars(args$p);
	/* get the file we are locating */
	CALL GetFile;
	/* can only locate a disk file */
	IF spathInfo.deviceType <> 3 THEN
		CALL ErrNotADisk;
	CALL MakeFullName(.spathInfo, .inFileName(1));
	/* convert to a omf style string by putting the length in at the front */
	inFileName(0) = PastFileName(.inFileName(1)) - .inFileName(1);
	/* check for TO (followed by space or & */
	IF Strequ(cmd$p, .mto, 3) OR Strequ(cmd$p, .mtoand, 3) THEN
	DO;
		CALL SkipNonArgChars(cmd$p + 2);
		CALL GetFile;	/* get the output file */
	END;
	ELSE
	DO;	/* handle the case of TO missing unless the input did not have an extension */
		IF spathInfo.ext(0) = 0 THEN
			CALL CmdErr(ERR233);	/* TO expected */
		spathInfo.ext(0) = 0;	/* assume TO would be input file name without extension */
		spathInfo.ext(1) = 0;
		spathInfo.ext(2) = 0;
	END;
	/* get the output file name in standard format */
	CALL MakeFullName(.spathInfo, .outFileName(1));
	outFileName(0) = PastFileName(.outFileName(1)) - .outFileName(1);
	/* only accept a disk file or the bit bucket */
	IF spathInfo.deviceType <> 3 and spathInfo.deviceId <> 22 THEN	/* 22 -> :BB: */
		CALL ErrNotADisk;
	/* copy the disk name over and create the tmp file name */
	tmpFileInfo(0) = spathInfo.deviceId;
	CALL MakeFullName(.tmpFileInfo, .tmpFileName(1));
	tmpFileName(0) = PastFileName(.tmpFileName(1)) - .tmpFileName(1);
	/* record if we are creating a real file */
	outRealFile = spathInfo.deviceId <> 22;
	/* Open the file to locate */
	CALL Open(.Readfd, .InFileName(1), 1, 0, .statusIO);
	CALL ErrChkReport(statusIO, .inFileName(1), TRUE);
	recNum = 0;
	/* check we have a relocation file */
	CALL GetRecord;
	IF inRecord.rectyp <> R$MODHDR THEN
		CALL ErrChkReport(ERR239, .inFileName(1), TRUE);	/* no module header record */
	/* assume listing to :CO: */
	CALL PStrcpy(.cout, .printFileName);
	/* set other defaults and record that we haven't seen the commands */
	columns = 1;
	startSeen = 0;
	stackSizeSeen = 0;
	restart0Seen = 0;
	MapSeen = 0;
	PublicsSeen = 0;
	SymbolsSeen = 0;
	LinesSeen = 0;
	PurgeSeen = 0;
	moduleNameSeen = 0;
	isMain = 0;		/* assume not main module */
	modhdr$x1 = 0;
	modhdr$x2 = 0;
	startAddr = 0;
	/* initialise the segment order */
	CALL InitSegOrder;
	/* and set all as not yet seen with 0 size and location */
	DO p = 0 TO 255;
		segFlags(p) = AUNKNOWN;
		segBases(p), segSizes(p) = 0;
	END;
	/* process the rest of the command args */
	DO WHILE cmdch <> 0DH;
		CALL ProcessControls;
	END;
	/* no paging file yet and no Allocated pages */
	havePagingFile = 0;
	roundRobinIndex = 0;
	pageIndexTmpFil = 0;
	/* recalculate pageCache size */
	pageCacheSize = HIGH(outRecord$p - (pageTab1$p := pageTab2$p + size(pageTab2))) - 1;
	/* set a new baseMemImage after Allocting pageTab1 slots - one for each page */
	baseMemImage =  pageTab1$p + (pageCacheSize + 1) * 2 ;
	/* initialise the paging table control information */
	DO p = 0 TO 255;
		/* we have only Allocated space for up to pageCacheSize entries in pageTab1 */
		IF p <= pageCacheSize THEN
			pageTab1(p).state = 0FFH; /* not used */
		pageTab2(p).pageIdx = 0FFH;	/* not used */
		pageTab2(p).fileIdx = 0FFH;	/* not used */
	END;
	/* Allocate the print buffer below the output buffer if we have one */
	IF usePrintBuf THEN
		spbuf$p, pbuf$p = epbuf$p - npbuf;
	/* set up the heap locations below the print buffer */
	topHeap, topDataFrags, botHeap = spbuf$p;
	/* recalculate the pageCacheSize now available */
	pageCacheSize = HIGH(botHeap - baseMemImage) - 1;
	/* create the output file*/
	CALL Delete(.outFileName(1), .statusIO);
	CALL Open(.outputfd, .outFilename(1), 3, 0, .statusIO);
	CALL ErrChkReport(statusIO, .outFileName(1), TRUE);
	/* and the print file (or console) */
	CALL Open(.printfd, .printFileName(1), 2, 0, .statusIO);
	CALL ErrChkReport(statusIO, .printFileName(1), TRUE);
	/* if not console then emit the signon and command line to the print file */
	IF printfd > 0 THEN
	DO;
		CALL PrintString(.signonMsg, 24);
		CALL PrintString(.VERSION, 4);
		CALL PrintString(.aInvokedBY, 14);
		CALL PrintString(.scmdch, cmd$p - .scmdch + 2);
	END;
END ProcArgsInit;

DECLARE aInpageSegment2(*) BYTE PUBLIC INITIAL('INPAGE SEGMENT > 256 BYTES COERCED TO PAGE BOUNDRY', 0DH, 0AH),
	segId BYTE PUBLIC,
	pad7935(3) BYTE PUBLIC;

AlignAddress: PROCEDURE(align, size, laddr) ADDRESS PUBLIC;
	DECLARE align BYTE;
	DECLARE (size, laddr) ADDRESS;
	IF size = 0 THEN	/* no size to no alignment needed */
		RETURN laddr;

	IF align = ABYTE THEN
		RETURN laddr;	/* no alignment needed */
	IF align = AINPAGE THEN
		IF size <= 256 THEN	/* check if fits in page */
		DO;
			IF HIGH(laddr) = HIGH(laddr + size - 1) THEN
				RETURN laddr;
		END;
		ELSE    /* inpage seg > 256 coerced to page boundary */
			CALL ConAndPrint(.aInpageSegment2, 52);	
	RETURN (laddr + 0FFH) AND 0FF00H;	/* get a whole page */
END AlignAddress;


ProcModhdr: PROCEDURE PUBLIC;
	DECLARE rbyt BASED in$p (1) BYTE;
	DECLARE sdef BASED in$p STRUCTURE (segId BYTE, len ADDRESS, combine BYTE); 
	DECLARE (loadAddress, segSize, segOrderId) ADDRESS;
	DECLARE (atTopOfMem, loadHasSize) BYTE;

	IF NOT moduleNameSeen THEN	/* copy over the module name if not user overridden */
		CALL PStrcpy(in$p, .moduleName);
	in$p = in$p + rbyt(0) + 1;	/* past name */
	modhdr$x1 = rbyt(0);		/* copy the reserved bytes */
	modhdr$x2 = rbyt(1);
	in$p = in$p + 2;
	loadHasSize = 0;
	DO WHILE in$p < .erec;		/* process all of the seg info */
		IF (segFlags(segId := sdef.segId) AND AMASK) <> AUNKNOWN THEN
			CALL IllegalRecord;	/* oops seen twice */
		IF segId <> SSTACK THEN		/* by default copy the length */
			segSizes(segId) = sdef.len;
		ELSE IF NOT stackSizeSeen THEN	/* for stack copy if not user overridden */
			segSizes(SSTACK) = sdef.len;
		IF segSizes(segId) > 0 THEN	/* check we have some data */
			loadHasSize = TRUE;
		IF sdef.combine - 1 > ABYTE - 1 THEN	/* check valid alignment */
			CALL IllegalRecord;
		segFlags(segId) = segFlags(segId) + sdef.combine;	/* set the combine info */
		in$p = .sdef + size(sdef);	/* skip to next seg info */
	END;
	IF (segFlags(SSTACK) AND AMASK) = AUNKNOWN THEN		/* if STACK not specified put default */
		segFlags(SSTACK) = segFlags(SSTACK) + ABYTE;	/* set to byte align */
	IF (segFlags(SMEMORY) AND AMASK) = AUNKNOWN THEN	/* if MEMORY not specified put default */
		segFlags(SMEMORY) = segFlags(SMEMORY) + ABYTE;	/* set to byte align */
	IF NOT stackSizeSeen AND loadHasSize THEN		/* it STACK not specified by user and we have data */
		segSizes(SSTACK) = segSizes(SSTACK) + 12;	/* reserve an additional 12 bytes */
	loadAddress = 3680H;				/* ISIS load address */
	atTopOfMem = 0;

	DO segOrderId = 1 TO 254;	/* process the segs taking account of user specified order */
		segid = segOrder(segOrderId);
		segSize = segSizes(segId);	/* pick up seg to process */
		IF (segFlags(segId) AND FHASADDR) = 0 THEN	/* no address specified */
		DO;
			IF atTopOfMem <> 0 THEN	/* check for going over 64k */
			DO;
				IF segSize > 0 THEN	/* program exceeds 64k */
					CALL ErrChkReport(ERR240, .inFileName(1), TRUE);
				segFlags(segId) = segFlags(segId) OR FWRAP0;
			END;
		END;
		ELSE
		DO;	/* user specified address */
			IF segSize > 0 THEN	/* reset topOfMemflag */
				atTopOfMem = 0;
			loadAddress = segBases(segId);	/* set the loadAddress to user specified */
		END;
		/* update this segments base address allowing for alignment */
		segBases(segId) = AlignAddress(segFlags(segId) AND AMASK, segSize, loadAddress);
		IF segId = SMEMORY THEN
			IF segSize = 0 AND loadHasSize THEN	/* if not specified and program has size */
								/* calcualte a MEMORY size */
				IF atTopOfMem = 0 AND memck > segBases(SMEMORY) THEN
					segSizes(SMEMORY), segSize = memck - segBases(SMEMORY);
		/* advance loadAddress and check for memory wrap around */
		IF (loadAddress := segBases(segId) + segSize) < segBases(segId) THEN
			IF loadAddress = 0 THEN		/* at 64k ok else Error */
				atTopOfMem = FWRAP0;
			ELSE
				CALL ErrChkReport(ERR240, .inFileName(1), TRUE);  /* exceeds 64k */
	END; 
	segBases(SSTACK) = segBases(SSTACK) + segSizes(SSTACK);	/* stack goes down so update to top */
	CALL GetRecord;	/* preload next record */
END ProcModhdr;


ProcComdef: PROCEDURE PUBLIC;
	DECLARE	comdefRec BASED in$p STRUCTURE (segid BYTE, name(1) BYTE);

	DO WHILE in$p < .erec;
		IF (segId := comdefRec.segid) < SNAMED OR segId = SBLANK THEN
			CALL IllegalRecord;
		/* check if combine value not appropriate for common or if this one alReady seen */
		IF ((segFlags(segId) AND AMASK) = AUNKNOWN) OR ((segFlags(segId) AND FSEGSEEN) <> 0)THEN
			CALL IllegalRecord;
		segFlags(segId) = segFlags(segId) OR FSEGSEEN;	/* flag as seen */
		in$p = in$p + 2 + comdefRec.name(0);		/* past byte, len, string */
	END;
	CALL GetRecord;
END ProcComdef;


ProcHdrAndComDef: PROCEDURE PUBLIC;
	CALL ObjSeek(0, 0);	/* rewind */
	CALL GetRecord;		/* get modhdr */
	CALL ProcModhdr;	/* load the modhdr and set the segment bases */

	DO WHILE inRecord.rectyp = R$COMDEF;	/* process any comdefs */
		CALL ProcComdef;
	END;
	DO segId = SNAMED TO SBLANK - 1;	/* check commons in modhdr have comdef entries */
		IF ((segFlags(segId) AND AMASK) <> AUNKNOWN) AND ((segFlags(segId) AND FSEGSEEN) = 0) THEN
			CALL BadRecordSeq;
	END;
END ProcHdrAndComDef;

END locate7;
loc8.plm
locate8: DO;
$include(loc8.ipx)

DECLARE devices (*) BYTE DATA('F0F1F2F3F4F5TITO',
		      'VIVOI1O1TRHRR1R2',
		      'TPHPP1P2LPL1BBCI',
		      'COF6F7F8F9');

/* convert the spath info into a standard file name :xx:file.ext */
MakeFullName: PROCEDURE(pinfo, pstr) PUBLIC;
	DECLARE pinfo ADDRESS;
	DECLARE pstr ADDRESS;
	DECLARE str BASED pstr(1) BYTE;
	DECLARE ch BASED pstr BYTE;
	DECLARE info BASED pinfo SPATH$T;

	DECLARE i BYTE;

	/* put the :xx: */
	str(0) = ':';
	str(1) = devices(info.deviceId + info.deviceId);
	str(2) = devices(info.deviceId + info.deviceId + 1);
	str(3) = ':';
	pstr = pstr + 4;	/* past the :xx: inserted */
	/* put the file */
	DO i = 0 TO 5;
		IF (ch := info.name(i)) <> 0 THEN
			pstr = pstr + 1;
	END;
	/* only put .ext if it exists */
	IF info.ext(0) <> 0 THEN
	DO;
		ch = '.';
		pstr = pstr + 1;
	END;
	/* put the ext - could have been in the if clause above */
	DO i = 0 TO 2;
		IF (ch := info.ext(i)) <> 0 THEN
			pstr = pstr + 1;
	END;
	ch = ' ';	/* space at end */
END MakeFullName;


StrUpr: PROCEDURE(pch) PUBLIC;
	DECLARE pch ADDRESS;
	DECLARE ch BASED pch BYTE;

	DO WHILE ch <> 0DH;
		ch = ToUpper(ch);
		pch = pch + 1;
	END;
END StrUpr;

END locate8;
loc8a.plm
locate8: DO;
$include(loc8a.ipx)

DECLARE hexch(*) BYTE DATA ('0123456789ABCDEF');

ParseNumber: PROCEDURE(ppstr) ADDRESS PUBLIC;
	DECLARE ppstr ADDRESS;
	DECLARE pstr BASED ppstr ADDRESS;
	DECLARE (pch, pafter, pendNum) ADDRESS;
	DECLARE (i, radix, digit) BYTE;
	DECLARE (num, lastnum) ADDRESS;
	DECLARE ch BASED pch BYTE;

	pch = pstr;
	DO WHILE ch = ' ';	/* skip spaces */
		pch = pch + 1;
	END;
	pstr = pch;		/* update the source pstr */

	DO WHILE '0' <= ch AND ch <= '9' OR 'A' <= ch AND ch <= 'F';
		pch = pch + 1;
	END;
	pafter = (pendNum := pch) + 1;
	IF ch = 'H' THEN
		radix = 16;
	ELSE IF ch = 'O' OR ch = 'Q' THEN
		radix = 8;
	ELSE
	DO;	/* check for D or B or numeric */
		pendNum, pch = (pafter := pch) - 1;
		IF ch = 'B' THEN
			radix = 2;
		ELSE
		DO;
			radix = 10;
			IF ch <> 'D' THEN	/* if a digit then include in number */
				pendNum = pendNum + 1;
		END;
	END;
	pch = pstr;	/* reset to start */
	num, lastnum = 0;
	DO WHILE pch < pendNum;
		DO i = 0 TO 15;
			IF ch = hexch(i) THEN
				digit = i;
		END;
		IF digit >= radix THEN
			RETURN 0;	/* illegal number */
		IF (num := lastnum * radix + digit) < lastnum THEN
			RETURN 0;	/* overflow */
		lastnum = num;
		pch = pch + 1;
	END;
	pstr = pafter;
	RETURN num;
END ParseNumber;


Strequ: PROCEDURE(pstr1, pstr2, len) BYTE PUBLIC;
	DECLARE (pstr1, pstr2) ADDRESS, len BYTE;
	DECLARE i BYTE;
	DECLARE str1 BASED pstr1 (1) BYTE, str2 BASED pstr2 (1) BYTE;

	len = len - 1;
	DO i = 0 TO len;
		IF str1(i) <> str2(i) THEN
			RETURN FALSE;
	END;
	RETURN TRUE;
END Strequ;


END locate8;
loc9.plm
locate9:
DO;
ToUpper: PROCEDURE(ch) BYTE PUBLIC;
	DECLARE ch BYTE;
	IF ch < 'a' THEN
		RETURN ch;
	IF ch > 'z' THEN
		RETURN ch;
	RETURN ch AND 0DFH;
END ToUpper;

END locate9;
memmov.asm
	PUBLIC memmov
	CSEG
; mem$move(count, src$p, dst$p)
memmov: pop	h
	xthl
	push	b
	mov	b, h
	mov	c, l
	pop	h
	dcx	b
	mov	a, e
	sub	l
	mov	a, d
	jz	l410F
	sbb	h
	jmp	l4111

l410F:	sbb	h
	rz

l4111:	push	h
	lxi	h, l4167
	jc	l4121
	pop	h
	dad	b
	push	h
	xchg
	dad	b
	xchg
	lxi	h, l4190

l4121:	inx	b
	mov	a, b
	rrc
	rrc
	rrc
	mov	b, a
	mvi	a, 7
	ana	c
	push	psw
	xra	c
	rrc
	rrc
	rrc
	xra	b
	ani	1Fh
	xra	b
	mov	c, a
	mvi	a, 1Fh
	ana	b
	mov	b, a
	inr	b
	inr	c
	pop	psw
	rlc
	rlc
	push	b
	cma
	mov	c, a
	mvi	b, 0FFh
	inx	b
	dad	b
	pop	b
	xthl
	ret

l4147:	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d

l4167:	dcr	c
	jnz	l4147
	dcr	b
	jnz	l4147
	ret

l4170:	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d

l4190:	dcr	c
	jnz	l4170
	dcr	b
	jnz	l4170
	ret
	END
