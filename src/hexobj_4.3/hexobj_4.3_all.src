hexobj.pex
# vim:ts=4:shiftwidth=4:expandtab:
# common literals
TRUE            '0FFh'
FALSE           '0'
CR              '0Dh'
LF      '0Ah'
FOREVER     'WHILE TRUE'

# my user types
pointer     'address'
bool        'byte'
apointer    'address'
word        'address'

# supported record types
RELOC$TYPE  '22h'
MODHDR$TYPE '2'
MODEND$TYPE '4'
CONTENT$TYPE    '6'
EOF$TYPE    '0eh'

ABS$SEG     '0'
# error codes
UNRECOG$SWITCH  '201'
INVALID$SYNTAX  '203'
EARLY$EOF       '204'
CHECKSUM$ERROR  '208'
BAD$REC$TYP     '212'

# external procedures
Deblank     P("pointer" ptr)"pointer"
Delimit     P("pointer" ptr)"pointer"
MoveAscii   P("pointer" dst,"pointer" src,B cnt)
FileError   P("word" status,"pointer" ptr,"bool" fatal)
ForceUpper  P("pointer" ptr)
NumOut      P("word" val,B base,B lc,"pointer" buf,B width)
Path        P("pointer" filename,"pointer" pn)B
Seq     P("pointer" str1,"pointer" str2,B cnt)"bool"
ReportError P("word" errNum)
ScanInteger P("pointer" buf$p)"word"
UpperCase   P(B char)B
WDelimit    P("pointer" ptr)"pointer"

Close           P("word" conn,"apointer" status$p)
Error       P("word" errnum)
Exit        P
Memck           P"apointer"
Open            P("apointer" conn$p,"pointer" path$p,"word" access,"word" echo,"apointer" status$p)
Read            P("word" conn,"pointer" buff$p,"word" count,"apointer" actual$p,"apointer" status$p)
Spath       P("pointer" path$p,"pointer" info$p,"apointer" status$p)    
Write           P("word" conn,"pointer" buff$p,"word" count,"apointer" status$p)

# file access modes
READ$MODE   '1'
WRITE$MODE  '2'

hexobj.plm
hexobj: DO;
$include(hexobj.ipx)
declare VERSION$LEVEL literally '4',
        EDIT$LEVEL literally '0';

declare copyRight(*) byte data(
    '(C) 1975,1976,1977,1978,1979,1980,1981,1982 INTEL CORP');
declare version(*) byte data(VERSION$LEVEL, EDIT$LEVEL);
declare programVersion(*) byte data('program_version_number=', 1, 'V4.3', 0);

declare buffer$size word;
declare iBuf(3328) byte;
declare iPtr word;
declare buffer(128) byte;
declare buffer$ptr pointer, char based buffer$ptr byte;
declare (output$ptr, input$ptr) pointer;
declare actual word;
declare status word;
declare (start, endFile) bool;
declare (aft$out, aft$in) word;
declare start$value word;
declare record$ptr word;
declare memory$ptr pointer, mem based memory$ptr byte;
/*                                 */
/*  content record definition      */
/*                                 */
declare content structure(
                type   byte,
                length word,
                seg$id byte,
                addr   word,
                dat    byte
                ) at (.MEMORY);
declare record$address word;
declare rlen byte;
declare type byte;
declare i byte;
declare checksum byte;
/*                                  */
/*  module header record definition */
/*                                  */
declare modhdr structure(
                type(1)  byte,
                length   word,
                name$len byte,
                name(31) byte,
                trn$id   byte,
                trn$vn   byte,
                chksum   byte);
/*                                 */
/*  module end record definition   */
/*                                 */
declare modend structure(
                rec$type byte,
                length   word,
                type     byte,
                seg$id   byte,
                offset   word,
                chksum   byte);

/*                                 */
/*  module end of file record      */
/*  definition                     */
/*                                 */
declare modeof structure(
                type    byte,
                length  word,
                chksum  byte);
/*                                 */

declare temp$ptr pointer;
declare modloc structure(
                rectype  byte,
                length   word,
                segid    byte,
                offset   word,
                namelen  byte,
                name(35) byte);
declare temp(17) byte;

OutRecord: procedure(ptr);
    declare ptr pointer, char based ptr(1) byte;
    declare p1 apointer, addr based p1 word;
    declare (i, status) word;
    declare checksum byte;

    p1 = ptr + 1;
    checksum = 0;
    do i = 0 to addr + 1;
        checksum = checksum + char(i);
    end;
    char(addr + 2) = 0 - checksum;
    call Write(aft$out, ptr, addr + 3, .status);
    call FileError(status, output$ptr, TRUE);
end OutRecord;

Gnc: procedure byte;

    if iPtr = length(iBuf) then
    do;
        call Read(aft$in, .iBuf, length(iBuf), .actual, .status);
        call FileError(status, input$ptr, TRUE);
        if actual = 0 then
        do;
            call FileError(EARLY$EOF, input$ptr, TRUE);
            call Exit;
        end;
        iPtr = 0;
    end;
    iPtr = iPtr + 1;
    return iBuf(iPtr - 1) and 7fh;
end Gnc;

Hex: procedure byte;
    declare char byte;

    if (char := Gnc) >= '0' and char <= '9' then return char - '0';
    if char >= 'A' and char <= 'F' then return char - 37h;
    return 0ffh;
end Hex;

Bytes: procedure byte;
    declare char byte;

    char = shl(Hex, 4) + Hex;
    checksum = checksum + char;
    return char;
end Bytes;

/* *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
   *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*

      BEGINNING OF MAIN PROGRAM.

   *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
   *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-* */

                /* Initialize module header record area */
start, endfile = 0;
modhdr.type(0) = MODHDR$TYPE;
do i = 1 to size(modhdr) - 1;
    modhdr.type(i) = 0;
end;
/*                                 */
input$ptr = .(':CI: ');
call Read(1, .buffer, length(buffer), .actual, .status);
call FileError(status, input$ptr, TRUE);
buffer(actual) = CR;
call ForceUpper(.buffer);
input$ptr,buffer$ptr  = Deblank(.buffer);
call Open(.aft$in, input$ptr, READ$MODE, 0, .status);
call FileError(status, input$ptr, TRUE);
buffer$ptr = Deblank(Delimit(buffer$ptr));
if Seq(.('TO '), buffer$ptr, 3) then
do;
    output$ptr,buffer$ptr = Deblank(buffer$ptr + 2);
    buffer$ptr = Deblank(Delimit(buffer$ptr));
end;
else
do;
    call FileError(INVALID$SYNTAX, output$ptr, TRUE);
end;
do while char <> CR;
    if char = '$' then
        buffer$ptr = Deblank(buffer$ptr + 1);
    if Seq(buffer$ptr, .('START'), 5) then
    do;
        start = TRUE;
        buffer$ptr = Deblank(buffer$ptr + 5);
        if char <> '(' then
        do;
            call FileError(INVALID$SYNTAX, buffer$ptr, TRUE);
        end;
        buffer$ptr = buffer$ptr + 1;
        start$value = ScanInteger(.buffer$ptr);    
        buffer$ptr = Deblank(buffer$ptr);
        if char <> ')' then
        do;
            call FileError(INVALID$SYNTAX, buffer$ptr, TRUE);
        end;
        buffer$ptr = Deblank(buffer$ptr + 1);
    end;                /* end of search loop */
    else
    do;                 /* unrecognized option */
        call FileError(UNRECOG$SWITCH, buffer$ptr, TRUE);
    end;
end;            /* end of command line search */
/*                                 */
/*                                 */
call Open(.aft$out, output$ptr, WRITE$MODE, 0, .status);
call FileError(status, output$ptr, TRUE);
status = Path(input$ptr, .modhdr.name$len);
modhdr.name$len = 6;
do while modhdr.name(modhdr.name$len - 1) = 0;
    modhdr.name$len = modhdr.name$len - 1;
end;
modhdr.length = modhdr.name$len + 4;
modhdr.type(modhdr.name$len + 4) = 0; /* TRN ID */
modhdr.type(modhdr.name$len + 5) = 0; /* TRN VN */
       
/*
  Output module header record
*/

call OutRecord(.modhdr);
/*                                       */
/* Assemble and output content record(s) */
/*                                       */
buffer$size = Memck - .MEMORY - 64;
content.type = CONTENT$TYPE;
content.length = 0;
content.seg$id = ABS$SEG;
content.addr = 0;
memory$ptr = .MEMORY + 6;
record$ptr = 0;
iPtr = length(iBuf);
rlen = 1;
do while rlen <> 0;
    do while (char := Gnc) <> ':';
        if char >= '0' and char <= '9' then
        do;
            do while Gnc <> ' ';
                ;
            end;
            do while (char := Gnc) = ' ';
                ;
            end;
            modloc.name(0) = char;
            i = 1;
            do while (modloc.name(i) := Gnc) <> ' ';
                i = i + 1;
            end;
            modloc.name(i) = 0;
            modloc.namelen = i;
            modloc.length = i + 6;
            do while (char := Gnc) < '0' or char > '9';
                ;
            end;
            do i = 0 to 9;
                temp(i) = ' ';
            end;
            i = 1;
            temp(0) = char;
            do while (char := Gnc) <> ' ' and char <> '$' and char <> CR;
                temp(i) = char;
                i = i + 1;
            end;
            temp$ptr = .temp;   /* this is ludicrious, but needed do to ScanInteger */
            modloc.offset = ScanInteger(.temp$ptr);
            modloc.segId = 0;
            modloc.recType = 12h;
            call OutRecord(.modloc);
        end;
    end;
    checksum = 0;
    rlen = Bytes;
    if rlen <> 0 then
    do;
        record$address = Bytes * 256 + Bytes;
        if record$ptr <> record$address or
          content.length > buffer$size then
        do;
            if content.length <> 0 then
            do;
                content.length = content.length + 4;
                call OutRecord(.MEMORY);
            end;
            content.length = 0;
            record$ptr = record$address;
            memory$ptr = .MEMORY + 6;
            content.addr = record$address;
        end;
        type = Bytes;
        do i = 1 to rlen;
            mem = Bytes;
            memory$ptr = memory$ptr + 1;
            record$ptr = record$ptr + 1;
            content.length = content.length + 1;
        end;
        type = Bytes;   /* compute checksum */
        if checksum <> 0 then
        do;
            call FileError(CHECKSUM$ERROR, input$ptr, TRUE);
            call Exit;
        end;
    end; 
    else
    do;
        if content.length <> 0 then
        do;
            content.length = content.length + 4;
            call OutRecord(.MEMORY);
        end;

        /*
            Initialize, assemble and
            output module end record
        */

        modend.rec$type = MODEND$TYPE;
        modend.length = 5;
        modend.type = 1;
        modend.seg$id = 0;
        modend.offset = Bytes * 256 + Bytes;
        if start then
            modend.offset = start$value;    /* start address was specified */
        call OutRecord(.modend);
    /*                                  */
    /*    Initialize, assemble and      */
    /*    output the                    */
    /*    module end of file record     */
    /*                                  */
        modeof.type = EOF$TYPE;
        modeof.length = 1;
        call OutRecord(.modeof);
    end;
end; 

call Close(aft$in, .status);
call FileError(status, input$ptr, TRUE);
call Close(aft$out, .status);
call FileError(status, output$ptr, TRUE);
call Exit;
end hexobj;
EOF
dblank.plm
DEBLANK: DO;
Deblank: procedure(str) address public;
    declare str address;
    declare c based str byte;

    do while (c = ' ');
        str = str + 1;
    end;
    return str;
end;

end;
dlimit.plm
DELIMIT: DO;
Delimit: procedure(ptr) address public;
    declare ptr address, ch based ptr byte;

    do while ch = ':' or ch = '.' or
         ('0' <= ch and ch <= '9') or
         ('A' <= ch and ch <= 'Z');
        ptr = ptr + 1;
    end;
    return ptr;
end;
end;
filerr.plm
FILEERROR: DO;
$include(filerr.ipx)

FileError: procedure(status, ptr, callExit) public;
    declare (status, ptr) address, callExit byte;
    declare actual address;

    if status <> 0 then
    do;
        ptr = Deblank(ptr);
        call Write(0, .(' '), 1, .actual);
        call Write(0, ptr, WDelimit(ptr) - ptr, .actual);
        call Write(0, .(','), 1, .actual);
        call ReportError(status);
        if callExit then
            call exit;
    end;
end;
end;
forupp.plm
FORCEUPPER: DO;
$include(forupp.ipx)

ForceUpper: procedure(bufferPtr) public;
    declare bufferPtr address, ch based bufferPtr byte;

    do while ch <> CR;
        ch = uppercase(ch);
        bufferPtr = bufferPtr + 1;
    end;
end;
end;
numout.plm
NUMOUT: DO;

declare digits(*) byte data('0123456789ABCDEF');

NumOut: procedure(val, base, lc, bufAdr, width) public;
    declare (val, bufAdr) address, (base, lc, width) byte; 
    declare i byte;
    declare buf based bufAdr (1) byte;

    do i = 1 to width;
        buf(width - i) = digits(val mod base);
        val = val / base;   
    end;

    i = 0;
    do while buf(i) = '0' and i < width - 1;
        buf(i) = lc;
        i = i + 1;
    end;
end;
end;
path.plm
PATH: DO;
$include(path.ipx)

Path: procedure(filename, pn) byte public;
    declare (filename, pn) address;
    declare info(12) byte;
    declare status byte;    /* ? bug should be word */

    call Spath(filename, .info, .status);
    call MoveAscii(pn, .info, size(info) - 2);
    return status;
end;
end;
scanin.plm
SCANIN: do;
declare hexDigits(*) byte data('0123456789ABCDEF');

ScanInteger: procedure(buf$p) address public;
    declare buf$p address;
    declare buf based buf$p address;
    declare (s, pastNum$p, endNum$p) address;
    declare (i, radix, digit) byte;
    declare (newValue, curValue) address;
    declare c based s byte;

    s = buf;    
    do while c = ' ';
        s = s + 1;
    end;
    buf = s;
    do while '0' <= c and c <= '9' or 'A' <= c and c <= 'F';
        s = s + 1;
    end;

    endNum$p = s;
    pastNum$p = s + 1;
    if c = 'H' then
        radix = 16;
    else if c = 'O' or c = 'Q' then
        radix = 8;
    else
    do;
        pastNum$p = s;
        endNum$p, s = s - 1;
        if c = 'B' then     /* force reload of s */
            radix = 2;
        else
        do;
            radix = 10;
            if c <> 'D' then    /* include last digit */
                endNum$p = endNum$p + 1;
        end;
    end;
    s = buf;
    newValue, curValue = 0; 
    do while s < endNum$p;
        do i = 0 to 15;
            if c = hexdigits(i) then
                digit = i;
        end;
        if digit >= radix then
            return 0;
        newValue = curValue * radix + digit;
        if newValue < curValue then /* force reload of newValue */
            return 0;
        curValue = newValue;
        s = s + 1;
    end;        
    buf = pastNum$p;
    return newValue;
end;
end;
seq.plm
SEQ: DO;
Seq: procedure(s1, s2, cnt) byte public;
    declare (s1,s2) address, cnt byte;
    declare s1a based s1(1) byte;
    declare s2a based s2(1) byte;
    declare i byte;
    cnt = cnt - 1;
    do i = 0 to cnt;
        if s1a(i) <> s2a(i) then
            return 0;
    end;
    return 0ffh;
end;
end;
mvasci.plm
MOVEASCII: DO;
MoveAscii: procedure(dst, src, cnt) public;
    declare (dst, src) address, cnt byte, i byte;
    declare dch based dst (1) byte, sch based src (1) byte;

    do i = 0 to cnt - 1;
        dch(i) = sch(i);
    end;
end;
end;
reperr.plm
REPORTERROR: DO;
$include(reperr.ipx)

declare msg(*) byte DATA(0, 0,
    2, 'ILLEGAL AFTN ARGUMENT', 0,
    4, 'INCORRECTLY SPECIFIED FILE', 0,
    5, 'UNRECOGNIZED DEVICE NAME', 0,
    6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
    8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
    9, 'DISK DIRECTORY FULL', 0,
    0AH, 'NOT ON SAME DISK', 0,
    0BH, 'FILE ALREADY EXISTS', 0,
    0CH, 'FILE IS ALREADY OPEN', 0,
    0DH, 'NO SUCH FILE', 0,
    0EH, 'WRITE PROTECTED', 0,
    11H, 'NOT A DISK FILE', 0,
    12H, 'ILLEGAL ISIS COMMAND', 0,
    13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
    14H, 'ATTEMPTED BACK SEEK TOO FAR', 0,
    15H, 'CAN''T RESCAN', 0,
    16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
    17H, 'MISSING FILENAME', 0,
    19H, 'ILLEGAL ECHO FILE', 0,
    1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
    1BH, 'ILLEGAL SEEK COMMAND', 0,
    1CH, 'MISSING EXTENSION', 0,
    1FH, 'CAN''T SEEK ON WRITE ONLY FILE', 0,
    20H, 'CAN''T DELETE OPEN FILE', 0,
    23H, 'SEEK PAST EOF', 0,
    0C9H, 'UNRECOGNIZED SWITCH', 0,
    0CAH, 'UNRECOGNIZED DELIMITER', 0,
    0CBH, 'INVALID SYNTAX', 0,
    0CCH, 'PREMATURE EOF', 0,
    0CEH, 'ILLEGAL DISKETTE LABEL', 0,
    0D0H, 'CHECKSUM ERROR', 0,
    0D1H, 'RELO FILE SEQUENCE ERROR', 0,
    0D2H, 'INSUFFICIENT MEMORY', 0,
    0D3H, 'RECORD TOO LONG', 0,
    0D4H, 'ILLEGAL RELO RECORD', 0,
    0D5H, 'FIXUP BOUNDS ERROR', 0,
    0D6H, 'ILLEGAL SUBMIT PARAMETER', 0,
    0D7H, 'ARGUMENT TOO LONG', 0,
    0D8H, 'TOO MANY PARAMETERS', 0,
    0D9H, 'OBJECT RECORD TOO SHORT', 0,
    0DAH, 'ILLEGAL RECORD FORMAT', 0,
    0DBH, 'PHASE ERROR', 0,
    0EAh, 'CANNOT FORMAT FROM TARGET DRIVE', 0,
    0EBh, 'NON-DISK DEVICE', 0,
    3DH, 'UNASSIGNED DEVICE', 0,
    0ECH, 'ILLEGAL FORMAT ON REMOTE DEVICE', 0
    );


ReportError: procedure(errNum) public;
    declare errNum address;
    declare numberBuffer(3) byte, i address, status address;
    
    if errNum <> 0 then
    do;
        i = 0;
        do while i < size(msg);
            if errNum = msg(i) and msg(i + 1) <> 0 then
            do;
                i = i + 1;
                call write(0, .(' '), 1, .status);
                do while msg(i) <> 0;
                    call Write(0, .msg(i), 1, .status);
                    i = i + 1;
                end;
                call Write(0, .(0dh, 0ah), 2, .status);
                return;
            end;
            else
            do;
                do while msg(i) <> 0;
                    i = i + 1;
                end;
                i = i + 1;
            end;
        end;
        call error(errNum);
    end;
end;
end;
upcase.plm
UPPERCASE: DO;
UpperCase: procedure(char) byte public;
    declare char byte;
    if char < 'a' then
        return char;
    if char > 'z' then
        return char;
    return char and 0dfh;
end;
end;
wdlmt.plm
WDELIMIT: DO;
/* b1=01, b2=31, CODE(63H) byte, DATA(2H) byte, STACK(4H) byte, MEMORY(0H) byte,*/
WDelimit: procedure(ptr) address public;
    declare ptr address;
    declare ch based ptr byte;

    do while (ch = ':' or ch = '.' or ch = '*' or ch = '?' or
          ('0' <= ch and ch <= '9') or ('A' <= ch and ch <= 'Z'));
        ptr = ptr + 1;
    end;
    return ptr;
end;
end;
