vers.pex
# vim:ts=4:shiftwidth=4:expandtab:
# common literals
TRUE            '0FFh'
FALSE           '0'
FOREVER         'WHILE TRUE'
CONSOLE$OUTPUT  '0'
CONSOLE$INPUT   '1'
BELL            '7'
TAB             '9'
LF              '0ah'
CR              '0dh'

# my user types
pointer     'address'
bool        'byte'
apointer    'address'
word        'address'

# external procedures
Close           P("word" conn,"apointer" status$p)
Error       P("word" errnum)
Exit        P
Open            P("apointer" conn$p,"pointer" path$p,"word" access,"word" echo,"apointer" status$p)
Read            P("word" conn,"pointer" buff$p,"word" count,"apointer" actual$p,"apointer" status$p)
Write           P("word" conn,"pointer" buff$p,"word" count,"apointer" status$p)
Co          P(B char)

# file access modes
OPEN$FOR$READ   '1'
OPEN$FOR$WRITE  '2'
NO$LINE$EDIT    '0'

SENTINEL$0      '0'
SENTINEL$1      '1'
SENTINEL$2      '2'

READ$BUFFER$LENGTH  '2048'

vers.plm
vers: do;
$include(vers.ipx)

declare copyright(*) byte data  ('(C)1981,1982 INTEL CORP');
declare program$version$number$string(*) byte data
    ('PROGRAM VERSION NUMBER=', SENTINEL$1, 'V4.3 ', SENTINEL$0, 'VERS X002', SENTINEL$2);

declare string$to$search(*) byte  initial('program_version_number=');
declare alt$string$to$search(*) byte initial('PROGRAM VERSION NUMBER=');
declare found$msg(*) byte initial('    program version number is ');
declare not$found$msg (*) byte initial('    file does not contain a program version number', CR,LF);

declare file$name(15) byte initial (':F0:           ');
declare buffer(READ$BUFFER$LENGTH) byte;
declare actual address;
declare aft$in address;
declare buffer$index address;
declare buffer$ptr pointer;
declare (len, len1) word;
declare status word;
declare version$msg$length address;
declare end$of$file bool;
declare sentinel byte;
declare i byte;
declare program$msg$printed bool;
declare string$index byte;
declare successful$find bool;
declare no$ver$found bool initial(TRUE);
declare end$ptr address;


SkipBlanksNTabs: procedure(char$ptr) pointer;
    declare char$ptr pointer, char based char$ptr byte;

    do while char = ' ' or char = TAB;
        char$ptr = char$ptr + 1;
    end;
    return char$ptr;
end;

CheckStatus: procedure(isis$status);
    declare isis$status word;

    if isis$status <> 0 then
    do;
        call Error(isis$status);
        call Exit;
    end;
end;

StopEveryThing: procedure(msg$ptr);
    declare msg$ptr pointer, msg based msg$ptr (256) byte;
    declare msg$length word;

    msg$length = 0;

    do while msg(msg$length) <> 0 and msg$length < 255;
        msg$length = msg$length + 1;
    end;

    call Write(CONSOLE$OUTPUT, msg$ptr, msg$length, .status);
    call CheckStatus(status);
    call Co(BELL);
    call Exit;
end;

Capitalize: procedure(ptr, len);
    declare ptr pointer, char based ptr byte;
    declare len byte;
    declare i byte;

    do i = 1 to len;
        if char >= 'a' and char <= 'z' then
            char = char - 20h;
        ptr = ptr + 1;
    end;
end;

AsciiDigit: procedure(char) bool;
    declare char byte;

    if char >= '0' and char <= '9' then
        return TRUE;
    else
        return FALSE;
end;

FileNameLength: procedure(ptr) byte;
    declare ptr pointer, char based ptr byte;
    declare tmp$ptr address;

    tmp$ptr = ptr;
    do while   (char >= 'A' and char <= 'Z')
            or (AsciiDigit(char))
            or char = '.'
            or char = ':';
        ptr =  ptr + 1;
    end;
    tmp$ptr = ptr - tmp$ptr;
    if tmp$ptr > 14 then
    do;
        call Error(4);  /* illegal filename specification */
        call Exit;
    end;
    return tmp$ptr;
end;

StringFound: procedure(buffer$ptr, len0) bool;
    declare buffer$ptr pointer;
    declare len0 word;
    declare buffer$char based buffer$ptr (256) byte;

    buffer$index = 0;
    do while buffer$index < len0 and string$index < len1;
        if   buffer$char(buffer$index) = string$to$search(string$index)
          or buffer$char(buffer$index) = alt$string$to$search(string$index) then
            string$index = string$index + 1;
        else
        if string$index > 0 then
        do;
            buffer$index = buffer$index - 1;
            string$index = 0;
        end;
        buffer$index = buffer$index + 1;
    end;

    if string$index >= len1 then
        return TRUE;
    else
        return FALSE;
end;

CheckVersionNumber: procedure(char$ptr);
    declare char$ptr pointer, char based char$ptr byte;
    declare (version$type$v, version$type$x) byte;

    version$type$v, version$type$x = FALSE;
    if char = 'V'  then
        version$type$v = TRUE;
    else
    if char = 'X'  then
        version$type$x = TRUE;

    if version$type$v  or  version$type$x  then
    do;
        version$msg$length = 4;
        program$msg$printed = true;
        char$ptr = char$ptr + 1;
        if AsciiDigit(char)  then
        do;
            char$ptr = char$ptr + 1;
            if (char = '.'  and  version$type$v)  or
                (AsciiDigit(char)  and  version$type$x)  then
            do;
                char$ptr = char$ptr + 1;
                if  AsciiDigit(char)  then
                    return;
            end;
        end;
    end;

    if char = SENTINEL$1 then     /* look for  1...0  combination  */
    do;
        char$ptr = char$ptr + 1;  /* advance beyond the sentinel  */
        buffer$ptr = buffer$ptr + 1;  /* don't print the sentinel  */
        program$msg$printed = false;
        version$msg$length = 0;
        do while char <> sentinel;  /*  determine the message length  */
            version$msg$length = version$msg$length + 1;
            if (char$ptr := char$ptr + 1) > end$ptr then
            do;
                call Write(CONSOLE$OUTPUT, buffer$ptr, version$msg$length, .status);
                call CheckStatus(status);
                call Read(aft$in, .buffer, READ$BUFFER$LENGTH, .actual, .status);
                call CheckStatus(status);
                buffer$ptr, char$ptr = .buffer;
                version$msg$length = 0;
            end;
        end;
        return;
    end;

    successful$find = false;
    string$index = 0;
end;

PrintResult: procedure;
    if program$msg$printed then
    do;
        call Write(CONSOLE$OUTPUT, .found$msg, length(found$msg), .status);
        call CheckStatus(status);
    end;
    call Write(console$output, buffer$ptr, version$msg$length, .status);
    call CheckStatus(status);
    call Write(console$output, .(CR, LF), 2, .status);
    call CheckStatus(status);
    string$index = 0;
end;

ParseCommandTail:  procedure;
    declare command$tail(140) byte;
    declare char$ptr pointer,
    char based char$ptr byte;

    call read(CONSOLE$INPUT, .command$tail, length(command$tail), .actual, .status);
    call CheckStatus(status);

    command$tail(actual - 1) = CR;
    call Capitalize(.command$tail, actual);
    char$ptr = SkipBlanksNTabs(.command$tail);

    len = FileNameLength(char$ptr);
    if char = ':'  then
    do i = 0  to  len;
      file$name(i) = char;
      char$ptr = char$ptr + 1;
    end;
    else
    do i = 4  to  len + 4;
      file$name(i) = char;
      char$ptr = char$ptr + 1;
    end;

    char$ptr = SkipBlanksNTabs(char$ptr);
    if char = 'X'  then
    do;
        char$ptr = char$ptr + 1;
        sentinel = 2;
    end;
    else
        sentinel = 0;
    char$ptr = SkipBlanksNTabs(char$ptr);
    if char <> CR then
        call stop$everything(.('Syntax is "VERS  <file name>" ',CR, LF, 0));
end;

SearchForString:  procedure;

    call open(.aft$in, .file$name, OPEN$FOR$READ, no$line$edit, .status);
    call CheckStatus(status);

    len1 = length(string$to$search);
    successful$find, end$of$file = FALSE;
    string$index = 0;
    end$ptr = .actual;

    do while not end$of$file;
        call Read(aft$in, .buffer, read$buffer$length, .actual, .status);
        call CheckStatus(status);
        if actual < READ$BUFFER$LENGTH  then
          end$of$file = TRUE;

        buffer$ptr = .buffer;

        do while buffer$ptr < .buffer(actual);
          successful$find = StringFound(buffer$ptr, .buffer(actual) - buffer$ptr);
          buffer$ptr = buffer$ptr + buffer$index;
          if successful$find  then
            do;
              call CheckVersionNumber(buffer$ptr);
              if successful$find  then
              do;
                call PrintResult;
                end$of$file = true;
                no$ver$found = FALSE;
              end;
            end;
        end;
    end;
end SearchForString;
 
main:
    call ParseCommandTail;
    call SearchForString;
    if no$ver$found then
      call Write(CONSOLE$OUTPUT, .not$found$msg, length(not$found$msg), .status);
    call CheckStatus(status);
    call Close(aft$in, .status);
    call CheckStatus(status);
    call Exit;
end;
eof; 
