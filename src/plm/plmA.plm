PLMA: DO;

DECLARE LIT LITERALLY 'LITERALLY',
	CR LIT '0DH',
	LF LIT '0AH',
	QUOTE LIT '27H',
	TRUE LIT '0ffh',
	FALSE LIT '0',
	BOOLEAN LIT 'BYTE',
	IRESCAN LIT '11';

DECLARE
	signonMsg(*) BYTE DATA(CR, LF, 'ISIS-II PL/M-80 COMPILER '),
	noMemMsg(*) BYTE DATA('NOT ENOUGH MEMORY FOR A COMPILATION'),
	a$ixi(*) BYTE DATA('.IXI'),
	a$obj(*) BYTE DATA('.OBJ'),
	a$lst(*) BYTE DATA('.LST'),
	plmtx1(*) BYTE DATA(':F1:PLMTX1.TMP '),
	plmtx2(*) BYTE DATA(':F1:PLMTX2.TMP '),
	plmat(*) BYTE DATA(':F1:PLMAT.TMP '),
	plmnms(*) BYTE DATA(':F1:PLMNMS.TMP '),
	plmxrf(*) BYTE DATA(':F1:PLMXRF.TMP '),
	aInvocationComm(*) BYTE DATA('INVOCATION COMMAND DOES NOT END WITH <CR><LF>'),
	aIncorrectDevice(*) BYTE DATA('INCORRECT DEVICE SPEC'),
	aSourceFileNotDisk(*) BYTE DATA('SOURCE FILE NOT A DISKETTE FILE'),
	aSourceFileName(*) BYTE DATA('SOURCE FILE NAME INCORRECT'),
	aSourceFileBadExt(*) BYTE DATA('SOURCE FILE EXTENSION INCORRECT'),
	aIllegalCommand(*) BYTE DATA('ILLEGAL COMMAND TAIL SYNTAX');


$include(:f3:movmem.aex)
/* use local definition for fill */
$include(fill.aex)
$include(:f3:initf.pex)
$include(:f3:openf.pex)
$include(:f3:memchk.aex)
$include(:f3:fatal.pex)
$include(:f3:prints.pex)
$include(:f3:fatlIO.pex)
$include(:f3:readf.pex)

setDate: PROCEDURE(str, len) EXTERNAL; DECLARE str ADDRESS, len BYTE; end setDate;
setPageLen: PROCEDURE(len) EXTERNAL; DECLARE len ADDRESS; end setPageLen;
setMarkerInfo: PROCEDURE(b1, b2, b3) EXTERNAL; DECLARE (b1, b2, b3) BYTE; end setMarkerInfo;
setPageNo: PROCEDURE(val) EXTERNAL; DECLARE val ADDRESS; end setPageNo;
setMarginAndTabW: PROCEDURE(b1, b2) EXTERNAL; DECLARE (b1, b2) BYTE; end setMarginAndTabW;
setPageWidth: PROCEDURE(val) EXTERNAL; DECLARE val ADDRESS; end setPageWidth;
setTitle: PROCEDURE(str, len) EXTERNAL; DECLARE str ADDRESS, len BYTE; end setTitle;

$include(:f3:data.inc)
declare ioBuffer(1) byte external,
	verno(1) byte external;

DECLARE
	cmdText$p ADDRESS PUBLIC,
	cmdch BASED cmdText$p BYTE;


sub$40AC: PROCEDURE PUBLIC;

	rescan: procedure (conn, status$p);
	    declare (conn, status$p) address;
		call ISIS(IRESCAN, .conn);
	end rescan;


	skipSpace: PROCEDURE;
		do while cmdch = ' ' or cmdch = '&';
			if cmdch = ' ' then
				cmdText$p = cmdText$p + 1;
			else if 0 <> cmd.link then
			do;
				cmdLine$p = cmd.link;
				cmdText$p = cmdLine$p + 3;
			end;
		end;
	end skipSpace;


	testToken: PROCEDURE(str, len) BOOLEAN;
		DECLARE str ADDRESS, len BYTE;
		DECLARE p ADDRESS;
		DECLARE strch BASED str BYTE;

		p = cmdText$p;
		do while len <> 0;
			if (cmdch and 5FH) <> strch then
			do;
				cmdText$p = p;
				return false;
			end;
			cmdText$p = cmdText$p + 1;
			str = str + 1;
			len = len - 1;
		end;
		return true;
	end testToken;


	skipAlphaNum: PROCEDURE;
		
		do while 'A' <= cmdch and cmdch <= 'Z' or 'a' <= cmdch and cmdch <= 'z'
					or '0' <= cmdch and cmdch <= '9';
			cmdText$p = cmdText$p + 1;
		end;
	end skipAlphaNum;



	getCmdLine: PROCEDURE;
		DECLARE (actual, status) ADDRESS;
		DECLARE (i, inQuote) BYTE;

		call Rescan(1, .status);
		if status <> 0 then
			call fatlIO(.conFile, status);
		startCmdLine$p = 0;
		cmdLine$p = topMem;

		loop: do;
			call readf(.conFile, .ioBuffer, 128, .actual);
			if ioBuffer(actual - 1) <> LF or ioBuffer(actual - 2) <> CR then
				call fatal(.aInvocationComm, length(aInvocationComm));
			topMem = cmdLine$p - actual - 3;
			if startCmdLine$p = 0 then
				startCmdLine$p = topMem;
			else
				cmd.link = topMem;
			cmdLine$p = topMem;
			cmd.pstr(0) = actual;
			call movmem(actual, .ioBuffer, .cmd.pstr(1));
			inQuote = 0;
			do i = 0 to actual - 1;
				if ioBuffer(i) = QUOTE then
					inQuote = not inQuote;
				else if ioBuffer(i) = '&' then
					if not inQuote then
						goto extend;
			end;
			cmd.link = 0;
			cmdLine$p = startCmdLine$p;
			topMem = topMem - 1;
			return;
		extend:
			call printStr(.('**'), 2);
			goto loop;
		end;
	end getCmdLine;

	parseInvokeName: PROCEDURE;
		DECLARE (p, start$p, len) ADDRESS;
		DECLARE ch BASED cmdText$p BYTE;

		call skipSpace;
		if testToken(.('DEBUG'), 5) then
			debugFlag = 0FFH;
		else
			debugFlag = 0;
		call skipSpace;
		start$p = cmdText$p;
		if ch = ':' then
			cmdText$p = cmdText$p + 4;
		call skipAlphaNum;
		if (len := cmdText$p - start$p) > 10 then
			len = 10;
		do p = .overlay1 to .overlay5 by length(overlay1);
			call movmem(len, start$p, p);
		end;
		call movmem(len, start$p, .invokeName);
		call movmem(len, start$p, .overlay6);
		do p = .overlay1 to .overlay5 by length(overlay1);
			call movmem(5, p + 10, p + len);
		end;
		call movmem(5, .ov0, .invokeName(len));
		call movmem(5, .ov6, .overlay6 + len);
	end parseInvokeName;


	parseSrcFile: PROCEDURE;
		DECLARE cmdText BASED cmdText$p(1) BYTE;
		DECLARE fullName ADDRESS;
		DECLARE fileName ADDRESS;
		DECLARE nameLen ADDRESS;

		do while  cmdch <> ' ' and cmdch <> CR and cmdch <> '&';
			cmdText$p = cmdText$p + 1;
		end;
		call skipSpace;
		fullName = cmdText$p;
		if cmdch = ':' then
		do;
			if cmdText(3) <> ':' then
				call fatal(.aIncorrectDevice, length(aIncorrectDevice));
			if cmdText(1) >= 'a' then
				cmdText(1) = cmdText(1) and 05FH;
			if cmdText(1) <> 'F' then
				call fatal(.aSourceFileNotDisk, length(aSourceFileNotDisk));
			cmdText$p = cmdText$p + 4;
		end;
		fileName = cmdText$p;
		call skipAlphaNum;
		if (nameLen := cmdText$p - fileName) = 0 or nameLen > 6 then
			call fatal(.aSourceFileName, length(aSourceFileName));
		srcStemLen = cmdText$p - fullname;
		call FILL(10, .srcStemName, ' ');
		call movmem(srcStemLen, fullname, .srcStemName);
		if cmdch = '.' then
		do;
			filename = (cmdText$p := cmdText$p + 1);
			call skipAlphaNum;
			if (namelen := cmdText$p - filename) = 0 or nameLen > 3 then
				call fatal(.aSourceFileBadExt, length(aSourceFileBadExt));
		end;
		namelen = cmdText$p - fullname;
		srcFileIdx = 0;
		call FILL(16, .srcFileTable, ' ');
		call movmem(namelen, fullname, .srcFileTable);
		call FILL(4, .srcFileTable(8), 0);
		call skipSpace;
		if cmdch = '$' then
			call fatal(.aIllegalCommand, length(aIllegalCommand));
		if cmdch = CR then
			offNxtCmdChM1 = 0;
		else
			offNxtCmdChM1 = cmdText$p - cmdLine$p - 1;
	end parseSrcFile;

	sub$45F6: PROCEDURE;
		LEFTMARGIN = 1;
		call FILL(15, .ixiFileName, ' ');
		call movmem(srcStemLen, .srcStemName, .ixiFileName);
		call movmem(4, .a$ixi, .ixiFileName(srcStemLen));
		call initf(.ixiFile, .('IXREF '), .ixiFileName);
		objBlk, objByte = 0;
		call FILL(15, .objFileName, ' ');	
		call movmem(srcStemLen, .srcStemName, .objFileName);
		call movmem(4, .a$obj, .objFileName(srcStemLen));
		call initf(.objFile, .('OBJECT'), .objFileName);
		call FILL(15, .lstFileName, ' ');	
		call movmem(srcStemLen, .srcStemName, .lstFileName);
		call movmem(4, .a$lst, .lstFileName(srcStemLen));
		call initf(.lstFil, .('LIST '), .lstFileName);
		call initf(.tx1File, .('UT1 '), .plmtx1);
		call initf(.tx2File, .('UT2 '), .plmtx2);
		call initf(.atFile, .('AT  '), .plmat);
		call initf(.nmsFile, .('NAMES '), .plmnms);
		call initf(.xrfFile, .('XREF '), .plmxrf);
		IXREF = false;
		IXREFSET = false;
		PRINT = true;
		PRINTSet = true;
		XREF = false;
		SYMBOLS = false;
		DEBUG = false;
		PAGING = true;
		OBJECT = true;
		OBJECTSet = true;
		OPTIMIZE = true;
		call setDate(.(' '), 1);
		call setPageLen(57);
		call setMarkerInfo(20, 45, 21);
		call setPageNo(0);
		call setMarginAndTabW(0FFH, 4);
		call setTitle(.(' '), 1);
		call setPageWidth(120);
	end sub$45F6;


	call movmem(4, .verNo, .version);
	call initf(.conFile, .('CONSOL'), .(':CI: '));
	call openf(.confile, 1);
	topMem = MEMCHK - 12;
	if topMem < 0C000H then
		call fatal(.noMemMsg, length(noMemMsg));
	call getCmdLine;
	call printStr(.signonMsg, length(signonMsg));
	call printStr(.version, 4);
	call printStr(.(CR, LF), 2);
	cmdText$p = cmdLine$p + 3;
	blkSize1 = topMem - blkSize1 - 256;
	blkSize2 = topMem - blkSize2 - 256;
	call parseInvokeName;
	call parseSrcFile;
	call sub$45F6;
end sub$40AC;

END;

