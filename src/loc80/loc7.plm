locate7: DO;
$INCLUDE(ISIS.EXT)
$INCLUDE(LOC.LIT)
$INCLUDE(LOC1.EXT)
$INCLUDE(LOC2A.EXT)
$INCLUDE(LOC2B.EXT)
$INCLUDE(LOC3.EXT)
$INCLUDE(LOC4.EXT)
$INCLUDE(LOC5.EXT)
$INCLUDE(LOC6.EXT)
/*$INCLUDE(LOC7.EXT)*/
$INCLUDE(LOC8.EXT)
$INCLUDE(LOC9.EXT)

$INCLUDE(LOC.BAS)

DECLARE erec BASED erec$p BYTE;

DECLARE cin(1) BYTE EXTERNAL;
DECLARE cout(1) BYTE EXTERNAL;
DECLARE mdebug(1) BYTE EXTERNAL;
DECLARE mstar2(1) BYTE EXTERNAL;
DECLARE mto(1) BYTE EXTERNAL;
DECLARE mtoand(1) BYTE EXTERNAL;

DECLARE nxtSegOrder BYTE PUBLIC;

parseLPNumRP: PROCEDURE ADDRESS PUBLIC;
	DECLARE num ADDRESS;

	CALL expectLP;
	IF cmdCh < '0' OR '9' < cmdCh THEN	/* must have digit */
		CALL cmdErr(ERR203);	/* invalid syntax */
	num = parseNumber(.cmd$p);
	IF pastFileName(cmd$p) <> cmd$p THEN	/* make sure not a filename or bad number */
		CALL cmdErr(ERR203);	/* invalid syntax */
	CALL expectRP;
	RETURN num;
END parseLPNumRP;


getCommonSegId: PROCEDURE BYTE PUBLIC;
	DECLARE name(32) BYTE;
	DECLARE	comdefRec BASED in$p STRUCTURE (segid BYTE, name(1) BYTE);

	IF cmdch = '/' THEN
		RETURN SBLANK;	/* blank common */
	CALL getpstrName(.name);
	name(name(0) + 1) = ' ';	/* space at end */
	CALL iseek(0, 0);
	CALL getRecord;		/* skip modhdr record */

	DO WHILE 1;
		CALL getRecord;
		IF inRecord.rectyp <> R$COMDEF THEN
			CALL errChkReport(ERR237, .name(1), TRUE);	/* common not found */
		DO WHILE in$p < .erec;
			IF strequ(.name, .comdefRec.name, name(0)+1) THEN
				RETURN comdefRec.segid;
			in$p = in$p + 2 + comdefRec.name(0);
		END;
	END;
END getCommonSegId;


insSegIdOrder: PROCEDURE(seg) PUBLIC;
	DECLARE seg BYTE;
	DECLARE i BYTE;
	nxtSegOrder = nxtSegOrder + 1;
	IF segOrder(nxtSegOrder) = seg THEN	/* already in order */
		RETURN;
	DO i = 0 TO nxtSegOrder;
		IF segOrder(i) = seg THEN	/* already allocated ? */
			CALL cmdErr(ERR203);	/* invalid syntax */
	END;
	DO i = nxtSegOrder + 1 TO SBLANK - 1;	/* find the current location of seg */
		IF segOrder(i) = seg THEN
			goto L6C93;
	END;
L6C93:
	DO WHILE i > nxtSegOrder;
		segOrder(i) = segOrder(i - 1);	/* make room for this seg */
		i = i - 1;
	END;
	segOrder(nxtSegOrder) = seg;		/* insert it */
END insSegIdOrder;


readCmdLine: PROCEDURE PUBLIC;

	CALL read(1, cmd$p, 128, .actRead, .statusIO);
	CALL errChkReport(statusIO, .cin, TRUE);
	cmdbuf(actRead) = 0DH;
	call strupr(cmd$p);
END readCmdLine;


procArgs$Init: PROCEDURE PUBLIC;
	DECLARE scmdch BASED scmd$p BYTE;
	DECLARE (p, args$p) ADDRESS;

	/* work out a good io buf size */
	/* checks are for >= 32k of space, >= 16k of space */
	IF (pageCacheSize := HIGH(memck - baseMemImage) - 1) >= 128 THEN
		npbuf = 4096;
	ELSE IF pageCacheSize >= 64 THEN
		npbuf = 2048;
	ELSE
		npbuf = 1056;

	eibuf$p, ibuf$p = memck;	/* in buffer at top of memory */
	sibuf$p, eout$p = eibuf$p - npbuf;	/* output buffer is below this */
						/* and for now now print buffer */
	outRecord$p, out$p, spbuf$p, pbuf$p, epbuf$p = eout$p - npbuf;
	scmd$p = .MEMORY;		/* command line buffer */
	/* if >= 32k then also use a print buffer */
	IF (usePrintBuf := pageCacheSize >= 64) THEN
		scmd$p = outRecord$p;	/* seems odd to share output buf */
	scmdch = '-';
	CALL rescan(1, .statusIO);	/* rewind to get command line args */
	cmd$p = scmd$p + 1;
	CALL readCmdLine;		/* read the command line args */
	cmd$p = skipspc(cmd$p);		/* skip leading space, DEBUG if present and loc command */
	IF strequ(cmd$p, .mdebug, 6) THEN
		cmd$p = skipspc(cmd$p + 6);
	cmd$p, args$p = skipspc(pastFileName(cmd$p));	/* args$p marks start of real args */
	DO WHILE cmdch <> 0DH;		/* read until end of args */
		IF cmdch = '&' THEN	/* handle continuation line */
		DO;
			p = cmd$p;	/* mark the & */
			cmd$p = skipspc(cmd$p + 1);	/* check we didn't have anything after */
			IF cmdch <> 0DH THEN
				CALL cmdErr(ERR203);	/* invalid syntax */
			cmd$p = p;	/* reset to & */
			CALL conStrOut(.mstar2, 2);	/* emit ** to user */
			cmdbuf(1) = 0DH;	/* put the cr lf ** after the & */
			cmdbuf(2) = 0AH;
			cmdbuf(3) = '*';
			cmdbuf(4) = '*';
			cmd$p = cmd$p + 5;	/* position to read the next line */
			CALL readCmdLine;	/* read another line */
		END;
		ELSE	/* skip char */
			cmd$p = cmd$p + 1;
	END;	/* DO WHILE */

	/* display the sign on message skipping the form feed */
	CALL constrOut(.signonMsg + 1, 23);
	CALL constrOut(.VERSION, 4);
	CALL constrOut(.crlf, 2);
	/* if we have run into the in buffer then we have a problem */
	IF cmd$p > sibuf$p THEN
		CALL cmdErr(ERR210);	/* insufficient memory */
	/* skip the leading space of the command args */
	CALL skipNonArgChars(args$p);
	/* get the file we are locating */
	CALL getFile;
	/* can only locate a disk file */
	IF spathInfo.deviceType <> 3 THEN
		CALL errNotADisk;
	CALL makeFullName(.spathInfo, .inFileName(1));
	/* convert to a omf style string by putting the length in at the front */
	inFileName(0) = pastFileName(.inFileName(1)) - .inFileName(1);
	/* check for TO (followed by space or & */
	IF strequ(cmd$p, .mto, 3) OR strequ(cmd$p, .mtoand, 3) THEN
	DO;
		CALL skipNonArgChars(cmd$p + 2);
		CALL getFile;	/* get the output file */
	END;
	ELSE
	DO;	/* handle the case of TO missing unless the input did not have an extension */
		IF spathInfo.ext(0) = 0 THEN
			CALL cmdErr(ERR233);	/* TO expected */
		spathInfo.ext(0) = 0;	/* assume TO would be input file name without extension */
		spathInfo.ext(1) = 0;
		spathInfo.ext(2) = 0;
	END;
	/* get the output file name in standard format */
	CALL makeFullName(.spathInfo, .outFileName(1));
	outFileName(0) = pastFileName(.outFileName(1)) - .outFileName(1);
	/* only accept a disk file or the bit bucket */
	IF spathInfo.deviceType <> 3 and spathInfo.deviceId <> 22 THEN	/* 22 -> :BB: */
		CALL errNotADisk;
	/* copy the disk name over and create the tmp file name */
	tmpFileInfo(0) = spathInfo.deviceId;
	CALL makefullName(.tmpFileInfo, .tmpFileName(1));
	tmpFileName(0) = pastFileName(.tmpFileName(1)) - .tmpFileName(1);
	/* record if we are creating a real file */
	outRealFile = spathInfo.deviceId <> 22;
	/* open the file to locate */
	CALL open(.readfd, .InFileName(1), 1, 0, .statusIO);
	CALL errChkReport(statusIO, .inFileName(1), TRUE);
	recNum = 0;
	/* check we have a relocation file */
	CALL getRecord;
	IF inRecord.rectyp <> R$MODHDR THEN
		CALL errChkReport(ERR239, .inFileName(1), TRUE);	/* no module header record */
	/* assume listing to :CO: */
	CALL pstrcpy(.cout, .printFileName);
	/* set other defaults and record that we haven't seen the commands */
	columns = 1;
	startSeen = 0;
	stackSizeSeen = 0;
	restart0Seen = 0;
	MapSeen = 0;
	PublicsSeen = 0;
	SymbolsSeen = 0;
	LinesSeen = 0;
	PurgeSeen = 0;
	moduleNameSeen = 0;
	isMain = 0;		/* assume not main module */
	modhdr$x1 = 0;
	modhdr$x2 = 0;
	startAddr = 0;
	/* initialise the segment order */
	CALL initSegOrder;
	/* and set all as not yet seen with 0 size and location */
	DO p = 0 TO 255;
		segFlags(p) = AUNKNOWN;
		segBases(p), segSizes(p) = 0;
	END;
	/* process the rest of the command args */
	DO WHILE cmdch <> 0DH;
		CALL processControls;
	END;
	/* no paging file yet and no allocated pages */
	havePagingFile = 0;
	roundRobinIndex = 0;
	pageIndexTmpFil = 0;
	/* recalculate pageCache size */
	pageCacheSize = HIGH(outRecord$p - (pageTab1$p := pageTab2$p + size(pageTab2))) - 1;
	/* set a new baseMemImage after allocting pageTab1 slots - one for each page */
	baseMemImage =  pageTab1$p + (pageCacheSize + 1) * 2 ;
	/* initialise the paging table control information */
	DO p = 0 TO 255;
		/* we have only allocated space for up to pageCacheSize entries in pageTab1 */
		IF p <= pageCacheSize THEN
			pageTab1(p).state = 0FFH; /* not used */
		pageTab2(p).pageIdx = 0FFH;	/* not used */
		pageTab2(p).fileIdx = 0FFH;	/* not used */
	END;
	/* allocate the print buffer below the output buffer if we have one */
	IF usePrintBuf THEN
		spbuf$p, pbuf$p = epbuf$p - npbuf;
	/* set up the heap locations below the print buffer */
	topHeap, topDataFrags, botHeap = spbuf$p;
	/* recalculate the pageCacheSize now available */
	pageCacheSize = HIGH(botHeap - baseMemImage) - 1;
	/* create the output file*/
	CALL delete(.outFileName(1), .statusIO);
	CALL open(.outputfd, .outFilename(1), 3, 0, .statusIO);
	CALL errChkReport(statusIO, .outFileName(1), TRUE);
	/* and the print file (or console) */
	CALL open(.printfd, .printFileName(1), 2, 0, .statusIO);
	CALL errChkReport(statusIO, .printFileName(1), TRUE);
	/* if not console then emit the signon and command line to the print file */
	IF printfd > 0 THEN
	DO;
		CALL printString(.signonMsg, 24);
		CALL printString(.VERSION, 4);
		CALL printString(.aInvokedBY, 14);
		CALL printString(.scmdch, cmd$p - .scmdch + 2);
	END;
END procArgs$Init;

DECLARE aInpageSegment2(*) BYTE PUBLIC INITIAL('INPAGE SEGMENT > 256 BYTES COERCED TO PAGE BOUNDRY', 0DH, 0AH),
	segId BYTE PUBLIC,
	pad7935(3) BYTE PUBLIC;

alignAddress: PROCEDURE(align, size, laddr) ADDRESS PUBLIC;
	DECLARE align BYTE;
	DECLARE (size, laddr) ADDRESS;
	IF size = 0 THEN	/* no size to no alignment needed */
		RETURN laddr;

	IF align = ABYTE THEN
		RETURN laddr;	/* no alignment needed */
	IF align = AINPAGE THEN
		IF size <= 256 THEN	/* check if fits in page */
		DO;
			IF HIGH(laddr) = HIGH(laddr + size - 1) THEN
				RETURN laddr;
		END;
		ELSE    /* inpage seg > 256 coerced to page boundary */
			CALL conAndPrint(.aInpageSegment2, 52);	
	RETURN (laddr + 0FFH) AND 0FF00H;	/* get a whole page */
END alignAddress;


procMODHDR: PROCEDURE PUBLIC;
	DECLARE rbyt BASED in$p (1) BYTE;
	DECLARE sdef BASED in$p STRUCTURE (segId BYTE, len ADDRESS, combine BYTE); 
	DECLARE (loadAddress, segSize, segOrderId) ADDRESS;
	DECLARE (atTopOfMem, loadHasSize) BYTE;

	IF NOT moduleNameSeen THEN	/* copy over the module name if not user overridden */
		CALL pstrcpy(in$p, .moduleName);
	in$p = in$p + rbyt(0) + 1;	/* past name */
	modhdr$x1 = rbyt(0);		/* copy the reserved bytes */
	modhdr$x2 = rbyt(1);
	in$p = in$p + 2;
	loadHasSize = 0;
	DO WHILE in$p < .erec;		/* process all of the seg info */
		IF (segFlags(segId := sdef.segId) AND AMASK) <> AUNKNOWN THEN
			CALL illegalRecord;	/* oops seen twice */
		IF segId <> SSTACK THEN		/* by default copy the length */
			segSizes(segId) = sdef.len;
		ELSE IF NOT stackSizeSeen THEN	/* for stack copy if not user overridden */
			segSizes(SSTACK) = sdef.len;
		IF segSizes(segId) > 0 THEN	/* check we have some data */
			loadHasSize = TRUE;
		IF sdef.combine - 1 > ABYTE - 1 THEN	/* check valid alignment */
			CALL illegalRecord;
		segFlags(segId) = segFlags(segId) + sdef.combine;	/* set the combine info */
		in$p = .sdef + size(sdef);	/* skip to next seg info */
	END;
	IF (segFlags(SSTACK) AND AMASK) = AUNKNOWN THEN		/* if STACK not specified put default */
		segFlags(SSTACK) = segFlags(SSTACK) + ABYTE;	/* set to byte align */
	IF (segFlags(SMEMORY) AND AMASK) = AUNKNOWN THEN	/* if MEMORY not specified put default */
		segFlags(SMEMORY) = segFlags(SMEMORY) + ABYTE;	/* set to byte align */
	IF NOT stackSizeSeen AND loadHasSize THEN		/* it STACK not specified by user and we have data */
		segSizes(SSTACK) = segSizes(SSTACK) + 12;	/* reserve an additional 12 bytes */
	loadAddress = 3680H;				/* ISIS load address */
	atTopOfMem = 0;

	DO segOrderId = 1 TO 254;	/* process the segs taking account of user specified order */
		segid = segOrder(segOrderId);
		segSize = segSizes(segId);	/* pick up seg to process */
		IF (segFlags(segId) AND FHASADDR) = 0 THEN	/* no address specified */
		DO;
			IF atTopOfMem <> 0 THEN	/* check for going over 64k */
			DO;
				IF segSize > 0 THEN	/* program exceeds 64k */
					CALL errChkReport(ERR240, .inFileName(1), TRUE);
				segFlags(segId) = segFlags(segId) OR FWRAP0;
			END;
		END;
		ELSE
		DO;	/* user specified address */
			IF segSize > 0 THEN	/* reset topOfMemflag */
				atTopOfMem = 0;
			loadAddress = segBases(segId);	/* set the loadAddress to user specified */
		END;
		/* update this segments base address allowing for alignment */
		segBases(segId) = alignAddress(segFlags(segId) AND AMASK, segSize, loadAddress);
		IF segId = SMEMORY THEN
			IF segSize = 0 AND loadHasSize THEN	/* if not specified and program has size */
								/* calcualte a MEMORY size */
				IF atTopOfMem = 0 AND memck > segBases(SMEMORY) THEN
					segSizes(SMEMORY), segSize = memck - segBases(SMEMORY);
		/* advance loadAddress and check for memory wrap around */
		IF (loadAddress := segBases(segId) + segSize) < segBases(segId) THEN
			IF loadAddress = 0 THEN		/* at 64k ok else error */
				atTopOfMem = FWRAP0;
			ELSE
				CALL errChkReport(ERR240, .inFileName(1), TRUE);  /* exceeds 64k */
	END; 
	segBases(SSTACK) = segBases(SSTACK) + segSizes(SSTACK);	/* stack goes down so update to top */
	CALL getRecord;	/* preload next record */
END procMODHDR;


procCOMDEF: PROCEDURE PUBLIC;
	DECLARE	comdefRec BASED in$p STRUCTURE (segid BYTE, name(1) BYTE);

	DO WHILE in$p < .erec;
		IF (segId := comdefRec.segid) < SNAMED OR segId = SBLANK THEN
			CALL illegalRecord;
		/* check if combine value not appropriate for common or if this one already seen */
		IF ((segFlags(segId) AND AMASK) = AUNKNOWN) OR ((segFlags(segId) AND FSEGSEEN) <> 0)THEN
			CALL illegalRecord;
		segFlags(segId) = segFlags(segId) OR FSEGSEEN;	/* flag as seen */
		in$p = in$p + 2 + comdefRec.name(0);		/* past byte, len, string */
	END;
	CALL getRecord;
END procCOMDEF;


procHdrAndComDef: PROCEDURE PUBLIC;
	CALL iseek(0, 0);	/* rewind */
	CALL getRecord;		/* get modhdr */
	CALL procMODHDR;	/* load the modhdr and set the segment bases */

	DO WHILE inRecord.rectyp = R$COMDEF;	/* process any comdefs */
		CALL procCOMDEF;
	END;
	DO segId = SNAMED TO SBLANK - 1;	/* check commons in modhdr have comdef entries */
		IF ((segFlags(segId) AND AMASK) <> AUNKNOWN) AND ((segFlags(segId) AND FSEGSEEN) = 0) THEN
			CALL badRecordSeq;
	END;
END procHdrAndComDef;

END locate7;
