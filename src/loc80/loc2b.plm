locate2: DO;
$include(loc2b.ipx)

DECLARE aUnsatisfiedExt(*) BYTE PUBLIC INITIAL('UNSATISFIED EXTERNAL(XXXXX) '),

	aReferenceToUns(*) BYTE PUBLIC INITIAL('REFERENCE TO UNSATISFIED EXTERNAL(XXXXX) AT XXXXH', 0DH, 0AH),
	aSymbolTableOfM(*) BYTE PUBLIC INITIAL(0DH, 0AH, 'SYMBOL TABLE OF MODULE '),
	aReadFromFile(*) BYTE PUBLIC INITIAL(0DH, 0AH, 'READ FROM FILE '),
	aWrittenToFile(*) BYTE PUBLIC INITIAL(0DH, 0AH, 'WRITTEN TO FILE '),
	aValueType(*) BYTE PUBLIC INITIAL('VALUE TYPE '),
	aSymbol(*) BYTE PUBLIC INITIAL(6, 'SYMBOL'),
	aPub(*) BYTE PUBLIC INITIAL('XXXXH PUB  '),
	aSym(*) BYTE PUBLIC INITIAL('XXXXH SYM  '),
	alin(*) BYTE PUBLIC INITIAL('XXXXH LIN  '),
	aMod(*) BYTE PUBLIC INITIAL('      MOD  '),
	x5(*) BYTE PUBLIC INITIAL(5, 'XXXXX'),
	spc32(*) BYTE PUBLIC INITIAL('                                ');

DECLARE	loHiBoth BYTE PUBLIC,
	outSegType BYTE PUBLIC,
	unused(2) BYTE,
	curColumn ADDRESS PUBLIC,
	workingSegBase ADDRESS PUBLIC,
	unsatisfiedCnt ADDRESS PUBLIC INITIAL(0),
	curcol BYTE PUBLIC INITIAL(0),
	curListField ADDRESS PUBLIC INITIAL(0),
	nameLen BYTE PUBLIC INITIAL(0),
	lsout$p ADDRESS PUBLIC,
	lsout BASED lsout$p STRUCTURE (rectyp BYTE, reclen ADDRESS, record(1) BYTE);


seekOutFile: PROCEDURE(mode, pblk, pbyt) PUBLIC;
	DECLARE (mode, pblk, pbyt) ADDRESS;
	CALL seek(outputfd, mode, pblk, pbyt, .statusIO);
	CALL errChkReport(statusIO, .outFileName(1), TRUE);
END seekOutFile;


flushOut: PROCEDURE PUBLIC;
	CALL write(outputfd, outRecord$p, out$p - outRecord$p, .statusIO);
	CALL errChkReport(statusIO, .outFileName(1), TRUE);
	out$p = outRecord$p;
END flushOut;

writeBytes: PROCEDURE(buf$p, cnt) PUBLIC;
	DECLARE (buf$p, cnt) ADDRESS;
	DECLARE bcnt ADDRESS;

	bcnt = eout$p - out$p;
	DO WHILE cnt > bcnt;
		CALL mem$mov(bcnt, buf$p, out$p);
		cnt = cnt - bcnt;
		buf$p = buf$p + bcnt;
		out$p = out$p + bcnt;
		CALL flushOut;
		bcnt = npbuf;
	END;
	CALL mem$mov(cnt, buf$p, out$p);
	out$p = out$p + cnt;
END writeBytes;


initRecOut: PROCEDURE(rectyp) PUBLIC;
	DECLARE rectyp BYTE;
	DECLARE lsout BASED lsout$p STRUCTURE(rectyp BYTE, reclen ADDRESS);

	IF eout$p - out$p < 1028 THEN
		CALL flushout;
	lsout$p = out$p;
	lsout.rectyp = rectyp;
	out$p = out$p + size(lsout);	/* rectyp + length */
END initRecOut;


endRecord: PROCEDURE PUBLIC;
	DECLARE crc BYTE;
	DECLARE pch ADDRESS;
	DECLARE ch BASED pch BYTE;
	DECLARE outch BASED out$p BYTE;

	/* check record not too long */
	IF (lsout.reclen := out$p - .lsout.rectyp - 2) > 1025 THEN
		CALL errChkReport(ERR211, .outFileName(1), TRUE);	/* RECORD TOO LONG */
	/* for what is there generate the CRC */
	crc = 0;
	DO pch = .lsout TO out$p - 1;
		crc = crc + ch;
	END;
	outch = -crc;
	out$p = out$p + 1;
END endRecord;


emitMODDAT: PROCEDURE(curDataFrag$p) PUBLIC;
	DECLARE curDataFrag$p ADDRESS;
	DECLARE curDataFrag BASED curDataFrag$p DATAFRAG$T;
	DECLARE (len, bcnt, pmem, curPC, j) ADDRESS;
	DECLARE crc BYTE;
	DECLARE mem BASED pmem (1) BYTE;
	DECLARE	moddatOut BASED out$p STRUCTURE (segid BYTE, offset ADDRESS, dat(1) BYTE);

	CALL initRecOut(R$MODDAT);
	len = curDataFrag.eaddr - curDataFrag.saddr + 1;
	lsout.reclen = len + 4;
	moddatOut.segid = SABS;		/* abs seg */
	curPC = (moddatOut.offset := curDataFrag.saddr);		/* load address */	
					/* initialise the CRC */
	crc = HIGH(lsout.reclen) + 6 + LOW(lsout.reclen) + HIGH(moddatOut.offset) + LOW(moddatOut.offset);
	out$p = out$p + 3;

	DO WHILE len > 0;
		bcnt = 256;	/* write 256, or less if no page boundary or less bytes available */
		IF LOW(curPC) <> 0 THEN
			bcnt = 256 - LOW(curPC);
		IF bcnt > len THEN
			bcnt = len;
		pmem =  addrInCache(curPC);	/* get a pointer to where the data is now */
		DO j = 0 TO bcnt - 1;		/* include the data in the CRC check */
			crc = crc + mem(j);
		END;
		CALL writeBytes(pmem, bcnt);	/* add the bytes to the output record */
		IF bcnt = 256 THEN		/* if was a whole page then free it */
		DO;
			pageTab1(pageTab2(HIGH(curPC)).pageIdx).state = 0FFH;
			pageTab2(HIGH(curPC)).pageIdx = 0FFH;	/* mark page as free */
		END;
		curPC = curPC + bcnt;		/* account for written data */
		len = len - bcnt;
	END;	/* DO WHILE */

	crc = -crc;			/* close off the record */
	CALL writeBytes(.crc, 1);
END emitMODDAT;


forceSOL: PROCEDURE PUBLIC;
	IF curcol <> 0 THEN
		CALL printcrlf;
	curcol = 0;
END forceSOL;



printColumn: PROCEDURE(field, pstr) PUBLIC;
	DECLARE field ADDRESS;
	DECLARE pstr ADDRESS;
	DECLARE str BASED pstr (1) BYTE;

	/* change of field type then force new line */
	IF field <> curListField THEN
		CALL forceSOL;
	curListField = field;
	/* reached max of columns then force new line */
	IF curcol = columns THEN
		CALL forceSOL;
	/* space to next column: 32 chars - length of previous name */
	IF curcol <> 0 THEN
		CALL printString(.spc32, 32 - nameLen);
	curcol = curcol + 1;
	nameLen = str(0);
	/* print out field lead */
	CALL printString(field, 11);
	/* and the name */
	CALL printString(.str(1), nameLen);
END printColumn;


setWorkingSeg: PROCEDURE(seg) BYTE PUBLIC;	/* always returns 0 */
	DECLARE seg BYTE;
	workingSegBase = segBases(seg);
	RETURN SABS;
END setWorkingSeg;


procMODEND: PROCEDURE PUBLIC;
	DECLARE rst0$p ADDRESS;
	DECLARE jmp BASED rst0$p STRUCTURE (inst BYTE, addr ADDRESS);
	DECLARE	inModend BASED in$p STRUCTURE (modtype BYTE, segid BYTE, offset ADDRESS);
	DECLARE	outModend BASED out$p STRUCTURE (modtype BYTE, segid BYTE, offset ADDRESS);

	DECLARE curDataFrag BASED curDataFrag$p DATAFRAG$T;	/* used for size below */

	IF inModend.modtype = 1 THEN	/* is main module */
	DO;
		isMain = 1;	/* flag as main module */
		outSegType = setWorkingSeg(inModend.segid);
		IF NOT startSeen THEN	/* use the main module's address */
			startAddr = workingSegBase + inModend.offset;
		IF restart0Seen THEN	/* restart0 the put jump to startAddr */
		DO;
			rst0$p = addrInCache(0);	/* location of address 0 in cache */
			jmp.inst = 0C3H;		/* insert the jump */
			jmp.addr = startAddr;
			CALL addSegFrag(AABS, SABS, 0, 3);/* add to the frags */
			CALL addDataFrag(0, 2);
		END;
	END;
	ELSE
		startAddr = 0;	/* 0 start address if not a main module */
	CALL flushOut;			/* flush any data in the buffers */
	curDataFrag$p = topDataFrags;
	DO WHILE curDataFrag$p <> botHeap;	/* emit all of the data frags */
		curDataFrag$p = curDataFrag$p - size(curDataFrag);
		CALL emitMODDAT(curDataFrag$p);
	END;

	CALL initRecOut(R$MODEND);	/* generate the rectyp 4 record */
	outModend.modtype = isMain;
	outModend.segid = 0;
	outModend.offset = startAddr;
	out$p = out$p + 4;
	CALL writeBytes(in$p + DOUBLE(4), recLen - DOUBLE(4) - 1);	/* copy rectyp 4 tail over */
	CALL endRecord;					/* insert length and CRC */
	CALL initRecOut(R$MODEOF);				/* EOF record */
	CALL endRecord;
	CALL flushOut;
END procMODEND;


procMODDAT: PROCEDURE PUBLIC;
	DECLARE (mark, endrec) STRUCTURE (blk ADDRESS, byt ADDRESS);
	DECLARE fixextUsed BYTE;
	DECLARE (fixRAddr, pad) ADDRESS;
	DECLARE (locRecLen, recSegBaseAddr) ADDRESS;
	DECLARE (fixLoc, fixLoc2) ADDRESS;
	DECLARE (loByt, hiByt) BYTE, bothByt ADDRESS AT (.loByt);	/* used to handle cross page fixup */

	DECLARE bfix BASED fixLoc BYTE;		/* fixup location of byte */
	DECLARE bfix2 BASED fixLoc2 BYTE;	/* fixup location of 2nd byte if cross page boundary */
	DECLARE wfix BASED fixLoc ADDRESS;
	DECLARE erec BASED erec$p(1) BYTE;
	DECLARE	moddatRec BASED in$p STRUCTURE (segid BYTE, offset ADDRESS, dat(1) BYTE);
	DECLARE	inLoHiBoth BASED in$p BYTE;
	DECLARE	outLoHiBoth BASED out$p BYTE;
	DECLARE	inExtfix BASED in$p STRUCTURE (namidx ADDRESS, offset ADDRESS);
	DECLARE	outExtfix BASED out$p STRUCTURE (namidx ADDRESS, offset ADDRESS);
	DECLARE	inFixOffset BASED in$p ADDRESS;
	DECLARE	inSegId BASED in$p BYTE;

	inRecord$p = .(R$MODDAT);		/* initialise to appear as a MODDAT record */
	ibuf$p = in$p;
	CALL chkRead(3);		/* make sure the record and length are in the buffer */
	in$p = ibuf$p;
	IF moddatRec.segid = SSTACK THEN
		CALL fatalErr(ERR238);	/* ILLEGAL STACK CONTENT RECORD */

	outSegType = setWorkingSeg(moddatRec.segid);	/* set to ABS and get working base address */
	recSegBaseAddr = workingSegBase;
	/* set the bounds for this moddat record checking for wrap round */
	inFragment.saddr = recSegBaseAddr + moddatRec.offset;
	IF (inFragment.eaddr := inFragment.saddr + recLen - 5) < inFragment.saddr THEN
		CALL illegalRecord;	/* oops over 64k */
	IF moddatRec.segid = SABS THEN	/* add this as a new frag */
		CALL addSegFrag(0, 0, inFragment.saddr, recLen - 4);
	ELSE IF (segFlags(moddatRec.segid) AND AMASK) = AUNKNOWN THEN
		CALL illegalRecord;	/* align is invalid */
	IF (locRecLen := recLen) > 1025 THEN	/* long records only ok if ABS */
	DO;
		IF moddatRec.segid <> 0 THEN
			CALL fatalErr(ERR211);	/* RECORD TOO LONG */
		CALL addDataFrag(inFragment.saddr, inFragment.eaddr);
	END;
	CALL loadMODDAT(moddatRec.segid);	/* suck the data in */
	CALL getRecord;
	IF locRecLen > 1025 THEN	/* can only happen for ABS blocks so no fixup */
		RETURN;

	fixextUsed = 0;

	DO WHILE inRecord.rectyp = R$FIXEXT OR inRecord.rectyp = R$FIXLOC OR inRecord.rectyp = R$FIXSEG;
		IF inRecord.rectyp = R$FIXEXT THEN
		DO;
			IF NOT fixextUsed THEN
			DO;
				CALL flushOut;	/* make sure written to disk and record current location */
				CALL seekOutFile(SEEKTELL, .mark.blk, .mark.byt);
				endrec.blk = 0;
				endrec.byt = locRecLen + 3;
				CALL seekOutFile(SEEKFWD, .endrec.blk, .endrec.byt);	/* past where data will go */
			END;
			fixextUsed = TRUE;	/* note we have fixext record(s) */
			CALL initRecOut(R$FIXEXT);	/* initialise the fixext record */
			IF (loHiBoth := inLoHiBoth) - 1 > FBOTH - 1 THEN	/* check fixup type valid */
				CALL illegalRecord;

			outLoHiBoth = loHiBoth;	/* copy to the output */
			out$p = out$p + 1;
			in$p = in$p + 1;

			DO WHILE in$p < .erec;
				/* set the new offset but do bounds check also */
				CALL fixupBoundsChk(outExtfix.offset := recSegBaseAddr + inExtfix.offset);
				IF loHiBoth = FBOTH THEN
					CALL fixupBoundsChk(outExtfix.offset + 1);	/* check 2nd byte in range */
				IF (outExtfix.namidx := inExtfix.namidx) >= unsatisfiedCnt THEN
					CALL badRecordSeq;	/* name index out of range */
				CALL forceSOL;			/* make sure on new line to record the problem */
				CALL binasc(outExtfix.namidx, 10, ' ', .aReferenceToUns(34), 5);
				CALL binasc(outExtfix.offset, 16, '0', .aReferenceToUns(44), 4);
				/* print 'REFERENCE TO UNSATISFIED EXTERNAL(' */
				CALL conAndPrint(.aReferenceToUns, 34);
				/* print the 'XXXXX) AT XXXXH\r\n' skipping leading spaces */
				CALL conAndPrint((curColumn := skipspc(.aReferenceToUns(34))),
						17 - (curColumn - .aReferenceToUns(34)));
				out$p = out$p + 4;	/* advance out and in position */
				in$p = in$p + 4;
			END;	/* DO WHILE */

			CALL endRecord;	/* finish off the record */
		END;
		ELSE
		DO;
			workingSegBase = recSegBaseAddr;			/* restore fixup seg base to the moddat's own */
			IF inRecord.rectyp = R$FIXSEG THEN				/* if different seg the set it up */
			DO;
				outSegType = setWorkingSeg(inSegid);
				in$p = in$p + 1;				/* rest treat as rectyp FIXLOC */
			END;
			IF (loHiBoth := inLoHiBoth) - 1 > FBOTH - 1 THEN	/* is fixup valid */
				CALL illegalRecord;
			in$p = in$p + 1;

			DO WHILE in$p < .erec;					/* process the record */
				/* set the fixup real address and check in range, both bytes for BOTH fixup type */
				CALL fixupBoundsChk(fixRaddr := recSegBaseAddr + inFixOffset);
				IF loHiBoth = FBOTH THEN
					CALL fixupBoundsChk(fixRaddr + 1);
				/* find the fixup location in memory */
				fixLoc = addrInCache(fixRaddr);
				DO CASE loHiBoth - 1;
					bfix = bfix + LOW(workingSegBase);	/* LO add in low of target base address */
					bfix = bfix + HIGH(workingSegBase);	/* HI add in high of target base address */
										/* BOTH */
					IF LOW(fixRaddr) <> 0FFH THEN	/* doesn't span pages */
						wfix = wfix + workingSegBase;	/* simple add in to existing word value */
					ELSE
					DO;
						lobyt = bfix;			/* get the low byte */
						fixLoc2 = addrInCache(fixRaddr + 1);	/* find address of high byte */
						hibyt = bfix2;
						bothbyt = bothbyt + workingSegBase;	/* add in the target base address */
						bfix = lobyt;			/* and put back in place */
						bfix2 = hibyt;
					END;
				END;
				in$p = in$p + 2;
			END;
		   END;
		CALL getRecord;
	END;
	IF fixextUsed THEN
	DO;
		CALL flushOut;	/* flush the extdef data */
		CALL seekOutFile(SEEKABS, .mark.blk, .mark.byt);	/* backup to the data record */
		CALL emitMODDAT(.inFragment.saddr);			/* emit the data record fragment as it needs fixup */
		CALL flushOut;
		CALL seekOutFile(SEEKEND, .endrec.blk, .endrec.byt);	/* back to end of file */
	END;
	ELSE
		CALL addDataFrag(inFragment.saddr, inFragment.eaddr);	/* record the fragment */

END procMODDAT;

END locate2;

