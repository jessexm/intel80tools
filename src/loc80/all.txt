isissub:
DO;
DECLARE LIT LITERALLY 'LITERALLY',
	IOPEN LIT	'0',
	ICLOSE LIT	'1',
	IDELETE LIT	'2',
	IREAD LIT	'3',
	IWRITE LIT	'4',
	ISEEK LIT	'5',
	ILOAD LIT	'6',
	IRENAME LIT	'7',
	ICONSOL LIT	'8',
	IEXIT LIT	'9',	
	IATTRIB LIT	'10',
	IRESCAN LIT	'11',
	IERROR LIT	'12',
	IWHOCON LIT	'13',
	ISPATH LIT	'14';

isis: procedure (type, parameter$ptr) external;
    declare type byte,
            parameter$ptr address;
end isis;

close: procedure (conn, status$p) public;
    declare (conn, status$p) address;
    CALL ISIS(ICLOSE, .conn);
end close;

delete: procedure (path$p, status$p) public;
    declare (path$p, status$p) address;
    CALL ISIS(IDELETE, .path$p);
end delete;

error: procedure (error$num) public;
    declare (error$num) address;
    declare err address;
    err = .err;
    CALL ISIS(IERROR, .error$num);
end error;

exit: procedure public;
	DECLARE exitarg ADDRESS;
	exitarg = .exitarg;
	CALL ISIS(IEXIT, .exitarg);
end exit;


open: procedure (conn$p, path$p, access, echo, status$p) public;
    declare (conn$p, path$p, access, echo, status$p) address;
    CALL ISIS(IOPEN, .conn$p);
end open;


read: procedure (conn, buff$p, count, actual$p, status$p) public;
    declare (conn, buff$p, count, actual$p, status$p) address;
    CALL ISIS(IREAD, .conn);
end read;

seek: procedure (conn, mode, block$p, byte$p, status$p) public;
    declare (conn, mode, block$p, byte$p, status$p) address;
    CALL ISIS(ISEEK, .conn);
end seek;

write: procedure (conn, buff$p, count, status$p) public;
    declare (conn, buff$p, count, status$p) address;
    CALL ISIS(IWRITE, .conn);
end write;



END;
$LIST
$CODE
LOCATE:
DO;
$INCLUDE(ISIS.EXT)
$INCLUDE(LOC.LIT)
$INCLUDE(LOC2A.EXT)
$INCLUDE(LOC3.EXT)
$INCLUDE(LOC4.EXT)
$INCLUDE(LOC5.EXT)
$INCLUDE(LOC6.EXT)
$INCLUDE(LOC7.EXT)

$list
/* Externals */

DECLARE COPYRIGHT (*) BYTE DATA ('(C) 1976, 1977, 1979 INTEL CORP');
DECLARE VERSION (*) BYTE PUBLIC DATA ('V3.0');
DECLARE NULLREC (*) BYTE DATA (0,0,0);
DECLARE addr1 ADDRESS DATA (0);
DECLARE addr1byts STRUCTURE (lobyt BYTE, hibyt BYTE) AT (.addr1);
DECLARE addr0 ADDRESS DATA (0);
DECLARE addr0byts STRUCTURE (lobyt BYTE, hibyt BYTE) AT (.addr0);


DECLARE (readfd, outputfd, printfd, tmpfd, statusIO, actRead) ADDRESS PUBLIC,
	inFileName (16) BYTE PUBLIC, outFileName (16) BYTE PUBLIC,
	printFileName (16) BYTE PUBLIC, tmpFileName (16) BYTE PUBLIC,
	columns BYTE PUBLIC,
	seen(9) BYTE PUBLIC,	/* START, STACK, RESTART0, MAP, PUBLICS, SYMBOLS, LINES, PURGE, NAME */
	nameArg(32) BYTE PUBLIC,
	type4SubType BYTE PUBLIC,
	type2$b1 BYTE PUBLIC,
	type2$b2 BYTE PUBLIC,
	startAddr ADDRESS PUBLIC,
	segOrder(255) BYTE PUBLIC,
	segBases (3) ADDRESS PUBLIC,	/* abs, code, data */
	stackAddr ADDRESS PUBLIC,
	MemoryBase(252) ADDRESS PUBLIC,
	segSizes(3) ADDRESS PUBLIC,
	stackSize ADDRESS PUBLIC,
	MemorySize(252) ADDRESS PUBLIC,
	segFlags(256) BYTE PUBLIC,
	srec$p ADDRESS PUBLIC,
	erec$p ADDRESS PUBLIC,
	rec$p ADDRESS PUBLIC,
	recNum ADDRESS PUBLIC,
	recLen ADDRESS PUBLIC,
	npbuf ADDRESS PUBLIC,
	sibuf$p ADDRESS PUBLIC,
	ibuf$p ADDRESS PUBLIC,
	eibuf$p ADDRESS PUBLIC,
	sout$p ADDRESS PUBLIC,
	out$p ADDRESS PUBLIC,
	eout$p ADDRESS PUBLIC,
	spbuf$p ADDRESS PUBLIC,
	pbuf$p ADDRESS PUBLIC,
	epbuf$p ADDRESS PUBLIC,
	topHeap ADDRESS PUBLIC,
	topDescriptor ADDRESS PUBLIC,
	curDescriptor62F ADDRESS PUBLIC,
	desc6a$p ADDRESS PUBLIC,
	botHeap ADDRESS PUBLIC,
	curDescriptor ADDRESS PUBLIC,
	desc4a$p ADDRESS PUBLIC,
	t6desc4 DESC4$T PUBLIC,
	usePrintBuf BYTE PUBLIC,
	isNotBB BYTE PUBLIC,
	baseMemImage ADDRESS PUBLIC,
	havePagingFile BYTE PUBLIC,
	pageCacheSize BYTE PUBLIC,
	roundRobinIndex BYTE PUBLIC,
	nxtPageNo BYTE PUBLIC,
	pageIndexTmpFil BYTE PUBLIC,
	pageTab1$p ADDRESS PUBLIC,
	pageTab2$p ADDRESS PUBLIC;

DECLARE	crlf(2) BYTE PUBLIC INITIAL(0DH, 0AH),
	aRecordType(*) BYTE PUBLIC INITIAL(' RECORD TYPE XXH, RECORD NUMBER *****', 0Dh, 0Ah),
	(inBlk, inByt) ADDRESS PUBLIC INITIAL(0,0),
	inb$p ADDRESS PUBLIC,
	inCRC BYTE PUBLIC;

$INCLUDE(LOC.BAS)

/* seek modes
	0-> current pos in blk/byte format
	1-> -ve
	2-> abs
	3-> +ve
	4-> to end
*/




conStrOut: PROCEDURE(buf, cnt) PUBLIC;
	DECLARE (buf, cnt) ADDRESS;
	CALL write(0, buf, cnt, .statusIO);
END conStrOut;


writePrintBuf: PROCEDURE PUBLIC;
	IF usePrintBuf THEN	/* only process if buffered print */
	DO;
		CALL write(printfd, spbuf$p, pbuf$p - spbuf$p, .statusIO);
		CALL errChkReport(statusIO, .printFileName(1), 0FFH);
	END;
	pbuf$p = spbuf$p;	/* rest buffer pointer */
END writePrintBuf;


fatalErr: PROCEDURE(errCode) PUBLIC;
	DECLARE errCode BYTE;

	CALL writePrintBuf;
	CALL conStrOut(.(' '), 1);
	CALL conStrOut(.inFileName(1), inFileName(0));
	CALL conStrOut(.(','), 1);
	CALL errmsg(errCode);
	CALL binasc(srec.type, 16, '0', .aRecordType(13), 2);
	IF recNum > 0 THEN
		CALL binasc(recNum, 10, ' ', .aRecordType(32), 5);
	CALL conStrOut(.aRecordType, 39); 
	CALL exit;
END fatalErr;


illegalRecord: PROCEDURE PUBLIC;
	CALL fatalErr(ERR218);	/* Illegal Record Format */
END illegalRecord;


illegalReloc: PROCEDURE PUBLIC;
	CALL fatalErr(ERR212);	/* Illegal Relo Record */
END illegalReloc;


badRecordSeq: PROCEDURE PUBLIC;
	CALL fatalErr(ERR224);	/* Bad Record Sequence */
END badRecordSeq;


pstrcpy: PROCEDURE(psrc, pdst) PUBLIC;
	DECLARE (psrc, pdst) ADDRESS;
	DECLARE src BASED psrc (1) BYTE;
	
	CALL mem$mov(src(0) + 1, psrc, pdst);
END pstrcpy;


printString: PROCEDURE(bufp, cnt) PUBLIC;
	DECLARE bufp ADDRESS;
	DECLARE cnt ADDRESS;
	DECLARE bcnt ADDRESS;

	IF usePrintBuf THEN
	DO;
		bcnt = epbuf$p - pbuf$p; 
		DO WHILE cnt > bcnt;
			CALL mem$mov(bcnt, bufp, pbuf$p);
			cnt = cnt - bcnt;
			bufp = bufp + bcnt;
			pbuf$p = pbuf$p + bcnt;
			CALL writePrintBuf;
			bcnt = npbuf;
		END;
		CALL mem$mov(cnt, bufp, pbuf$p);
		pbuf$p = pbuf$p + cnt;
	END;
	ELSE
	DO;
		CALL write(printfd, bufp, cnt, .statusIO);
		CALL errChkReport(statusIO, .printFileName(1), 0FFH);
	END;
END printString;


printcrlf: PROCEDURE PUBLIC;
	CALL printString(.crlf, 2);
END printcrlf;


conAndPrint: PROCEDURE(buf, cnt) PUBLIC;
	DECLARE (buf, cnt) ADDRESS;
	CALL printString(buf, cnt);
	IF printfd > 0 THEN	/* make sure always seen on console */
		CALL conStrOut(buf, cnt);
END conAndPrint;


chkRead: PROCEDURE(cnt) PUBLIC;
	DECLARE cnt ADDRESS;
	DECLARE bcnt ADDRESS;

	IF (bcnt := eibuf$p - ibuf$p) < cnt THEN	/* data already in buffer */
	DO;
		CALL mem$mov(bcnt, ibuf$p, sibuf$p);	/* move down bytes in buffer */
		CALL read(readfd, sibuf$p + bcnt, npbuf - bcnt, .actRead, .statusIO);
		CALL errChkReport(statusIO, .inFileName(1), 0FFH);
		inBlk = inBlk + (inByt + ibuf$p - sibuf$p) / 128;
		inByt = (inByt + ibuf$p - sibuf$p) MOD 128;
		IF (bcnt := bcnt + actRead) < cnt THEN
			CALL errChkReport(ERR204, .inFileName(1), 0FFH);  /* Premature EOF */
		eibuf$p = (ibuf$p := sibuf$p) + bcnt;
	END;
END chkRead;

getRecord: PROCEDURE PUBLIC;
	DECLARE ch BASED inb$p BYTE;
	DECLARE bcnt ADDRESS;
	DECLARE erec BASED erec$p BYTE;

	IF (bcnt := eibuf$p - ibuf$p) >= 4 THEN
	DO;
		srec$p = ibuf$p;
		erec$p = srec$p + srec.len + 2;
	END;
	ELSE
	DO;
		srec$p = .NULLREC;	/* scratch area */
		erec$p = 0FFFFH;
	END;
	IF erec$p >= eibuf$p THEN
	DO;
		IF srec.len <= 1025 THEN
		DO;
			CALL chkRead(bcnt + 1);
			srec$p = ibuf$p;
			IF (erec$p := srec$p + srec.len + 2) >= eibuf$p THEN
				CALL errChkReport(ERR204, .inFileName(1), 0FFH);	/* premature EOF */
		END;
	END;
	recLen = srec.len;
	rec$p = srec$p + 3;
	ibuf$p = erec$p + 1;	/* update for next record */
	recNum = recNum + 1;
	IF srec.type > 2EH OR srec.type THEN	/* > 2EH or odd */
		CALL illegalReloc;
	IF srec.type = 6 THEN
		RETURN;
	IF recLen > 1025 THEN
		CALL fatalErr(ERR211);	/* Record too long */
	inCRC = 0;
	DO inb$p = srec$p TO .erec;
		inCRC = inCRC + ch;
	END;
	IF inCRC <> 0 THEN
		CALL fatalErr(ERR208);	/* checksum error */
END getRecord;


iseek: PROCEDURE(blk, byt) PUBLIC;
	DECLARE (blk, byt) ADDRESS;

	recNum = 0;		/* reset record number */
	IF  inBlk <= blk AND blk <= inBlk + (inByt + (eibuf$p - sibuf$p)) / 128 THEN
		IF (ibuf$p := sibuf$p + (blk - inBlk) * 128 + (byt - inByt)) >= sibuf$p
		    AND ibuf$p < eibuf$p THEN
			RETURN;
	CALL seek(readfd, 2, .blk, .byt, .statusIO);
	CALL errChkReport(statusIO, .inFileName(1), 0FFH);
	ibufp = eibufp;
	CALL chkRead(1);	/* read the buffer */
	inBlk = blk;
	inByt = byt;
END iseek;



seekPageTmpFile: PROCEDURE(para) PUBLIC;
	DECLARE para BYTE;
	DECLARE blk ADDRESS;
	
	blk = DOUBLE(para) + DOUBLE(para);
	CALL seek(tmpfd, 2, .blk, .(0,0), .statusIO);
	CALL errChkReport(statusIO, .tmpFileName(1), 0FFH);
END seekPageTmpFile;


pageout: PROCEDURE(page, bufp) PUBLIC;
	DECLARE page BYTE;
	DECLARE bufp ADDRESS;
	DECLARE pt ADDRESS, t BASED pt STRUCTURE (state BYTE, fpage BYTE);

	pt = .pageTab2(page);
	IF t.fpage = 0FFH THEN
	DO;
		t.fpage = pageIndexTmpFil;	/* record location in tmp file */
		pageIndexTmpFil = pageIndexTmpFil + 1;
	END;
	CALL seekPageTmpFile(t.fpage);
	CALL write(tmpfd, bufp, 256, .statusIO);	/* write the page out */
	CALL errChkReport(statusIO, .tmpFileName(1), 0FFH);
	t.state = 0FEH;	/* flag as paged out */
END pageout;


anotherPage: PROCEDURE(page) PUBLIC;
	DECLARE page BYTE;
	DECLARE i BYTE;
	

	IF usePrintBuf THEN	/* use print buffer space */
	DO;
		CALL writePrintBuf;	/* flush the buffer */
		usePrintBuf = 0;	/* no longer available */
		CALL mem$mov(topHeap - botHeap, botHeap, botHeap + npbuf);
		spbuf$p, pbuf$p, topheap = epbuf$p;
		topDescriptor = topDescriptor + npbuf;
		curDescriptor62F = curDescriptor62F + npbuf;
		curDescriptor = curDescriptor + npbuf;
		nxtPageNo = pageCacheSize + 1;
		pageCacheSize = HIGH((botHeap := botHeap + npbuf) - baseMemImage) - 1;
		RETURN;
	END;
	IF NOT havePagingFile THEN
	DO;
		havePagingFile = 0FFH;
		CALL delete(.tmpFileName(1), .statusIO);
		CALL open(.tmpfd, .tmpFileName(1), 3, 0, .statusIO);
		CALL errChkReport(statusIO, .tmpFileName(1), 0FFH);
	END;

	pageTab1(page).state = 0FFH;
	i = pageTab1(page).mpage;
	addr1byts.hibyt = page;
	CALL pageout(i, baseMemImage + addr1);
END anotherPage;


allocNewPage: PROCEDURE(page) ADDRESS PUBLIC;
	DECLARE page BYTE;

	DO nxtPageNo = 0 TO pageCacheSize;
		IF pageTab1(nxtPageNo).state THEN	/* one is free */
			GOTO found;
	END;
	IF roundRobinIndex > pageCacheSize THEN
		roundRobinIndex = 0;
	nxtPageNo = roundRobinIndex;
	CALL anotherPage(roundRobinIndex);
	IF nxtPageNo = roundRobinIndex  THEN	/* we got more pages so don't need to round robin pages to free */
		roundRobinIndex = roundRobinIndex + 1;
found:
	pageTab1(nxtPageNo).state = 0;	/* no longer free */
	pageTab1(nxtPageNo).mpage = page;
	pageTab2(page).state = nxtPageNo;
	addr0byts.hibyt = nxtPageNo;
	RETURN baseMemImage + addr0;
END allocNewPage;


RAddr2LAddr: PROCEDURE(addr) ADDRESS PUBLIC;
	DECLARE addr ADDRESS;
	DECLARE baddr ADDRESS;
	DECLARE (lobyt, hibyt) BYTE AT(.baddr);
	DECLARE pt ADDRESS;
	DECLARE t BASED pt STRUCTURE (state BYTE, fpage BYTE);

	pt = .pageTab2(HIGH(addr));
	IF t.state = 0FFH THEN	/* needs allocating */
		RETURN allocNewPage(HIGH(addr)) + LOW(addr);
	IF t.state = 0FEH THEN	/* on disk */
	DO;
		baddr = allocNewPage(HIGH(addr));
		CALL seekPageTmpFile(t.fpage);
		CALL read(tmpfd, baddr, 256, .actRead, .StatusIO);
		CALL errChkReport(statusIO, .tmpFileName(1), 0FFH);
		IF actRead <> 256 THEN
			IF isNotBB THEN
				CALL errChkReport(ERR204, .tmpFileName(1), 0FFH);    /* premature EOF */
		RETURN baddr + LOW(addr);
	END;
	hibyt = t.state;
	lobyt = LOW(addr);
	RETURN baseMemImage + baddr;
END RAddr2LAddr;


sub$3DB9: PROCEDURE(arg1w) PUBLIC;
	DECLARE arg1w ADDRESS;

	IF HIGH(botHeap - baseMemImage) <> HIGH((botHeap := botHeap - arg1w) - baseMemImage) THEN
	DO;
		IF NOT pageTab1(pageCacheSize).state THEN
			CALL anotherPage(PageCacheSize);

		IF (pageCacheSize := HIGH(botHeap - baseMemImage) - 1) = 0FFH THEN
			CALL errChkReport(ERR210, .inFileName(1), 0FFH);	/* Insufficient memory */
	END;
END sub$3DB9;


insert6Desc: PROCEDURE(flags, seg, start, len) PUBLIC;
	DECLARE (flags, seg) BYTE;
	DECLARE (start, len) ADDRESS;
	DECLARE desc6 BASED curDescriptor62F DESC6$T;
	DECLARE desc6a BASED desc6a$p DESC6$T;

	curDescriptor62F = topHeap;

	DO WHILE curDescriptor62F <> topDescriptor;
		curDescriptor62F = curDescriptor62F - DOUBLE(6);
		IF desc6.start > start THEN
			IF start + len = desc6.start AND desc6.seg = seg THEN /* does end address = start of this block */
			DO;	/* merge the blocks */
				desc6.start = start;
				desc6.len = desc6.len + len;
				RETURN;
			END;
			ELSE
				GOTO loc$3F87;
		ELSE IF desc6.start + desc6.len = start THEN
			IF desc6.seg = seg THEN
			DO;
				desc6.len = desc6.len + len;
				IF curDescriptor62F <> topDescriptor THEN
				DO;
					desc6a$p = curDescriptor62F - DOUBLE(6);
					IF desc6a.start = desc6.start + desc6.len AND desc6a.seg = desc6.seg THEN
					DO;
						desc6.len = desc6.len + desc6a.len;
						CALL mem$mov(desc6a$p - botHeap, botHeap, botHeap + DOUBLE(6));
						topDescriptor = topDescriptor + DOUBLE(6);
						botHeap = botHeap + DOUBLE(6);
					END;
				END;
				RETURN;
			END;
	END;
	curDescriptor62F = curDescriptor62F - DOUBLE(6);
loc$3F87:
	CALL sub$3DB9(6);
	topDescriptor = topDescriptor - DOUBLE(6);
	CALL mem$mov(curDescriptor62F - botHeap, botHeap + DOUBLE(6), botHeap);
	desc6.flags = flags;
	desc6.seg = seg;
	desc6.start = start;
	desc6.len = len;
END insert6Desc;


insert4Desc: PROCEDURE(saddr, eaddr) PUBLIC;
	DECLARE saddr ADDRESS;
	DECLARE eaddr ADDRESS;
	DECLARE desc4 BASED curDescriptor DESC4$T;
	DECLARE desc4a BASED desc4a$p DESC4$T;

	curDescriptor = topDescriptor;
	DO WHILE curDescriptor <> botHeap;
		curDescriptor = curDescriptor - DOUBLE(4);
		IF desc4.saddr > saddr THEN
		DO;
			IF eaddr >= desc4.saddr - 1 THEN
			DO;
				desc4.saddr = saddr;
				IF eaddr > desc4.eaddr THEN
				DO;
					desc4.eaddr = eaddr;
					desc4a$p = curDescriptor - DOUBLE(4);
					DO WHILE curDescriptor <> botHeap;
						IF eaddr + 1 < desc4a.saddr THEN
							RETURN;
						IF eaddr + 1 = desc4a.saddr THEN
							desc4.eaddr = desc4a.eaddr;
						CALL mem$mov(desc4a$p - botHeap, botHeap, botHeap + DOUBLE(4));
						botHeap = botHeap + DOUBLE(4);
					END;
				END;
				RETURN;
			END;
			ELSE
			DO;
				CALL sub3DB9(4);
				CALL mem$mov(curDescriptor - botHeap, botHeap + DOUBLE(4), botHeap);
				desc4.saddr = saddr;
				desc4.eaddr = eaddr;
				RETURN;
			END;
		END;
		ELSE
		DO;
			IF desc4.saddr = saddr OR saddr - 1 <= desc4.eaddr THEN
			DO;
				IF desc4.eaddr >= eaddr THEN
					RETURN;
				desc4.eaddr = eaddr;
				desc4a$p = curDescriptor - DOUBLE(4);
				DO WHILE curDescriptor <> botHeap;
					IF desc4a.saddr - 1 > eaddr THEN
						RETURN;
					IF desc4a.saddr - 1 = eaddr THEN
						desc4.eaddr = desc4a.eaddr;
					CALL mem$mov(desc4a$p - botHeap, botHeap, botHeap + DOUBLE(4));
					botHeap = botHeap + DOUBLE(4);
				END;
				RETURN;
			END;
		END;	/* IF ELSE */
	END;	/* DO WHILE */

	CALL sub3DB9(4);
	curDescriptor = botHeap;
	desc4.saddr = saddr;
	desc4.eaddr = eaddr;
END insert4Desc;


loadtype6Data: PROCEDURE(arg1b) PUBLIC;
	DECLARE arg1b BYTE;
	DECLARE rdata BASED rec$p (1) BYTE;
	DECLARE (dataLen, bytes2Read, curLoadAddr) ADDRESS;
	DECLARE curLoadPage BYTE;

	DECLARE ch BASED inb$p BYTE;

	dataLen = recLen - 4;
	inCRC = HIGH(recLen) + 6 + LOW(recLen) + rdata(0) + rdata(1) + rdata(2);
	ibuf$p = ibuf$p + 3;
	IF LOW(curLoadAddr := t6desc4.saddr) <> 0 THEN
	DO;
		IF HIGH(curLoadAddr + (bytes2Read := dataLen) - 1) <> HIGH(curLoadAddr) THEN
			bytes2Read = 256 - LOW(curLoadAddr);	/* don't go over page boundary */
		CALL chkRead(bytes2Read);
		DO inb$p = ibuf$p TO ibuf$p + bytes2Read - 1;
			inCRC = inCRC + ch;
		END;
		CALL mem$mov(bytes2Read, ibuf$p, RAddr2LAddr(curLoadAddr));
		dataLen = dataLen - bytes2Read;
		curLoadAddr = curLoadAddr + bytes2Read;
		ibuf$p = ibuf$p + bytes2Read;
	END;
	DO WHILE dataLen >= 256;
		CALL chkRead(256);
		DO inb$p = ibuf$p TO ibuf$p + 255;
			inCRC = inCRC + ch;
		END;
		IF arg1b = 0 AND havePagingFile THEN
		DO;
			IF pageTab2(curLoadPage := HIGH(curLoadAddr)).state <= 0FDH THEN
				pageTab1(pageTab2(curLoadPage).state).state = 0FFH;
			CALL pageout(curLoadPage, ibuf$p);
		END;
		ELSE
			CALL mem$mov(256, ibuf$p, RAddr2Laddr(curLoadAddr));

		dataLen = dataLen - 256;
		curLoadAddr = curLoadAddr + 256;
		ibuf$p = ibuf$p + 256;
	END;
	IF dataLen > 0 THEN
	DO;
		CALL chkRead(dataLen);
		DO inb$p = ibuf$p TO ibuf$p + dataLen - 1;
			inCRC = inCRC + ch;
		END;
		CALL mem$mov(dataLen, ibuf$p, RAddr2LAddr(curLoadAddr));
		ibuf$p = ibuf$p + dataLen;
	END;
	CALL chkRead(1);
	ibuf$p = (inb$p := ibuf$p) + 1;
	IF inCRC + ch <> 0 THEN
		CALL fatalErr(ERR208);	/* Checksum error */
END loadtype6Data;


baseMemImage, pageTab2$p = .controls;	/* once we have processed args overwrite area */
CALL procArgs$Init;
CALL sub$5359;
CALL writePrintBuf;
CALL close(printfd, .statusIO);
CALL exit;

END;
locate2a: DO;

$INCLUDE(ISIS.EXT)

$list
DECLARE	errTab(*) BYTE DATA (
	   2, 'ILLEGAL AFTN ARGUMENT', 0,
	   3, 'TOO MANY OPEN FILES', 0,
	   4, 'INCORRECTLY SPECIFIED FILE', 0,
	   5, 'UNRECOGNIZED DEVICE NAME', 0,
	   9, 'DISK DIRECTORY FULL', 0,
	 0Ch, 'FILE IS ALREADY OPEN', 0,
	 0Dh, 'NO SUCH FILE', 0,
	 0Eh, 'WRITE PROTECTED', 0,
	 11h, 'NOT A DISK FILE', 0,
	 13h, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
	 14h, 'ATTEMPTED BACK SEEK TOO FAR', 0,
	 15h, 'CAN''T RESCAN', 0,
	 16h, 'ILLEGAL ACCESS MODE TO OPEN', 0,
	 17h, 'MISSING FILENAME', 0,
	 1Bh, 'ILLEGAL SEEK COMMAND', 0,
	 1Ch, 'MISSING EXTENSION', 0,
	 1Fh, 'CAN''T SEEK ON WRITE ONLY FILE', 0,
	 20h, 'CAN''T DELETE OPEN FILE', 0,
	 23h, 'SEEK PAST EOF', 0,
	0CBh, 'INVALID SYNTAX', 0,
	0CCh, 'PREMATURE EOF', 0,
	0D0h, 'CHECKSUM ERROR', 0,
	0D2h, 'INSUFFICIENT MEMORY', 0,
	0D3h, 'RECORD TOO LONG', 0,
	0D4h, 'ILLEGAL RELO RECORD', 0,
	0D5h, 'FIXUP BOUNDS ERROR', 0,
	0DAh, 'ILLEGAL RECORD FORMAT', 0,
	0E0h, 'BAD RECORD SEQUENCE', 0,
	0E1h, 'INVALID NAME', 0,
	0E2h, 'NAME TOO LONG', 0,
	0E3h, 'LEFT PARENTHESIS EXPECTED', 0,
	0E4h, 'RIGHT PARENTHESIS EXPECTED', 0,
	0E5h, 'UNRECOGNIZED CONTROL', 0,
	0E9h, '''TO'' EXPECTED', 0,
	0EDh, 'COMMON NOT FOUND', 0,
	0EEh, 'ILLEGAL STACK CONTENT RECORD', 0,
	0EFh, 'NO MODULE HEADER RECORD', 0,
	0F0h, 'PROGRAM EXCEEDS 64K', 0);

errmsg: PROCEDURE(errCode) PUBLIC;
	DECLARE errCode ADDRESS;
	DECLARE i ADDRESS;
	DECLARE status ADDRESS;
	
	IF LOW(errCode) <> 0 THEN
	DO;
		i = 0;
		DO WHILE i < LENGTH(errTab);	/* 328h */
			IF LOW(errCode) = errTab(i) THEN
			DO;
				CALL write(0, .(' '), 1, .status);
				DO WHILE errTab(i := i + 1) <> 0;
					CALL write(0, .errTab(i), 1, .status);
				END;
				CALL write(0, .(0DH, 0AH), 2, .status);
				RETURN;
			END;
			ELSE
			DO;
				DO WHILE errTab(i := i + 1) <> 0;
				END;
				i = i + 1;
			END;
		END;
		CALL error(errCode);	/* ISIS error code */
	END;
END errmsg;

END locate2a;
locate2: DO;
$INCLUDE(ISIS.EXT)

$INCLUDE(LOC.LIT)
$INCLUDE(LOC1.EXT)
$INCLUDE(LOC3.EXT)
$INCLUDE(LOC4.EXT)
$INCLUDE(LOC5.EXT)
$INCLUDE(LOC6.EXT)

$INCLUDE(LOC.BAS)

DECLARE aUnsatisfiedExt(*) BYTE PUBLIC INITIAL('UNSATISFIED EXTERNAL(XXXXX) '),

	aReferenceToUns(*) BYTE PUBLIC INITIAL('REFERENCE TO UNSATISFIED EXTERNAL(XXXXX) AT XXXXH', 0DH, 0AH),
	aSymbolTableOfM(*) BYTE PUBLIC INITIAL(0DH, 0AH, 'SYMBOL TABLE OF MODULE '),
	aReadFromFile(*) BYTE PUBLIC INITIAL(0DH, 0AH, 'READ FROM FILE '),
	aWrittenToFile(*) BYTE PUBLIC INITIAL(0DH, 0AH, 'WRITTEN TO FILE '),
	aValueType(*) BYTE PUBLIC INITIAL('VALUE TYPE '),
	aSymbol(*) BYTE PUBLIC INITIAL(6, 'SYMBOL'),
	aPub(*) BYTE PUBLIC INITIAL('XXXXH PUB  '),
	aSym(*) BYTE PUBLIC INITIAL('XXXXH SYM  '),
	alin(*) BYTE PUBLIC INITIAL('XXXXH LIN  '),
	aMod(*) BYTE PUBLIC INITIAL('      MOD  '),
	x5(*) BYTE PUBLIC INITIAL(5, 'XXXXX'),
	spc32(*) BYTE PUBLIC INITIAL('                                ');

DECLARE	fixType BYTE PUBLIC,
	outSegType(3) BYTE PUBLIC,
	curColumn ADDRESS PUBLIC,
	workingSegBase ADDRESS PUBLIC,
	unsatisfiedCnt ADDRESS PUBLIC INITIAL(0),
	curcol BYTE PUBLIC INITIAL(0),
	word$6483 ADDRESS PUBLIC INITIAL(0),
	LabelLen BYTE PUBLIC INITIAL(0),
	lsout$p ADDRESS PUBLIC,
	lsout BASED lsout$p STRUCTURE (type BYTE, len ADDRESS, bytes(1) BYTE);


seekOutFile: PROCEDURE(mode, pblk, pbyt) PUBLIC;
	DECLARE (mode, pblk, pbyt) ADDRESS;
	CALL seek(outputfd, mode, pblk, pbyt, .statusIO);
	CALL errChkReport(statusIO, .outFileName(1), 0FFH);
END seekOutFile;


flushOut: PROCEDURE PUBLIC;
	CALL write(outputfd, sout$p, out$p - sout$p, .statusIO);
	CALL errChkReport(statusIO, .outFileName(1), 0FFH);
	out$p = sout$p;
END flushOut;

writeBytes: PROCEDURE(buf$p, cnt) PUBLIC;
	DECLARE (buf$p, cnt) ADDRESS;
	DECLARE bcnt ADDRESS;

	bcnt = eout$p - out$p;
	DO WHILE cnt > bcnt;
		CALL mem$mov(bcnt, buf$p, out$p);
		cnt = cnt - bcnt;
		buf$p = buf$p + bcnt;
		out$p = out$p + bcnt;
		CALL flushOut;
		bcnt = npbuf;
	END;
	CALL mem$mov(cnt, buf$p, out$p);
	out$p = out$p + cnt;
END writeBytes;


initRecOut: PROCEDURE(type) PUBLIC;
	DECLARE type BYTE;
	DECLARE lsout BASED lsout$p STRUCTURE(type BYTE);

	IF eout$p - out$p < 1028 THEN
		CALL flushout;
	lsout$p = out$p;
	lsout.type = type;
	out$p = out$p + 3;	/* type + length */
END initRecOut;


endRecord: PROCEDURE PUBLIC;
	DECLARE crc BYTE;
	DECLARE pch ADDRESS;
	DECLARE ch BASED pch BYTE;
	DECLARE outch BASED out$p BYTE;

	IF (lsout.len := out$p - .lsout.type - 2) > 1025 THEN
		CALL errChkReport(ERR211, .outFileName(1), 0FFH);	/* RECORD TOO LONG */
	crc = 0;
	DO pch = .lsout TO out$p - 1;
		crc = crc + ch;
	END;
	outch = -crc;
	out$p = out$p + 1;
END endRecord;


writeType6Block: PROCEDURE(pdesc4) PUBLIC;
	DECLARE pdesc4 ADDRESS;
	DECLARE desc4 BASED pdesc4 DESC4$T;
	DECLARE (i, bcnt, pmem, curPC, j) ADDRESS;
	DECLARE crc BYTE;
	DECLARE mem BASED pmem (1) BYTE;

	CALL initRecOut(6);
	i = desc4.eaddr - desc4.saddr + 1;	/* last - first + 1 */
	lsout.len = i + 4;
	t6out.seg = 0;		/* abs seg */
	curPC = (t6out.addr := desc4.saddr);		/* load address */	
	crc = HIGH(lsout.len) + 6 + LOW(lsout.len) + HIGH(t6out.addr) + LOW(t6out.addr);
	out$p = out$p + 3;

	DO WHILE i > 0;
		bcnt = 256;
		IF LOW(curPC) <> 0 THEN
			bcnt = 256 - LOW(curPC);
		IF bcnt > i THEN
			bcnt = i;
		pmem =  RAddr2LAddr(curPC);
		DO j = 0 TO bcnt - 1;
			crc = crc + mem(j);
		END;
		CALL writeBytes(pmem, bcnt);
		IF bcnt = 256 THEN
		DO;
			pageTab1(pageTab2(HIGH(curPC)).state).state = 0FFH;
			pageTab2(HIGH(curPC)).state = 0FFH;	/* mark page as free */
		END;
		curPC = curPC + bcnt;
		i = i - bcnt;
	END;	/* DO WHILE */

	crc = -crc;
	CALL writeBytes(.crc, 1);
END writeType6Block;


forceSOL: PROCEDURE PUBLIC;
	IF curcol <> 0 THEN
		CALL printcrlf;
	curcol = 0;
END forceSOL;



sub$4B3A: PROCEDURE(arg1w, pstr) PUBLIC;
	DECLARE arg1w ADDRESS;
	DECLARE pstr ADDRESS;
	DECLARE str BASED pstr (1) BYTE;

	IF arg1w <> word$6483 THEN
		CALL forceSOL;
	word$6483 = arg1w;
	IF curcol = columns THEN
		CALL forceSOL;
	IF curcol <> 0 THEN
		CALL printString(.spc32, 32 - LabelLen);
	curcol = curcol + 1;
	LabelLen = str(0);
	CALL printString(arg1w, 11);
	CALL printString(pstr + 1, LabelLen);
END sub$4B3A;


setWorkingSeg: PROCEDURE(seg) BYTE PUBLIC;	/* always returns 0 */
	DECLARE seg BYTE;
	workingSegBase = segBases(seg);
	RETURN 0;
END setWorkingSeg;


procType4: PROCEDURE PUBLIC;
	DECLARE rst0$p ADDRESS;
	DECLARE jmp BASED rst0$p STRUCTURE (inst BYTE, addr ADDRESS);

	IF t4rec.subtype = 1 THEN
	DO;
		type4SubType = 1;
		outSegType(0) = setWorkingSeg(t4rec.segtype);
		IF NOT startSeen THEN
			startAddr = workingSegBase + t4rec.addr;
		IF restart0Seen THEN
		DO;
			rst0$p = RAddr2LAddr(0);
			jmp.inst = 0C3H;
			jmp.addr = startAddr;
			CALL insert6Desc(0, 0, 0, 3);
			CALL insert4Desc(0, 2);
		END;
	END;
	ELSE
		startAddr = 0;	/* 0 start address if type4 input does not have one */
	CALL flushOut;
	curDescriptor = topDescriptor;
	DO WHILE curDescriptor <> botHeap;
		curDescriptor = curDescriptor - DOUBLE(4);
		CALL writeType6Block(curDescriptor);
	END;

	CALL initRecOut(4);	/* generate the type 4 record */
	t4out.subtype = type4SubType;
	t4out.segtype = 0;
	t4out.addr = startAddr;
	out$p = out$p + 4;
	CALL writeBytes(rec$p + DOUBLE(4), recLen - DOUBLE(4) - 1);	/* copy type 4 tail over */
	CALL endRecord;					/* insert length and CRC */
	CALL initRecOut(0EH);				/* EOF record */
	CALL endRecord;
	CALL flushOut;
END procType4;


sub$4CAA: PROCEDURE PUBLIC;
	DECLARE (mark, backup) STRUCTURE (blk ADDRESS, byt ADDRESS);
	DECLARE type20primed BYTE;
	DECLARE (fixRAddr, pad) ADDRESS;
	DECLARE (locRecLen, lasttype6base) ADDRESS;
	DECLARE (fixLoc, fixLoc2) ADDRESS;
	DECLARE (loByt, hiByt) BYTE, bothByt ADDRESS AT (.loByt);

	DECLARE bfix BASED fixLoc BYTE;
	DECLARE bfix2 BASED fixLoc2 BYTE;
	DECLARE wfix BASED fixLoc ADDRESS;
	DECLARE erec BASED erec$p(1) BYTE;


	srec$p = .(6);
	ibuf$p = rec$p;
	CALL chkRead(3);
	rec$p = ibuf$p;
	IF t6rec.seg = 3 THEN
		CALL fatalErr(ERR238);	/* ILLEGAL STACK CONTENT RECORD */

	outSegType(0) = setWorkingSeg(t6rec.seg);
	lasttype6Base = workingSegBase;
	t6desc4.saddr = lasttype6base + t6rec.addr;
	IF (t6desc4.eaddr := t6desc4.saddr + recLen - 5) < t6desc4.saddr THEN
		CALL illegalRecord;	/* oops over 64k */
	IF t6rec.seg = 0 THEN
		CALL insert6Desc(0, 0, t6desc4.saddr, recLen - 4);
	ELSE IF (segFlags(t6rec.seg) AND 0FH) = 0 THEN
		CALL illegalRecord;	/* align 0 is invalid */
	IF (locRecLen := recLen) > 1025 THEN
	DO;
		IF t6rec.seg <> 0 THEN
			CALL fatalErr(ERR211);	/* RECORD TOO LONG */
		CALL insert4Desc(t6desc4.saddr, t6desc4.eaddr);
	END;
	CALL loadtype6Data(t6rec.seg);
	CALL getRecord;
	IF locRecLen > 1025 THEN
		RETURN;

	type20primed = 0;

	DO WHILE srec.type = 20H OR srec.type = 22H OR srec.type = 24H;
		IF srec.type = 20H THEN
		DO;
			IF NOT type20primed THEN
			DO;
				CALL flushOut;
				CALL seekOutFile(0, .mark.blk, .mark.byt);
				backup.blk = 0;
				backup.byt = locRecLen + 3;
				CALL seekOutFile(3, .backup.blk, .backup.byt);
			END;
			type20primed = 0FFH;
			CALL initRecOut(20H);
			IF (fixType := t20arec.fixType) - 1 > 2 THEN
				CALL illegalRecord;

			t20aout.fixType = fixType;
			out$p = out$p + 1;
			rec$p = rec$p + 1;

			DO WHILE rec$p < .erec;
				CALL fixupBoundsChk(t20bout.addr := lasttype6base + t20brec.addr);
				IF fixType = 3 THEN
					CALL fixupBoundsChk(t20bout.addr + 1);	/* check 2nd byte in range */
				IF (t20bout.sym := t20brec.sym) >= unsatisfiedCnt THEN
					CALL badRecordSeq;
				CALL forceSOL;
				CALL binasc(t20bout.sym, 10, ' ', .aReferenceToUns(34), 5);
				CALL binasc(t20bout.addr, 16, '0', .aReferenceToUns(44), 4);
				CALL conAndPrint(.aReferenceToUns, 34);
				
				CALL conAndPrint((curColumn := skipspc(.aReferenceToUns(34))),
						17 - (curColumn - .aReferenceToUns(34)));
				out$p = out$p +  4;
				rec$p = rec$p + 4;
			END;	/* DO WHILE */

			CALL endRecord;
		END;
		ELSE
		DO;
			workingSegBase = lasttype6base;
			IF srec.type = 24H THEN
			DO;
				outSegType(0) = setWorkingSeg(t24arec.seg);
				rec$p = rec$p + 1;				/* rest treat as type 22H */
			END;
			IF (fixType := t22arec.fixtype) - 1 > 2 THEN
				CALL illegalRecord;
			rec$p = rec$p + 1;

			DO WHILE rec$p < .erec;
				CALL fixupBoundsChk(fixRaddr := lasttype6base + t22brec.addr);
				IF fixType = 3 THEN
					CALL fixupBoundsChk(fixRaddr + 1);
				fixLoc = RAddr2LAddr(fixRaddr);
				DO CASE fixType - 1;
					bfix = bfix + LOW(workingSegBase);
					bfix = bfix + HIGH(workingSegBase);
					IF LOW(fixRaddr) <> 0FFH THEN	/* doesn't span pages */
						wfix = wfix + workingSegBase;	
					ELSE
					DO;
						lobyt = bfix;
						fixLoc2 = RAddr2Laddr(fixRaddr + 1);
						hibyt = bfix2;
						bothbyt = bothbyt + workingSegBase;
						bfix = lobyt;
						bfix2 = hibyt;
					END;
				END;
				rec$p = rec$p + 2;
			END;
		   END;
		CALL getRecord;
	END;
	IF type20primed THEN
	DO;
		CALL flushOut;
		CALL seekOutFile(2, .mark.blk, .mark.byt);
		CALL writeType6Block(.t6desc4.saddr);
		CALL flushOut;
		CALL seekOutFile(4, .backup.blk, .backup.byt);
	END;
	ELSE
		CALL insert4Desc(t6desc4.saddr, t6desc4.eaddr);

END sub$4CAA;

END locate2;

locate3: DO;
$INCLUDE(ISIS.EXT)
$INCLUDE(LOC.LIT)
$INCLUDE(LOC1.EXT)
$INCLUDE(LOC2A.EXT)
$INCLUDE(LOC2B.EXT)
/*$INCLUDE(LOC3.EXT)*/
$INCLUDE(LOC4.EXT)
$INCLUDE(LOC5.EXT)
$INCLUDE(LOC6.EXT)
$INCLUDE(LOC7.EXT)
$INCLUDE(LOC8.EXT)
$INCLUDE(LOC9.EXT)

$INCLUDE(LOC.BAS)

DECLARE erec BASED erec$p BYTE;

fixupBoundsChk: PROCEDURE(addr) PUBLIC;
	DECLARE addr ADDRESS;
	IF addr < t6desc4.saddr OR t6desc4.eaddr < addr THEN
		CALL fatalErr(ERR213);	/* Fixup Bounds Error */
END fixupBoundsChk;


sub$5041: PROCEDURE PUBLIC;
	DECLARE rdata BASED rec$p BYTE;
	DECLARE buf BASED out$p (1) BYTE;
	DECLARE wbuf BASED out$p (1) ADDRESS;

	IF NOT PurgeSeen OR LinesSeen THEN
	DO;
		outSegType(0) =  setWorkingSeg(t8arec.seg);
		IF NOT PurgeSeen THEN
		DO;
			CALL initRecOut(8);
			t8aout.seg = outSegType(0);
			out$p = out$p + 1;
		END;
		rec$p = rec$p + 1;
		DO WHILE rec$p < .erec;
			IF NOT PurgeSeen THEN
			DO;
				t8bout.addr = workingSegBase + t8brec.addr;
				t8bout.line = t8brec.line;
				out$p = out$p + 4;
				
			END;
			IF LinesSeen THEN
			DO;
				CALL binasc(workingSegBase + t8brec.addr, 16, '0', .alin, 4);
				CALL binasc(t8brec.line, 10, ' ', .x5(1), 5);
				CALL sub$4B3A(.alin, .x5);
			END;
			rec$p = rec$p + 4;
		END;
		IF NOT PurgeSeen THEN
			CALL endRecord;
	END;
	CALL getRecord;
END sub$5041;


sub$5113: PROCEDURE PUBLIC;
	DECLARE str BASED rec$p (1) BYTE;
	IF LinesSeen OR SymbolsSeen THEN
	DO;
		CALL sub$4B3A(.aMod, rec$p);
		CALL forceSOL;
	END;
	IF NOT PurgeSeen THEN
	DO;
		CALL initRecOut(16);
		CALL writeBytes(.str(0), str(0) + 1);
		CALL endRecord;
	END;
	CALL getRecord;
END sub$5113;


proc12$16: PROCEDURE(arg1b, arg2w) PUBLIC;
	DECLARE arg1b BYTE;
	DECLARE arg2w ADDRESS;
	DECLARE ritem BASED rec$p STRUCTURE (len ADDRESS, name (1) BYTE);
	DECLARE owd BASED out$p ADDRESS;
	DECLARE buf BASED out$p (1) BYTE;

	IF NOT purgeseen OR arg1b THEN
	DO;
		IF t12arec.seg = 3 THEN	/* stack ? */
		DO;
			outSegType(0) = 3;
			workingSegBase = 0;
		END;
		ELSE
			outSegType(0)= setWorkingSeg(t12arec.seg);	
		IF NOT PurgeSeen THEN
		DO;
			CALL initRecOut(srec.type);
			t12aout.seg = outSegType(0);
			out$p = out$p + 1;
		END;
		rec$p = rec$p + 1;
		DO WHILE rec$p < .erec;
			IF NOT PurgeSeen THEN
			DO;
				t12bout.offset = workingSegBase + t12brec.offset;
				CALL pstrcpy(.t12brec.name, .t12bout.name);
				t12bout.name(t12brec.name(0) + 1) = 0;
				out$p = out$p + 4 + t12brec.name(0);
			END;
			IF arg1b THEN
			DO;
				CALL binasc(workingSegBase + t12brec.offset, 16, '0', arg2w, 4);
				CALL sub$4B3A(arg2w, .t12brec.name);
			END;
			rec$p = rec$p + 4 + t12brec.name(0);
		END;
		IF NOT PurgeSeen THEN
			CALL endRecord;
	END;
	CALL getRecord;
END proc12$16;


sub$5257: PROCEDURE PUBLIC;
	DECLARE ch BASED rec$p BYTE;
	DECLARE buf BASED out$p (1) BYTE;

	CALL initRecOut(18H);
	DO WHILE rec$p < .erec;
		CALL forceSOL;
		CALL binasc((unsatisfiedCnt := unsatisfiedCnt + 1) - 1, 10, ' ', .aUnsatisfiedExt(21), 5);
			CALL conAndPrint(.aUnsatisfiedExt, 21);
			CALL conAndPrint(curColumn := skipSpc(.aUnsatisfiedExt(21)), 7 - (curColumn - .aUnsatisfiedExt(21)));
			CALL conAndPrint(.t18rec.name(1), t18rec.name(0));
			CALL conAndPrint(.crlf, 2);
			CALL pstrcpy(.t18rec.name, .t18out.name);
			t18out.name(DOUBLE(t18rec.name(0)) + 1) = 0;
			out$p = out$p + 2 + t18rec.name(0);
			rec$p = rec$p + 2 + t18rec.name(0);
	END;
	CALL endRecord;
	CALL getRecord;
END sub$5257;


sub$5309: PROCEDURE(buf, len) PUBLIC;
	DECLARE buf ADDRESS;
	DECLARE len ADDRESS;
	CALL printString(buf, len);
	CALL printString(.nameArg(1), nameArg(0));
	CALL printString(.aReadFromFile, 17);
	CALL printString(.inFileName(1), inFileName(0));
	CALL printString(.aWrittenToFile, 18);
	CALL printString(.outFileName(1), outFileName(0));
	CALL printcrlf;
END sub$5309;


sub$5359: PROCEDURE PUBLIC;
	DECLARE buf BASED out$p (1) BYTE;
	CALL procHeader;
	CALL initRecOut(2);	/* create header record */
	CALL writeBytes(.nameArg, nameArg(0)+1);	/* write the name */
	buf(0) = type2$b1;	/* copy the passed in data */
	buf(1) = type2$b2;
	out$p = out$p + 2;
	CALL endRecord;
	IF PublicsSeen  OR SymbolsSeen OR LinesSeen THEN
	DO;
		CALL sub$5309(.aSymbolTableOfM, 25);
		CALL printcrlf;
		DO curColumn = 1 TO columns;
			CALL sub$4B3A(.aValueType, .aSymbol);
		END;
		CALL printcrlf;
	END;
	DO WHILE srec.type <> 4;
	    DO CASE SHR(srec.type, 1);
		CALL illegalReloc;	/* 0 */
		CALL badRecordSeq;	/* 2 */
		;			/* 4 */
		CALL sub$4CAA;		/* 6 */
		CALL sub$5041;		/* 8 */
		CALL illegalReloc;	/* 0A */
		CALL illegalReloc;	/* 0C */
		CALL errChkReport(ERR204, .inFileName(1), 0FFH); /* 0E - Premature EOF */
		CALL sub$5113;		/* 10 */
		CALL proc12$16(SymbolsSeen, .aSym);	/* 12 */
		CALL illegalReloc;	/* 14 */
		CALL proc12$16(PublicsSeen, .aPub);	/* 16 */
		call sub$5257;		/* 18 - undefined externals */
		CALL illegalReloc;	/* 1A */
		CALL illegalReloc;	/* 1C */
		CALL illegalReloc;	/* 1E */
		CALL badRecordSeq;	/* 20 */
		CALL badRecordSeq;	/* 22 */
		CALL badRecordSeq;	/* 24 */
		CALL badRecordSeq;	/* 26 */
		CALL badRecordSeq;	/* 28 */
		CALL badRecordSeq;	/* 2A */
		CALL badRecordSeq;	/* 2C */
		CALL badRecordSeq;	/* 2E */
	    END;
	END;
	CALL procType4;
	CALL close(outputfd, .statusIO);
	CALL errChkReport(statusIO, .outFileName(1), 0FFH);
	IF havePagingFile THEN
	DO;
		CALL close(tmpfd, .statusIO);
		CALL delete(.tmpFileName(1), .statusIO);
	END;
	CALL forceSOL;
	CALL sub$5576;
	CALL close(readfd, .statusIO);
	CALL errChkReport(statusIO, .inFileName(1), 0FFH);
END sub$5359;

END locate3;
locate4: DO;
$INCLUDE(ISIS.EXT)
$INCLUDE(LOC.LIT)
$INCLUDE(LOC1.EXT)
$INCLUDE(LOC2A.EXT)
$INCLUDE(LOC3.EXT)
$INCLUDE(LOC5.EXT)
$INCLUDE(LOC6.EXT)

$INCLUDE(LOC.BAS)

DECLARE erec BASED erec$p BYTE;

DECLARE	aMemoryMapOfMod(*) BYTE PUBLIC INITIAL(0DH, 0AH, 'MEMORY MAP OF MODULE '),
	aStartStopLengt(*) BYTE PUBLIC INITIAL(0DH, 0AH, 0AH, 'START   STOP LENGTH REL NAME', 0DH, 0AH, 0AH),
	aModuleStartAdd(*) BYTE PUBLIC INITIAL('MODULE START ADDRESS XXXXH'),
	aModuleIsNotAMa(*) BYTE PUBLIC INITIAL('MODULE IS NOT A MAIN MODULE'),
	aStartControlIg(*) BYTE PUBLIC INITIAL(', START CONTROL IGNORED'),
	aRestartControl(*) BYTE PUBLIC INITIAL(', RESTART CONTROL IGNORED'),
	aAddresses(*) BYTE PUBLIC INITIAL('XXXXH  XXXXH  XXXXH  X  '),
	aMemOverlap(*) BYTE PUBLIC INITIAL('  (MEMORY OVERLAP FROM XXXXH THROUGH XXXXH)'),
	a0LengthSegment(*) BYTE PUBLIC INITIAL('  (0 LENGTH SEGMENT WRAPPED AROUND TO 0000H)'),
	segNames(*) BYTE PUBLIC INITIAL('ABSOLUTE', 'CODE    ', 'DATA    ', 'STACK   ', 'MEMORY  '),
	alignNames(*) BYTE PUBLIC INITIAL('AIPB');

sub$5517: PROCEDURE(seg) ADDRESS PUBLIC;
	DECLARE seg BYTE;
	DECLARE rdata BASED rec$p (1) BYTE;

	IF seg = 255 THEN
		RETURN .(0);
	CALL iseek(0,0);
	CALL getRecord;
	DO WHILE 1;
		CALL getRecord;
		IF srec.type <> 2EH THEN
			CALL badRecordSeq;
		DO WHILE rec$p < .erec;
			IF seg = rdata(0) THEN
				RETURN rec$p + 1;
			rec$p = rec$p + 2 + rdata(1);
		END;
	END;
END sub$5517;

sub$5576: PROCEDURE PUBLIC;
	DECLARE (p, q) ADDRESS;
	DECLARE (i, j, k) BYTE;
	DECLARE desc6 BASED curDescriptor62F DESC6$T;
	DECLARE rdata BASED rec$p (1) BYTE;

	IF MapSeen THEN
	DO;
		CALL sub$5309(.aMemoryMapOfMod, 23);
		IF type4SubType THEN
		DO;
			CALL binasc(startAddr, 16, '0', .aModuleStartAdd(21), 4);
			CALL printString(.aModuleStartAdd, 26);
		END;
		ELSE
		DO;
			CALL printString(.aModuleIsNotAMa, 27);
			IF startSeen THEN
				CALL printString(.aStartControlIg, 23);
			IF restart0Seen THEN
				CALL printString(.aRestartControl, 25);
		END;
		CALL printString(.aStartStopLengt, 34);
	END;
	stackAddr = stackAddr - stackSize;
	DO q = 1 TO 254;
		IF segSizes(i := segOrder(q)) > 0 OR (segFlags(i) AND 20H) <> 0 THEN
			CALL insert6Desc(segFlags(i), i, segBases(i), segSizes(i));
	END;

	p, j = 0;
	curDescriptor62F = topHeap;
	DO WHILE curDescriptor62F <> topDescriptor ; 
		curDescriptor62F = curDescriptor62F - DOUBLE(6);
		CALL binasc(desc6.start, 16, '0', .aAddresses, 4);
		aAddresses(7) = '*';
		aAddresses(8) = '*';
		aAddresses(9) = '*';
		aAddresses(10) = '*';
		IF desc6.len > 0 THEN
			CALL binasc(desc6.start + desc6.len - 1, 16, '0', .aAddresses(7), 4);
		CALL binasc(desc6.len, 16, ' ', .aAddresses(14), 4);
		CALL mem$mov(4, .aAddresses, .aMemOverlap(23));
		CALL mem$mov(4, .aAddresses(7), .aMemOverlap(37));
		IF desc6.start + desc6.len > p THEN
		DO;
			aMemOverlap(37) = '*';
			aMemOverlap(38) = '*';
			aMemOverlap(39) = '*';
			aMemOverlap(40) = '*';
			IF desc6.len > 0 AND (p > 0  OR j <> 0) THEN
				CALL binasc(p - 1, 16, '0', .aMemOverlap(37), 4);
		END;
		k = 0;
		IF mapSeen THEN
		DO;
			aAddresses(21) = alignNames(desc6.flags AND 0FH);
			CALL printString(.aAddresses, 24);
			IF desc6.seg >= 6 THEN
			DO;
				CALL printString(.('/'), 1);
				rec$p = sub$5517(desc6.seg);
				CALL printString(rec$p+1, rdata(0));	
				CALL printString(.('/'), 1);
			END;
			ELSE
				CALL printString(.segNames(SHL(desc6.seg, 3)), 8);
		END;
		IF desc6.start < p OR j <> 0 THEN
		DO;
			k = 0FFH;
			CALL conAndPrint(.aMemOverlap, 43);
		END;
		IF (desc6.flags AND 40H) <> 0 THEN
		DO;
			k = 0FFH;
			CALL conAndPrint(.a0LengthSegment, 44);
		END;
		IF k THEN
			CALL conAndPrint(.crlf, 2);
		ELSE IF MapSeen THEN
			CALL printcrlf;
		IF desc6.start + desc6.len = 0 AND desc6.len > 0 THEN
		DO;
			p = 0;
			j = 40H;
		END;
		ELSE IF j = 0 THEN
			IF desc6.start + desc6.len > p THEN
				p = desc6.start + desc6.len;
	END;	/* DO WHILE */
END sub$5576;






skipspc: PROCEDURE(pch) ADDRESS PUBLIC;
	DECLARE pch ADDRESS;
	DECLARE ch BASED pch BYTE;
	
	DO WHILE ch = ' ';
		pch = pch + 1;
	END;
	RETURN pch;
END skipspc;




END locate4;
loc4a: DO;
$INCLUDE (ISIS.EXT)
$INCLUDE (LOC2A.EXT)
$INCLUDE (LOC5.EXT)

skipspc: PROCEDURE(pch) ADDRESS EXTERNAL;
	DECLARE pch ADDRESS;
END skipspc;

errChkReport: PROCEDURE(errCode, file, errExit) PUBLIC;
	DECLARE errCode ADDRESS;
	DECLARE file ADDRESS;
	DECLARE errExit BYTE;
	DECLARE status ADDRESS;
	
	IF errCode <> 0 THEN
	DO;
		file = skipspc(file);
		CALL write(0, .(' '), 1, .status);
		CALL write(0, file, pastAFN(file) - file, .status);	/* write file name */
		CALL write(0, .(','), 1, .status);
		CALL errmsg(errCode);
		IF errExit THEN
			CALL exit;
	END;
END errChkReport;
END;
locate5a: DO;
$INCLUDE (loc5b.ext)

DECLARE hexdigits(*) BYTE DATA ('0123456789ABCDEF');

binasc: PROCEDURE(number, base,	pad, bufp, ndigits) PUBLIC;
	DECLARE number ADDRESS, (base, pad) BYTE, bufp ADDRESS, ndigits BYTE;
	DECLARE i BYTE;
	DECLARE buf BASED bufp (1) BYTE;
	
	DO i = 1 TO ndigits;
		buf(ndigits - i) = hexdigits(number MOD base);
		number = number / base;
	END;

	i = 0;
	DO WHILE buf(i) = '0' AND i < ndigits - 1;
		buf(i) = pad;
		i = i + 1;
	END;
END binasc;


pastAFN: PROCEDURE(pch) ADDRESS PUBLIC;
	DECLARE pch ADDRESS;
	DECLARE ch BASED pch BYTE;

	DO WHILE 1;
		pch = pastFileName(pch);
		IF ch = '*' OR ch = '?' THEN
			pch = pch + 1;
		ELSE
			RETURN pch;
	END;
END pastAFN;

END locate5a;



locate5b: DO;

pastFileName: PROCEDURE(pch) ADDRESS PUBLIC;
	DECLARE pch ADDRESS;
	DECLARE ch BASED pch BYTE;

	DO WHILE ch = ':' OR ch = '.' OR ('0' <= ch AND ch <= '9') OR ('A' <= ch AND ch <= 'Z');
		pch = pch + 1;
	END;
	RETURN pch;
END pastFileName;


END locate5b;



locate6: DO;
$INCLUDE(ISIS.EXT)
$INCLUDE(LOC.LIT)
$INCLUDE(LOC1.EXT)
$INCLUDE(LOC2A.EXT)
$INCLUDE(LOC2B.EXT)
$INCLUDE(LOC3.EXT)
$INCLUDE(LOC4.EXT)
$INCLUDE(LOC5.EXT)
/*$INCLUDE(LOC6.EXT)*/
$INCLUDE(LOC7.EXT)
$INCLUDE(LOC8.EXT)
$INCLUDE(LOC9.EXT)



DECLARE spathInfo SPATH$T PUBLIC;
DECLARE signonMsg(*) BYTE PUBLIC INITIAL(0CH, 'ISIS-II OBJECT LOCATER '),
	aInvokedBy(*) BYTE PUBLIC INITIAL(' INVOKED BY:', 0Dh, 0Ah),
	aCommandTailErr(*) BYTE PUBLIC INITIAL('COMMAND TAIL ERROR NEAR #:'),
	tmpFileInfo(*) BYTE PUBLIC INITIAL(0, 'LOCATETMP'),
	scmd$p ADDRESS PUBLIC,
	cmd$p ADDRESS PUBLIC;
DECLARE nxtSegOrder BYTE EXTERNAL;
$INCLUDE(LOC.BAS)




DECLARE controls(*) BYTE PUBLIC DATA(
		0, 0, 253,		/* 253 = -3 */
		1, 1, 4, 'CODE',
		1, 2, 4, 'DATA',
		1, 3, 5, 'STACK',
		1, 4, 6, 'MEMORY',
		2, 0, 5, 'START',
		3, 1, 9, 'STACKSIZE',
		4, 2, 8, 'RESTART0',
		4, 3, 3, 'MAP',
		4, 4, 7, 'PUBLICS',
		4, 5, 7, 'SYMBOLS',
		4, 6, 5, 'LINES',
		4, 7, 5, 'PURGE',
		5, 8, 4, 'NAME',
		6, 0, 5, 'PRINT',
		7, 0, 5, 'ORDER',
		8, 0, 7, 'COLUMNS');

DECLARE cin(*) BYTE PUBLIC DATA(':CI: ');
DECLARE cout(*) BYTE PUBLIC DATA(5,':CO: ');
DECLARE mdebug(*) BYTE PUBLIC DATA('DEBUG ');
DECLARE mstar2(*) BYTE PUBLIC DATA('**');
DECLARE mto(*) BYTE PUBLIC DATA('TO ');
DECLARE mtoand(*) BYTE PUBLIC DATA('TO&');




cmdErr: PROCEDURE(err) PUBLIC;
	DECLARE err ADDRESS;
	DECLARE scmdch BASED scmd$p BYTE;

	IF pastFileName(cmd$p) = cmd$p THEN
	DO;
		IF cmdch <> 0DH THEN
			cmd$p = cmd$p + 1;
	END;
	ELSE
		cmd$p = pastFileName(cmd$p);

	cmdch = '#';	/* put a marker in */
	CALL conStrOut(.aCommandTailErr, 26);
	CALL errmsg(err);
	CALL conStrOut(.scmdch, cmd$p - .scmdch + 1);
	CALL conStrOut(.crlf, 2);
	CALL exit;
END cmdErr;


skipWhiteSpc: PROCEDURE(pch) PUBLIC;
	DECLARE pch ADDRESS;
	cmd$p = skipspc(pch);
	DO WHILE cmdch = '&';
		cmd$p = skipspc(cmd$p + 5);
	END;
END skipWhiteSpc;


expectChar: PROCEDURE(ch, err) PUBLIC;
	DECLARE (ch, err) BYTE;
	CALL skipWhiteSpc(cmd$p);
	IF ch = cmdch THEN
		CALL skipWhiteSpc(cmd$p + 1);
	ELSE
		CALL cmdErr(err);
END expectChar;


expectLP: PROCEDURE PUBLIC;
	CALL expectChar('(', ERR227);	/* left parenthesis expected */
END expectLP;


expectRP: PROCEDURE PUBLIC;
	CALL expectChar(')', ERR228);	/* right parenthesis expected */
END expectRP;


expectSlash: PROCEDURE PUBLIC;
	CALL expectChar('/', ERR203);	/* invalid syntax */
END expectSlash;


checkFile: PROCEDURE PUBLIC;
	CALL spath(cmd$p, .spathInfo, .statusIO);	/* try to parse file */
	IF statusIO > 0 THEN
		CALL cmdERR(statusIO);
	CALL skipWhiteSpc(pastFileName(cmd$p));
END checkFile;


initSegOrder: PROCEDURE PUBLIC;
	DECLARE i BYTE;
	segOrder(0) = 0;
	segOrder(1) = 1;
	segOrder(2) = 3;
	DO i = 3 TO 252;
		segOrder(i) = i + 3;
	END;
	segOrder(253) = 2;
	segOrder(254) = 4;
END initSegOrder;


errNotADisk: PROCEDURE PUBLIC;
	CALL makeFullName(.spathInfo, .inFileName(1));
	CALL errChkReport(ERR17, .inFileName(1), 0FFH);	/* not a disk file */
END errNotADisk;


getpstrName: PROCEDURE(pstr) PUBLIC;
	DECLARE pstr ADDRESS;
	DECLARE str BASED pstr (1) BYTE;

	IF cmdCh < '?' OR 'Z' < cmdCh THEN
		CALL cmdERR(ERR225);	/* invalid Name */
	str(0) = 0;			/* set length */
	DO WHILE '0' <= cmdCh AND cmdCh <= '9' OR '?' <= cmdCh and cmdCh <= 'Z';
		str(0) = str(0) + 1;
		IF str(0) > 31 THEN
			CALL cmdErr(ERR226);	/* name too long */
		str(str(0)) = cmdch;
		cmd$p = cmd$p + 1;
	END;
END getpstrName;


processControls: PROCEDURE PUBLIC;
	DECLARE (p, q, cwindex) ADDRESS;
	DECLARE cindex BYTE AT(.cwindex);
	DECLARE (cid, caux, clen, ctype) BYTE;

	clen = pastFileName(cmd$p) - cmd$p;
	cindex = 3;
	cid = 0;
	IF cmdch = '/' THEN
	DO;
		clen = 1;
		cid = 9;
	END;
	ELSE IF clen > 0 THEN
		DO WHILE cindex < length(controls);
			IF controls(cindex+2) = clen AND strequ(cmd$p, .controls(cindex+3), clen) THEN
			DO;
				cid = controls(cindex);	
				caux = controls(cindex+1);
				cindex = 140;
			END;
			ELSE
				cindex = cindex + controls(cindex + 2) + 3;
		END;
	IF cid = 0 THEN
		CALL cmdERR(ERR229);	/* unrecognised control */
	CALL skipWhiteSpc(cmd$p + clen);
	DO CASE cid - 1;
	    DO;		/* CODE, DATA, STACK, MEMORY */
		segFlags(caux) = 80H;
		segBases(caux) = parseLPNumRP;
	    END;
	    DO;		/* START */
	    	startSeen = 0FFH;
		startAddr = parseLPNumRP;
	    END;
	    DO;		/* STACKSIZE */
	        stackSizeSet = 0FFH;
		stackSize = parseLPNumRP;
	    END;
	    seen(caux) = 0FFH; 		/* RESTART0, MAP, PUBLICS, SYMBOLS, LINES, PURGE */
	    DO;		/* NAME */
	    	nameArgSeen = 0FFH;
		CALL expectLP;
		CALL getpstrName(.nameArg);
		CALL expectRP;
	    END;
	    DO;		/* PRINT */
		CALL expectLP;
		CALL checkFile;
		CALL makeFullName(.spathInfo, .printFileName(1));
		printFileName(0) = pastFileName(.printFileName(1)) - .printFileName(1);
		CALL expectRP;
	    END;
	    DO;		/* ORDER */
	    	CALL initSegOrder;
		nxtSegOrder = 0;
		CALL expectLP;
		DO WHILE cmdch <> ')';
			cindex = 3;
			DO WHILE controls(cindex) = 1;	/* CODE DATA STACK MEMORY */
				IF strequ(cmd$p, .controls(cindex + 3), controls(cindex + 2)) THEN
				DO;
					CALL insSegIdOrder(controls(cindex + 1));
					cmd$p = cmd$p + controls(cindex + 2);
					cindex = 0;
				END;
				/* note if cindex = 0 then this keeps where we are & will termiante loop */
				cindex = cindex + controls(cindex + 2) + 3;
			END;
			IF cindex <> 0 THEN	/* check we haven't already processed */
			DO;
				CALL expectSlash;
				ctype = getCommonTypeId;
				CALL expectSlash;
				CALL insSegIdOrder(ctype);
			END;
			CALL skipWhiteSpc(cmd$p);
			IF cmdch = ',' THEN
				CALL expectChar(',', ERR203); /* invalid syntax */
		END;
		CALL expectRP;
	    END;
	    DO;		/* COLUMNS */
	    	p = cmd$p;
		CALL expectLP;
		q = cmd$p;
		cmd$p = p;
		columns = parseLPNumRP;
		IF columns < 1 OR columns > 3 THEN
		DO;
			cmd$p = q;	/* for error reporting */
			CALL cmdErr(ERR203);	/* invalid syntax */
		END;
	    END;
	    DO;		/* / -> common */
	    	ctype = getCommonTypeID;
		CALL expectSlash;
		segFlags(ctype) = 80H;
		segBases(ctype) = parseLPNumRP;
	    END;
	END;
END processControls;
END locate6;
locate7: DO;
$INCLUDE(ISIS.EXT)
$INCLUDE(LOC.LIT)
$INCLUDE(LOC1.EXT)
$INCLUDE(LOC2A.EXT)
$INCLUDE(LOC2B.EXT)
$INCLUDE(LOC3.EXT)
$INCLUDE(LOC4.EXT)
$INCLUDE(LOC5.EXT)
$INCLUDE(LOC6.EXT)
/*$INCLUDE(LOC7.EXT)*/
$INCLUDE(LOC8.EXT)
$INCLUDE(LOC9.EXT)

$INCLUDE(LOC.BAS)

DECLARE erec BASED erec$p BYTE;

DECLARE cin(1) BYTE EXTERNAL;
DECLARE cout(1) BYTE EXTERNAL;
DECLARE mdebug(1) BYTE EXTERNAL;
DECLARE mstar2(1) BYTE EXTERNAL;
DECLARE mto(1) BYTE EXTERNAL;
DECLARE mtoand(1) BYTE EXTERNAL;

DECLARE nxtSegOrder BYTE PUBLIC;

parseLPNumRP: PROCEDURE ADDRESS PUBLIC;
	DECLARE num ADDRESS;

	CALL expectLP;
	IF cmdCh < '0' OR '9' < cmdCh THEN	/* must have digit */
		CALL cmdErr(ERR203);	/* invalid syntax */
	num = parseNumber(.cmd$p);
	IF pastFileName(cmd$p) <> cmd$p THEN	/* make sure not a filename or bad number */
		CALL cmdErr(ERR203);	/* invalid syntax */
	CALL expectRP;
	RETURN num;
END parseLPNumRP;


getCommonTypeID: PROCEDURE BYTE PUBLIC;
	DECLARE name(32) BYTE;

	IF cmdch = '/' THEN
		RETURN 0FFH;	/* blank common */
	CALL getpstrName(.name);
	name(name(0) + 1) = ' ';	/* space at end */
	CALL iseek(0, 0);
	CALL getRecord;		/* skip type 2 record */

	DO WHILE 1;
		CALL getRecord;
		IF srec.type <> 2EH THEN
			CALL errChkReport(ERR237, .name(1), 0FFH);	/* common not found */
		DO WHILE rec$p < .erec;
			IF strequ(.name, .t2Erec.name, name(0)+1) THEN
				RETURN t2Erec.seg;
			rec$p = rec$p + 2 + t2Erec.name(0);
		END;
	END;
END getCommonTypeID;


insSegIdOrder: PROCEDURE(seg) PUBLIC;
	DECLARE seg BYTE;
	DECLARE i BYTE;
	nxtSegOrder = nxtSegOrder + 1;
	IF segOrder(nxtSegOrder) = seg THEN	/* already in order */
		RETURN;
	DO i = 0 TO nxtSegOrder;
		IF segOrder(i) = seg THEN	/* already allocated ? */
			CALL cmdErr(ERR203);	/* invalid syntax */
	END;
	DO i = nxtSegOrder + 1 TO 254;
		IF segOrder(i) = seg THEN
			goto L6C93;
	END;
L6C93:
	DO WHILE i > nxtSegOrder;
		segOrder(i) = segOrder(i - 1);	/* make room for this seg */
		i = i - 1;
	END;
	segOrder(nxtSegOrder) = seg;
END insSegIdOrder;


readCmdLine: PROCEDURE PUBLIC;

	CALL read(1, cmd$p, 128, .actRead, .statusIO);
	CALL errChkReport(statusIO, .cin, 0FFH);
	cmdbuf(actRead) = 0DH;
	call strupr(cmd$p);
END readCmdLine;


procArgs$Init: PROCEDURE PUBLIC;
	DECLARE scmdch BASED scmd$p BYTE;
	DECLARE (p, q) ADDRESS;

	IF (pageCacheSize := HIGH(memck - baseMemImage) - 1) >= 128 THEN
		npbuf = 4096;
	ELSE IF pageCacheSize >= 64 THEN
		npbuf = 2048;
	ELSE
		npbuf = 1056;

	eibuf$p, ibuf$p = memck;
	sibuf$p, eout$p = eibuf$p - npbuf;
	sout$p, out$p, spbuf$p, pbuf$p, epbuf$p = eout$p - npbuf;
	scmd$p = .MEMORY;
	IF (usePrintBuf := pageCacheSize >= 64) THEN
		scmd$p = sout$p;
	scmdch = '-';
	CALL rescan(1, .statusIO);
	cmd$p = scmd$p + 1;
	CALL readCmdLine;
	cmd$p = skipspc(cmd$p);
	IF strequ(cmd$p, .mdebug, 6) THEN
		cmd$p = skipspc(cmd$p + 6);
	cmd$p, q = skipspc(pastFileName(cmd$p));
	DO WHILE cmdch <> 0DH;
		IF cmdch = '&' THEN
		DO;
			p = cmd$p;
			cmd$p = skipspc(cmd$p + 1);
			IF cmdch <> 0DH THEN
				CALL cmdErr(ERR203);	/* invalid syntax */
			cmd$p = p;
			CALL conStrOut(.mstar2, 2);
			cmdbuf(1) = 0DH;
			cmdbuf(2) = 0AH;
			cmdbuf(3) = '*';
			cmdbuf(4) = '*';
			cmd$p = cmd$p + 5;
			CALL readCmdLine;
		END;
		ELSE
			cmd$p = cmd$p + 1;
	END;	/* DO WHILE */

	CALL constrOut(.signonMsg + 1, 23);
	CALL constrOut(.VERSION, 4);
	CALL constrOut(.crlf, 2);
	IF cmd$p > sibuf$p THEN
		CALL cmdErr(ERR210);	/* insufficient memory */
	CALL skipWhiteSpc(q);
	CALL checkFile;
	IF spathInfo.deviceType <> 3 THEN
		CALL errNotADisk;
	CALL makeFullName(.spathInfo, .inFileName(1));
	inFileName(0) = pastFileName(.inFileName(1)) - .inFileName(1);
	IF strequ(cmd$p, .mto, 3) OR strequ(cmd$p, .mtoand, 3) THEN
	DO;
		CALL skipWhiteSpc(cmd$p + 2);
		CALL checkFile;
	END;
	ELSE
	DO;
		IF spathInfo.ext(0) = 0 THEN
			CALL cmdErr(ERR233);	/* TO expected */
		spathInfo.ext(0) = 0;
		spathInfo.ext(1) = 0;
		spathInfo.ext(2) = 0;
	END;
	CALL makeFullName(.spathInfo, .outFileName(1));
	outFileName(0) = pastFileName(.outFileName(1)) - .outFileName(1);
	IF spathInfo.deviceType <> 3 and spathInfo.deviceId <> 22 THEN	/* 22 -> :BB: */
		CALL errNotADisk;
	tmpFileInfo(0) = spathInfo.deviceId;
	CALL makefullName(.tmpFileInfo, .tmpFileName(1));
	tmpFileName(0) = pastFileName(.tmpFileName(1)) - .tmpFileName(1);
	isNotBB = spathInfo.deviceId <> 22;
	CALL open(.readfd, .InFileName(1), 1, 0, .statusIO);
	CALL errChkReport(statusIO, .inFileName(1), 0FFH);
	recNum = 0;
	CALL getRecord;
	IF srec.type <> 2 THEN
		CALL errChkReport(ERR239, .inFileName(1), 0FFH);	/* no module header record */
	CALL pstrcpy(.cout, .printFileName);
	columns = 1;
	startSeen = 0;
	stackSizeSet = 0;
	restart0Seen = 0;
	MapSeen = 0;
	PublicsSeen = 0;
	SymbolsSeen = 0;
	LinesSeen = 0;
	PurgeSeen = 0;
	nameArgSeen = 0;
	type4SubType = 0;
	type2$b1 = 0;
	type2$b2 = 0;
	startAddr = 0;
	CALL initSegOrder;
	DO p = 0 TO 255;
		segFlags(p) = 0;
		segBases(p), segSizes(p) = 0;
	END;
	DO WHILE cmdch <> 0DH;
		CALL processControls;
	END;
	havePagingFile = 0;
	roundRobinIndex = 0;
	pageIndexTmpFil = 0;
	pageCacheSize = HIGH(sout$p - (pageTab1$p := pageTab2$p + 512)) - 1;
	baseMemImage =  pageTab1$p + (pageCacheSize + 1) * 2 ;
	DO p = 0 TO 255;
		IF p <= pageCacheSize THEN
			pageTab1(p).state = 0FFH;
		pageTab2(p).state = 0FFH;
		pageTab2(p).fpage = 0FFH;
	END;

	IF usePrintBuf THEN
		spbuf$p, pbuf$p = epbuf$p - npbuf;
	topHeap, topDescriptor, botHeap = spbuf$p;
	pageCacheSize = HIGH(botHeap - baseMemImage) - 1;
	CALL delete(.outFileName(1), .statusIO);
	CALL open(.outputfd, .outFilename(1), 3, 0, .statusIO);
	CALL errChkReport(statusIO, .outFileName(1), 0FFH);
	CALL open(.printfd, .printFileName(1), 2, 0, .statusIO);
	CALL errChkReport(statusIO, .printFileName(1), 0FFH);
	IF printfd > 0 THEN
	DO;
		CALL printString(.signonMsg, 24);
		CALL printString(.VERSION, 4);
		CALL printString(.aInvokedBY, 14);
		CALL printString(.scmdch, cmd$p - .scmdch + 2);
	END;
END procArgs$Init;

DECLARE aInpageSegment2(*) BYTE PUBLIC INITIAL('INPAGE SEGMENT > 256 BYTES COERCED TO PAGE BOUNDRY', 0DH, 0AH),
	segId BYTE PUBLIC,
	pad7935(3) BYTE PUBLIC;

alignAddress: PROCEDURE(align, size, laddr) ADDRESS PUBLIC;
	DECLARE align BYTE;
	DECLARE (size, laddr) ADDRESS;
	IF size = 0 THEN
		RETURN laddr;

	IF align = 3 THEN
		RETURN laddr;
	IF align = 1 THEN
		IF size <= 256 THEN
		DO;
			IF HIGH(laddr) = HIGH(laddr + size - 1) THEN
				RETURN laddr;
		END;
		ELSE    /* inpage seg > 256 coerced to page boundary */
			CALL conAndPrint(.aInpageSegment2, 52);	
	RETURN (laddr + 0FFH) AND 0FF00H;	/* get a whole page */
END alignAddress;


procRec2: PROCEDURE PUBLIC;
	DECLARE rbyt BASED rec$p (1) BYTE;
	DECLARE sdef BASED rec$p STRUCTURE (segId BYTE, len ADDRESS, combine BYTE, next BYTE);
	DECLARE (loadAddress, segSize, segOrderId) ADDRESS;
	DECLARE (atTopOfMem, loadHasSize) BYTE;

	IF NOT nameArgSeen THEN
		CALL pstrcpy(rec$p, .nameArg);
	rec$p = rec$p + rbyt(0) + 1;	/* past name */
	type2$b1 = rbyt(0);
	type2$b2 = rbyt(1);
	rec$p = rec$p + 2;
	loadHasSize = 0;
	DO WHILE rec$p < .erec;
		IF (segFlags(segId := sdef.segId) AND 0FH) <> 0 THEN
			CALL illegalRecord;
		IF segId <> 3 THEN
			segSizes(segId) = sdef.len;
		ELSE IF NOT stackSizeSet THEN
			stackSize = sdef.len;
		IF segSizes(segId) > 0 THEN
			loadHasSize = 0FFH;
		IF sdef.combine - 1 > 2 THEN
			CALL illegalRecord;
		segFlags(segId) = segFlags(segId) + sdef.combine;
		rec$p = .sdef.next;
	END;
	IF (segFlags(3) AND 0FH) = 0 THEN
		segFlags(3) = segFlags(3) + 3;	/* set low bits to 3 */
	IF (segFlags(4) AND 0FH) = 0 THEN
		segFlags(4) = segFlags(4) + 3;	/* set low bits to 3 */
	IF NOT stackSizeSet AND loadHasSize THEN
		stackSize = stackSize + 12;
	loadAddress = 3680H;				/* ISIS load address */
	atTopOfMem = 0;

	DO segOrderId = 1 TO 254;
		segid = segOrder(segOrderId);
		segSize = segSizes(segId);	/* pick up seg to process */
		IF (segFlags(segId) AND 80H) = 0 THEN
		DO;
			IF atTopOfMem <> 0 THEN
			DO;
				IF segSize > 0 THEN	/* program exceeds 64k */
					CALL errChkReport(ERR240, .inFileName(1), 0FFH);
				segFlags(segId) = segFlags(segId) OR 40H;
			END;
		END;
		ELSE
		DO;					/* common */
			IF segSize > 0 THEN
				atTopOfMem = 0;
			loadAddress = segBases(segId);
		END;
		segBases(segId) = alignAddress(segFlags(segId) AND 0FH, segSize, loadAddress);
		IF segId = 4 THEN
			IF segSize = 0 AND loadHasSize THEN
				IF atTopOfMem = 0 AND memck > MemoryBase(0) THEN
					MemorySize(0), segSize = memck - MemoryBase(0);
		IF (loadAddress := segBases(segId) + segSize) < segBases(segId) THEN
			IF loadAddress = 0 THEN
				atTopOfMem = 40H;
			ELSE
				CALL errChkReport(ERR240, .inFileName(1), 0FFH);  /* exceeds 64k */
	END; 
	stackAddr = stackAddr + stackSize;	/* stack goes down so update top */
	CALL getRecord;
END procRec2;


procRec2E: PROCEDURE PUBLIC;
	DO WHILE rec$p < .erec;
		IF (segId := t2Erec.seg) < 6 OR segId = 0FFH THEN
			CALL illegalRecord;
		IF ((segFlags(segId) AND 0FH) = 0) OR ((segFlags(segId) AND 10H) <> 0)THEN
			CALL illegalRecord;
		segFlags(segId) = segFlags(segId) OR 10H;
		rec$p = rec$p + 2 + t2Erec.name(0);		/* past byte, len, string */
	END;
	CALL getRecord;
END procRec2E;


procHeader: PROCEDURE PUBLIC;
	CALL iseek(0, 0);
	CALL getRecord;
	CALL procRec2;

	DO WHILE srec.type = 2EH;
		CALL procRec2E;
	END;
	DO segId = 6 TO 254;	
		IF ((segFlags(segId) AND 0FH) <> 0) AND ((segFlags(segId) AND 10H) = 0) THEN
			CALL badRecordSeq;
	END;
END procHeader;

END locate7;
locate8: DO;
$INCLUDE(LOC.LIT)
$INCLUDE(LOC9.EXT)

DECLARE devices (*) BYTE DATA('F0F1F2F3F4F5TITO',
		      'VIVOI1O1TRHRR1R2',
		      'TPHPP1P2LPL1BBCI',
		      'COF6F7F8F9');

makeFullName: PROCEDURE(pinfo, pstr) PUBLIC;
	DECLARE pinfo ADDRESS;
	DECLARE pstr ADDRESS;
	DECLARE str BASED pstr(1) BYTE;
	DECLARE ch BASED pstr BYTE;
	DECLARE info BASED pinfo SPATH$T;

	DECLARE i BYTE;

	str(0) = ':';
	str(1) = devices(info.deviceId + info.deviceId);
	str(2) = devices(info.deviceId + info.deviceId + 1);
	str(3) = ':';
	pstr = pstr + 4;	/* past the :xx: inserted */
	DO i = 0 TO 5;
		IF (ch := info.name(i)) <> 0 THEN
			pstr = pstr + 1;
	END;
	IF info.ext(0) <> 0 THEN
	DO;
		ch = '.';
		pstr = pstr + 1;
	END;
	DO i = 0 TO 2;
		IF (ch := info.ext(i)) <> 0 THEN
			pstr = pstr + 1;
	END;
	ch = ' ';	/* space at end */
END makeFullName;


strupr: PROCEDURE(pch) PUBLIC;
	DECLARE pch ADDRESS;
	DECLARE ch BASED pch BYTE;

	DO WHILE ch <> 0DH;
		ch = toupper(ch);
		pch = pch + 1;
	END;
END strupr;

END locate8;
locate8: DO;
$INCLUDE(LOC.LIT)
$INCLUDE(LOC9.EXT)

DECLARE hexch(*) BYTE DATA ('0123456789ABCDEF');

parseNumber: PROCEDURE(ppstr) ADDRESS PUBLIC;
	DECLARE ppstr ADDRESS;
	DECLARE pstr BASED ppstr ADDRESS;
	DECLARE (pch, pafter, pendNum) ADDRESS;
	DECLARE (i, radix, digit) BYTE;
	DECLARE (num, lastnum) ADDRESS;
	DECLARE ch BASED pch BYTE;

	pch = pstr;
	DO WHILE ch = ' ';	/* skip spaces */
		pch = pch + 1;
	END;
	pstr = pch;		/* update the source pstr */

	DO WHILE '0' <= ch AND ch <= '9' OR 'A' <= ch AND ch <= 'F';
		pch = pch + 1;
	END;
	pafter = (pendNum := pch) + 1;
	IF ch = 'H' THEN
		radix = 16;
	ELSE IF ch = 'O' OR ch = 'Q' THEN
		radix = 8;
	ELSE
	DO;	/* check for D or B or numeric */
		pendNum, pch = (pafter := pch) - 1;
		IF ch = 'B' THEN
			radix = 2;
		ELSE
		DO;
			radix = 10;
			IF ch <> 'D' THEN	/* if a digit then include in number */
				pendNum = pendNum + 1;
		END;
	END;
	pch = pstr;	/* reset to start */
	num, lastnum = 0;
	DO WHILE pch < pendNum;
		DO i = 0 TO 15;
			IF ch = hexch(i) THEN
				digit = i;
		END;
		IF digit >= radix THEN
			RETURN 0;	/* illegal number */
		IF (num := lastnum * radix + digit) < lastnum THEN
			RETURN 0;	/* overflow */
		lastnum = num;
		pch = pch + 1;
	END;
	pstr = pafter;
	RETURN num;
END parseNumber;


strequ: PROCEDURE(pstr1, pstr2, len) BYTE PUBLIC;
	DECLARE (pstr1, pstr2) ADDRESS, len BYTE;
	DECLARE i BYTE;
	DECLARE str1 BASED pstr1 (1) BYTE, str2 BASED pstr2 (1) BYTE;

	len = len - 1;
	DO i = 0 TO len;
		IF str1(i) <> str2(i) THEN
			RETURN 0;
	END;
	RETURN 0FFH;
END strequ;


END locate8;
locate9:
DO;
toupper: PROCEDURE(ch) BYTE PUBLIC;
	DECLARE ch BYTE;
	IF ch < 'a' THEN
		RETURN ch;
	IF ch > 'z' THEN
		RETURN ch;
	RETURN ch AND 0DFH;
END toupper;

END locate9;
