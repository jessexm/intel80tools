locate6: DO;
$INCLUDE(ISIS.EXT)
$INCLUDE(LOC.LIT)
$INCLUDE(LOC1.EXT)
$INCLUDE(LOC2A.EXT)
$INCLUDE(LOC2B.EXT)
$INCLUDE(LOC3.EXT)
$INCLUDE(LOC4.EXT)
$INCLUDE(LOC5.EXT)
/*$INCLUDE(LOC6.EXT)*/
$INCLUDE(LOC7.EXT)
$INCLUDE(LOC8.EXT)
$INCLUDE(LOC9.EXT)



DECLARE spathInfo SPATH$T PUBLIC;
DECLARE signonMsg(*) BYTE PUBLIC INITIAL(0CH, 'ISIS-II OBJECT LOCATER '),
	aInvokedBy(*) BYTE PUBLIC INITIAL(' INVOKED BY:', 0Dh, 0Ah),
	aCommandTailErr(*) BYTE PUBLIC INITIAL('COMMAND TAIL ERROR NEAR #:'),
	tmpFileInfo(*) BYTE PUBLIC INITIAL(0, 'LOCATETMP'),
	scmd$p ADDRESS PUBLIC,
	cmd$p ADDRESS PUBLIC;
DECLARE nxtSegOrder BYTE EXTERNAL;
$INCLUDE(LOC.BAS)




DECLARE controls(*) BYTE PUBLIC DATA(
		0, 0, 253,		/* 253 = -3 */
		1, 1, 4, 'CODE',
		1, 2, 4, 'DATA',
		1, 3, 5, 'STACK',
		1, 4, 6, 'MEMORY',
		2, 0, 5, 'START',
		3, 1, 9, 'STACKSIZE',
		4, 2, 8, 'RESTART0',
		4, 3, 3, 'MAP',
		4, 4, 7, 'PUBLICS',
		4, 5, 7, 'SYMBOLS',
		4, 6, 5, 'LINES',
		4, 7, 5, 'PURGE',
		5, 8, 4, 'NAME',
		6, 0, 5, 'PRINT',
		7, 0, 5, 'ORDER',
		8, 0, 7, 'COLUMNS');

DECLARE cin(*) BYTE PUBLIC DATA(':CI: ');
DECLARE cout(*) BYTE PUBLIC DATA(5,':CO: ');
DECLARE mdebug(*) BYTE PUBLIC DATA('DEBUG ');
DECLARE mstar2(*) BYTE PUBLIC DATA('**');
DECLARE mto(*) BYTE PUBLIC DATA('TO ');
DECLARE mtoand(*) BYTE PUBLIC DATA('TO&');




cmdErr: PROCEDURE(err) PUBLIC;
	DECLARE err ADDRESS;
	DECLARE scmdch BASED scmd$p BYTE;

	IF pastFileName(cmd$p) = cmd$p THEN
	DO;
		IF cmdch <> 0DH THEN
			cmd$p = cmd$p + 1;
	END;
	ELSE
		cmd$p = pastFileName(cmd$p);

	cmdch = '#';	/* put a marker in */
	CALL conStrOut(.aCommandTailErr, 26);
	CALL errmsg(err);
	CALL conStrOut(.scmdch, cmd$p - .scmdch + 1);
	CALL conStrOut(.crlf, 2);
	CALL exit;
END cmdErr;


skipNonArgChars: PROCEDURE(pch) PUBLIC;
	DECLARE pch ADDRESS;
	cmd$p = skipspc(pch);
	/* skip any continuation bits and leading space */
	DO WHILE cmdch = '&';
		cmd$p = skipspc(cmd$p + 5);
	END;
END skipNonArgChars;


expectChar: PROCEDURE(ch, err) PUBLIC;
	DECLARE (ch, err) BYTE;
	CALL skipNonArgChars(cmd$p);
	IF ch = cmdch THEN
		CALL skipNonArgChars(cmd$p + 1);
	ELSE
		CALL cmdErr(err);
END expectChar;


expectLP: PROCEDURE PUBLIC;
	CALL expectChar('(', ERR227);	/* left parenthesis expected */
END expectLP;


expectRP: PROCEDURE PUBLIC;
	CALL expectChar(')', ERR228);	/* right parenthesis expected */
END expectRP;


expectSlash: PROCEDURE PUBLIC;
	CALL expectChar('/', ERR203);	/* invalid syntax */
END expectSlash;


getFile: PROCEDURE PUBLIC;
	CALL spath(cmd$p, .spathInfo, .statusIO);	/* try to parse file */
	IF statusIO > 0 THEN
		CALL cmdERR(statusIO);
	CALL skipNonArgChars(pastFileName(cmd$p));
END getFile;


initSegOrder: PROCEDURE PUBLIC;
	DECLARE i BYTE;
	segOrder(0) = SABS;
	segOrder(1) = SCODE;
	segOrder(2) = SSTACK;
	/* next come the common segs in order */
	DO i = 3 TO 252;
		segOrder(i) = i + 3;
	END;
	/* DATA is after these and MEMORY is last */
	segOrder(253) = SDATA;
	segOrder(254) = SMEMORY;
END initSegOrder;


errNotADisk: PROCEDURE PUBLIC;
	CALL makeFullName(.spathInfo, .inFileName(1));
	CALL errChkReport(ERR17, .inFileName(1), TRUE);	/* not a disk file */
END errNotADisk;


getpstrName: PROCEDURE(pstr) PUBLIC;
	DECLARE pstr ADDRESS;
	DECLARE str BASED pstr (1) BYTE;

	IF cmdCh < '?' OR 'Z' < cmdCh THEN
		CALL cmdErr(ERR225);	/* invalid Name */
	str(0) = 0;			/* set length */
	DO WHILE '0' <= cmdCh AND cmdCh <= '9' OR '?' <= cmdCh and cmdCh <= 'Z';
		str(0) = str(0) + 1;
		IF str(0) > 31 THEN
			CALL cmdErr(ERR226);	/* name too long */
		str(str(0)) = cmdch;
		cmd$p = cmd$p + 1;
	END;
END getpstrName;


processControls: PROCEDURE PUBLIC;
	DECLARE (p, q, cwindex) ADDRESS;
	DECLARE cindex BYTE AT(.cwindex);
	DECLARE (cid, caux, clen, cSegId) BYTE;

	/* find the command length */
	clen = pastFileName(cmd$p) - cmd$p;
	cindex = 3;
	cid = 0;
	IF cmdch = '/' THEN	/* common seg address */
	DO;
		clen = 1;	/* treat specially */
		cid = 9;
	END;
	ELSE IF clen > 0 THEN	/* look up the control */
		DO WHILE cindex < length(controls);
			IF controls(cindex+2) = clen AND strequ(cmd$p, .controls(cindex+3), clen) THEN
			DO;
				cid = controls(cindex);	
				caux = controls(cindex+1);
				cindex = length(controls);
			END;
			ELSE
				cindex = cindex + controls(cindex + 2) + 3;
		END;
	IF cid = 0 THEN		/* check we have a valid command */
		CALL cmdERR(ERR229);	/* unrecognised control */
	CALL skipNonArgChars(cmd$p + clen);
	DO CASE cid - 1;
	    DO;		/* CODE, DATA, STACK, MEMORY */
		segFlags(caux) = FHASADDR;	/* note that the address is specified */
		segBases(caux) = parseLPNumRP;	/* and its value */
	    END;
	    DO;		/* START */
	    	startSeen = TRUE;		/* got a start address */
		startAddr = parseLPNumRP;	/* and its value */
	    END;
	    DO;		/* STACKSIZE */
	        stackSizeSeen = TRUE;		/* got a stack size */
		segSizes(SSTACK) = parseLPNumRP;/* and its value */
	    END;
	    seen(caux) = TRUE; 		/* simple command seen - RESTART0, MAP, PUBLICS, SYMBOLS, LINES, PURGE */
	    DO;		/* NAME */
	    	moduleNameSeen = TRUE;		/* got a module name */
		CALL expectLP;
		CALL getpstrName(.moduleName);	/* getand its value */
		CALL expectRP;
	    END;
	    DO;		/* PRINT */		/* get the print file */
		CALL expectLP;
		CALL getFile;
		CALL makeFullName(.spathInfo, .printFileName(1));
		printFileName(0) = pastFileName(.printFileName(1)) - .printFileName(1);
		CALL expectRP;
	    END;
	    DO;		/* ORDER */		/* process the order list */
	    	CALL initSegOrder;
		nxtSegOrder = 0;
		CALL expectLP;
		DO WHILE cmdch <> ')';
			cindex = 3;			/* skip seg 0 */
			DO WHILE controls(cindex) = 1;	/* CODE DATA STACK MEMORY */
				IF strequ(cmd$p, .controls(cindex + 3), controls(cindex + 2)) THEN
				DO;
					CALL insSegIdOrder(controls(cindex + 1));
					cmd$p = cmd$p + controls(cindex + 2);
					cindex = 0;
				END;
				/* note if cindex = 0 then this keeps where we are & will terminate loop */
				cindex = cindex + controls(cindex + 2) + 3;
			END;
			IF cindex <> 0 THEN	/* check we haven't already processed */
			DO;			/* if not scan for /common/ names */
				CALL expectSlash;
				cSegId = getCommonSegId;
				CALL expectSlash;
				CALL insSegIdOrder(cSegId);
			END;
			CALL skipNonArgChars(cmd$p);
			/* look for list of names */
			IF cmdch = ',' THEN
				CALL expectChar(',', ERR203); /* invalid syntax */
		END;
		CALL expectRP;
	    END;
	    DO;		/* COLUMNS */		/* get the number of columns */
	    	p = cmd$p;	/* mark where we are */
		CALL expectLP;	/* look for the ( */
		q = cmd$p;	/* mark start of number */
		cmd$p = p;	/* reset to start of (n) */
		columns = parseLPNumRP;
		IF columns < 1 OR columns > 3 THEN	/* must be 1-3 */
		DO;
			cmd$p = q;	/* for error reporting */
			CALL cmdErr(ERR203);	/* invalid syntax */
		END;
	    END;
	    DO;		/* / -> common */	/* find the common name or blank */
	    	cSegId = getCommonSegId;	/* look up seg */
		CALL expectSlash;		/* end with a slash */
		segFlags(cSegId) = FHASADDR;	/* note we have an address */
		segBases(cSegId) = parseLPNumRP; /* and its value */
	    END;
	END;
END processControls;
END locate6;
