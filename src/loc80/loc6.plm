locate6: DO;
$INCLUDE(ISIS.EXT)
$INCLUDE(LOC.LIT)
$INCLUDE(LOC1.EXT)
$INCLUDE(LOC2A.EXT)
$INCLUDE(LOC2B.EXT)
$INCLUDE(LOC3.EXT)
$INCLUDE(LOC4.EXT)
$INCLUDE(LOC5.EXT)
/*$INCLUDE(LOC6.EXT)*/
$INCLUDE(LOC7.EXT)
$INCLUDE(LOC8.EXT)
$INCLUDE(LOC9.EXT)



DECLARE spathInfo SPATH$T PUBLIC;
DECLARE signonMsg(*) BYTE PUBLIC INITIAL(0CH, 'ISIS-II OBJECT LOCATER '),
	aInvokedBy(*) BYTE PUBLIC INITIAL(' INVOKED BY:', 0Dh, 0Ah),
	aCommandTailErr(*) BYTE PUBLIC INITIAL('COMMAND TAIL ERROR NEAR #:'),
	tmpFileInfo(*) BYTE PUBLIC INITIAL(0, 'LOCATETMP'),
	scmd$p ADDRESS PUBLIC,
	cmd$p ADDRESS PUBLIC;
DECLARE nxtSegOrder BYTE EXTERNAL;
$INCLUDE(LOC.BAS)




DECLARE controls(*) BYTE PUBLIC DATA(
		0, 0, 253,		/* 253 = -3 */
		1, 1, 4, 'CODE',
		1, 2, 4, 'DATA',
		1, 3, 5, 'STACK',
		1, 4, 6, 'MEMORY',
		2, 0, 5, 'START',
		3, 1, 9, 'STACKSIZE',
		4, 2, 8, 'RESTART0',
		4, 3, 3, 'MAP',
		4, 4, 7, 'PUBLICS',
		4, 5, 7, 'SYMBOLS',
		4, 6, 5, 'LINES',
		4, 7, 5, 'PURGE',
		5, 8, 4, 'NAME',
		6, 0, 5, 'PRINT',
		7, 0, 5, 'ORDER',
		8, 0, 7, 'COLUMNS');

DECLARE cin(*) BYTE PUBLIC DATA(':CI: ');
DECLARE cout(*) BYTE PUBLIC DATA(5,':CO: ');
DECLARE mdebug(*) BYTE PUBLIC DATA('DEBUG ');
DECLARE mstar2(*) BYTE PUBLIC DATA('**');
DECLARE mto(*) BYTE PUBLIC DATA('TO ');
DECLARE mtoand(*) BYTE PUBLIC DATA('TO&');




cmdErr: PROCEDURE(err) PUBLIC;
	DECLARE err ADDRESS;
	DECLARE scmdch BASED scmd$p BYTE;

	IF pastFileName(cmd$p) = cmd$p THEN
	DO;
		IF cmdch <> 0DH THEN
			cmd$p = cmd$p + 1;
	END;
	ELSE
		cmd$p = pastFileName(cmd$p);

	cmdch = '#';	/* put a marker in */
	CALL conStrOut(.aCommandTailErr, 26);
	CALL errmsg(err);
	CALL conStrOut(.scmdch, cmd$p - .scmdch + 1);
	CALL conStrOut(.crlf, 2);
	CALL exit;
END cmdErr;


skipWhiteSpc: PROCEDURE(pch) PUBLIC;
	DECLARE pch ADDRESS;
	cmd$p = skipspc(pch);
	DO WHILE cmdch = '&';
		cmd$p = skipspc(cmd$p + 5);
	END;
END skipWhiteSpc;


expectChar: PROCEDURE(ch, err) PUBLIC;
	DECLARE (ch, err) BYTE;
	CALL skipWhiteSpc(cmd$p);
	IF ch = cmdch THEN
		CALL skipWhiteSpc(cmd$p + 1);
	ELSE
		CALL cmdErr(err);
END expectChar;


expectLP: PROCEDURE PUBLIC;
	CALL expectChar('(', ERR227);	/* left parenthesis expected */
END expectLP;


expectRP: PROCEDURE PUBLIC;
	CALL expectChar(')', ERR228);	/* right parenthesis expected */
END expectRP;


expectSlash: PROCEDURE PUBLIC;
	CALL expectChar('/', ERR203);	/* invalid syntax */
END expectSlash;


checkFile: PROCEDURE PUBLIC;
	CALL spath(cmd$p, .spathInfo, .statusIO);	/* try to parse file */
	IF statusIO > 0 THEN
		CALL cmdERR(statusIO);
	CALL skipWhiteSpc(pastFileName(cmd$p));
END checkFile;


initSegOrder: PROCEDURE PUBLIC;
	DECLARE i BYTE;
	segOrder(0) = 0;
	segOrder(1) = 1;
	segOrder(2) = 3;
	DO i = 3 TO 252;
		segOrder(i) = i + 3;
	END;
	segOrder(253) = 2;
	segOrder(254) = 4;
END initSegOrder;


errNotADisk: PROCEDURE PUBLIC;
	CALL makeFullName(.spathInfo, .inFileName(1));
	CALL errChkReport(ERR17, .inFileName(1), 0FFH);	/* not a disk file */
END errNotADisk;


getpstrName: PROCEDURE(pstr) PUBLIC;
	DECLARE pstr ADDRESS;
	DECLARE str BASED pstr (1) BYTE;

	IF cmdCh < '?' OR 'Z' < cmdCh THEN
		CALL cmdErr(ERR225);	/* invalid Name */
	str(0) = 0;			/* set length */
	DO WHILE '0' <= cmdCh AND cmdCh <= '9' OR '?' <= cmdCh and cmdCh <= 'Z';
		str(0) = str(0) + 1;
		IF str(0) > 31 THEN
			CALL cmdErr(ERR226);	/* name too long */
		str(str(0)) = cmdch;
		cmd$p = cmd$p + 1;
	END;
END getpstrName;


processControls: PROCEDURE PUBLIC;
	DECLARE (p, q, cwindex) ADDRESS;
	DECLARE cindex BYTE AT(.cwindex);
	DECLARE (cid, caux, clen, ctype) BYTE;

	clen = pastFileName(cmd$p) - cmd$p;
	cindex = 3;
	cid = 0;
	IF cmdch = '/' THEN
	DO;
		clen = 1;
		cid = 9;
	END;
	ELSE IF clen > 0 THEN
		DO WHILE cindex < length(controls);
			IF controls(cindex+2) = clen AND strequ(cmd$p, .controls(cindex+3), clen) THEN
			DO;
				cid = controls(cindex);	
				caux = controls(cindex+1);
				cindex = 140;
			END;
			ELSE
				cindex = cindex + controls(cindex + 2) + 3;
		END;
	IF cid = 0 THEN
		CALL cmdERR(ERR229);	/* unrecognised control */
	CALL skipWhiteSpc(cmd$p + clen);
	DO CASE cid - 1;
	    DO;		/* CODE, DATA, STACK, MEMORY */
		segFlags(caux) = 80H;
		segBases(caux) = parseLPNumRP;
	    END;
	    DO;		/* START */
	    	startSeen = 0FFH;
		startAddr = parseLPNumRP;
	    END;
	    DO;		/* STACKSIZE */
	        stackSizeSet = 0FFH;
		stackSize = parseLPNumRP;
	    END;
	    seen(caux) = 0FFH; 		/* RESTART0, MAP, PUBLICS, SYMBOLS, LINES, PURGE */
	    DO;		/* NAME */
	    	nameArgSeen = 0FFH;
		CALL expectLP;
		CALL getpstrName(.nameArg);
		CALL expectRP;
	    END;
	    DO;		/* PRINT */
		CALL expectLP;
		CALL checkFile;
		CALL makeFullName(.spathInfo, .printFileName(1));
		printFileName(0) = pastFileName(.printFileName(1)) - .printFileName(1);
		CALL expectRP;
	    END;
	    DO;		/* ORDER */
	    	CALL initSegOrder;
		nxtSegOrder = 0;
		CALL expectLP;
		DO WHILE cmdch <> ')';
			cindex = 3;
			DO WHILE controls(cindex) = 1;	/* CODE DATA STACK MEMORY */
				IF strequ(cmd$p, .controls(cindex + 3), controls(cindex + 2)) THEN
				DO;
					CALL insSegIdOrder(controls(cindex + 1));
					cmd$p = cmd$p + controls(cindex + 2);
					cindex = 0;
				END;
				/* note if cindex = 0 then this keeps where we are & will termiante loop */
				cindex = cindex + controls(cindex + 2) + 3;
			END;
			IF cindex <> 0 THEN	/* check we haven't already processed */
			DO;
				CALL expectSlash;
				ctype = getCommonTypeId;
				CALL expectSlash;
				CALL insSegIdOrder(ctype);
			END;
			CALL skipWhiteSpc(cmd$p);
			IF cmdch = ',' THEN
				CALL expectChar(',', ERR203); /* invalid syntax */
		END;
		CALL expectRP;
	    END;
	    DO;		/* COLUMNS */
	    	p = cmd$p;
		CALL expectLP;
		q = cmd$p;
		cmd$p = p;
		columns = parseLPNumRP;
		IF columns < 1 OR columns > 3 THEN
		DO;
			cmd$p = q;	/* for error reporting */
			CALL cmdErr(ERR203);	/* invalid syntax */
		END;
	    END;
	    DO;		/* / -> common */
	    	ctype = getCommonTypeID;
		CALL expectSlash;
		segFlags(ctype) = 80H;
		segBases(ctype) = parseLPNumRP;
	    END;
	END;
END processControls;
END locate6;
