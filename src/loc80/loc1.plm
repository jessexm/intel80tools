$LIST
$CODE
LOCATE:
DO;
$INCLUDE(ISIS.EXT)
$INCLUDE(LOC.LIT)
$INCLUDE(LOC2A.EXT)
$INCLUDE(LOC3.EXT)
$INCLUDE(LOC4.EXT)
$INCLUDE(LOC5.EXT)
$INCLUDE(LOC6.EXT)
$INCLUDE(LOC7.EXT)

$list
/* Externals */

DECLARE COPYRIGHT (*) BYTE DATA ('(C) 1976, 1977, 1979 INTEL CORP');
DECLARE VERSION (*) BYTE PUBLIC DATA ('V3.0');
DECLARE NULLREC (*) BYTE DATA (0,0,0);
DECLARE pageoutOffset ADDRESS DATA (0);
DECLARE pageoutOffset$b STRUCTURE (lobyt BYTE, hibyt BYTE) AT (.pageoutOffset);
DECLARE cachePageOffset ADDRESS DATA (0);
DECLARE cachePageOffset$b STRUCTURE (lobyt BYTE, hibyt BYTE) AT (.cachePageOffset);


DECLARE (readfd, outputfd, printfd, tmpfd, statusIO, actRead) ADDRESS PUBLIC,
	inFileName (16) BYTE PUBLIC, outFileName (16) BYTE PUBLIC,
	printFileName (16) BYTE PUBLIC, tmpFileName (16) BYTE PUBLIC,
	columns BYTE PUBLIC,
	seen(9) BYTE PUBLIC,	/* START, STACK, RESTART0, MAP, PUBLICS, SYMBOLS, LINES, PURGE, NAME */
	moduleName(32) BYTE PUBLIC,
	isMain BYTE PUBLIC,
	modhdr$x1 BYTE PUBLIC,
	modhdr$x2 BYTE PUBLIC,
	startAddr ADDRESS PUBLIC,
	segOrder(255) BYTE PUBLIC,
	segBases(256) ADDRESS PUBLIC,	/* abs, code, data */
	segSizes(256) ADDRESS PUBLIC,
	segFlags(256) BYTE PUBLIC,
	inRecord$p ADDRESS PUBLIC,
	erec$p ADDRESS PUBLIC,
	in$p ADDRESS PUBLIC,
	recNum ADDRESS PUBLIC,
	recLen ADDRESS PUBLIC,
	npbuf ADDRESS PUBLIC,
	sibuf$p ADDRESS PUBLIC,
	ibuf$p ADDRESS PUBLIC,
	eibuf$p ADDRESS PUBLIC,
	outRecord$p ADDRESS PUBLIC,
	out$p ADDRESS PUBLIC,
	eout$p ADDRESS PUBLIC,
	spbuf$p ADDRESS PUBLIC,
	pbuf$p ADDRESS PUBLIC,
	epbuf$p ADDRESS PUBLIC,
	topHeap ADDRESS PUBLIC,
	topDataFrags ADDRESS PUBLIC,
	curSegFrag$p ADDRESS PUBLIC,
	nextSegFrag$p ADDRESS PUBLIC,
	botHeap ADDRESS PUBLIC,
	curDataFrag$p ADDRESS PUBLIC,
	nextDataFrag$p ADDRESS PUBLIC,
	inFragment DATAFRAG$T PUBLIC,
	usePrintBuf BYTE PUBLIC,
	outRealFile BYTE PUBLIC,
	baseMemImage ADDRESS PUBLIC,
	havePagingFile BYTE PUBLIC,
	pageCacheSize BYTE PUBLIC,
	roundRobinIndex BYTE PUBLIC,
	nxtPageNo BYTE PUBLIC,
	pageIndexTmpFil BYTE PUBLIC,
	pageTab1$p ADDRESS PUBLIC,
	pageTab2$p ADDRESS PUBLIC;

DECLARE	crlf(2) BYTE PUBLIC INITIAL(0DH, 0AH),
	aRecordType(*) BYTE PUBLIC INITIAL(' RECORD TYPE XXH, RECORD NUMBER *****', 0Dh, 0Ah),
	(inBlk, inByt) ADDRESS PUBLIC INITIAL(0,0),
	inb$p ADDRESS PUBLIC,
	inCRC BYTE PUBLIC;

$INCLUDE(LOC.BAS)


conStrOut: PROCEDURE(buf, cnt) PUBLIC;
	DECLARE (buf, cnt) ADDRESS;
	CALL write(0, buf, cnt, .statusIO);
END conStrOut;


flushPrintBuf: PROCEDURE PUBLIC;
	IF usePrintBuf THEN	/* only process if buffered print */
	DO;
		CALL write(printfd, spbuf$p, pbuf$p - spbuf$p, .statusIO);
		CALL errChkReport(statusIO, .printFileName(1), TRUE);
	END;
	pbuf$p = spbuf$p;	/* rest buffer pointer */
END flushPrintBuf;


fatalErr: PROCEDURE(errCode) PUBLIC;
	DECLARE errCode BYTE;

	CALL flushPrintBuf;
	CALL conStrOut(.(' '), 1);
	CALL conStrOut(.inFileName(1), inFileName(0));
	CALL conStrOut(.(','), 1);
	CALL errmsg(errCode);
	CALL binasc(inRecord.rectyp, 16, '0', .aRecordType(13), 2);
	IF recNum > 0 THEN
		CALL binasc(recNum, 10, ' ', .aRecordType(32), 5);
	CALL conStrOut(.aRecordType, 39); 
	CALL exit;
END fatalErr;


illegalRecord: PROCEDURE PUBLIC;
	CALL fatalErr(ERR218);	/* Illegal Record Format */
END illegalRecord;


illegalReloc: PROCEDURE PUBLIC;
	CALL fatalErr(ERR212);	/* Illegal Relo Record */
END illegalReloc;


badRecordSeq: PROCEDURE PUBLIC;
	CALL fatalErr(ERR224);	/* Bad Record Sequence */
END badRecordSeq;


pstrcpy: PROCEDURE(psrc, pdst) PUBLIC;	/* copy pascal style string */
	DECLARE (psrc, pdst) ADDRESS;
	DECLARE src BASED psrc (1) BYTE;
	
	CALL mem$mov(src(0) + 1, psrc, pdst);
END pstrcpy;


printString: PROCEDURE(bufp, cnt) PUBLIC;
	DECLARE bufp ADDRESS;
	DECLARE cnt ADDRESS;
	DECLARE bcnt ADDRESS;

	IF usePrintBuf THEN	/* using buffer ? */
	DO;
		bcnt = epbuf$p - pbuf$p; 	/* space in buffer */
		DO WHILE cnt > bcnt;		/* not enough room for all chars */
			CALL mem$mov(bcnt, bufp, pbuf$p);	/* copy what we can */
			cnt = cnt - bcnt;	/* adjust what is left */
			bufp = bufp + bcnt;	/* advance position in the src string */
			pbuf$p = pbuf$p + bcnt;	/* and the print buffer position */
			CALL flushPrintBuf;	/* write the buffer */
			bcnt = npbuf;		/* reset to the buffer size */
		END;
		CALL mem$mov(cnt, bufp, pbuf$p); /* copy the remaining chars */
		pbuf$p = pbuf$p + cnt;		/* advance the print buf ptr */
	END;
	ELSE
	DO;	/* just use the operating system functions */
		CALL write(printfd, bufp, cnt, .statusIO);
		CALL errChkReport(statusIO, .printFileName(1), TRUE);
	END;
END printString;


printcrlf: PROCEDURE PUBLIC;
	CALL printString(.crlf, 2);
END printcrlf;


conAndPrint: PROCEDURE(buf, cnt) PUBLIC;
	DECLARE (buf, cnt) ADDRESS;
	CALL printString(buf, cnt);
	IF printfd > 0 THEN	/* make sure always seen on console */
		CALL conStrOut(buf, cnt);
END conAndPrint;


chkRead: PROCEDURE(cnt) PUBLIC;
	DECLARE cnt ADDRESS;
	DECLARE bcnt ADDRESS;

	IF (bcnt := eibuf$p - ibuf$p) < cnt THEN	/* data already in buffer */
	DO;
		CALL mem$mov(bcnt, ibuf$p, sibuf$p);	/* move down bytes in buffer */
		CALL read(readfd, sibuf$p + bcnt, npbuf - bcnt, .actRead, .statusIO);
		CALL errChkReport(statusIO, .inFileName(1), TRUE);
		inBlk = inBlk + (inByt + ibuf$p - sibuf$p) / 128;
		inByt = (inByt + ibuf$p - sibuf$p) MOD 128;
		IF (bcnt := bcnt + actRead) < cnt THEN
			CALL errChkReport(ERR204, .inFileName(1), TRUE);  /* Premature EOF */
		eibuf$p = (ibuf$p := sibuf$p) + bcnt;
	END;
END chkRead;

getRecord: PROCEDURE PUBLIC;
	DECLARE ch BASED inb$p BYTE;
	DECLARE bcnt ADDRESS;
	DECLARE erec BASED erec$p BYTE;

	IF (bcnt := eibuf$p - ibuf$p) >= 4 THEN
	DO;
		inRecord$p = ibuf$p;
		erec$p = inRecord$p + inRecord.reclen + 2;
	END;
	ELSE
	DO;
		inRecord$p = .NULLREC;	/* scratch area */
		erec$p = 0FFFFH;
	END;
	IF erec$p >= eibuf$p THEN
	DO;
		IF inRecord.reclen <= 1025 THEN
		DO;
			CALL chkRead(bcnt + 1);
			inRecord$p = ibuf$p;
			IF (erec$p := inRecord$p + inRecord.reclen + 2) >= eibuf$p THEN
				CALL errChkReport(ERR204, .inFileName(1), TRUE);	/* premature EOF */
		END;
	END;
	recLen = inRecord.reclen;
	in$p = inRecord$p + 3;
	ibuf$p = erec$p + 1;	/* update for next record */
	recNum = recNum + 1;
	IF inRecord.rectyp > R$COMDEF OR inRecord.rectyp THEN	/* > 2EH or odd */
		CALL illegalReloc;
	IF inRecord.rectyp = R$MODDAT THEN
		RETURN;
	IF recLen > 1025 THEN
		CALL fatalErr(ERR211);	/* Record too long */
	inCRC = 0;
	DO inb$p = inRecord$p TO .erec;
		inCRC = inCRC + ch;
	END;
	IF inCRC <> 0 THEN
		CALL fatalErr(ERR208);	/* checksum error */
END getRecord;


iseek: PROCEDURE(blk, byt) PUBLIC;
	DECLARE (blk, byt) ADDRESS;

	recNum = 0;		/* reset record number */
	IF  inBlk <= blk AND blk <= inBlk + (inByt + (eibuf$p - sibuf$p)) / 128 THEN
		IF (ibuf$p := sibuf$p + (blk - inBlk) * 128 + (byt - inByt)) >= sibuf$p
		    AND ibuf$p < eibuf$p THEN
			RETURN;
	CALL seek(readfd, SEEKABS, .blk, .byt, .statusIO);
	CALL errChkReport(statusIO, .inFileName(1), TRUE);
	ibufp = eibufp;
	CALL chkRead(1);	/* read the buffer */
	inBlk = blk;
	inByt = byt;
END iseek;



seekPagingFile: PROCEDURE(para) PUBLIC;
	DECLARE para BYTE;
	DECLARE blk ADDRESS;
	
	blk = DOUBLE(para) + DOUBLE(para);
	CALL seek(tmpfd, SEEKABS, .blk, .(0,0), .statusIO);
	CALL errChkReport(statusIO, .tmpFileName(1), TRUE);
END seekPagingFile;


pageout: PROCEDURE(page, bufp) PUBLIC;
	DECLARE page BYTE;
	DECLARE bufp ADDRESS;
	DECLARE pt ADDRESS, t BASED pt STRUCTURE (pageIdx BYTE, fileIdx BYTE);

	pt = .pageTab2(page);
	IF t.fileIdx = 0FFH THEN	/* not used */
	DO;
		t.fileIdx = pageIndexTmpFil;	/* record location in tmp file */
		pageIndexTmpFil = pageIndexTmpFil + 1;
	END;
	CALL seekPagingFile(t.fileIdx);
	CALL write(tmpfd, bufp, 256, .statusIO);	/* write the page out */
	CALL errChkReport(statusIO, .tmpFileName(1), TRUE);
	t.pageIdx = 0FEH;	/* flag as paged out */
END pageout;


anotherPage: PROCEDURE(page) PUBLIC;
	DECLARE page BYTE;
	DECLARE i BYTE;
	

	IF usePrintBuf THEN	/* use print buffer space */
	DO;
		CALL flushPrintBuf;	/* flush the buffer */
		usePrintBuf = FALSE;	/* no longer available */
		/* move the heap up */
		CALL mem$mov(topHeap - botHeap, botHeap, botHeap + npbuf);
		/* adjust the topheap and the start/cur print buf addresses */
		spbuf$p, pbuf$p, topheap = epbuf$p;
		/* adjust the descriptor pointers */
		topDataFrags = topDataFrags + npbuf;
		curSegFrag$p = curSegFrag$p + npbuf;
		curDataFrag$p = curDataFrag$p + npbuf;
		/* page allocated is first after the current max pageCacheSize */
		nxtPageNo = pageCacheSize + 1;
		/* increase the pageCacheSize available */
		pageCacheSize = HIGH((botHeap := botHeap + npbuf) - baseMemImage) - 1;
		RETURN;
	END;
	IF NOT havePagingFile THEN	/* have to page, create file if not done */
	DO;
		havePagingFile = TRUE;
		CALL delete(.tmpFileName(1), .statusIO);
		CALL open(.tmpfd, .tmpFileName(1), 3, FALSE, .statusIO);
		CALL errChkReport(statusIO, .tmpFileName(1), TRUE);
	END;

	pageTab1(page).state = 0FFH;	/* mark this page as now free */
	i = pageTab1(page).mpage;	/* get the current target page stored here */
	pageoutOffset$b.hibyt = page;
	CALL pageout(i, baseMemImage + pageoutOffset);
END anotherPage;


allocNewPage: PROCEDURE(page) ADDRESS PUBLIC;
	DECLARE page BYTE;

	DO nxtPageNo = 0 TO pageCacheSize;		/* see if free page */
		IF pageTab1(nxtPageNo).state THEN	/* one is free */
			GOTO found;
	END;
	IF roundRobinIndex > pageCacheSize THEN		/* manage roundRobin for paging to disk */
		roundRobinIndex = 0;
	nxtPageNo = roundRobinIndex;
	CALL anotherPage(roundRobinIndex);		/* get a page */
	IF nxtPageNo = roundRobinIndex  THEN	/* if the roundRobin page then we didn't get from printbuf reuse */
		roundRobinIndex = roundRobinIndex + 1;	/* so manage the roundRobin counter */
found:
	pageTab1(nxtPageNo).state = 0;	/* no longer free */
	pageTab1(nxtPageNo).mpage = page;	/* record the memory page located here */
	pageTab2(page).pageIdx = nxtPageNo;	/* save the mapping */
	cachePageOffset$b.hibyt = nxtPageNo;
	RETURN baseMemImage + cachePageOffset;		/* return the pointer in memory */
END allocNewPage;


/* convert a target address into its current location in cache */
addrInCache: PROCEDURE(addr) ADDRESS PUBLIC;
	DECLARE addr ADDRESS;
	DECLARE baddr ADDRESS;
	DECLARE (lobyt, hibyt) BYTE AT(.baddr);
	DECLARE pt ADDRESS;
	DECLARE t BASED pt STRUCTURE (pageIdx BYTE, fileIdx BYTE);

	pt = .pageTab2(HIGH(addr));
	IF t.pageIdx = 0FFH THEN	/* needs allocating */
		RETURN allocNewPage(HIGH(addr)) + LOW(addr);
	IF t.pageIdx = 0FEH THEN	/* on disk */
	DO;
		baddr = allocNewPage(HIGH(addr));	/* alloc page in cache */
		CALL seekPagingFile(t.fileIdx);		/* seek to its place in the paging file */
		CALL read(tmpfd, baddr, 256, .actRead, .StatusIO);	/* read in */
		CALL errChkReport(statusIO, .tmpFileName(1), TRUE);
		IF actRead <> 256 THEN			/* if problems and not :BB: out file then error */
			IF outRealFile THEN
				CALL errChkReport(ERR204, .tmpFileName(1), TRUE);    /* premature EOF */
		RETURN baddr + LOW(addr);		/* return the mapped address */
	END;
	hibyt = t.pageIdx;		/* page offset in cache */
	lobyt = LOW(addr);		/* offset in page */
	RETURN baseMemImage + baddr;	/* mapped address */
END addrInCache;


alloc: PROCEDURE(cnt) PUBLIC;
	DECLARE cnt ADDRESS;

	/* allocate but check whether we have crossed a page boundary */
	IF HIGH(botHeap - baseMemImage) <> HIGH((botHeap := botHeap - cnt) - baseMemImage) THEN
	DO;
		IF NOT pageTab1(pageCacheSize).state THEN	/* if current cache all used, try forcing using print buf */
			CALL anotherPage(PageCacheSize);	/* or paging the last page to disk */

		IF (pageCacheSize := HIGH(botHeap - baseMemImage) - 1) = 0FFH THEN	/* check we haven't eliminated all cache */
			CALL errChkReport(ERR210, .inFileName(1), TRUE);	/* Insufficient memory */
	END;
END alloc;


addSegFrag: PROCEDURE(flags, seg, start, len) PUBLIC;
	DECLARE (flags, seg) BYTE;
	DECLARE (start, len) ADDRESS;
	DECLARE curSegFrag BASED curSegFrag$p SEGFRAG$T;
	DECLARE nextSegFrag BASED nextSegFrag$p SEGFRAG$T;

	curSegFrag$p = topHeap;

	DO WHILE curSegFrag$p <> topDataFrags;
		curSegFrag$p = curSegFrag$p - size(curSegFrag);
		IF curSegFrag.start > start THEN
			IF start + len = curSegFrag.start AND curSegFrag.seg = seg THEN /* does the new frag join the curfrag */
			DO;	/* merge the blocks */
				curSegFrag.start = start;
				curSegFrag.len = curSegFrag.len + len;
				RETURN;
			END;
			ELSE
				GOTO break;
		ELSE IF curSegFrag.start + curSegFrag.len = start THEN	/* does the curFrag join the new frag */
			IF curSegFrag.seg = seg THEN			/* segs must be same */
			DO;
				curSegFrag.len = curSegFrag.len + len;	/* merge the lengths */
				IF curSegFrag$p <> topDataFrags THEN	/* if not at the end of list see if this joins the next one */
				DO;
					nextSegFrag$p = curSegFrag$p - size(nextSegFrag);
					IF nextSegFrag.start = curSegFrag.start + curSegFrag.len AND nextSegFrag.seg = curSegFrag.seg THEN
					DO;
						curSegFrag.len = curSegFrag.len + nextSegFrag.len;	/* join and delete extra frag */
						CALL mem$mov(nextSegFrag$p - botHeap, botHeap, botHeap + size(nextSegFrag));
						topDataFrags = topDataFrags + size(curSegFrag);
						botHeap = botHeap + size(curSegFrag);
					END;
				END;
				RETURN;
			END;
	END;
	curSegFrag$p = curSegFrag$p - size(curSegFrag);	/* will insert at end of list */
break:
	CALL alloc(6);	/* reserve space for the segFrag */
	topDataFrags = topDataFrags - size(curSegFrag);
	CALL mem$mov(curSegFrag$p - botHeap, botHeap + size(curSegFrag), botHeap);	/* create the space in the list */
	curSegFrag.flags = flags;	/* set all of the values */
	curSegFrag.seg = seg;
	curSegFrag.start = start;
	curSegFrag.len = len;
END addSegFrag;


addDataFrag: PROCEDURE(saddr, eaddr) PUBLIC;
	DECLARE saddr ADDRESS;
	DECLARE eaddr ADDRESS;
	DECLARE curDataFrag BASED curDataFrag$p DATAFRAG$T;
	DECLARE nextDataFrag BASED nextDataFrag$p DATAFRAG$T;

	curDataFrag$p = topDataFrags;
	DO WHILE curDataFrag$p <> botHeap;
		curDataFrag$p = curDataFrag$p - size(curDataFrag);
		IF curDataFrag.saddr > saddr THEN	/* the curfrag starts above this one */
		DO;
			IF eaddr >= curDataFrag.saddr - 1 THEN	/* does the new frag join or overlap the curent one */
			DO;
				curDataFrag.saddr = saddr;		/* update the start */
				IF eaddr > curDataFrag.eaddr THEN	/* it overlaps */
				DO;
					curDataFrag.eaddr = eaddr;	/* extend the existing */
					nextDataFrag$p = curDataFrag$p - size(curDataFrag);	/* check if more are overlapped */
					DO WHILE curDataFrag$p <> botHeap;
						IF eaddr + 1 < nextDataFrag.saddr THEN	/* no there is a gap all done */
							RETURN;
						IF eaddr + 1 = nextDataFrag.saddr THEN	/* joins so update the end address */
							curDataFrag.eaddr = nextDataFrag.eaddr;
						/* remove the other descriptor if either joined or was overlapped */
						CALL mem$mov(nextDataFrag$p - botHeap, botHeap, botHeap + size(curDataFrag));
						botHeap = botHeap + size(nextDataFrag);
					END;
				END;
				RETURN;
			END;
			ELSE	/* we have a new fragment */
			DO;
				CALL alloc(4);	/* alloc more space and insert descriptor above this one */
				CALL mem$mov(curDataFrag$p - botHeap, botHeap + size(curDataFrag), botHeap);
				curDataFrag.saddr = saddr;
				curDataFrag.eaddr = eaddr;
				RETURN;
			END;
		END;
		ELSE	/* check if candidate frag to join / overlap */
		DO;
			IF curDataFrag.saddr = saddr OR saddr - 1 <= curDataFrag.eaddr THEN
			DO;
				IF curDataFrag.eaddr >= eaddr THEN	/* already overlapped */
					RETURN;
				curDataFrag.eaddr = eaddr;		/* set new end address */
				nextDataFrag$p = curDataFrag$p - size(curDataFrag);	/* delete other join/overlapping frags */
				DO WHILE curDataFrag$p <> botHeap;
					IF nextDataFrag.saddr - 1 > eaddr THEN
						RETURN;
					IF nextDataFrag.saddr - 1 = eaddr THEN
						curDataFrag.eaddr = nextDataFrag.eaddr;
					CALL mem$mov(nextDataFrag$p - botHeap, botHeap, botHeap + size(curDataFrag));
					botHeap = botHeap + size(curDataFrag);
				END;
				RETURN;
			END;
		END;	/* IF ELSE */
	END;	/* DO WHILE */

	CALL alloc(4);
	curDataFrag$p = botHeap;	/* allocated at new botHeap */
	curDataFrag.saddr = saddr;	/* record the start and end address */
	curDataFrag.eaddr = eaddr;
END addDataFrag;


loadMODDAT: PROCEDURE(segId) PUBLIC;
	DECLARE segId BYTE;
	DECLARE rdata BASED in$p (1) BYTE;
	DECLARE (dataLen, bytes2Read, curLoadAddr) ADDRESS;
	DECLARE curLoadPage BYTE;

	DECLARE ch BASED inb$p BYTE;

	dataLen = recLen - 4;
	inCRC = HIGH(recLen) + 6 + LOW(recLen) + rdata(0) + rdata(1) + rdata(2);
	ibuf$p = ibuf$p + 3;
	IF LOW(curLoadAddr := inFragment.saddr) <> 0 THEN
	DO;
		IF HIGH(curLoadAddr + (bytes2Read := dataLen) - 1) <> HIGH(curLoadAddr) THEN
			bytes2Read = 256 - LOW(curLoadAddr);	/* don't go over page boundary */
		CALL chkRead(bytes2Read);			/* make sure data is in the buffer */
		DO inb$p = ibuf$p TO ibuf$p + bytes2Read - 1;	/* add the data to the crc */
			inCRC = inCRC + ch;
		END;
		CALL mem$mov(bytes2Read, ibuf$p, addrInCache(curLoadAddr));	/* copy to the pagecache location */
		dataLen = dataLen - bytes2Read;			/* adjust bytes read */
		curLoadAddr = curLoadAddr + bytes2Read;
		ibuf$p = ibuf$p + bytes2Read;
	END;
	DO WHILE dataLen >= 256;				/* read in whole pages */
		CALL chkRead(256);				/* make sure data in buffer */
		DO inb$p = ibuf$p TO ibuf$p + 255;		/* add to crc */
			inCRC = inCRC + ch;
		END;
		IF segId = SABS AND havePagingFile THEN		/* if abs and paging write it out to paging file */
								/* there is no fixup involved */
		DO;
			/* if a page cache entry exists then this would be trashed anyway so free up */
			IF pageTab2(curLoadPage := HIGH(curLoadAddr)).pageIdx <= 0FDH THEN
				pageTab1(pageTab2(curLoadPage).pageIdx).state = 0FFH;
			CALL pageout(curLoadPage, ibuf$p);
		END;
		ELSE						/* copy to the page cache */
			CALL mem$mov(256, ibuf$p, addrInCache(curLoadAddr));

		dataLen = dataLen - 256;			/* adjust and continue */
		curLoadAddr = curLoadAddr + 256;
		ibuf$p = ibuf$p + 256;
	END;
	IF dataLen > 0 THEN					/* load an remaining into the page cache */
	DO;
		CALL chkRead(dataLen);
		DO inb$p = ibuf$p TO ibuf$p + dataLen - 1;
			inCRC = inCRC + ch;
		END;
		CALL mem$mov(dataLen, ibuf$p, addrInCache(curLoadAddr));
		ibuf$p = ibuf$p + dataLen;
	END;
	CALL chkRead(1);
	ibuf$p = (inb$p := ibuf$p) + 1;
	IF inCRC + ch <> 0 THEN					/* sanity check */
		CALL fatalErr(ERR208);	/* Checksum error */
END loadMODDAT;

main:
	baseMemImage, pageTab2$p = .controls;	/* once we have processed args overwrite area */
	CALL procArgs$Init;
	CALL locateFile;
	CALL flushPrintBuf;
	CALL close(printfd, .statusIO);
	CALL exit;

END;
