isissub:
DO;
DECLARE LIT LITERALLY 'LITERALLY',
	IOPEN LIT	'0',
	ICLOSE LIT	'1',
	IDELETE LIT	'2',
	IREAD LIT	'3',
	IWRITE LIT	'4',
	ISEEK LIT	'5',
	ILOAD LIT	'6',
	IRENAME LIT	'7',
	ICONSOL LIT	'8',
	IEXIT LIT	'9',	
	IATTRIB LIT	'10',
	IRESCAN LIT	'11',
	IERROR LIT	'12',
	IWHOCON LIT	'13',
	ISPATH LIT	'14';


isis: procedure (rectyp, parameter$ptr) external;
    declare rectyp byte,
            parameter$ptr address;
end isis;

close: procedure (conn, status$p) public;
    declare (conn, status$p) address;
    CALL ISIS(ICLOSE, .conn);
end close;

delete: procedure (path$p, status$p) public;
    declare (path$p, status$p) address;
    CALL ISIS(IDELETE, .path$p);
end delete;

error: procedure (error$num) public;
    declare (error$num) address;
    declare err address;
    err = .err;
    CALL ISIS(IERROR, .error$num);
end error;

exit: procedure public;
	DECLARE exitarg ADDRESS;
	exitarg = .exitarg;
	CALL ISIS(IEXIT, .exitarg);
end exit;


open: procedure (conn$p, path$p, access, echo, status$p) public;
    declare (conn$p, path$p, access, echo, status$p) address;
    CALL ISIS(IOPEN, .conn$p);
end open;


read: procedure (conn, buff$p, count, actual$p, status$p) public;
    declare (conn, buff$p, count, actual$p, status$p) address;
    CALL ISIS(IREAD, .conn);
end read;

seek: procedure (conn, mode, block$p, byte$p, status$p) public;
    declare (conn, mode, block$p, byte$p, status$p) address;
    CALL ISIS(ISEEK, .conn);
end seek;

write: procedure (conn, buff$p, count, status$p) public;
    declare (conn, buff$p, count, status$p) address;
    CALL ISIS(IWRITE, .conn);
end write;



END;
