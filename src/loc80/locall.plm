ISIS.EXT
close: procedure (conn, status$p) external;
    declare (conn, status$p) address;
end close;

delete: procedure (path$p, status$p) external;
    declare (path$p, status$p) address;
end delete;

error: procedure (error$num) external;
    declare (error$num) address;
end error;

exit: procedure external;
end exit;

open: procedure (conn$p, path$p, access, echo, status$p) external;
    declare (conn$p, path$p, access, echo, status$p) address;
end open;

read: procedure (conn, buff$p, count, actual$p, status$p) external;
    declare (conn, buff$p, count, actual$p, status$p) address;
end read;

seek: procedure (conn, mode, block$p, byte$p, status$p) external;
    declare (conn, mode, block$p, byte$p, status$p) address;
end seek;

write: procedure (conn, buff$p, count, status$p) external;
    declare (conn, buff$p, count, status$p) address;
end write;



rescan: procedure (conn, status$p) external;
    declare (conn, status$p) address;
end rescan;

spath: procedure (path$p, info$p, status$p) external;
    declare (path$p, info$p, status$p) address;
end spath;





memck: procedure address external;
end memck;

$list
isis.plm
isissub:
DO;
DECLARE LIT LITERALLY 'LITERALLY',
	IOPEN LIT	'0',
	ICLOSE LIT	'1',
	IDELETE LIT	'2',
	IREAD LIT	'3',
	IWRITE LIT	'4',
	ISEEK LIT	'5',
	ILOAD LIT	'6',
	IRENAME LIT	'7',
	ICONSOL LIT	'8',
	IEXIT LIT	'9',	
	IATTRIB LIT	'10',
	IRESCAN LIT	'11',
	IERROR LIT	'12',
	IWHOCON LIT	'13',
	ISPATH LIT	'14';

isis: procedure (type, parameter$ptr) external;
    declare type byte,
            parameter$ptr address;
end isis;

close: procedure (conn, status$p) public;
    declare (conn, status$p) address;
    CALL ISIS(ICLOSE, .conn);
end close;

delete: procedure (path$p, status$p) public;
    declare (path$p, status$p) address;
    CALL ISIS(IDELETE, .path$p);
end delete;

error: procedure (error$num) public;
    declare (error$num) address;
    declare err address;
    err = .err;
    CALL ISIS(IERROR, .error$num);
end error;

exit: procedure public;
	DECLARE exitarg ADDRESS;
	exitarg = .exitarg;
	CALL ISIS(IEXIT, .exitarg);
end exit;


open: procedure (conn$p, path$p, access, echo, status$p) public;
    declare (conn$p, path$p, access, echo, status$p) address;
    CALL ISIS(IOPEN, .conn$p);
end open;


read: procedure (conn, buff$p, count, actual$p, status$p) public;
    declare (conn, buff$p, count, actual$p, status$p) address;
    CALL ISIS(IREAD, .conn);
end read;

seek: procedure (conn, mode, block$p, byte$p, status$p) public;
    declare (conn, mode, block$p, byte$p, status$p) address;
    CALL ISIS(ISEEK, .conn);
end seek;

write: procedure (conn, buff$p, count, status$p) public;
    declare (conn, buff$p, count, status$p) address;
    CALL ISIS(IWRITE, .conn);
end write;



END;
loc.bas
DECLARE	cmdch BASED cmd$p BYTE;
DECLARE	cmdbuf BASED cmd$p (1) BYTE;
DECLARE	pageTab1 BASED pageTab1$p (1) STRUCTURE (state BYTE, mpage BYTE);
DECLARE	pageTab2 BASED pageTab2$p (1) STRUCTURE (state BYTE, fpage BYTE);
DECLARE	srec BASED srec$p STRUCTURE (type BYTE, len ADDRESS, rec(1) BYTE);
DECLARE	sout BASED sout$p STRUCTURE (type BYTE, len ADDRESS, rec(1) BYTE);
DECLARE	modendRec BASED rec$p STRUCTURE (subtype BYTE, segtype BYTE, addr ADDRESS);
DECLARE	modendOut BASED out$p STRUCTURE (subtype BYTE, segtype BYTE, addr ADDRESS);
DECLARE	moddatRec BASED rec$p STRUCTURE (seg BYTE, addr ADDRESS, bytes(1) BYTE);
DECLARE	moddatOut BASED out$p STRUCTURE (seg BYTE, addr ADDRESS, bytes(1) BYTE);
DECLARE	linnumARec BASED rec$p STRUCTURE (seg BYTE);
DECLARE	linnumBRec BASED rec$p STRUCTURE (addr ADDRESS, line ADDRESS);
DECLARE	linnumAOut BASED out$p STRUCTURE (seg BYTE);
DECLARE	linnumBOut BASED out$p STRUCTURE (addr ADDRESS, line ADDRESS);
DECLARE defsARec BASED rec$p STRUCTURE (seg BYTE);
DECLARE defsBRec BASED rec$p STRUCTURE (offset ADDRESS, name(1) BYTE /*, 0 */);
DECLARE defsAOut BASED out$p STRUCTURE (seg BYTE);
DECLARE defsBOut BASED out$p STRUCTURE (offset ADDRESS, name(1) BYTE /*, 0 */);
DECLARE extnamRec BASED rec$p STRUCTURE (name(1) BYTE /*, 0 */);
DECLARE extnamOut BASED out$p STRUCTURE (name(1) BYTE /*, 0 */);
DECLARE	fixextARec BASED rec$p STRUCTURE (fixType BYTE);
DECLARE	fixextAOut BASED out$p STRUCTURE (fixType BYTE);
DECLARE	fixextBRec BASED rec$p STRUCTURE (sym ADDRESS, addr ADDRESS);
DECLARE	fixextBOut BASED out$p STRUCTURE (sym ADDRESS, addr ADDRESS);
DECLARE	fixlocARec BASED rec$p STRUCTURE (fixType BYTE);
DECLARE	fixlocBRec BASED rec$p STRUCTURE (addr ADDRESS);
DECLARE	fixsegARec BASED rec$p STRUCTURE (seg BYTE);
DECLARE	comdefRec BASED rec$p STRUCTURE (seg BYTE, name(1) BYTE);
loc.lit
DECLARE	LIT LITERALLY 'LITERALLY';
DECLARE	SPATH$T LIT 'STRUCTURE (deviceId BYTE, name(6) BYTE, ext(3) BYTE, deviceType BYTE, driveType BYTE)',
        DESC4$T LIT 'STRUCTURE (saddr ADDRESS, eaddr ADDRESS)',
	DESC6$T LIT 'STRUCTURE (flags BYTE, seg BYTE, start ADDRESS, len ADDRESS)';
DECLARE	ERR2 LIT '2', /* ILLEGAL AFTN ARGUMENT */
	ERR3 LIT '3', /* TOO MANY OPEN FILES */
	ERR4 LIT '4', /* INCORRECTLY SPECIFIED FILE */
	ERR5 LIT '5', /* UNRECOGNIZED DEVICE NAME */
	ERR9 LIT '9', /* DISK DIRECTORY FULL */
	ERR12 LIT '12', /* FILE IS ALREADY OPEN */
	ERR13 LIT '13', /* NO SUCH FILE */
	ERR14 LIT '14', /* WRITE PROTECTED */
	ERR17 LIT '17', /* NOT A DISK FILE */
	ERR19 LIT '19', /* ATTEMPTED SEEK ON NON-DISK FILE */
	ERR20 LIT '20', /* ATTEMPTED BACK SEEK TOO FAR */
	ERR21 LIT '21', /* CAN'T RESCAN */
	ERR22 LIT '22', /* ILLEGAL ACCESS MODE TO OPEN */
	ERR23 LIT '23', /* MISSING FILENAME */
	ERR27 LIT '27', /* ILLEGAL SEEK COMMAND */
	ERR28 LIT '28', /* MISSING EXTENSION */
	ERR31 LIT '31', /* CAN'T SEEK ON WRITE ONLY FILE */
	ERR32 LIT '32', /* CAN'T DELETE OPEN FILE */
	ERR35 LIT '35', /* SEEK PAST EOF */
	ERR203 LIT '203', /* INVALID SYNTAX */
	ERR204 LIT '204', /* PREMATURE EOF */
	ERR208 LIT '208', /* CHECKSUM ERROR */
	ERR210 LIT '210', /* INSUFFICIENT MEMORY */
	ERR211 LIT '211', /* RECORD TOO LONG */
	ERR212 LIT '212', /* ILLEGAL RELO RECORD */
	ERR213 LIT '213', /* FIXUP BOUNDS ERROR */
	ERR218 LIT '218', /* ILLEGAL RECORD FORMAT */
	ERR224 LIT '224', /* BAD RECORD SEQUENCE */
	ERR225 LIT '225', /* INVALID NAME */
	ERR226 LIT '226', /* NAME TOO LONG */
	ERR227 LIT '227', /* LEFT PARENTHESIS EXPECTED */
	ERR228 LIT '228', /* RIGHT PARENTHESIS EXPECTED */
	ERR229 LIT '229', /* UNRECOGNIZED CONTROL */
	ERR233 LIT '233', /* 'TO' EXPECTED */
	ERR237 LIT '237', /* COMMON NOT FOUND */
	ERR238 LIT '238', /* ILLEGAL STACK CONTENT RECORD */
	ERR239 LIT '239', /* NO MODULE HEADER RECORD */
	ERR240 LIT '240'; /* PROGRAM EXCEEDS 64K */

DECLARE	R$MODHDR	LIT	'2',
	R$MODEND	LIT	'4',
	R$MODDAT	LIT	'6',
	R$LINNUM	LIT	'8',
	R$MODEOF	LIT	'0EH',
	R$ANCEST	LIT	'10H',
	R$LOCDEF	LIT	'12H',
	R$PUBDEF	LIT	'16H',
	R$EXTNAM	LIT	'18H',
	R$FIXEXT	LIT	'20H',
	R$FIXLOC	LIT	'22H',
	R$FIXSEG	LIT	'24H',
	R$LIBLOC	LIT	'26H',
	R$LIBNAM	LIT	'28H',
	R$LIBDIC	LIT	'2AH',
	R$LIBHDR	LIT	'2CH',
	R$COMDEF	LIT	'2EH';

DECLARE	SABS	LIT	'0',
	SCODE	LIT	'1',
	SDATA	LIT	'2',
	SSTACK	LIT	'3',
	SMEMORY	LIT	'4',
	SRESERVED LIT	'5',
	SNAMED	LIT	'6',
	SBLANK	LIT	'255';

DECLARE	startSeen LIT 'seen(0)',
	stackSizeSet LIT 'seen(1)',
	restart0Seen LIT 'seen(2)',
	MapSeen LIT 'seen(3)',
	PublicsSeen LIT 'seen(4)',
	SymbolsSeen LIT 'seen(5)',
	LinesSeen LIT 'seen(6)',
	PurgeSeen LIT 'seen(7)',
	nameArgSeen LIT 'seen(8)';

mem$mov: PROCEDURE(cnt, src, dst) EXTERNAL;
	DECLARE cnt ADDRESS, src ADDRESS, dst ADDRESS;
END mem$mov;	
loc1.ext
DECLARE	VERSION (1) BYTE EXTERNAL ;
DECLARE	(readfd, outputfd, printfd, tmpfd, statusIO, actRead) ADDRESS EXTERNAL,
	inFileName (16) BYTE EXTERNAL, outFileName (16) BYTE EXTERNAL,
	printFileName (16) BYTE EXTERNAL, tmpFileName (16) BYTE EXTERNAL,
	columns BYTE EXTERNAL,
	seen(9) BYTE EXTERNAL,	/* START, STACK, RESTART0, MAP, PUBLICS, SYMBOLS, LINES, PURGE, NAME */
	nameArg(32) BYTE EXTERNAL,
	type4SubType BYTE EXTERNAL,
	modhdr$x1 BYTE EXTERNAL,
	modhdr$x2 BYTE EXTERNAL,
	startAddr ADDRESS EXTERNAL,
	segOrder(255) BYTE EXTERNAL,
	segBases (3) ADDRESS EXTERNAL,	/* abs, code, data */
	stackAddr ADDRESS EXTERNAL,
	MemoryBase(252) ADDRESS EXTERNAL,
	segSizes(3) ADDRESS EXTERNAL,
	stackSize ADDRESS EXTERNAL,
	MemorySize(252) ADDRESS EXTERNAL,
	segFlags(256) BYTE EXTERNAL,
	srec$p ADDRESS EXTERNAL,
	erec$p ADDRESS EXTERNAL,
	rec$p ADDRESS EXTERNAL,
	recNum ADDRESS EXTERNAL,
	recLen ADDRESS EXTERNAL,
	npbuf ADDRESS EXTERNAL,
	sibuf$p ADDRESS EXTERNAL,
	ibuf$p ADDRESS EXTERNAL,
	eibuf$p ADDRESS EXTERNAL,
	sout$p ADDRESS EXTERNAL,
	out$p ADDRESS EXTERNAL,
	eout$p ADDRESS EXTERNAL,
	spbuf$p ADDRESS EXTERNAL,
	pbuf$p ADDRESS EXTERNAL,
	epbuf$p ADDRESS EXTERNAL,
	topHeap ADDRESS EXTERNAL,
	topDescriptor ADDRESS EXTERNAL,
	curDescriptor62F ADDRESS EXTERNAL,
	desc6a$p ADDRESS EXTERNAL,
	botHeap ADDRESS EXTERNAL,
	curDescriptor ADDRESS EXTERNAL,
	desc4a$p ADDRESS EXTERNAL,
	t6desc4 DESC4$T EXTERNAL,
	usePrintBuf BYTE EXTERNAL,
	isNotBB BYTE EXTERNAL,
	baseMemImage ADDRESS EXTERNAL,
	havePagingFile BYTE EXTERNAL,
	pageCacheSize BYTE EXTERNAL,
	roundRobinIndex BYTE EXTERNAL,
	nxtPageNo BYTE EXTERNAL,
	pageIndexTmpFil BYTE EXTERNAL,
	pageTab1$p ADDRESS EXTERNAL,
	pageTab2$p ADDRESS EXTERNAL;
DECLARE	crlf(2) BYTE EXTERNAL,
	aRecordType(1) BYTE EXTERNAL,
	(inBlk, inByt) ADDRESS EXTERNAL,
	inb$p ADDRESS EXTERNAL,
	inCRC BYTE EXTERNAL;

conStrOut: PROCEDURE(buf, cnt) EXTERNAL;
	DECLARE (buf, cnt) ADDRESS;
END conStrOut;

fatalErr: PROCEDURE(errCode) EXTERNAL;
	DECLARE errCode BYTE;
END fatalErr;

illegalRecord: PROCEDURE EXTERNAL;
END illegalRecord;

illegalReloc: PROCEDURE EXTERNAL;
END illegalReloc;

badRecordSeq: PROCEDURE EXTERNAL;
END badRecordSeq;

pstrcpy: PROCEDURE(psrc, pdst) EXTERNAL;
	DECLARE (psrc, pdst) ADDRESS;
END pstrcpy;

printString: PROCEDURE(bufp, cnt) EXTERNAL;
	DECLARE bufp ADDRESS;
	DECLARE cnt ADDRESS;
END printString;

printcrlf: PROCEDURE EXTERNAL;
END printcrlf;

conAndPrint: PROCEDURE(buf, cnt) EXTERNAL;
	DECLARE (buf, cnt) ADDRESS;
END conAndPrint;

chkRead: PROCEDURE(cnt) EXTERNAL;
	DECLARE cnt ADDRESS;
END chkRead;

getRecord: PROCEDURE EXTERNAL;
END getRecord;

iseek: PROCEDURE(blk, byt) EXTERNAL;
	DECLARE (blk, byt) ADDRESS;
END iseek;


RAddr2LAddr: PROCEDURE(addr) ADDRESS EXTERNAL;
	DECLARE addr ADDRESS;
END RAddr2LAddr;


insert6Desc: PROCEDURE(flags, seg, start, len) EXTERNAL;
	DECLARE (flags, seg) BYTE;
	DECLARE (start, len) ADDRESS;
END insert6Desc;

insert4Desc: PROCEDURE(arg1w, arg2w) EXTERNAL;
	DECLARE arg1w ADDRESS;
	DECLARE arg2w ADDRESS;
END insert4Desc;

loadMODDAT: PROCEDURE(arg1b) EXTERNAL;
	DECLARE arg1b BYTE;
END loadMODDAT;

loc1.plm
$LIST
$CODE
LOCATE:
DO;
$INCLUDE(ISIS.EXT)
$INCLUDE(LOC.LIT)
$INCLUDE(LOC2A.EXT)
$INCLUDE(LOC3.EXT)
$INCLUDE(LOC4.EXT)
$INCLUDE(LOC5.EXT)
$INCLUDE(LOC6.EXT)
$INCLUDE(LOC7.EXT)

$list
/* Externals */

DECLARE COPYRIGHT (*) BYTE DATA ('(C) 1976, 1977, 1979 INTEL CORP');
DECLARE VERSION (*) BYTE PUBLIC DATA ('V3.0');
DECLARE NULLREC (*) BYTE DATA (0,0,0);
DECLARE addr1 ADDRESS DATA (0);
DECLARE addr1byts STRUCTURE (lobyt BYTE, hibyt BYTE) AT (.addr1);
DECLARE addr0 ADDRESS DATA (0);
DECLARE addr0byts STRUCTURE (lobyt BYTE, hibyt BYTE) AT (.addr0);


DECLARE (readfd, outputfd, printfd, tmpfd, statusIO, actRead) ADDRESS PUBLIC,
	inFileName (16) BYTE PUBLIC, outFileName (16) BYTE PUBLIC,
	printFileName (16) BYTE PUBLIC, tmpFileName (16) BYTE PUBLIC,
	columns BYTE PUBLIC,
	seen(9) BYTE PUBLIC,	/* START, STACK, RESTART0, MAP, PUBLICS, SYMBOLS, LINES, PURGE, NAME */
	nameArg(32) BYTE PUBLIC,
	type4SubType BYTE PUBLIC,
	modhdr$x1 BYTE PUBLIC,
	modhdr$x2 BYTE PUBLIC,
	startAddr ADDRESS PUBLIC,
	segOrder(255) BYTE PUBLIC,
	segBases (3) ADDRESS PUBLIC,	/* abs, code, data */
	stackAddr ADDRESS PUBLIC,
	MemoryBase(252) ADDRESS PUBLIC,
	segSizes(3) ADDRESS PUBLIC,
	stackSize ADDRESS PUBLIC,
	MemorySize(252) ADDRESS PUBLIC,
	segFlags(256) BYTE PUBLIC,
	srec$p ADDRESS PUBLIC,
	erec$p ADDRESS PUBLIC,
	rec$p ADDRESS PUBLIC,
	recNum ADDRESS PUBLIC,
	recLen ADDRESS PUBLIC,
	npbuf ADDRESS PUBLIC,
	sibuf$p ADDRESS PUBLIC,
	ibuf$p ADDRESS PUBLIC,
	eibuf$p ADDRESS PUBLIC,
	sout$p ADDRESS PUBLIC,
	out$p ADDRESS PUBLIC,
	eout$p ADDRESS PUBLIC,
	spbuf$p ADDRESS PUBLIC,
	pbuf$p ADDRESS PUBLIC,
	epbuf$p ADDRESS PUBLIC,
	topHeap ADDRESS PUBLIC,
	topDescriptor ADDRESS PUBLIC,
	curDescriptor62F ADDRESS PUBLIC,
	desc6a$p ADDRESS PUBLIC,
	botHeap ADDRESS PUBLIC,
	curDescriptor ADDRESS PUBLIC,
	desc4a$p ADDRESS PUBLIC,
	t6desc4 DESC4$T PUBLIC,
	usePrintBuf BYTE PUBLIC,
	isNotBB BYTE PUBLIC,
	baseMemImage ADDRESS PUBLIC,
	havePagingFile BYTE PUBLIC,
	pageCacheSize BYTE PUBLIC,
	roundRobinIndex BYTE PUBLIC,
	nxtPageNo BYTE PUBLIC,
	pageIndexTmpFil BYTE PUBLIC,
	pageTab1$p ADDRESS PUBLIC,
	pageTab2$p ADDRESS PUBLIC;

DECLARE	crlf(2) BYTE PUBLIC INITIAL(0DH, 0AH),
	aRecordType(*) BYTE PUBLIC INITIAL(' RECORD TYPE XXH, RECORD NUMBER *****', 0Dh, 0Ah),
	(inBlk, inByt) ADDRESS PUBLIC INITIAL(0,0),
	inb$p ADDRESS PUBLIC,
	inCRC BYTE PUBLIC;

$INCLUDE(LOC.BAS)

/* seek modes
	0-> current pos in blk/byte format
	1-> -ve
	2-> abs
	3-> +ve
	4-> to end
*/




conStrOut: PROCEDURE(buf, cnt) PUBLIC;
	DECLARE (buf, cnt) ADDRESS;
	CALL write(0, buf, cnt, .statusIO);
END conStrOut;


writePrintBuf: PROCEDURE PUBLIC;
	IF usePrintBuf THEN	/* only process if buffered print */
	DO;
		CALL write(printfd, spbuf$p, pbuf$p - spbuf$p, .statusIO);
		CALL errChkReport(statusIO, .printFileName(1), 0FFH);
	END;
	pbuf$p = spbuf$p;	/* rest buffer pointer */
END writePrintBuf;


fatalErr: PROCEDURE(errCode) PUBLIC;
	DECLARE errCode BYTE;

	CALL writePrintBuf;
	CALL conStrOut(.(' '), 1);
	CALL conStrOut(.inFileName(1), inFileName(0));
	CALL conStrOut(.(','), 1);
	CALL errmsg(errCode);
	CALL binasc(srec.type, 16, '0', .aRecordType(13), 2);
	IF recNum > 0 THEN
		CALL binasc(recNum, 10, ' ', .aRecordType(32), 5);
	CALL conStrOut(.aRecordType, 39); 
	CALL exit;
END fatalErr;


illegalRecord: PROCEDURE PUBLIC;
	CALL fatalErr(ERR218);	/* Illegal Record Format */
END illegalRecord;


illegalReloc: PROCEDURE PUBLIC;
	CALL fatalErr(ERR212);	/* Illegal Relo Record */
END illegalReloc;


badRecordSeq: PROCEDURE PUBLIC;
	CALL fatalErr(ERR224);	/* Bad Record Sequence */
END badRecordSeq;


pstrcpy: PROCEDURE(psrc, pdst) PUBLIC;
	DECLARE (psrc, pdst) ADDRESS;
	DECLARE src BASED psrc (1) BYTE;
	
	CALL mem$mov(src(0) + 1, psrc, pdst);
END pstrcpy;


printString: PROCEDURE(bufp, cnt) PUBLIC;
	DECLARE bufp ADDRESS;
	DECLARE cnt ADDRESS;
	DECLARE bcnt ADDRESS;

	IF usePrintBuf THEN
	DO;
		bcnt = epbuf$p - pbuf$p; 
		DO WHILE cnt > bcnt;
			CALL mem$mov(bcnt, bufp, pbuf$p);
			cnt = cnt - bcnt;
			bufp = bufp + bcnt;
			pbuf$p = pbuf$p + bcnt;
			CALL writePrintBuf;
			bcnt = npbuf;
		END;
		CALL mem$mov(cnt, bufp, pbuf$p);
		pbuf$p = pbuf$p + cnt;
	END;
	ELSE
	DO;
		CALL write(printfd, bufp, cnt, .statusIO);
		CALL errChkReport(statusIO, .printFileName(1), 0FFH);
	END;
END printString;


printcrlf: PROCEDURE PUBLIC;
	CALL printString(.crlf, 2);
END printcrlf;


conAndPrint: PROCEDURE(buf, cnt) PUBLIC;
	DECLARE (buf, cnt) ADDRESS;
	CALL printString(buf, cnt);
	IF printfd > 0 THEN	/* make sure always seen on console */
		CALL conStrOut(buf, cnt);
END conAndPrint;


chkRead: PROCEDURE(cnt) PUBLIC;
	DECLARE cnt ADDRESS;
	DECLARE bcnt ADDRESS;

	IF (bcnt := eibuf$p - ibuf$p) < cnt THEN	/* data already in buffer */
	DO;
		CALL mem$mov(bcnt, ibuf$p, sibuf$p);	/* move down bytes in buffer */
		CALL read(readfd, sibuf$p + bcnt, npbuf - bcnt, .actRead, .statusIO);
		CALL errChkReport(statusIO, .inFileName(1), 0FFH);
		inBlk = inBlk + (inByt + ibuf$p - sibuf$p) / 128;
		inByt = (inByt + ibuf$p - sibuf$p) MOD 128;
		IF (bcnt := bcnt + actRead) < cnt THEN
			CALL errChkReport(ERR204, .inFileName(1), 0FFH);  /* Premature EOF */
		eibuf$p = (ibuf$p := sibuf$p) + bcnt;
	END;
END chkRead;

getRecord: PROCEDURE PUBLIC;
	DECLARE ch BASED inb$p BYTE;
	DECLARE bcnt ADDRESS;
	DECLARE erec BASED erec$p BYTE;

	IF (bcnt := eibuf$p - ibuf$p) >= 4 THEN
	DO;
		srec$p = ibuf$p;
		erec$p = srec$p + srec.len + 2;
	END;
	ELSE
	DO;
		srec$p = .NULLREC;	/* scratch area */
		erec$p = 0FFFFH;
	END;
	IF erec$p >= eibuf$p THEN
	DO;
		IF srec.len <= 1025 THEN
		DO;
			CALL chkRead(bcnt + 1);
			srec$p = ibuf$p;
			IF (erec$p := srec$p + srec.len + 2) >= eibuf$p THEN
				CALL errChkReport(ERR204, .inFileName(1), 0FFH);	/* premature EOF */
		END;
	END;
	recLen = srec.len;
	rec$p = srec$p + 3;
	ibuf$p = erec$p + 1;	/* update for next record */
	recNum = recNum + 1;
	IF srec.type > R$COMDEF OR srec.type THEN	/* > 2EH or odd */
		CALL illegalReloc;
	IF srec.type = R$MODDAT THEN
		RETURN;
	IF recLen > 1025 THEN
		CALL fatalErr(ERR211);	/* Record too long */
	inCRC = 0;
	DO inb$p = srec$p TO .erec;
		inCRC = inCRC + ch;
	END;
	IF inCRC <> 0 THEN
		CALL fatalErr(ERR208);	/* checksum error */
END getRecord;


iseek: PROCEDURE(blk, byt) PUBLIC;
	DECLARE (blk, byt) ADDRESS;

	recNum = 0;		/* reset record number */
	IF  inBlk <= blk AND blk <= inBlk + (inByt + (eibuf$p - sibuf$p)) / 128 THEN
		IF (ibuf$p := sibuf$p + (blk - inBlk) * 128 + (byt - inByt)) >= sibuf$p
		    AND ibuf$p < eibuf$p THEN
			RETURN;
	CALL seek(readfd, 2, .blk, .byt, .statusIO);
	CALL errChkReport(statusIO, .inFileName(1), 0FFH);
	ibufp = eibufp;
	CALL chkRead(1);	/* read the buffer */
	inBlk = blk;
	inByt = byt;
END iseek;



seekPageTmpFile: PROCEDURE(para) PUBLIC;
	DECLARE para BYTE;
	DECLARE blk ADDRESS;
	
	blk = DOUBLE(para) + DOUBLE(para);
	CALL seek(tmpfd, 2, .blk, .(0,0), .statusIO);
	CALL errChkReport(statusIO, .tmpFileName(1), 0FFH);
END seekPageTmpFile;


pageout: PROCEDURE(page, bufp) PUBLIC;
	DECLARE page BYTE;
	DECLARE bufp ADDRESS;
	DECLARE pt ADDRESS, t BASED pt STRUCTURE (state BYTE, fpage BYTE);

	pt = .pageTab2(page);
	IF t.fpage = 0FFH THEN
	DO;
		t.fpage = pageIndexTmpFil;	/* record location in tmp file */
		pageIndexTmpFil = pageIndexTmpFil + 1;
	END;
	CALL seekPageTmpFile(t.fpage);
	CALL write(tmpfd, bufp, 256, .statusIO);	/* write the page out */
	CALL errChkReport(statusIO, .tmpFileName(1), 0FFH);
	t.state = 0FEH;	/* flag as paged out */
END pageout;


anotherPage: PROCEDURE(page) PUBLIC;
	DECLARE page BYTE;
	DECLARE i BYTE;
	

	IF usePrintBuf THEN	/* use print buffer space */
	DO;
		CALL writePrintBuf;	/* flush the buffer */
		usePrintBuf = 0;	/* no longer available */
		CALL mem$mov(topHeap - botHeap, botHeap, botHeap + npbuf);
		spbuf$p, pbuf$p, topheap = epbuf$p;
		topDescriptor = topDescriptor + npbuf;
		curDescriptor62F = curDescriptor62F + npbuf;
		curDescriptor = curDescriptor + npbuf;
		nxtPageNo = pageCacheSize + 1;
		pageCacheSize = HIGH((botHeap := botHeap + npbuf) - baseMemImage) - 1;
		RETURN;
	END;
	IF NOT havePagingFile THEN
	DO;
		havePagingFile = 0FFH;
		CALL delete(.tmpFileName(1), .statusIO);
		CALL open(.tmpfd, .tmpFileName(1), 3, 0, .statusIO);
		CALL errChkReport(statusIO, .tmpFileName(1), 0FFH);
	END;

	pageTab1(page).state = 0FFH;
	i = pageTab1(page).mpage;
	addr1byts.hibyt = page;
	CALL pageout(i, baseMemImage + addr1);
END anotherPage;


allocNewPage: PROCEDURE(page) ADDRESS PUBLIC;
	DECLARE page BYTE;

	DO nxtPageNo = 0 TO pageCacheSize;
		IF pageTab1(nxtPageNo).state THEN	/* one is free */
			GOTO found;
	END;
	IF roundRobinIndex > pageCacheSize THEN
		roundRobinIndex = 0;
	nxtPageNo = roundRobinIndex;
	CALL anotherPage(roundRobinIndex);
	IF nxtPageNo = roundRobinIndex  THEN	/* we got more pages so don't need to round robin pages to free */
		roundRobinIndex = roundRobinIndex + 1;
found:
	pageTab1(nxtPageNo).state = 0;	/* no longer free */
	pageTab1(nxtPageNo).mpage = page;
	pageTab2(page).state = nxtPageNo;
	addr0byts.hibyt = nxtPageNo;
	RETURN baseMemImage + addr0;
END allocNewPage;


RAddr2LAddr: PROCEDURE(addr) ADDRESS PUBLIC;
	DECLARE addr ADDRESS;
	DECLARE baddr ADDRESS;
	DECLARE (lobyt, hibyt) BYTE AT(.baddr);
	DECLARE pt ADDRESS;
	DECLARE t BASED pt STRUCTURE (state BYTE, fpage BYTE);

	pt = .pageTab2(HIGH(addr));
	IF t.state = 0FFH THEN	/* needs allocating */
		RETURN allocNewPage(HIGH(addr)) + LOW(addr);
	IF t.state = 0FEH THEN	/* on disk */
	DO;
		baddr = allocNewPage(HIGH(addr));
		CALL seekPageTmpFile(t.fpage);
		CALL read(tmpfd, baddr, 256, .actRead, .StatusIO);
		CALL errChkReport(statusIO, .tmpFileName(1), 0FFH);
		IF actRead <> 256 THEN
			IF isNotBB THEN
				CALL errChkReport(ERR204, .tmpFileName(1), 0FFH);    /* premature EOF */
		RETURN baddr + LOW(addr);
	END;
	hibyt = t.state;
	lobyt = LOW(addr);
	RETURN baseMemImage + baddr;
END RAddr2LAddr;


sub$3DB9: PROCEDURE(arg1w) PUBLIC;
	DECLARE arg1w ADDRESS;

	IF HIGH(botHeap - baseMemImage) <> HIGH((botHeap := botHeap - arg1w) - baseMemImage) THEN
	DO;
		IF NOT pageTab1(pageCacheSize).state THEN
			CALL anotherPage(PageCacheSize);

		IF (pageCacheSize := HIGH(botHeap - baseMemImage) - 1) = 0FFH THEN
			CALL errChkReport(ERR210, .inFileName(1), 0FFH);	/* Insufficient memory */
	END;
END sub$3DB9;


insert6Desc: PROCEDURE(flags, seg, start, len) PUBLIC;
	DECLARE (flags, seg) BYTE;
	DECLARE (start, len) ADDRESS;
	DECLARE desc6 BASED curDescriptor62F DESC6$T;
	DECLARE desc6a BASED desc6a$p DESC6$T;

	curDescriptor62F = topHeap;

	DO WHILE curDescriptor62F <> topDescriptor;
		curDescriptor62F = curDescriptor62F - DOUBLE(6);
		IF desc6.start > start THEN
			IF start + len = desc6.start AND desc6.seg = seg THEN /* does end address = start of this block */
			DO;	/* merge the blocks */
				desc6.start = start;
				desc6.len = desc6.len + len;
				RETURN;
			END;
			ELSE
				GOTO loc$3F87;
		ELSE IF desc6.start + desc6.len = start THEN
			IF desc6.seg = seg THEN
			DO;
				desc6.len = desc6.len + len;
				IF curDescriptor62F <> topDescriptor THEN
				DO;
					desc6a$p = curDescriptor62F - DOUBLE(6);
					IF desc6a.start = desc6.start + desc6.len AND desc6a.seg = desc6.seg THEN
					DO;
						desc6.len = desc6.len + desc6a.len;
						CALL mem$mov(desc6a$p - botHeap, botHeap, botHeap + DOUBLE(6));
						topDescriptor = topDescriptor + DOUBLE(6);
						botHeap = botHeap + DOUBLE(6);
					END;
				END;
				RETURN;
			END;
	END;
	curDescriptor62F = curDescriptor62F - DOUBLE(6);
loc$3F87:
	CALL sub$3DB9(6);
	topDescriptor = topDescriptor - DOUBLE(6);
	CALL mem$mov(curDescriptor62F - botHeap, botHeap + DOUBLE(6), botHeap);
	desc6.flags = flags;
	desc6.seg = seg;
	desc6.start = start;
	desc6.len = len;
END insert6Desc;


insert4Desc: PROCEDURE(saddr, eaddr) PUBLIC;
	DECLARE saddr ADDRESS;
	DECLARE eaddr ADDRESS;
	DECLARE desc4 BASED curDescriptor DESC4$T;
	DECLARE desc4a BASED desc4a$p DESC4$T;

	curDescriptor = topDescriptor;
	DO WHILE curDescriptor <> botHeap;
		curDescriptor = curDescriptor - DOUBLE(4);
		IF desc4.saddr > saddr THEN
		DO;
			IF eaddr >= desc4.saddr - 1 THEN
			DO;
				desc4.saddr = saddr;
				IF eaddr > desc4.eaddr THEN
				DO;
					desc4.eaddr = eaddr;
					desc4a$p = curDescriptor - DOUBLE(4);
					DO WHILE curDescriptor <> botHeap;
						IF eaddr + 1 < desc4a.saddr THEN
							RETURN;
						IF eaddr + 1 = desc4a.saddr THEN
							desc4.eaddr = desc4a.eaddr;
						CALL mem$mov(desc4a$p - botHeap, botHeap, botHeap + DOUBLE(4));
						botHeap = botHeap + DOUBLE(4);
					END;
				END;
				RETURN;
			END;
			ELSE
			DO;
				CALL sub3DB9(4);
				CALL mem$mov(curDescriptor - botHeap, botHeap + DOUBLE(4), botHeap);
				desc4.saddr = saddr;
				desc4.eaddr = eaddr;
				RETURN;
			END;
		END;
		ELSE
		DO;
			IF desc4.saddr = saddr OR saddr - 1 <= desc4.eaddr THEN
			DO;
				IF desc4.eaddr >= eaddr THEN
					RETURN;
				desc4.eaddr = eaddr;
				desc4a$p = curDescriptor - DOUBLE(4);
				DO WHILE curDescriptor <> botHeap;
					IF desc4a.saddr - 1 > eaddr THEN
						RETURN;
					IF desc4a.saddr - 1 = eaddr THEN
						desc4.eaddr = desc4a.eaddr;
					CALL mem$mov(desc4a$p - botHeap, botHeap, botHeap + DOUBLE(4));
					botHeap = botHeap + DOUBLE(4);
				END;
				RETURN;
			END;
		END;	/* IF ELSE */
	END;	/* DO WHILE */

	CALL sub3DB9(4);
	curDescriptor = botHeap;
	desc4.saddr = saddr;
	desc4.eaddr = eaddr;
END insert4Desc;


loadMODDAT: PROCEDURE(arg1b) PUBLIC;
	DECLARE arg1b BYTE;
	DECLARE rdata BASED rec$p (1) BYTE;
	DECLARE (dataLen, bytes2Read, curLoadAddr) ADDRESS;
	DECLARE curLoadPage BYTE;

	DECLARE ch BASED inb$p BYTE;

	dataLen = recLen - 4;
	inCRC = HIGH(recLen) + 6 + LOW(recLen) + rdata(0) + rdata(1) + rdata(2);
	ibuf$p = ibuf$p + 3;
	IF LOW(curLoadAddr := t6desc4.saddr) <> 0 THEN
	DO;
		IF HIGH(curLoadAddr + (bytes2Read := dataLen) - 1) <> HIGH(curLoadAddr) THEN
			bytes2Read = 256 - LOW(curLoadAddr);	/* don't go over page boundary */
		CALL chkRead(bytes2Read);
		DO inb$p = ibuf$p TO ibuf$p + bytes2Read - 1;
			inCRC = inCRC + ch;
		END;
		CALL mem$mov(bytes2Read, ibuf$p, RAddr2LAddr(curLoadAddr));
		dataLen = dataLen - bytes2Read;
		curLoadAddr = curLoadAddr + bytes2Read;
		ibuf$p = ibuf$p + bytes2Read;
	END;
	DO WHILE dataLen >= 256;
		CALL chkRead(256);
		DO inb$p = ibuf$p TO ibuf$p + 255;
			inCRC = inCRC + ch;
		END;
		IF arg1b = 0 AND havePagingFile THEN
		DO;
			IF pageTab2(curLoadPage := HIGH(curLoadAddr)).state <= 0FDH THEN
				pageTab1(pageTab2(curLoadPage).state).state = 0FFH;
			CALL pageout(curLoadPage, ibuf$p);
		END;
		ELSE
			CALL mem$mov(256, ibuf$p, RAddr2Laddr(curLoadAddr));

		dataLen = dataLen - 256;
		curLoadAddr = curLoadAddr + 256;
		ibuf$p = ibuf$p + 256;
	END;
	IF dataLen > 0 THEN
	DO;
		CALL chkRead(dataLen);
		DO inb$p = ibuf$p TO ibuf$p + dataLen - 1;
			inCRC = inCRC + ch;
		END;
		CALL mem$mov(dataLen, ibuf$p, RAddr2LAddr(curLoadAddr));
		ibuf$p = ibuf$p + dataLen;
	END;
	CALL chkRead(1);
	ibuf$p = (inb$p := ibuf$p) + 1;
	IF inCRC + ch <> 0 THEN
		CALL fatalErr(ERR208);	/* Checksum error */
END loadMODDAT;


baseMemImage, pageTab2$p = .controls;	/* once we have processed args overwrite area */
CALL procArgs$Init;
CALL sub$5359;
CALL writePrintBuf;
CALL close(printfd, .statusIO);
CALL exit;

END;
loc2a.ext
errmsg: PROCEDURE(errCode) EXTERNAL;
	DECLARE errCode ADDRESS;
END errmsg;

loc2a.plm
locate2a: DO;

$INCLUDE(ISIS.EXT)

$list
DECLARE	errTab(*) BYTE DATA (
	   2, 'ILLEGAL AFTN ARGUMENT', 0,
	   3, 'TOO MANY OPEN FILES', 0,
	   4, 'INCORRECTLY SPECIFIED FILE', 0,
	   5, 'UNRECOGNIZED DEVICE NAME', 0,
	   9, 'DISK DIRECTORY FULL', 0,
	 0Ch, 'FILE IS ALREADY OPEN', 0,
	 0Dh, 'NO SUCH FILE', 0,
	 0Eh, 'WRITE PROTECTED', 0,
	 11h, 'NOT A DISK FILE', 0,
	 13h, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
	 14h, 'ATTEMPTED BACK SEEK TOO FAR', 0,
	 15h, 'CAN''T RESCAN', 0,
	 16h, 'ILLEGAL ACCESS MODE TO OPEN', 0,
	 17h, 'MISSING FILENAME', 0,
	 1Bh, 'ILLEGAL SEEK COMMAND', 0,
	 1Ch, 'MISSING EXTENSION', 0,
	 1Fh, 'CAN''T SEEK ON WRITE ONLY FILE', 0,
	 20h, 'CAN''T DELETE OPEN FILE', 0,
	 23h, 'SEEK PAST EOF', 0,
	0CBh, 'INVALID SYNTAX', 0,
	0CCh, 'PREMATURE EOF', 0,
	0D0h, 'CHECKSUM ERROR', 0,
	0D2h, 'INSUFFICIENT MEMORY', 0,
	0D3h, 'RECORD TOO LONG', 0,
	0D4h, 'ILLEGAL RELO RECORD', 0,
	0D5h, 'FIXUP BOUNDS ERROR', 0,
	0DAh, 'ILLEGAL RECORD FORMAT', 0,
	0E0h, 'BAD RECORD SEQUENCE', 0,
	0E1h, 'INVALID NAME', 0,
	0E2h, 'NAME TOO LONG', 0,
	0E3h, 'LEFT PARENTHESIS EXPECTED', 0,
	0E4h, 'RIGHT PARENTHESIS EXPECTED', 0,
	0E5h, 'UNRECOGNIZED CONTROL', 0,
	0E9h, '''TO'' EXPECTED', 0,
	0EDh, 'COMMON NOT FOUND', 0,
	0EEh, 'ILLEGAL STACK CONTENT RECORD', 0,
	0EFh, 'NO MODULE HEADER RECORD', 0,
	0F0h, 'PROGRAM EXCEEDS 64K', 0);

errmsg: PROCEDURE(errCode) PUBLIC;
	DECLARE errCode ADDRESS;
	DECLARE i ADDRESS;
	DECLARE status ADDRESS;
	
	IF LOW(errCode) <> 0 THEN
	DO;
		i = 0;
		DO WHILE i < LENGTH(errTab);	/* 328h */
			IF LOW(errCode) = errTab(i) THEN
			DO;
				CALL write(0, .(' '), 1, .status);
				DO WHILE errTab(i := i + 1) <> 0;
					CALL write(0, .errTab(i), 1, .status);
				END;
				CALL write(0, .(0DH, 0AH), 2, .status);
				RETURN;
			END;
			ELSE
			DO;
				DO WHILE errTab(i := i + 1) <> 0;
				END;
				i = i + 1;
			END;
		END;
		CALL error(errCode);	/* ISIS error code */
	END;
END errmsg;

END locate2a;
loc2b.ext
DECLARE	aUnsatisfiedExt(1) BYTE EXTERNAL,
	aSymbolTableOfM(1) BYTE EXTERNAL,
	aReadFromFile(1) BYTE EXTERNAL,
	aWrittenToFile(1) BYTE EXTERNAL,
	aValueType(1) BYTE EXTERNAL,
	aSymbol(1) BYTE EXTERNAL,
	aPub(1) BYTE EXTERNAL,
	aSym(1) BYTE EXTERNAL,
	alin(1) BYTE EXTERNAL,
	aMod(1) BYTE EXTERNAL,
	x5(1) BYTE EXTERNAL;
DECLARE
	outSegType(3) BYTE EXTERNAL,
	curColumn ADDRESS EXTERNAL,
	workingSegBase ADDRESS EXTERNAL,
	unsatisfiedCnt ADDRESS EXTERNAL;

writeBytes: PROCEDURE(arg1w, arg2w) EXTERNAL;
	DECLARE arg1w ADDRESS;
	DECLARE arg2w ADDRESS;
END writeBytes;

initRecOut: PROCEDURE(type) EXTERNAL;
	DECLARE type BYTE;
END initRecOut;

endRecord: PROCEDURE EXTERNAL;
END endRecord;


forceSOL: PROCEDURE EXTERNAL;
END forceSOL;

sub$4B3A: PROCEDURE(arg1w, pstr) EXTERNAL;
	DECLARE arg1w ADDRESS;
	DECLARE pstr ADDRESS;
END sub$4B3A;

setWorkingSeg: PROCEDURE(arg1b) BYTE EXTERNAL;	/* always returns 0 */
	DECLARE arg1b BYTE;
END setWorkingSeg;

procMODEND: PROCEDURE EXTERNAL;
END procMODEND;

procMODDAT: PROCEDURE EXTERNAL;
END procMODDAT;

loc2b.plm
locate2: DO;
$INCLUDE(ISIS.EXT)

$INCLUDE(LOC.LIT)
$INCLUDE(LOC1.EXT)
$INCLUDE(LOC3.EXT)
$INCLUDE(LOC4.EXT)
$INCLUDE(LOC5.EXT)
$INCLUDE(LOC6.EXT)

$INCLUDE(LOC.BAS)

DECLARE aUnsatisfiedExt(*) BYTE PUBLIC INITIAL('UNSATISFIED EXTERNAL(XXXXX) '),

	aReferenceToUns(*) BYTE PUBLIC INITIAL('REFERENCE TO UNSATISFIED EXTERNAL(XXXXX) AT XXXXH', 0DH, 0AH),
	aSymbolTableOfM(*) BYTE PUBLIC INITIAL(0DH, 0AH, 'SYMBOL TABLE OF MODULE '),
	aReadFromFile(*) BYTE PUBLIC INITIAL(0DH, 0AH, 'READ FROM FILE '),
	aWrittenToFile(*) BYTE PUBLIC INITIAL(0DH, 0AH, 'WRITTEN TO FILE '),
	aValueType(*) BYTE PUBLIC INITIAL('VALUE TYPE '),
	aSymbol(*) BYTE PUBLIC INITIAL(6, 'SYMBOL'),
	aPub(*) BYTE PUBLIC INITIAL('XXXXH PUB  '),
	aSym(*) BYTE PUBLIC INITIAL('XXXXH SYM  '),
	alin(*) BYTE PUBLIC INITIAL('XXXXH LIN  '),
	aMod(*) BYTE PUBLIC INITIAL('      MOD  '),
	x5(*) BYTE PUBLIC INITIAL(5, 'XXXXX'),
	spc32(*) BYTE PUBLIC INITIAL('                                ');

DECLARE	fixType BYTE PUBLIC,
	outSegType(3) BYTE PUBLIC,
	curColumn ADDRESS PUBLIC,
	workingSegBase ADDRESS PUBLIC,
	unsatisfiedCnt ADDRESS PUBLIC INITIAL(0),
	curcol BYTE PUBLIC INITIAL(0),
	word$6483 ADDRESS PUBLIC INITIAL(0),
	LabelLen BYTE PUBLIC INITIAL(0),
	lsout$p ADDRESS PUBLIC,
	lsout BASED lsout$p STRUCTURE (type BYTE, len ADDRESS, bytes(1) BYTE);


seekOutFile: PROCEDURE(mode, pblk, pbyt) PUBLIC;
	DECLARE (mode, pblk, pbyt) ADDRESS;
	CALL seek(outputfd, mode, pblk, pbyt, .statusIO);
	CALL errChkReport(statusIO, .outFileName(1), 0FFH);
END seekOutFile;


flushOut: PROCEDURE PUBLIC;
	CALL write(outputfd, sout$p, out$p - sout$p, .statusIO);
	CALL errChkReport(statusIO, .outFileName(1), 0FFH);
	out$p = sout$p;
END flushOut;

writeBytes: PROCEDURE(buf$p, cnt) PUBLIC;
	DECLARE (buf$p, cnt) ADDRESS;
	DECLARE bcnt ADDRESS;

	bcnt = eout$p - out$p;
	DO WHILE cnt > bcnt;
		CALL mem$mov(bcnt, buf$p, out$p);
		cnt = cnt - bcnt;
		buf$p = buf$p + bcnt;
		out$p = out$p + bcnt;
		CALL flushOut;
		bcnt = npbuf;
	END;
	CALL mem$mov(cnt, buf$p, out$p);
	out$p = out$p + cnt;
END writeBytes;


initRecOut: PROCEDURE(type) PUBLIC;
	DECLARE type BYTE;
	DECLARE lsout BASED lsout$p STRUCTURE(type BYTE);

	IF eout$p - out$p < 1028 THEN
		CALL flushout;
	lsout$p = out$p;
	lsout.type = type;
	out$p = out$p + 3;	/* type + length */
END initRecOut;


endRecord: PROCEDURE PUBLIC;
	DECLARE crc BYTE;
	DECLARE pch ADDRESS;
	DECLARE ch BASED pch BYTE;
	DECLARE outch BASED out$p BYTE;

	IF (lsout.len := out$p - .lsout.type - 2) > 1025 THEN
		CALL errChkReport(ERR211, .outFileName(1), 0FFH);	/* RECORD TOO LONG */
	crc = 0;
	DO pch = .lsout TO out$p - 1;
		crc = crc + ch;
	END;
	outch = -crc;
	out$p = out$p + 1;
END endRecord;


emitMODDAT: PROCEDURE(pdesc4) PUBLIC;
	DECLARE pdesc4 ADDRESS;
	DECLARE desc4 BASED pdesc4 DESC4$T;
	DECLARE (i, bcnt, pmem, curPC, j) ADDRESS;
	DECLARE crc BYTE;
	DECLARE mem BASED pmem (1) BYTE;

	CALL initRecOut(R$MODDAT);
	i = desc4.eaddr - desc4.saddr + 1;	/* last - first + 1 */
	lsout.len = i + 4;
	moddatOut.seg = SABS;		/* abs seg */
	curPC = (moddatOut.addr := desc4.saddr);		/* load address */	
	crc = HIGH(lsout.len) + 6 + LOW(lsout.len) + HIGH(moddatOut.addr) + LOW(moddatOut.addr);
	out$p = out$p + 3;

	DO WHILE i > 0;
		bcnt = 256;
		IF LOW(curPC) <> 0 THEN
			bcnt = 256 - LOW(curPC);
		IF bcnt > i THEN
			bcnt = i;
		pmem =  RAddr2LAddr(curPC);
		DO j = 0 TO bcnt - 1;
			crc = crc + mem(j);
		END;
		CALL writeBytes(pmem, bcnt);
		IF bcnt = 256 THEN
		DO;
			pageTab1(pageTab2(HIGH(curPC)).state).state = 0FFH;
			pageTab2(HIGH(curPC)).state = 0FFH;	/* mark page as free */
		END;
		curPC = curPC + bcnt;
		i = i - bcnt;
	END;	/* DO WHILE */

	crc = -crc;
	CALL writeBytes(.crc, 1);
END emitMODDAT;


forceSOL: PROCEDURE PUBLIC;
	IF curcol <> 0 THEN
		CALL printcrlf;
	curcol = 0;
END forceSOL;



sub$4B3A: PROCEDURE(arg1w, pstr) PUBLIC;
	DECLARE arg1w ADDRESS;
	DECLARE pstr ADDRESS;
	DECLARE str BASED pstr (1) BYTE;

	IF arg1w <> word$6483 THEN
		CALL forceSOL;
	word$6483 = arg1w;
	IF curcol = columns THEN
		CALL forceSOL;
	IF curcol <> 0 THEN
		CALL printString(.spc32, 32 - LabelLen);
	curcol = curcol + 1;
	LabelLen = str(0);
	CALL printString(arg1w, 11);
	CALL printString(pstr + 1, LabelLen);
END sub$4B3A;


setWorkingSeg: PROCEDURE(seg) BYTE PUBLIC;	/* always returns 0 */
	DECLARE seg BYTE;
	workingSegBase = segBases(seg);
	RETURN 0;
END setWorkingSeg;


procMODEND: PROCEDURE PUBLIC;
	DECLARE rst0$p ADDRESS;
	DECLARE jmp BASED rst0$p STRUCTURE (inst BYTE, addr ADDRESS);

	IF modendRec.subtype = 1 THEN
	DO;
		type4SubType = 1;
		outSegType(0) = setWorkingSeg(modendRec.segtype);
		IF NOT startSeen THEN
			startAddr = workingSegBase + modendRec.addr;
		IF restart0Seen THEN
		DO;
			rst0$p = RAddr2LAddr(0);
			jmp.inst = 0C3H;
			jmp.addr = startAddr;
			CALL insert6Desc(0, 0, 0, 3);
			CALL insert4Desc(0, 2);
		END;
	END;
	ELSE
		startAddr = 0;	/* 0 start address if type4 input does not have one */
	CALL flushOut;
	curDescriptor = topDescriptor;
	DO WHILE curDescriptor <> botHeap;
		curDescriptor = curDescriptor - DOUBLE(4);
		CALL emitMODDAT(curDescriptor);
	END;

	CALL initRecOut(R$MODEND);	/* generate the type 4 record */
	modendOut.subtype = type4SubType;
	modendOut.segtype = 0;
	modendOut.addr = startAddr;
	out$p = out$p + 4;
	CALL writeBytes(rec$p + DOUBLE(4), recLen - DOUBLE(4) - 1);	/* copy type 4 tail over */
	CALL endRecord;					/* insert length and CRC */
	CALL initRecOut(R$MODEOF);				/* EOF record */
	CALL endRecord;
	CALL flushOut;
END procMODEND;


procMODDAT: PROCEDURE PUBLIC;
	DECLARE (mark, backup) STRUCTURE (blk ADDRESS, byt ADDRESS);
	DECLARE fixextPrimed BYTE;
	DECLARE (fixRAddr, pad) ADDRESS;
	DECLARE (locRecLen, lasttype6base) ADDRESS;
	DECLARE (fixLoc, fixLoc2) ADDRESS;
	DECLARE (loByt, hiByt) BYTE, bothByt ADDRESS AT (.loByt);

	DECLARE bfix BASED fixLoc BYTE;
	DECLARE bfix2 BASED fixLoc2 BYTE;
	DECLARE wfix BASED fixLoc ADDRESS;
	DECLARE erec BASED erec$p(1) BYTE;


	srec$p = .(6);
	ibuf$p = rec$p;
	CALL chkRead(3);
	rec$p = ibuf$p;
	IF moddatRec.seg = SSTACK THEN
		CALL fatalErr(ERR238);	/* ILLEGAL STACK CONTENT RECORD */

	outSegType(0) = setWorkingSeg(moddatRec.seg);
	lasttype6Base = workingSegBase;
	t6desc4.saddr = lasttype6base + moddatRec.addr;
	IF (t6desc4.eaddr := t6desc4.saddr + recLen - 5) < t6desc4.saddr THEN
		CALL illegalRecord;	/* oops over 64k */
	IF moddatRec.seg = SABS THEN
		CALL insert6Desc(0, 0, t6desc4.saddr, recLen - 4);
	ELSE IF (segFlags(moddatRec.seg) AND 0FH) = 0 THEN
		CALL illegalRecord;	/* align 0 is invalid */
	IF (locRecLen := recLen) > 1025 THEN
	DO;
		IF moddatRec.seg <> 0 THEN
			CALL fatalErr(ERR211);	/* RECORD TOO LONG */
		CALL insert4Desc(t6desc4.saddr, t6desc4.eaddr);
	END;
	CALL loadMODDAT(moddatRec.seg);
	CALL getRecord;
	IF locRecLen > 1025 THEN
		RETURN;

	fixextPrimed = 0;

	DO WHILE srec.type = R$FIXEXT OR srec.type = R$FIXLOC OR srec.type = R$FIXSEG;
		IF srec.type = R$FIXEXT THEN
		DO;
			IF NOT fixextPrimed THEN
			DO;
				CALL flushOut;
				CALL seekOutFile(0, .mark.blk, .mark.byt);
				backup.blk = 0;
				backup.byt = locRecLen + 3;
				CALL seekOutFile(3, .backup.blk, .backup.byt);
			END;
			fixextPrimed = 0FFH;
			CALL initRecOut(R$FIXEXT);
			IF (fixType := fixextARec.fixType) - 1 > 2 THEN
				CALL illegalRecord;

			fixextAOut.fixType = fixType;
			out$p = out$p + 1;
			rec$p = rec$p + 1;

			DO WHILE rec$p < .erec;
				CALL fixupBoundsChk(fixextBOut.addr := lasttype6base + fixextBRec.addr);
				IF fixType = 3 THEN
					CALL fixupBoundsChk(fixextBOut.addr + 1);	/* check 2nd byte in range */
				IF (fixextBOut.sym := fixextBRec.sym) >= unsatisfiedCnt THEN
					CALL badRecordSeq;
				CALL forceSOL;
				CALL binasc(fixextBOut.sym, 10, ' ', .aReferenceToUns(34), 5);
				CALL binasc(fixextBOut.addr, 16, '0', .aReferenceToUns(44), 4);
				CALL conAndPrint(.aReferenceToUns, 34);
				
				CALL conAndPrint((curColumn := skipspc(.aReferenceToUns(34))),
						17 - (curColumn - .aReferenceToUns(34)));
				out$p = out$p +  4;
				rec$p = rec$p + 4;
			END;	/* DO WHILE */

			CALL endRecord;
		END;
		ELSE
		DO;
			workingSegBase = lasttype6base;
			IF srec.type = R$FIXSEG THEN
			DO;
				outSegType(0) = setWorkingSeg(fixsegARec.seg);
				rec$p = rec$p + 1;				/* rest treat as type FIXLOC */
			END;
			IF (fixType := fixlocARec.fixtype) - 1 > 2 THEN
				CALL illegalRecord;
			rec$p = rec$p + 1;

			DO WHILE rec$p < .erec;
				CALL fixupBoundsChk(fixRaddr := lasttype6base + fixlocBRec.addr);
				IF fixType = 3 THEN
					CALL fixupBoundsChk(fixRaddr + 1);
				fixLoc = RAddr2LAddr(fixRaddr);
				DO CASE fixType - 1;
					bfix = bfix + LOW(workingSegBase);
					bfix = bfix + HIGH(workingSegBase);
					IF LOW(fixRaddr) <> 0FFH THEN	/* doesn't span pages */
						wfix = wfix + workingSegBase;	
					ELSE
					DO;
						lobyt = bfix;
						fixLoc2 = RAddr2Laddr(fixRaddr + 1);
						hibyt = bfix2;
						bothbyt = bothbyt + workingSegBase;
						bfix = lobyt;
						bfix2 = hibyt;
					END;
				END;
				rec$p = rec$p + 2;
			END;
		   END;
		CALL getRecord;
	END;
	IF fixextPrimed THEN
	DO;
		CALL flushOut;
		CALL seekOutFile(2, .mark.blk, .mark.byt);
		CALL emitMODDAT(.t6desc4.saddr);
		CALL flushOut;
		CALL seekOutFile(4, .backup.blk, .backup.byt);
	END;
	ELSE
		CALL insert4Desc(t6desc4.saddr, t6desc4.eaddr);

END procMODDAT;

END locate2;

loc3.ext
fixupBoundsChk: PROCEDURE(addr) EXTERNAL;
	DECLARE addr ADDRESS;
END fixupBoundsChk;

procLINNUM: PROCEDURE EXTERNAL;
END procLINNUM;

procAncestor: PROCEDURE EXTERNAL;
END procAncestor;

procDefs: PROCEDURE(arg1b, arg2w) EXTERNAL;
	DECLARE arg1b BYTE;
	DECLARE arg2w ADDRESS;
END procDefs;

procEXTNAM: PROCEDURE EXTERNAL;
END procEXTNAM;

sub$5309: PROCEDURE(buf, len) EXTERNAL;
	DECLARE buf ADDRESS;
	DECLARE len ADDRESS;
END sub$5309;

sub$5359: PROCEDURE EXTERNAL;
END sub$5359;

loc3.plm
locate3: DO;
$INCLUDE(ISIS.EXT)
$INCLUDE(LOC.LIT)
$INCLUDE(LOC1.EXT)
$INCLUDE(LOC2A.EXT)
$INCLUDE(LOC2B.EXT)
/*$INCLUDE(LOC3.EXT)*/
$INCLUDE(LOC4.EXT)
$INCLUDE(LOC5.EXT)
$INCLUDE(LOC6.EXT)
$INCLUDE(LOC7.EXT)
$INCLUDE(LOC8.EXT)
$INCLUDE(LOC9.EXT)

$INCLUDE(LOC.BAS)

DECLARE erec BASED erec$p BYTE;

fixupBoundsChk: PROCEDURE(addr) PUBLIC;
	DECLARE addr ADDRESS;
	IF addr < t6desc4.saddr OR t6desc4.eaddr < addr THEN
		CALL fatalErr(ERR213);	/* Fixup Bounds Error */
END fixupBoundsChk;


procLINNUM: PROCEDURE PUBLIC;
	DECLARE rdata BASED rec$p BYTE;
	DECLARE buf BASED out$p (1) BYTE;
	DECLARE wbuf BASED out$p (1) ADDRESS;

	IF NOT PurgeSeen OR LinesSeen THEN
	DO;
		outSegType(0) =  setWorkingSeg(linnumARec.seg);
		IF NOT PurgeSeen THEN
		DO;
			CALL initRecOut(R$LINNUM);
			linnumAOut.seg = outSegType(0);
			out$p = out$p + 1;
		END;
		rec$p = rec$p + 1;
		DO WHILE rec$p < .erec;
			IF NOT PurgeSeen THEN
			DO;
				linnumBOut.addr = workingSegBase + linnumBRec.addr;
				linnumBOut.line = linnumBRec.line;
				out$p = out$p + 4;
				
			END;
			IF LinesSeen THEN
			DO;
				CALL binasc(workingSegBase + linnumBRec.addr, 16, '0', .alin, 4);
				CALL binasc(linnumBRec.line, 10, ' ', .x5(1), 5);
				CALL sub$4B3A(.alin, .x5);
			END;
			rec$p = rec$p + 4;
		END;
		IF NOT PurgeSeen THEN
			CALL endRecord;
	END;
	CALL getRecord;
END procLINNUM;


procAncestor: PROCEDURE PUBLIC;
	DECLARE str BASED rec$p (1) BYTE;
	IF LinesSeen OR SymbolsSeen THEN
	DO;
		CALL sub$4B3A(.aMod, rec$p);
		CALL forceSOL;
	END;
	IF NOT PurgeSeen THEN
	DO;
		CALL initRecOut(R$ANCEST);
		CALL writeBytes(.str(0), str(0) + 1);
		CALL endRecord;
	END;
	CALL getRecord;
END procAncestor;


procDefs: PROCEDURE(arg1b, arg2w) PUBLIC;
	DECLARE arg1b BYTE;
	DECLARE arg2w ADDRESS;
	DECLARE ritem BASED rec$p STRUCTURE (len ADDRESS, name (1) BYTE);
	DECLARE owd BASED out$p ADDRESS;
	DECLARE buf BASED out$p (1) BYTE;

	IF NOT purgeseen OR arg1b THEN
	DO;
		IF defsARec.seg = SSTACK THEN	/* stack ? */
		DO;
			outSegType(0) = 3;
			workingSegBase = 0;
		END;
		ELSE
			outSegType(0)= setWorkingSeg(defsARec.seg);	
		IF NOT PurgeSeen THEN
		DO;
			CALL initRecOut(srec.type);
			defsAOut.seg = outSegType(0);
			out$p = out$p + 1;
		END;
		rec$p = rec$p + 1;
		DO WHILE rec$p < .erec;
			IF NOT PurgeSeen THEN
			DO;
				defsBOut.offset = workingSegBase + defsBRec.offset;
				CALL pstrcpy(.defsBRec.name, .defsBOut.name);
				defsBOut.name(defsBRec.name(0) + 1) = 0;
				out$p = out$p + 4 + defsBRec.name(0);
			END;
			IF arg1b THEN
			DO;
				CALL binasc(workingSegBase + defsBRec.offset, 16, '0', arg2w, 4);
				CALL sub$4B3A(arg2w, .defsBRec.name);
			END;
			rec$p = rec$p + 4 + defsBRec.name(0);
		END;
		IF NOT PurgeSeen THEN
			CALL endRecord;
	END;
	CALL getRecord;
END procDefs;


procEXTNAM: PROCEDURE PUBLIC;
	DECLARE ch BASED rec$p BYTE;
	DECLARE buf BASED out$p (1) BYTE;

	CALL initRecOut(R$EXTNAM);
	DO WHILE rec$p < .erec;
		CALL forceSOL;
		CALL binasc((unsatisfiedCnt := unsatisfiedCnt + 1) - 1, 10, ' ', .aUnsatisfiedExt(21), 5);
			CALL conAndPrint(.aUnsatisfiedExt, 21);
			CALL conAndPrint(curColumn := skipSpc(.aUnsatisfiedExt(21)), 7 - (curColumn - .aUnsatisfiedExt(21)));
			CALL conAndPrint(.extnamRec.name(1), extnamRec.name(0));
			CALL conAndPrint(.crlf, 2);
			CALL pstrcpy(.extnamRec.name, .extnamOut.name);
			extnamOut.name(DOUBLE(extnamRec.name(0)) + 1) = 0;
			out$p = out$p + 2 + extnamRec.name(0);
			rec$p = rec$p + 2 + extnamRec.name(0);
	END;
	CALL endRecord;
	CALL getRecord;
END procEXTNAM;


sub$5309: PROCEDURE(buf, len) PUBLIC;
	DECLARE buf ADDRESS;
	DECLARE len ADDRESS;
	CALL printString(buf, len);
	CALL printString(.nameArg(1), nameArg(0));
	CALL printString(.aReadFromFile, 17);
	CALL printString(.inFileName(1), inFileName(0));
	CALL printString(.aWrittenToFile, 18);
	CALL printString(.outFileName(1), outFileName(0));
	CALL printcrlf;
END sub$5309;


sub$5359: PROCEDURE PUBLIC;
	DECLARE buf BASED out$p (1) BYTE;
	CALL procHeader;
	CALL initRecOut(R$MODHDR);	/* create header record */
	CALL writeBytes(.nameArg, nameArg(0)+1);	/* write the name */
	buf(0) = modhdr$x1;	/* copy the passed in data */
	buf(1) = modhdr$x2;
	out$p = out$p + 2;
	CALL endRecord;
	IF PublicsSeen  OR SymbolsSeen OR LinesSeen THEN
	DO;
		CALL sub$5309(.aSymbolTableOfM, 25);
		CALL printcrlf;
		DO curColumn = 1 TO columns;
			CALL sub$4B3A(.aValueType, .aSymbol);
		END;
		CALL printcrlf;
	END;
	DO WHILE srec.type <> R$MODEND;
	    DO CASE SHR(srec.type, 1);
		CALL illegalReloc;	/* 0 */
		CALL badRecordSeq;	/* 2 */
		;			/* 4 */
		CALL procMODDAT;		/* 6 */
		CALL procLINNUM;		/* 8 */
		CALL illegalReloc;	/* 0A */
		CALL illegalReloc;	/* 0C */
		CALL errChkReport(ERR204, .inFileName(1), 0FFH); /* 0E - Premature EOF */
		CALL procAncestor;		/* 10 */
		CALL procDefs(SymbolsSeen, .aSym);	/* 12 */
		CALL illegalReloc;	/* 14 */
		CALL procDefs(PublicsSeen, .aPub);	/* 16 */
		call procEXTNAM;		/* 18 - undefined externals */
		CALL illegalReloc;	/* 1A */
		CALL illegalReloc;	/* 1C */
		CALL illegalReloc;	/* 1E */
		CALL badRecordSeq;	/* 20 */
		CALL badRecordSeq;	/* 22 */
		CALL badRecordSeq;	/* 24 */
		CALL badRecordSeq;	/* 26 */
		CALL badRecordSeq;	/* 28 */
		CALL badRecordSeq;	/* 2A */
		CALL badRecordSeq;	/* 2C */
		CALL badRecordSeq;	/* 2E */
	    END;
	END;
	CALL procMODEND;
	CALL close(outputfd, .statusIO);
	CALL errChkReport(statusIO, .outFileName(1), 0FFH);
	IF havePagingFile THEN
	DO;
		CALL close(tmpfd, .statusIO);
		CALL delete(.tmpFileName(1), .statusIO);
	END;
	CALL forceSOL;
	CALL sub$5576;
	CALL close(readfd, .statusIO);
	CALL errChkReport(statusIO, .inFileName(1), 0FFH);
END sub$5359;

END locate3;
loc4.ext
sub$5576: PROCEDURE EXTERNAL;
END sub$5576;

skipspc: PROCEDURE(pch) ADDRESS EXTERNAL;
	DECLARE pch ADDRESS;
END skipspc;

errChkReport: PROCEDURE(errCode, file, errExit) EXTERNAL;
	DECLARE errCode ADDRESS;
	DECLARE file ADDRESS;
	DECLARE errExit BYTE;
END errChkReport;

loc4.plm
locate4: DO;
$INCLUDE(ISIS.EXT)
$INCLUDE(LOC.LIT)
$INCLUDE(LOC1.EXT)
$INCLUDE(LOC2A.EXT)
$INCLUDE(LOC3.EXT)
$INCLUDE(LOC5.EXT)
$INCLUDE(LOC6.EXT)

$INCLUDE(LOC.BAS)

DECLARE erec BASED erec$p BYTE;

DECLARE	aMemoryMapOfMod(*) BYTE PUBLIC INITIAL(0DH, 0AH, 'MEMORY MAP OF MODULE '),
	aStartStopLengt(*) BYTE PUBLIC INITIAL(0DH, 0AH, 0AH, 'START   STOP LENGTH REL NAME', 0DH, 0AH, 0AH),
	aModuleStartAdd(*) BYTE PUBLIC INITIAL('MODULE START ADDRESS XXXXH'),
	aModuleIsNotAMa(*) BYTE PUBLIC INITIAL('MODULE IS NOT A MAIN MODULE'),
	aStartControlIg(*) BYTE PUBLIC INITIAL(', START CONTROL IGNORED'),
	aRestartControl(*) BYTE PUBLIC INITIAL(', RESTART CONTROL IGNORED'),
	aAddresses(*) BYTE PUBLIC INITIAL('XXXXH  XXXXH  XXXXH  X  '),
	aMemOverlap(*) BYTE PUBLIC INITIAL('  (MEMORY OVERLAP FROM XXXXH THROUGH XXXXH)'),
	a0LengthSegment(*) BYTE PUBLIC INITIAL('  (0 LENGTH SEGMENT WRAPPED AROUND TO 0000H)'),
	segNames(*) BYTE PUBLIC INITIAL('ABSOLUTE', 'CODE    ', 'DATA    ', 'STACK   ', 'MEMORY  '),
	alignNames(*) BYTE PUBLIC INITIAL('AIPB');

sub$5517: PROCEDURE(seg) ADDRESS PUBLIC;
	DECLARE seg BYTE;
	DECLARE rdata BASED rec$p (1) BYTE;

	IF seg = 255 THEN
		RETURN .(0);
	CALL iseek(0,0);
	CALL getRecord;
	DO WHILE 1;
		CALL getRecord;
		IF srec.type <> R$COMDEF THEN
			CALL badRecordSeq;
		DO WHILE rec$p < .erec;
			IF seg = rdata(0) THEN
				RETURN rec$p + 1;
			rec$p = rec$p + 2 + rdata(1);
		END;
	END;
END sub$5517;

sub$5576: PROCEDURE PUBLIC;
	DECLARE (p, q) ADDRESS;
	DECLARE (i, j, k) BYTE;
	DECLARE desc6 BASED curDescriptor62F DESC6$T;
	DECLARE rdata BASED rec$p (1) BYTE;

	IF MapSeen THEN
	DO;
		CALL sub$5309(.aMemoryMapOfMod, 23);
		IF type4SubType THEN
		DO;
			CALL binasc(startAddr, 16, '0', .aModuleStartAdd(21), 4);
			CALL printString(.aModuleStartAdd, 26);
		END;
		ELSE
		DO;
			CALL printString(.aModuleIsNotAMa, 27);
			IF startSeen THEN
				CALL printString(.aStartControlIg, 23);
			IF restart0Seen THEN
				CALL printString(.aRestartControl, 25);
		END;
		CALL printString(.aStartStopLengt, 34);
	END;
	stackAddr = stackAddr - stackSize;
	DO q = 1 TO 254;
		IF segSizes(i := segOrder(q)) > 0 OR (segFlags(i) AND 20H) <> 0 THEN
			CALL insert6Desc(segFlags(i), i, segBases(i), segSizes(i));
	END;

	p, j = 0;
	curDescriptor62F = topHeap;
	DO WHILE curDescriptor62F <> topDescriptor ; 
		curDescriptor62F = curDescriptor62F - DOUBLE(6);
		CALL binasc(desc6.start, 16, '0', .aAddresses, 4);
		aAddresses(7) = '*';
		aAddresses(8) = '*';
		aAddresses(9) = '*';
		aAddresses(10) = '*';
		IF desc6.len > 0 THEN
			CALL binasc(desc6.start + desc6.len - 1, 16, '0', .aAddresses(7), 4);
		CALL binasc(desc6.len, 16, ' ', .aAddresses(14), 4);
		CALL mem$mov(4, .aAddresses, .aMemOverlap(23));
		CALL mem$mov(4, .aAddresses(7), .aMemOverlap(37));
		IF desc6.start + desc6.len > p THEN
		DO;
			aMemOverlap(37) = '*';
			aMemOverlap(38) = '*';
			aMemOverlap(39) = '*';
			aMemOverlap(40) = '*';
			IF desc6.len > 0 AND (p > 0  OR j <> 0) THEN
				CALL binasc(p - 1, 16, '0', .aMemOverlap(37), 4);
		END;
		k = 0;
		IF mapSeen THEN
		DO;
			aAddresses(21) = alignNames(desc6.flags AND 0FH);
			CALL printString(.aAddresses, 24);
			IF desc6.seg >= 6 THEN
			DO;
				CALL printString(.('/'), 1);
				rec$p = sub$5517(desc6.seg);
				CALL printString(rec$p+1, rdata(0));	
				CALL printString(.('/'), 1);
			END;
			ELSE
				CALL printString(.segNames(SHL(desc6.seg, 3)), 8);
		END;
		IF desc6.start < p OR j <> 0 THEN
		DO;
			k = 0FFH;
			CALL conAndPrint(.aMemOverlap, 43);
		END;
		IF (desc6.flags AND 40H) <> 0 THEN
		DO;
			k = 0FFH;
			CALL conAndPrint(.a0LengthSegment, 44);
		END;
		IF k THEN
			CALL conAndPrint(.crlf, 2);
		ELSE IF MapSeen THEN
			CALL printcrlf;
		IF desc6.start + desc6.len = 0 AND desc6.len > 0 THEN
		DO;
			p = 0;
			j = 40H;
		END;
		ELSE IF j = 0 THEN
			IF desc6.start + desc6.len > p THEN
				p = desc6.start + desc6.len;
	END;	/* DO WHILE */
END sub$5576;






skipspc: PROCEDURE(pch) ADDRESS PUBLIC;
	DECLARE pch ADDRESS;
	DECLARE ch BASED pch BYTE;
	
	DO WHILE ch = ' ';
		pch = pch + 1;
	END;
	RETURN pch;
END skipspc;




END locate4;
loc4a.plm
loc4a: DO;
$INCLUDE (ISIS.EXT)
$INCLUDE (LOC2A.EXT)
$INCLUDE (LOC5.EXT)

skipspc: PROCEDURE(pch) ADDRESS EXTERNAL;
	DECLARE pch ADDRESS;
END skipspc;

errChkReport: PROCEDURE(errCode, file, errExit) PUBLIC;
	DECLARE errCode ADDRESS;
	DECLARE file ADDRESS;
	DECLARE errExit BYTE;
	DECLARE status ADDRESS;
	
	IF errCode <> 0 THEN
	DO;
		file = skipspc(file);
		CALL write(0, .(' '), 1, .status);
		CALL write(0, file, pastAFN(file) - file, .status);	/* write file name */
		CALL write(0, .(','), 1, .status);
		CALL errmsg(errCode);
		IF errExit THEN
			CALL exit;
	END;
END errChkReport;
END;
loc5.ext
binasc: PROCEDURE(number, base,	pad, bufp, ndigits) EXTERNAL;
	DECLARE number ADDRESS, (base, pad) BYTE, bufp ADDRESS, ndigits BYTE;
	DECLARE buf BASED bufp (1) BYTE;
END binasc;

pastAFN: PROCEDURE(pch) ADDRESS EXTERNAL;
	DECLARE pch ADDRESS;
	DECLARE ch BASED pch BYTE;
END pastAFN;

$INCLUDE (loc5b.ext)
loc5a.plm
locate5a: DO;
$INCLUDE (loc5b.ext)

DECLARE hexdigits(*) BYTE DATA ('0123456789ABCDEF');

binasc: PROCEDURE(number, base,	pad, bufp, ndigits) PUBLIC;
	DECLARE number ADDRESS, (base, pad) BYTE, bufp ADDRESS, ndigits BYTE;
	DECLARE i BYTE;
	DECLARE buf BASED bufp (1) BYTE;
	
	DO i = 1 TO ndigits;
		buf(ndigits - i) = hexdigits(number MOD base);
		number = number / base;
	END;

	i = 0;
	DO WHILE buf(i) = '0' AND i < ndigits - 1;
		buf(i) = pad;
		i = i + 1;
	END;
END binasc;


pastAFN: PROCEDURE(pch) ADDRESS PUBLIC;
	DECLARE pch ADDRESS;
	DECLARE ch BASED pch BYTE;

	DO WHILE 1;
		pch = pastFileName(pch);
		IF ch = '*' OR ch = '?' THEN
			pch = pch + 1;
		ELSE
			RETURN pch;
	END;
END pastAFN;

END locate5a;



loc5b.ext
pastFileName: PROCEDURE (pch) ADDRESS EXTERNAL;
	DECLARE pch ADDRESS;
END pastFileName;
loc5b.plm
locate5b: DO;

pastFileName: PROCEDURE(pch) ADDRESS PUBLIC;
	DECLARE pch ADDRESS;
	DECLARE ch BASED pch BYTE;

	DO WHILE ch = ':' OR ch = '.' OR ('0' <= ch AND ch <= '9') OR ('A' <= ch AND ch <= 'Z');
		pch = pch + 1;
	END;
	RETURN pch;
END pastFileName;


END locate5b;



loc6.ext
DECLARE	spathInfo SPATH$T EXTERNAL;
DECLARE	signonMsg(1) BYTE EXTERNAL,
	aInvokedBy(1) BYTE EXTERNAL,
	tmpFileInfo(1) BYTE EXTERNAL,
	scmd$p ADDRESS EXTERNAL,
	cmd$p ADDRESS EXTERNAL;
DECLARE	controls(1) BYTE EXTERNAL;


cmdErr: PROCEDURE(err) EXTERNAL;
	DECLARE err ADDRESS;
END cmdErr;

skipWhiteSpc: PROCEDURE(pch) EXTERNAL;
	DECLARE pch ADDRESS;
END skipWhiteSpc;

expectLP: PROCEDURE EXTERNAL;
END expectLP;

expectRP: PROCEDURE EXTERNAL;
END expectRP;

checkFile: PROCEDURE EXTERNAL;
END checkFile;

initSegOrder: PROCEDURE EXTERNAL;
END initSegOrder;

errNotADisk: PROCEDURE EXTERNAL;
END errNotADisk;

getpstrName: PROCEDURE(pstr) EXTERNAL;
	DECLARE pstr ADDRESS;
END getpstrName;

processControls: PROCEDURE EXTERNAL;
END processControls;

loc6.plm
locate6: DO;
$INCLUDE(ISIS.EXT)
$INCLUDE(LOC.LIT)
$INCLUDE(LOC1.EXT)
$INCLUDE(LOC2A.EXT)
$INCLUDE(LOC2B.EXT)
$INCLUDE(LOC3.EXT)
$INCLUDE(LOC4.EXT)
$INCLUDE(LOC5.EXT)
/*$INCLUDE(LOC6.EXT)*/
$INCLUDE(LOC7.EXT)
$INCLUDE(LOC8.EXT)
$INCLUDE(LOC9.EXT)



DECLARE spathInfo SPATH$T PUBLIC;
DECLARE signonMsg(*) BYTE PUBLIC INITIAL(0CH, 'ISIS-II OBJECT LOCATER '),
	aInvokedBy(*) BYTE PUBLIC INITIAL(' INVOKED BY:', 0Dh, 0Ah),
	aCommandTailErr(*) BYTE PUBLIC INITIAL('COMMAND TAIL ERROR NEAR #:'),
	tmpFileInfo(*) BYTE PUBLIC INITIAL(0, 'LOCATETMP'),
	scmd$p ADDRESS PUBLIC,
	cmd$p ADDRESS PUBLIC;
DECLARE nxtSegOrder BYTE EXTERNAL;
$INCLUDE(LOC.BAS)




DECLARE controls(*) BYTE PUBLIC DATA(
		0, 0, 253,		/* 253 = -3 */
		1, 1, 4, 'CODE',
		1, 2, 4, 'DATA',
		1, 3, 5, 'STACK',
		1, 4, 6, 'MEMORY',
		2, 0, 5, 'START',
		3, 1, 9, 'STACKSIZE',
		4, 2, 8, 'RESTART0',
		4, 3, 3, 'MAP',
		4, 4, 7, 'PUBLICS',
		4, 5, 7, 'SYMBOLS',
		4, 6, 5, 'LINES',
		4, 7, 5, 'PURGE',
		5, 8, 4, 'NAME',
		6, 0, 5, 'PRINT',
		7, 0, 5, 'ORDER',
		8, 0, 7, 'COLUMNS');

DECLARE cin(*) BYTE PUBLIC DATA(':CI: ');
DECLARE cout(*) BYTE PUBLIC DATA(5,':CO: ');
DECLARE mdebug(*) BYTE PUBLIC DATA('DEBUG ');
DECLARE mstar2(*) BYTE PUBLIC DATA('**');
DECLARE mto(*) BYTE PUBLIC DATA('TO ');
DECLARE mtoand(*) BYTE PUBLIC DATA('TO&');




cmdErr: PROCEDURE(err) PUBLIC;
	DECLARE err ADDRESS;
	DECLARE scmdch BASED scmd$p BYTE;

	IF pastFileName(cmd$p) = cmd$p THEN
	DO;
		IF cmdch <> 0DH THEN
			cmd$p = cmd$p + 1;
	END;
	ELSE
		cmd$p = pastFileName(cmd$p);

	cmdch = '#';	/* put a marker in */
	CALL conStrOut(.aCommandTailErr, 26);
	CALL errmsg(err);
	CALL conStrOut(.scmdch, cmd$p - .scmdch + 1);
	CALL conStrOut(.crlf, 2);
	CALL exit;
END cmdErr;


skipWhiteSpc: PROCEDURE(pch) PUBLIC;
	DECLARE pch ADDRESS;
	cmd$p = skipspc(pch);
	DO WHILE cmdch = '&';
		cmd$p = skipspc(cmd$p + 5);
	END;
END skipWhiteSpc;


expectChar: PROCEDURE(ch, err) PUBLIC;
	DECLARE (ch, err) BYTE;
	CALL skipWhiteSpc(cmd$p);
	IF ch = cmdch THEN
		CALL skipWhiteSpc(cmd$p + 1);
	ELSE
		CALL cmdErr(err);
END expectChar;


expectLP: PROCEDURE PUBLIC;
	CALL expectChar('(', ERR227);	/* left parenthesis expected */
END expectLP;


expectRP: PROCEDURE PUBLIC;
	CALL expectChar(')', ERR228);	/* right parenthesis expected */
END expectRP;


expectSlash: PROCEDURE PUBLIC;
	CALL expectChar('/', ERR203);	/* invalid syntax */
END expectSlash;


checkFile: PROCEDURE PUBLIC;
	CALL spath(cmd$p, .spathInfo, .statusIO);	/* try to parse file */
	IF statusIO > 0 THEN
		CALL cmdERR(statusIO);
	CALL skipWhiteSpc(pastFileName(cmd$p));
END checkFile;


initSegOrder: PROCEDURE PUBLIC;
	DECLARE i BYTE;
	segOrder(0) = 0;
	segOrder(1) = 1;
	segOrder(2) = 3;
	DO i = 3 TO 252;
		segOrder(i) = i + 3;
	END;
	segOrder(253) = 2;
	segOrder(254) = 4;
END initSegOrder;


errNotADisk: PROCEDURE PUBLIC;
	CALL makeFullName(.spathInfo, .inFileName(1));
	CALL errChkReport(ERR17, .inFileName(1), 0FFH);	/* not a disk file */
END errNotADisk;


getpstrName: PROCEDURE(pstr) PUBLIC;
	DECLARE pstr ADDRESS;
	DECLARE str BASED pstr (1) BYTE;

	IF cmdCh < '?' OR 'Z' < cmdCh THEN
		CALL cmdErr(ERR225);	/* invalid Name */
	str(0) = 0;			/* set length */
	DO WHILE '0' <= cmdCh AND cmdCh <= '9' OR '?' <= cmdCh and cmdCh <= 'Z';
		str(0) = str(0) + 1;
		IF str(0) > 31 THEN
			CALL cmdErr(ERR226);	/* name too long */
		str(str(0)) = cmdch;
		cmd$p = cmd$p + 1;
	END;
END getpstrName;


processControls: PROCEDURE PUBLIC;
	DECLARE (p, q, cwindex) ADDRESS;
	DECLARE cindex BYTE AT(.cwindex);
	DECLARE (cid, caux, clen, ctype) BYTE;

	clen = pastFileName(cmd$p) - cmd$p;
	cindex = 3;
	cid = 0;
	IF cmdch = '/' THEN
	DO;
		clen = 1;
		cid = 9;
	END;
	ELSE IF clen > 0 THEN
		DO WHILE cindex < length(controls);
			IF controls(cindex+2) = clen AND strequ(cmd$p, .controls(cindex+3), clen) THEN
			DO;
				cid = controls(cindex);	
				caux = controls(cindex+1);
				cindex = 140;
			END;
			ELSE
				cindex = cindex + controls(cindex + 2) + 3;
		END;
	IF cid = 0 THEN
		CALL cmdERR(ERR229);	/* unrecognised control */
	CALL skipWhiteSpc(cmd$p + clen);
	DO CASE cid - 1;
	    DO;		/* CODE, DATA, STACK, MEMORY */
		segFlags(caux) = 80H;
		segBases(caux) = parseLPNumRP;
	    END;
	    DO;		/* START */
	    	startSeen = 0FFH;
		startAddr = parseLPNumRP;
	    END;
	    DO;		/* STACKSIZE */
	        stackSizeSet = 0FFH;
		stackSize = parseLPNumRP;
	    END;
	    seen(caux) = 0FFH; 		/* RESTART0, MAP, PUBLICS, SYMBOLS, LINES, PURGE */
	    DO;		/* NAME */
	    	nameArgSeen = 0FFH;
		CALL expectLP;
		CALL getpstrName(.nameArg);
		CALL expectRP;
	    END;
	    DO;		/* PRINT */
		CALL expectLP;
		CALL checkFile;
		CALL makeFullName(.spathInfo, .printFileName(1));
		printFileName(0) = pastFileName(.printFileName(1)) - .printFileName(1);
		CALL expectRP;
	    END;
	    DO;		/* ORDER */
	    	CALL initSegOrder;
		nxtSegOrder = 0;
		CALL expectLP;
		DO WHILE cmdch <> ')';
			cindex = 3;
			DO WHILE controls(cindex) = 1;	/* CODE DATA STACK MEMORY */
				IF strequ(cmd$p, .controls(cindex + 3), controls(cindex + 2)) THEN
				DO;
					CALL insSegIdOrder(controls(cindex + 1));
					cmd$p = cmd$p + controls(cindex + 2);
					cindex = 0;
				END;
				/* note if cindex = 0 then this keeps where we are & will termiante loop */
				cindex = cindex + controls(cindex + 2) + 3;
			END;
			IF cindex <> 0 THEN	/* check we haven't already processed */
			DO;
				CALL expectSlash;
				ctype = getCommonTypeId;
				CALL expectSlash;
				CALL insSegIdOrder(ctype);
			END;
			CALL skipWhiteSpc(cmd$p);
			IF cmdch = ',' THEN
				CALL expectChar(',', ERR203); /* invalid syntax */
		END;
		CALL expectRP;
	    END;
	    DO;		/* COLUMNS */
	    	p = cmd$p;
		CALL expectLP;
		q = cmd$p;
		cmd$p = p;
		columns = parseLPNumRP;
		IF columns < 1 OR columns > 3 THEN
		DO;
			cmd$p = q;	/* for error reporting */
			CALL cmdErr(ERR203);	/* invalid syntax */
		END;
	    END;
	    DO;		/* / -> common */
	    	ctype = getCommonTypeID;
		CALL expectSlash;
		segFlags(ctype) = 80H;
		segBases(ctype) = parseLPNumRP;
	    END;
	END;
END processControls;
END locate6;
loc7.ext
parseLPNumRP: PROCEDURE ADDRESS EXTERNAL;
END parseLPNumRP;

getCommonTypeID: PROCEDURE BYTE EXTERNAL;
END getCommonTypeID;

insSegIdOrder: PROCEDURE(seg) EXTERNAL;
	DECLARE seg BYTE;
END insSegIdOrder;

procArgs$Init: PROCEDURE EXTERNAL;
END procArgs$Init;

procHeader: PROCEDURE EXTERNAL;
END procHeader;
loc7.plm
locate7: DO;
$INCLUDE(ISIS.EXT)
$INCLUDE(LOC.LIT)
$INCLUDE(LOC1.EXT)
$INCLUDE(LOC2A.EXT)
$INCLUDE(LOC2B.EXT)
$INCLUDE(LOC3.EXT)
$INCLUDE(LOC4.EXT)
$INCLUDE(LOC5.EXT)
$INCLUDE(LOC6.EXT)
/*$INCLUDE(LOC7.EXT)*/
$INCLUDE(LOC8.EXT)
$INCLUDE(LOC9.EXT)

$INCLUDE(LOC.BAS)

DECLARE erec BASED erec$p BYTE;

DECLARE cin(1) BYTE EXTERNAL;
DECLARE cout(1) BYTE EXTERNAL;
DECLARE mdebug(1) BYTE EXTERNAL;
DECLARE mstar2(1) BYTE EXTERNAL;
DECLARE mto(1) BYTE EXTERNAL;
DECLARE mtoand(1) BYTE EXTERNAL;

DECLARE nxtSegOrder BYTE PUBLIC;

parseLPNumRP: PROCEDURE ADDRESS PUBLIC;
	DECLARE num ADDRESS;

	CALL expectLP;
	IF cmdCh < '0' OR '9' < cmdCh THEN	/* must have digit */
		CALL cmdErr(ERR203);	/* invalid syntax */
	num = parseNumber(.cmd$p);
	IF pastFileName(cmd$p) <> cmd$p THEN	/* make sure not a filename or bad number */
		CALL cmdErr(ERR203);	/* invalid syntax */
	CALL expectRP;
	RETURN num;
END parseLPNumRP;


getCommonTypeID: PROCEDURE BYTE PUBLIC;
	DECLARE name(32) BYTE;

	IF cmdch = '/' THEN
		RETURN 0FFH;	/* blank common */
	CALL getpstrName(.name);
	name(name(0) + 1) = ' ';	/* space at end */
	CALL iseek(0, 0);
	CALL getRecord;		/* skip type 2 record */

	DO WHILE 1;
		CALL getRecord;
		IF srec.type <> R$COMDEF THEN
			CALL errChkReport(ERR237, .name(1), 0FFH);	/* common not found */
		DO WHILE rec$p < .erec;
			IF strequ(.name, .comdefRec.name, name(0)+1) THEN
				RETURN comdefRec.seg;
			rec$p = rec$p + 2 + comdefRec.name(0);
		END;
	END;
END getCommonTypeID;


insSegIdOrder: PROCEDURE(seg) PUBLIC;
	DECLARE seg BYTE;
	DECLARE i BYTE;
	nxtSegOrder = nxtSegOrder + 1;
	IF segOrder(nxtSegOrder) = seg THEN	/* already in order */
		RETURN;
	DO i = 0 TO nxtSegOrder;
		IF segOrder(i) = seg THEN	/* already allocated ? */
			CALL cmdErr(ERR203);	/* invalid syntax */
	END;
	DO i = nxtSegOrder + 1 TO 254;
		IF segOrder(i) = seg THEN
			goto L6C93;
	END;
L6C93:
	DO WHILE i > nxtSegOrder;
		segOrder(i) = segOrder(i - 1);	/* make room for this seg */
		i = i - 1;
	END;
	segOrder(nxtSegOrder) = seg;
END insSegIdOrder;


readCmdLine: PROCEDURE PUBLIC;

	CALL read(1, cmd$p, 128, .actRead, .statusIO);
	CALL errChkReport(statusIO, .cin, 0FFH);
	cmdbuf(actRead) = 0DH;
	call strupr(cmd$p);
END readCmdLine;


procArgs$Init: PROCEDURE PUBLIC;
	DECLARE scmdch BASED scmd$p BYTE;
	DECLARE (p, q) ADDRESS;

	IF (pageCacheSize := HIGH(memck - baseMemImage) - 1) >= 128 THEN
		npbuf = 4096;
	ELSE IF pageCacheSize >= 64 THEN
		npbuf = 2048;
	ELSE
		npbuf = 1056;

	eibuf$p, ibuf$p = memck;
	sibuf$p, eout$p = eibuf$p - npbuf;
	sout$p, out$p, spbuf$p, pbuf$p, epbuf$p = eout$p - npbuf;
	scmd$p = .MEMORY;
	IF (usePrintBuf := pageCacheSize >= 64) THEN
		scmd$p = sout$p;
	scmdch = '-';
	CALL rescan(1, .statusIO);
	cmd$p = scmd$p + 1;
	CALL readCmdLine;
	cmd$p = skipspc(cmd$p);
	IF strequ(cmd$p, .mdebug, 6) THEN
		cmd$p = skipspc(cmd$p + 6);
	cmd$p, q = skipspc(pastFileName(cmd$p));
	DO WHILE cmdch <> 0DH;
		IF cmdch = '&' THEN
		DO;
			p = cmd$p;
			cmd$p = skipspc(cmd$p + 1);
			IF cmdch <> 0DH THEN
				CALL cmdErr(ERR203);	/* invalid syntax */
			cmd$p = p;
			CALL conStrOut(.mstar2, 2);
			cmdbuf(1) = 0DH;
			cmdbuf(2) = 0AH;
			cmdbuf(3) = '*';
			cmdbuf(4) = '*';
			cmd$p = cmd$p + 5;
			CALL readCmdLine;
		END;
		ELSE
			cmd$p = cmd$p + 1;
	END;	/* DO WHILE */

	CALL constrOut(.signonMsg + 1, 23);
	CALL constrOut(.VERSION, 4);
	CALL constrOut(.crlf, 2);
	IF cmd$p > sibuf$p THEN
		CALL cmdErr(ERR210);	/* insufficient memory */
	CALL skipWhiteSpc(q);
	CALL checkFile;
	IF spathInfo.deviceType <> 3 THEN
		CALL errNotADisk;
	CALL makeFullName(.spathInfo, .inFileName(1));
	inFileName(0) = pastFileName(.inFileName(1)) - .inFileName(1);
	IF strequ(cmd$p, .mto, 3) OR strequ(cmd$p, .mtoand, 3) THEN
	DO;
		CALL skipWhiteSpc(cmd$p + 2);
		CALL checkFile;
	END;
	ELSE
	DO;
		IF spathInfo.ext(0) = 0 THEN
			CALL cmdErr(ERR233);	/* TO expected */
		spathInfo.ext(0) = 0;
		spathInfo.ext(1) = 0;
		spathInfo.ext(2) = 0;
	END;
	CALL makeFullName(.spathInfo, .outFileName(1));
	outFileName(0) = pastFileName(.outFileName(1)) - .outFileName(1);
	IF spathInfo.deviceType <> 3 and spathInfo.deviceId <> 22 THEN	/* 22 -> :BB: */
		CALL errNotADisk;
	tmpFileInfo(0) = spathInfo.deviceId;
	CALL makefullName(.tmpFileInfo, .tmpFileName(1));
	tmpFileName(0) = pastFileName(.tmpFileName(1)) - .tmpFileName(1);
	isNotBB = spathInfo.deviceId <> 22;
	CALL open(.readfd, .InFileName(1), 1, 0, .statusIO);
	CALL errChkReport(statusIO, .inFileName(1), 0FFH);
	recNum = 0;
	CALL getRecord;
	IF srec.type <> R$MODHDR THEN
		CALL errChkReport(ERR239, .inFileName(1), 0FFH);	/* no module header record */
	CALL pstrcpy(.cout, .printFileName);
	columns = 1;
	startSeen = 0;
	stackSizeSet = 0;
	restart0Seen = 0;
	MapSeen = 0;
	PublicsSeen = 0;
	SymbolsSeen = 0;
	LinesSeen = 0;
	PurgeSeen = 0;
	nameArgSeen = 0;
	type4SubType = 0;
	modhdr$x1 = 0;
	modhdr$x2 = 0;
	startAddr = 0;
	CALL initSegOrder;
	DO p = 0 TO 255;
		segFlags(p) = 0;
		segBases(p), segSizes(p) = 0;
	END;
	DO WHILE cmdch <> 0DH;
		CALL processControls;
	END;
	havePagingFile = 0;
	roundRobinIndex = 0;
	pageIndexTmpFil = 0;
	pageCacheSize = HIGH(sout$p - (pageTab1$p := pageTab2$p + 512)) - 1;
	baseMemImage =  pageTab1$p + (pageCacheSize + 1) * 2 ;
	DO p = 0 TO 255;
		IF p <= pageCacheSize THEN
			pageTab1(p).state = 0FFH;
		pageTab2(p).state = 0FFH;
		pageTab2(p).fpage = 0FFH;
	END;

	IF usePrintBuf THEN
		spbuf$p, pbuf$p = epbuf$p - npbuf;
	topHeap, topDescriptor, botHeap = spbuf$p;
	pageCacheSize = HIGH(botHeap - baseMemImage) - 1;
	CALL delete(.outFileName(1), .statusIO);
	CALL open(.outputfd, .outFilename(1), 3, 0, .statusIO);
	CALL errChkReport(statusIO, .outFileName(1), 0FFH);
	CALL open(.printfd, .printFileName(1), 2, 0, .statusIO);
	CALL errChkReport(statusIO, .printFileName(1), 0FFH);
	IF printfd > 0 THEN
	DO;
		CALL printString(.signonMsg, 24);
		CALL printString(.VERSION, 4);
		CALL printString(.aInvokedBY, 14);
		CALL printString(.scmdch, cmd$p - .scmdch + 2);
	END;
END procArgs$Init;

DECLARE aInpageSegment2(*) BYTE PUBLIC INITIAL('INPAGE SEGMENT > 256 BYTES COERCED TO PAGE BOUNDRY', 0DH, 0AH),
	segId BYTE PUBLIC,
	pad7935(3) BYTE PUBLIC;

alignAddress: PROCEDURE(align, size, laddr) ADDRESS PUBLIC;
	DECLARE align BYTE;
	DECLARE (size, laddr) ADDRESS;
	IF size = 0 THEN
		RETURN laddr;

	IF align = 3 THEN
		RETURN laddr;
	IF align = 1 THEN
		IF size <= 256 THEN
		DO;
			IF HIGH(laddr) = HIGH(laddr + size - 1) THEN
				RETURN laddr;
		END;
		ELSE    /* inpage seg > 256 coerced to page boundary */
			CALL conAndPrint(.aInpageSegment2, 52);	
	RETURN (laddr + 0FFH) AND 0FF00H;	/* get a whole page */
END alignAddress;


procMODHDR: PROCEDURE PUBLIC;
	DECLARE rbyt BASED rec$p (1) BYTE;
	DECLARE sdef BASED rec$p STRUCTURE (segId BYTE, len ADDRESS, combine BYTE); 
	DECLARE (loadAddress, segSize, segOrderId) ADDRESS;
	DECLARE (atTopOfMem, loadHasSize) BYTE;

	IF NOT nameArgSeen THEN
		CALL pstrcpy(rec$p, .nameArg);
	rec$p = rec$p + rbyt(0) + 1;	/* past name */
	modhdr$x1 = rbyt(0);
	modhdr$x2 = rbyt(1);
	rec$p = rec$p + 2;
	loadHasSize = 0;
	DO WHILE rec$p < .erec;
		IF (segFlags(segId := sdef.segId) AND 0FH) <> 0 THEN
			CALL illegalRecord;
		IF segId <> SSTACK THEN
			segSizes(segId) = sdef.len;
		ELSE IF NOT stackSizeSet THEN
			stackSize = sdef.len;
		IF segSizes(segId) > 0 THEN
			loadHasSize = 0FFH;
		IF sdef.combine - 1 > 2 THEN
			CALL illegalRecord;
		segFlags(segId) = segFlags(segId) + sdef.combine;
		rec$p = .sdef + size(sdef);
	END;
	IF (segFlags(SSTACK) AND 0FH) = 0 THEN
		segFlags(SSTACK) = segFlags(SSTACK) + 3;	/* set low bits to 3 */
	IF (segFlags(SMEMORY) AND 0FH) = 0 THEN
		segFlags(SMEMORY) = segFlags(SMEMORY) + 3;	/* set low bits to 3 */
	IF NOT stackSizeSet AND loadHasSize THEN
		stackSize = stackSize + 12;
	loadAddress = 3680H;				/* ISIS load address */
	atTopOfMem = 0;

	DO segOrderId = 1 TO 254;
		segid = segOrder(segOrderId);
		segSize = segSizes(segId);	/* pick up seg to process */
		IF (segFlags(segId) AND 80H) = 0 THEN
		DO;
			IF atTopOfMem <> 0 THEN
			DO;
				IF segSize > 0 THEN	/* program exceeds 64k */
					CALL errChkReport(ERR240, .inFileName(1), 0FFH);
				segFlags(segId) = segFlags(segId) OR 40H;
			END;
		END;
		ELSE
		DO;					/* common */
			IF segSize > 0 THEN
				atTopOfMem = 0;
			loadAddress = segBases(segId);
		END;
		segBases(segId) = alignAddress(segFlags(segId) AND 0FH, segSize, loadAddress);
		IF segId = 4 THEN
			IF segSize = 0 AND loadHasSize THEN
				IF atTopOfMem = 0 AND memck > MemoryBase(0) THEN
					MemorySize(0), segSize = memck - MemoryBase(0);
		IF (loadAddress := segBases(segId) + segSize) < segBases(segId) THEN
			IF loadAddress = 0 THEN
				atTopOfMem = 40H;
			ELSE
				CALL errChkReport(ERR240, .inFileName(1), 0FFH);  /* exceeds 64k */
	END; 
	stackAddr = stackAddr + stackSize;	/* stack goes down so update top */
	CALL getRecord;
END procMODHDR;


procCOMDEF: PROCEDURE PUBLIC;
	DO WHILE rec$p < .erec;
		IF (segId := comdefRec.seg) < SNAMED OR segId = SBLANK THEN
			CALL illegalRecord;
		/* check if combine value not appropriate for common or if this one already seen */
		IF ((segFlags(segId) AND 0FH) = 0) OR ((segFlags(segId) AND 10H) <> 0)THEN
			CALL illegalRecord;
		segFlags(segId) = segFlags(segId) OR 10H;	/* flag as seen */
		rec$p = rec$p + 2 + comdefRec.name(0);		/* past byte, len, string */
	END;
	CALL getRecord;
END procCOMDEF;


procHeader: PROCEDURE PUBLIC;
	CALL iseek(0, 0);
	CALL getRecord;
	CALL procMODHDR;

	DO WHILE srec.type = R$COMDEF;
		CALL procCOMDEF;
	END;
	DO segId = SNAMED TO SBLANK - 1;	
		IF ((segFlags(segId) AND 0FH) <> 0) AND ((segFlags(segId) AND 10H) = 0) THEN
			CALL badRecordSeq;
	END;
END procHeader;

END locate7;
loc8.ext

makeFullName: PROCEDURE(pinfo, pstr) EXTERNAL;
	DECLARE pinfo ADDRESS;
	DECLARE pstr ADDRESS;
END makeFullName;

strupr: PROCEDURE(pch) EXTERNAL;
	DECLARE pch ADDRESS;
END strupr;


parseNumber: PROCEDURE(ppstr) ADDRESS EXTERNAL;
	DECLARE ppstr ADDRESS;
END parseNumber;

strequ: PROCEDURE(pstr1, pstr2, len) BYTE EXTERNAL;
	DECLARE (pstr1, pstr2) ADDRESS, len BYTE;
END strequ;

loc8.plm
locate8: DO;
$INCLUDE(LOC.LIT)
$INCLUDE(LOC9.EXT)

DECLARE devices (*) BYTE DATA('F0F1F2F3F4F5TITO',
		      'VIVOI1O1TRHRR1R2',
		      'TPHPP1P2LPL1BBCI',
		      'COF6F7F8F9');

makeFullName: PROCEDURE(pinfo, pstr) PUBLIC;
	DECLARE pinfo ADDRESS;
	DECLARE pstr ADDRESS;
	DECLARE str BASED pstr(1) BYTE;
	DECLARE ch BASED pstr BYTE;
	DECLARE info BASED pinfo SPATH$T;

	DECLARE i BYTE;

	str(0) = ':';
	str(1) = devices(info.deviceId + info.deviceId);
	str(2) = devices(info.deviceId + info.deviceId + 1);
	str(3) = ':';
	pstr = pstr + 4;	/* past the :xx: inserted */
	DO i = 0 TO 5;
		IF (ch := info.name(i)) <> 0 THEN
			pstr = pstr + 1;
	END;
	IF info.ext(0) <> 0 THEN
	DO;
		ch = '.';
		pstr = pstr + 1;
	END;
	DO i = 0 TO 2;
		IF (ch := info.ext(i)) <> 0 THEN
			pstr = pstr + 1;
	END;
	ch = ' ';	/* space at end */
END makeFullName;


strupr: PROCEDURE(pch) PUBLIC;
	DECLARE pch ADDRESS;
	DECLARE ch BASED pch BYTE;

	DO WHILE ch <> 0DH;
		ch = toupper(ch);
		pch = pch + 1;
	END;
END strupr;

END locate8;
loc8a.plm
locate8: DO;
$INCLUDE(LOC.LIT)
$INCLUDE(LOC9.EXT)

DECLARE hexch(*) BYTE DATA ('0123456789ABCDEF');

parseNumber: PROCEDURE(ppstr) ADDRESS PUBLIC;
	DECLARE ppstr ADDRESS;
	DECLARE pstr BASED ppstr ADDRESS;
	DECLARE (pch, pafter, pendNum) ADDRESS;
	DECLARE (i, radix, digit) BYTE;
	DECLARE (num, lastnum) ADDRESS;
	DECLARE ch BASED pch BYTE;

	pch = pstr;
	DO WHILE ch = ' ';	/* skip spaces */
		pch = pch + 1;
	END;
	pstr = pch;		/* update the source pstr */

	DO WHILE '0' <= ch AND ch <= '9' OR 'A' <= ch AND ch <= 'F';
		pch = pch + 1;
	END;
	pafter = (pendNum := pch) + 1;
	IF ch = 'H' THEN
		radix = 16;
	ELSE IF ch = 'O' OR ch = 'Q' THEN
		radix = 8;
	ELSE
	DO;	/* check for D or B or numeric */
		pendNum, pch = (pafter := pch) - 1;
		IF ch = 'B' THEN
			radix = 2;
		ELSE
		DO;
			radix = 10;
			IF ch <> 'D' THEN	/* if a digit then include in number */
				pendNum = pendNum + 1;
		END;
	END;
	pch = pstr;	/* reset to start */
	num, lastnum = 0;
	DO WHILE pch < pendNum;
		DO i = 0 TO 15;
			IF ch = hexch(i) THEN
				digit = i;
		END;
		IF digit >= radix THEN
			RETURN 0;	/* illegal number */
		IF (num := lastnum * radix + digit) < lastnum THEN
			RETURN 0;	/* overflow */
		lastnum = num;
		pch = pch + 1;
	END;
	pstr = pafter;
	RETURN num;
END parseNumber;


strequ: PROCEDURE(pstr1, pstr2, len) BYTE PUBLIC;
	DECLARE (pstr1, pstr2) ADDRESS, len BYTE;
	DECLARE i BYTE;
	DECLARE str1 BASED pstr1 (1) BYTE, str2 BASED pstr2 (1) BYTE;

	len = len - 1;
	DO i = 0 TO len;
		IF str1(i) <> str2(i) THEN
			RETURN 0;
	END;
	RETURN 0FFH;
END strequ;


END locate8;
loc9.ext
toupper: PROCEDURE(ch) BYTE EXTERNAL;
	DECLARE ch BYTE;
END toupper;

loc9.plm
locate9:
DO;
toupper: PROCEDURE(ch) BYTE PUBLIC;
	DECLARE ch BYTE;
	IF ch < 'a' THEN
		RETURN ch;
	IF ch > 'z' THEN
		RETURN ch;
	RETURN ch AND 0DFH;
END toupper;

END locate9;
makefile
ISIS=..\..\thames
PLMDIR=..\..\plm80v4
ASMDIR=..\..\plm80v4
OLDPLMDIR=..\..\plm80v3
#
# compilation and assembly rules
.SUFFIXES: .plm .pl3
.plm.obj:
	@SET ISIS_F0=.
	@SET ISIS_F1=$(PLMDIR)
	$(ISIS) :F1:PLM80 $< code
	@if not exist $*.obj exit /b 1

.pl3.obj:
	@SET ISIS_F0=.
	@SET ISIS_F1=$(OLDPLMDIR)
	$(ISIS) :F1:PLM80 $< code
	@find $*.lst "     0 PROGRAM ERROR(S)" >nul || (del $*.obj & exit /b 1)

.asm.obj:
	@SET ISIS_F0=.
	@SET ISIS_F1=$(ASMDIR)
	$(ISIS) :F1:ASM80 $< 
	@find $*.lst "ASSEMBLY COMPLETE,   NO ERRORS" >nul || (del $*.obj & exit /b 1)


LOWOBJ=loc1.obj loc2a.obj memmov.obj loc2b.obj loc3.obj loc4.obj loc4a.obj loc5a.obj loc5b.obj isis.obj
HIGHOBJ=loc6.obj loc7.obj loc8.obj loc8a.obj loc9.obj

# locate is built in two parts the value of the macro is the base address of the higher part
# it should be the same as the MEMORY address at the end of the loctmp.map file
HICODE=6656H

# locate build rules
# default target
locate: loctmp.abs $(HIGHOBJ)
	@SET ISIS_F0=.
	@SET ISIS_F1=$(PLMDIR)
	$(ISIS) :F1:link "&" < <<
$(**: =,&
),:f1:system.lib,:f1:plm80.lib to $*.rel
<<NOKEEP
	$(ISIS) :F1:locate $*.rel to locate MAP PRINT($*.map) SYMBOLS PUBLICS STACKSIZE(0) CODE($(HICODE)) PURGE
	@del $*.rel $*.abs
	@(find $*.map "UNSATISFIED EXTERNAL" >NUL && exit /b 1) || exit /b 0

# intermediate target - note will have unsatisfied externals see also HICODE above
loctmp.abs: $(LOWOBJ)
	@SET ISIS_F0=.
	@SET ISIS_F1=$(PLMDIR)
	echo $(**: =,)
	$(ISIS) :F1:link "&" < <<
$(**: =,&
),:f1:plm80.lib to $*.rel 
<<NOKEEP
	$(ISIS) :F1:locate $*.rel to $@ STACKSIZE(6CH) map print(loctmp.map)
	@del $*.rel
	@if not exist $@ exit /b 1

clean:
	del *.obj *lst *.map *.abs *.rel locate

# make this target to check the build matches the original binary
verify: locate
	fc /b locate $(PLMDIR)\locate

$(LOWOBJ) $(HIGHOBJ): makefile
memmov.asm
	PUBLIC memmov
	CSEG
; mem$move(count, src$p, dst$p)
memmov: pop	h
	xthl
	push	b
	mov	b, h
	mov	c, l
	pop	h
	dcx	b
	mov	a, e
	sub	l
	mov	a, d
	jz	l410F
	sbb	h
	jmp	l4111

l410F:	sbb	h
	rz

l4111:	push	h
	lxi	h, l4167
	jc	l4121
	pop	h
	dad	b
	push	h
	xchg
	dad	b
	xchg
	lxi	h, l4190

l4121:	inx	b
	mov	a, b
	rrc
	rrc
	rrc
	mov	b, a
	mvi	a, 7
	ana	c
	push	psw
	xra	c
	rrc
	rrc
	rrc
	xra	b
	ani	1Fh
	xra	b
	mov	c, a
	mvi	a, 1Fh
	ana	b
	mov	b, a
	inr	b
	inr	c
	pop	psw
	rlc
	rlc
	push	b
	cma
	mov	c, a
	mvi	b, 0FFh
	inx	b
	dad	b
	pop	b
	xthl
	ret

l4147:	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d

l4167:	dcr	c
	jnz	l4147
	dcr	b
	jnz	l4147
	ret

l4170:	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d

l4190:	dcr	c
	jnz	l4170
	dcr	b
	jnz	l4170
	ret
	END
