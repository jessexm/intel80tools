locate3: DO;
$INCLUDE(ISIS.EXT)
$INCLUDE(LOC.LIT)
$INCLUDE(LOC1.EXT)
$INCLUDE(LOC2A.EXT)
$INCLUDE(LOC2B.EXT)
/*$INCLUDE(LOC3.EXT)*/
$INCLUDE(LOC4.EXT)
$INCLUDE(LOC5.EXT)
$INCLUDE(LOC6.EXT)
$INCLUDE(LOC7.EXT)
$INCLUDE(LOC8.EXT)
$INCLUDE(LOC9.EXT)

$INCLUDE(LOC.BAS)

DECLARE erec BASED erec$p BYTE;

fixupBoundsChk: PROCEDURE(addr) PUBLIC;
	DECLARE addr ADDRESS;
	IF addr < t6desc4.saddr OR t6desc4.eaddr < addr THEN
		CALL fatalErr(ERR213);	/* Fixup Bounds Error */
END fixupBoundsChk;


procLINNUM: PROCEDURE PUBLIC;
	DECLARE rdata BASED rec$p BYTE;
	DECLARE buf BASED out$p (1) BYTE;
	DECLARE wbuf BASED out$p (1) ADDRESS;

	IF NOT PurgeSeen OR LinesSeen THEN
	DO;
		outSegType(0) =  setWorkingSeg(linnumARec.seg);
		IF NOT PurgeSeen THEN
		DO;
			CALL initRecOut(R$LINNUM);
			linnumAOut.seg = outSegType(0);
			out$p = out$p + 1;
		END;
		rec$p = rec$p + 1;
		DO WHILE rec$p < .erec;
			IF NOT PurgeSeen THEN
			DO;
				linnumBOut.addr = workingSegBase + linnumBRec.addr;
				linnumBOut.line = linnumBRec.line;
				out$p = out$p + 4;
				
			END;
			IF LinesSeen THEN
			DO;
				CALL binasc(workingSegBase + linnumBRec.addr, 16, '0', .alin, 4);
				CALL binasc(linnumBRec.line, 10, ' ', .x5(1), 5);
				CALL sub$4B3A(.alin, .x5);
			END;
			rec$p = rec$p + 4;
		END;
		IF NOT PurgeSeen THEN
			CALL endRecord;
	END;
	CALL getRecord;
END procLINNUM;


procAncestor: PROCEDURE PUBLIC;
	DECLARE str BASED rec$p (1) BYTE;
	IF LinesSeen OR SymbolsSeen THEN
	DO;
		CALL sub$4B3A(.aMod, rec$p);
		CALL forceSOL;
	END;
	IF NOT PurgeSeen THEN
	DO;
		CALL initRecOut(R$ANCEST);
		CALL writeBytes(.str(0), str(0) + 1);
		CALL endRecord;
	END;
	CALL getRecord;
END procAncestor;


procDefs: PROCEDURE(arg1b, arg2w) PUBLIC;
	DECLARE arg1b BYTE;
	DECLARE arg2w ADDRESS;
	DECLARE ritem BASED rec$p STRUCTURE (len ADDRESS, name (1) BYTE);
	DECLARE owd BASED out$p ADDRESS;
	DECLARE buf BASED out$p (1) BYTE;

	IF NOT purgeseen OR arg1b THEN
	DO;
		IF defsARec.seg = SSTACK THEN	/* stack ? */
		DO;
			outSegType(0) = 3;
			workingSegBase = 0;
		END;
		ELSE
			outSegType(0)= setWorkingSeg(defsARec.seg);	
		IF NOT PurgeSeen THEN
		DO;
			CALL initRecOut(srec.type);
			defsAOut.seg = outSegType(0);
			out$p = out$p + 1;
		END;
		rec$p = rec$p + 1;
		DO WHILE rec$p < .erec;
			IF NOT PurgeSeen THEN
			DO;
				defsBOut.offset = workingSegBase + defsBRec.offset;
				CALL pstrcpy(.defsBRec.name, .defsBOut.name);
				defsBOut.name(defsBRec.name(0) + 1) = 0;
				out$p = out$p + 4 + defsBRec.name(0);
			END;
			IF arg1b THEN
			DO;
				CALL binasc(workingSegBase + defsBRec.offset, 16, '0', arg2w, 4);
				CALL sub$4B3A(arg2w, .defsBRec.name);
			END;
			rec$p = rec$p + 4 + defsBRec.name(0);
		END;
		IF NOT PurgeSeen THEN
			CALL endRecord;
	END;
	CALL getRecord;
END procDefs;


procEXTNAM: PROCEDURE PUBLIC;
	DECLARE ch BASED rec$p BYTE;
	DECLARE buf BASED out$p (1) BYTE;

	CALL initRecOut(R$EXTNAM);
	DO WHILE rec$p < .erec;
		CALL forceSOL;
		CALL binasc((unsatisfiedCnt := unsatisfiedCnt + 1) - 1, 10, ' ', .aUnsatisfiedExt(21), 5);
			CALL conAndPrint(.aUnsatisfiedExt, 21);
			CALL conAndPrint(curColumn := skipSpc(.aUnsatisfiedExt(21)), 7 - (curColumn - .aUnsatisfiedExt(21)));
			CALL conAndPrint(.extnamRec.name(1), extnamRec.name(0));
			CALL conAndPrint(.crlf, 2);
			CALL pstrcpy(.extnamRec.name, .extnamOut.name);
			extnamOut.name(DOUBLE(extnamRec.name(0)) + 1) = 0;
			out$p = out$p + 2 + extnamRec.name(0);
			rec$p = rec$p + 2 + extnamRec.name(0);
	END;
	CALL endRecord;
	CALL getRecord;
END procEXTNAM;


sub$5309: PROCEDURE(buf, len) PUBLIC;
	DECLARE buf ADDRESS;
	DECLARE len ADDRESS;
	CALL printString(buf, len);
	CALL printString(.nameArg(1), nameArg(0));
	CALL printString(.aReadFromFile, 17);
	CALL printString(.inFileName(1), inFileName(0));
	CALL printString(.aWrittenToFile, 18);
	CALL printString(.outFileName(1), outFileName(0));
	CALL printcrlf;
END sub$5309;


sub$5359: PROCEDURE PUBLIC;
	DECLARE buf BASED out$p (1) BYTE;
	CALL procHeader;
	CALL initRecOut(R$MODHDR);	/* create header record */
	CALL writeBytes(.nameArg, nameArg(0)+1);	/* write the name */
	buf(0) = modhdr$x1;	/* copy the passed in data */
	buf(1) = modhdr$x2;
	out$p = out$p + 2;
	CALL endRecord;
	IF PublicsSeen  OR SymbolsSeen OR LinesSeen THEN
	DO;
		CALL sub$5309(.aSymbolTableOfM, 25);
		CALL printcrlf;
		DO curColumn = 1 TO columns;
			CALL sub$4B3A(.aValueType, .aSymbol);
		END;
		CALL printcrlf;
	END;
	DO WHILE srec.type <> R$MODEND;
	    DO CASE SHR(srec.type, 1);
		CALL illegalReloc;	/* 0 */
		CALL badRecordSeq;	/* 2 */
		;			/* 4 */
		CALL procMODDAT;		/* 6 */
		CALL procLINNUM;		/* 8 */
		CALL illegalReloc;	/* 0A */
		CALL illegalReloc;	/* 0C */
		CALL errChkReport(ERR204, .inFileName(1), 0FFH); /* 0E - Premature EOF */
		CALL procAncestor;		/* 10 */
		CALL procDefs(SymbolsSeen, .aSym);	/* 12 */
		CALL illegalReloc;	/* 14 */
		CALL procDefs(PublicsSeen, .aPub);	/* 16 */
		call procEXTNAM;		/* 18 - undefined externals */
		CALL illegalReloc;	/* 1A */
		CALL illegalReloc;	/* 1C */
		CALL illegalReloc;	/* 1E */
		CALL badRecordSeq;	/* 20 */
		CALL badRecordSeq;	/* 22 */
		CALL badRecordSeq;	/* 24 */
		CALL badRecordSeq;	/* 26 */
		CALL badRecordSeq;	/* 28 */
		CALL badRecordSeq;	/* 2A */
		CALL badRecordSeq;	/* 2C */
		CALL badRecordSeq;	/* 2E */
	    END;
	END;
	CALL procMODEND;
	CALL close(outputfd, .statusIO);
	CALL errChkReport(statusIO, .outFileName(1), 0FFH);
	IF havePagingFile THEN
	DO;
		CALL close(tmpfd, .statusIO);
		CALL delete(.tmpFileName(1), .statusIO);
	END;
	CALL forceSOL;
	CALL sub$5576;
	CALL close(readfd, .statusIO);
	CALL errChkReport(statusIO, .inFileName(1), 0FFH);
END sub$5359;

END locate3;
