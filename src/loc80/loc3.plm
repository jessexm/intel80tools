locate3: DO;
$INCLUDE(ISIS.EXT)
$INCLUDE(LOC.LIT)
$INCLUDE(LOC1.EXT)
$INCLUDE(LOC2A.EXT)
$INCLUDE(LOC2B.EXT)
/*$INCLUDE(LOC3.EXT)*/
$INCLUDE(LOC4.EXT)
$INCLUDE(LOC5.EXT)
$INCLUDE(LOC6.EXT)
$INCLUDE(LOC7.EXT)
$INCLUDE(LOC8.EXT)
$INCLUDE(LOC9.EXT)

$INCLUDE(LOC.BAS)

DECLARE erec BASED erec$p BYTE;

fixupBoundsChk: PROCEDURE(addr) PUBLIC;
	DECLARE addr ADDRESS;
	IF addr < inFragment.saddr OR inFragment.eaddr < addr THEN
		CALL fatalErr(ERR213);	/* Fixup Bounds Error */
END fixupBoundsChk;


procLINNUM: PROCEDURE PUBLIC;
	DECLARE	inSeg BASED in$p BYTE;
	DECLARE	inLinDef BASED in$p STRUCTURE (offset ADDRESS, linnum ADDRESS);
	DECLARE	outSeg BASED out$p BYTE;
	DECLARE	outLinDef BASED out$p STRUCTURE (offset ADDRESS, linnum ADDRESS);

	IF NOT PurgeSeen OR LinesSeen THEN	/* only process if not purge or lines requested */
	DO;
		outSegType =  setWorkingSeg(inSeg);	/* get ABS seg and set working base address */
		IF NOT PurgeSeen THEN		/* need to create output record */
		DO;
			CALL initRecOut(R$LINNUM);
			outSeg = outSegType;
			out$p = out$p + 1;
		END;
		in$p = in$p + 1;		/* past segid */
		DO WHILE in$p < .erec;		/* loop over all entries */
			IF NOT PurgeSeen THEN	/* emit to output record */
			DO;
				outLinDef.offset = workingSegBase + inLinDef.offset;	/* final location */
				outLinDef.linnum = inLinDef.linnum;	/* copy the line number */
				out$p = out$p + size(outLinDef);	/* past this entry */
				
			END;
			IF LinesSeen THEN	/* if required list the mapping */
			DO;
				CALL binasc(workingSegBase + inLinDef.offset, 16, '0', .alin, 4);
				CALL binasc(inLinDef.linnum, 10, ' ', .x5(1), 5);
				CALL printColumn(.alin, .x5);
			END;
			in$p = in$p + size(inLinDef);			/* to next entry */
		END;
		IF NOT PurgeSeen THEN		/* finish off output record */
			CALL endRecord;
	END;
	CALL getRecord;	/* prep next record */
END procLINNUM;


procANCEST: PROCEDURE PUBLIC;
	DECLARE str BASED in$p (1) BYTE;
	IF LinesSeen OR SymbolsSeen THEN	/* if lines or symbols */
	DO;
		CALL printColumn(.aMod, in$p);	/* print the ancestor */
		CALL forceSOL;
	END;
	IF NOT PurgeSeen THEN			/* if needed in output */
	DO;
		CALL initRecOut(R$ANCEST);	/* init record, copy the name and finalise */
		CALL writeBytes(.str(0), str(0) + 1);
		CALL endRecord;
	END;
	CALL getRecord;	/* prep next record */
END procANCEST;


procDefs: PROCEDURE(list, template) PUBLIC;
	DECLARE list BYTE;
	DECLARE template ADDRESS;
	DECLARE ritem BASED in$p STRUCTURE (len ADDRESS, name (1) BYTE);
	DECLARE owd BASED out$p ADDRESS;
	DECLARE buf BASED out$p (1) BYTE;
	DECLARE inSeg BASED in$p BYTE;
	DECLARE inDef BASED in$p STRUCTURE (offset ADDRESS, name(1) BYTE /*, 0 */);
	DECLARE outSeg BASED out$p BYTE;
	DECLARE outDef BASED out$p STRUCTURE (offset ADDRESS, name(1) BYTE /*, 0 */);

	IF NOT purgeseen OR list THEN	/* only process if not purged or list requested for these symbols */
	DO;
		IF inSeg = SSTACK THEN	/* stack ? */
		DO;
			outSegType = SSTACK;
			workingSegBase = 0;			/* stack base is 0 */
		END;
		ELSE
			outSegType = setWorkingSeg(inSeg);	/* sets working base address * returns ABS Seg */
		IF NOT PurgeSeen THEN
		DO;
			CALL initRecOut(inRecord.rectyp);	/* initialise the output record */
			outSeg = outSegType;
			out$p = out$p + 1;
		END;
		in$p = in$p + 1;			/* past segId */
		DO WHILE in$p < .erec;
			IF NOT PurgeSeen THEN
			DO;
				outDef.offset = workingSegBase + inDef.offset;	/* add in the base address */
				CALL pstrcpy(.inDef.name, .outDef.name);	/* copy the name over */
				outDef.name(inDef.name(0) + 1) = 0;		/* add the trailing 0 */
				out$p = out$p + 4 + inDef.name(0);		/* update output record past offset, name and extra 0 */
			END;
			IF list THEN			/* if required list the location */
			DO;
				CALL binasc(workingSegBase + inDef.offset, 16, '0', template, 4);
				CALL printColumn(template, .inDef.name);
			END;
			in$p = in$p + 4 + inDef.name(0);			/* to the next entry - past offset, name and extra 0 */
		END;
		IF NOT PurgeSeen THEN		/* if not purged finish off the output record */
			CALL endRecord;
	END;
	CALL getRecord;	/* prep for next record */
END procDefs;


procEXTNAM: PROCEDURE PUBLIC;
	DECLARE ch BASED in$p BYTE;
	DECLARE buf BASED out$p (1) BYTE;
	DECLARE inName BASED in$p STRUCTURE (len BYTE, name(1) BYTE /*, 0 */);
	DECLARE outName BASED out$p STRUCTURE (len BYTE, name(1) BYTE /*, 0 */);

	CALL initRecOut(R$EXTNAM);	/* initialise the EXTNAM in the located file */
	DO WHILE in$p < .erec;		/* process each item in the input EXTNAM record */
		CALL forceSOL;
		/* insert the index number of the unsatisfied external & print the error message */
		CALL binasc((unsatisfiedCnt := unsatisfiedCnt + 1) - 1, 10, ' ', .aUnsatisfiedExt(21), 5);
		/* print to the start of the number */
		CALL conAndPrint(.aUnsatisfiedExt, 21);
		/* print the rest of the message omitting leading spaces in the number */
		CALL conAndPrint(curColumn := skipSpc(.aUnsatisfiedExt(21)), 7 - (curColumn - .aUnsatisfiedExt(21)));
		/* print the name */
		CALL conAndPrint(.inName.name, inName.len);
		CALL conAndPrint(.crlf, 2);
		/* copy the name to the output record */
		CALL pstrcpy(.inName, .outName);
		outName.name(inName.len) = 0;	/* add the zero */
		out$p = out$p + 2 + inName.len;			/* skip past the name in out and in records */
		in$p = in$p + 2 + inName.len;
	END;
	CALL endRecord;	/* finish off the record */
	CALL getRecord; /* prep the next record */
END procEXTNAM;


printListingHeader: PROCEDURE(buf, len) PUBLIC;
	DECLARE buf ADDRESS;
	DECLARE len ADDRESS;
	CALL printString(buf, len);
	CALL printString(.moduleName(1), moduleName(0));
	CALL printString(.aReadFromFile, 17);	/* '\r\nREAD FROM FILE ' */
	CALL printString(.inFileName(1), inFileName(0));
	CALL printString(.aWrittenToFile, 18); /* '\r\nWRITTEN TO FILE ' */
	CALL printString(.outFileName(1), outFileName(0));
	CALL printcrlf;
END printListingHeader;


/* main procedure to locate the file */
locateFile: PROCEDURE PUBLIC;
	DECLARE buf BASED out$p (1) BYTE;
	CALL procHdrAndComDef;		/* determine all of the segment base addresses */
	CALL initRecOut(R$MODHDR);	/* create header record */
	CALL writeBytes(.moduleName, moduleName(0)+1);	/* write the name */
	buf(0) = modhdr$x1;	/* copy the passed in x field data */
	buf(1) = modhdr$x2;
	out$p = out$p + 2;
	CALL endRecord;		/* located modhdrs don't have seg size info */
	/* print symbol table header message if required */
	IF PublicsSeen  OR SymbolsSeen OR LinesSeen THEN
	DO;
		CALL printListingHeader(.aSymbolTableOfM, 25);
		CALL printcrlf;
		/* print the column headings */
		DO curColumn = 1 TO columns;
			CALL printColumn(.aValueType, .aSymbol);
		END;
		CALL printcrlf;
	END;

	/* process the link file */
	DO WHILE inRecord.rectyp <> R$MODEND;
	    DO CASE SHR(inRecord.rectyp, 1);
		CALL illegalReloc;	/* 0 */
		CALL badRecordSeq;	/* 2 - modhdr already processed */
		;			/* 4 - modend exited while already */
		CALL procMODDAT;		/* 6 - moddat */
		CALL procLINNUM;		/* 8 - linnum */
		CALL illegalReloc;	/* 0A */
		CALL illegalReloc;	/* 0C */
		CALL errChkReport(ERR204, .inFileName(1), TRUE); /* 0E - modeof Premature EOF */
		CALL procANCEST;		/* 10 - ancest */
		CALL procDefs(SymbolsSeen, .aSym);	/* 12 - locdef */
		CALL illegalReloc;	/* 14 */
		CALL procDefs(PublicsSeen, .aPub);	/* 16 - pubdef */
		call procEXTNAM;		/* 18 - extnam - externals */
		CALL illegalReloc;	/* 1A */
		CALL illegalReloc;	/* 1C */
		CALL illegalReloc;	/* 1E */
		CALL badRecordSeq;	/* 20 - fixext link should have processed these */
		CALL badRecordSeq;	/* 22 - fixloc link should have processed these */
		CALL badRecordSeq;	/* 24 - fixseg link should have processed these */
		CALL badRecordSeq;	/* 26 - libloc attempting to locate a library */
		CALL badRecordSeq;	/* 28 - libnam attempting to locate a library */
		CALL badRecordSeq;	/* 2A - libdic attempting to locate a library */
		CALL badRecordSeq;	/* 2C - libhdr attempting to locate a library */
		CALL badRecordSeq;	/* 2E - processed comdef already */
	    END;
	END;
	CALL procMODEND;		/* read the modend and generate the rest of the located file */
	CALL close(outputfd, .statusIO);
	CALL errChkReport(statusIO, .outFileName(1), TRUE);
	IF havePagingFile THEN		/* get rid of any paging file */
	DO;
		CALL close(tmpfd, .statusIO);
		CALL delete(.tmpFileName(1), .statusIO);
	END;
	CALL forceSOL;		/* make sure at start of line if symbols listed */
	CALL printMemoryMap;	/* print the final memory map + any overlay errors */
	CALL close(readfd, .statusIO);
	CALL errChkReport(statusIO, .inFileName(1), TRUE);
END locateFile;

END locate3;
