locate4: DO;
$INCLUDE(ISIS.EXT)
$INCLUDE(LOC.LIT)
$INCLUDE(LOC1.EXT)
$INCLUDE(LOC2A.EXT)
$INCLUDE(LOC3.EXT)
$INCLUDE(LOC5.EXT)
$INCLUDE(LOC6.EXT)

$INCLUDE(LOC.BAS)

DECLARE erec BASED erec$p BYTE;

DECLARE	aMemoryMapOfMod(*) BYTE PUBLIC INITIAL(0DH, 0AH, 'MEMORY MAP OF MODULE '),
	aStartStopLengt(*) BYTE PUBLIC INITIAL(0DH, 0AH, 0AH, 'START   STOP LENGTH REL NAME', 0DH, 0AH, 0AH),
	aModuleStartAdd(*) BYTE PUBLIC INITIAL('MODULE START ADDRESS XXXXH'),
	aModuleIsNotAMa(*) BYTE PUBLIC INITIAL('MODULE IS NOT A MAIN MODULE'),
	aStartControlIg(*) BYTE PUBLIC INITIAL(', START CONTROL IGNORED'),
	aRestartControl(*) BYTE PUBLIC INITIAL(', RESTART CONTROL IGNORED'),
	aAddresses(*) BYTE PUBLIC INITIAL('XXXXH  XXXXH  XXXXH  X  '),
	aMemOverlap(*) BYTE PUBLIC INITIAL('  (MEMORY OVERLAP FROM XXXXH THROUGH XXXXH)'),
	a0LengthSegment(*) BYTE PUBLIC INITIAL('  (0 LENGTH SEGMENT WRAPPED AROUND TO 0000H)'),
	segNames(*) BYTE PUBLIC INITIAL('ABSOLUTE', 'CODE    ', 'DATA    ', 'STACK   ', 'MEMORY  '),
	alignNames(*) BYTE PUBLIC INITIAL('AIPB');

getCommonName: PROCEDURE(segid) ADDRESS PUBLIC;
	DECLARE segid BYTE;
	DECLARE cdef BASED in$p STRUCTURE (segid BYTE, name(1) BYTE);

	IF segid = SBLANK THEN
		RETURN .(0);	/* blank name */
	CALL iseek(0,0);	/* seek start of file */
	CALL getRecord;		/* junk the modhdr record */
	DO WHILE 1;
		CALL getRecord;	/* scan comdef records */
		IF inRecord.rectyp <> R$COMDEF THEN
			CALL badRecordSeq;
		DO WHILE in$p < .erec;	/* look for the seg */
			IF segid = cdef.segid THEN
				RETURN .cdef.name(0);	/* return pointer to name */
			in$p = in$p + size(cdef) + cdef.name(0);	/* skip to next seg/name */
		END;
	END;
END getCommonName;

printMemoryMap: PROCEDURE PUBLIC;
	DECLARE (minStart, q) ADDRESS;
	DECLARE (i, wrapped, addCRLF) BYTE;
	DECLARE curSegFrag BASED curSegFrag$p SEGFRAG$T;
	DECLARE omfName BASED in$p STRUCTURE(len BYTE, name(1) BYTE);

	IF MapSeen THEN		/* print map header info if asked for */
	DO;
		CALL printListingHeader(.aMemoryMapOfMod, size(aMemoryMapOfMod)); /* '\r\nMEMORY MAP OF MODULE ' */
		IF isMain THEN
		DO;
			CALL binasc(startAddr, 16, '0', .aModuleStartAdd(21), 4);  /* insert start address in string */
			CALL printString(.aModuleStartAdd, size(aModuleStartAdd)); /* 'MODULE START ADDRESS XXXXH' */
		END;
		ELSE
		DO;
			CALL printString(.aModuleIsNotAMa, size(aModuleIsNotAMa)); /* 'MODULE IS NOT A MAIN MODULE' */
			IF startSeen THEN
				CALL printString(.aStartControlIg, size(aStartControLIg)); /* ', START CONTROL IGNORED' */
			IF restart0Seen THEN
				CALL printString(.aRestartControl, size(aRestartControl)); /* ', RESTART CONTROL IGNORED' */
		END;
		CALL printString(.aStartStopLengt, 34);	/* '\r\nSTART   STOP LENGTH REL NAME\r\n\n' */
	END;

	segBases(SSTACK) = segBases(SSTACK) - segSizes(SSTACK);
	DO q = 1 TO 254;
		IF segSizes(i := segOrder(q)) > SABS  OR (segFlags(i) AND 20H) <> 0 THEN
			CALL addSegFrag(segFlags(i), i, segBases(i), segSizes(i));
	END;

	minStart, wrapped = 0;
	/* emit information on all of the blocks */
	curSegFrag$p = topHeap;
	DO WHILE curSegFrag$p <> topDataFrags; 	/* done ? */
		curSegFrag$p = curSegFrag$p - size(curSegFrag);	/* point to start of block info */
		CALL binasc(curSegFrag.start, 16, '0', .aAddresses, 4);	/* start address */
		aAddresses(7) = '*';		/* assume no length so show **** for stop address */
		aAddresses(8) = '*';
		aAddresses(9) = '*';
		aAddresses(10) = '*';
		IF curSegFrag.len > 0 THEN		/* we have length so fill stop address */
			CALL binasc(curSegFrag.start + curSegFrag.len - 1, 16, '0', .aAddresses(7), 4);
		CALL binasc(curSegFrag.len, 16, ' ', .aAddresses(14), 4);	/* length */
		/* copy the start and stop into the memory overlap message */
		CALL mem$mov(4, .aAddresses, .aMemOverlap(23));
		CALL mem$mov(4, .aAddresses(7), .aMemOverlap(37));
		IF curSegFrag.start + curSegFrag.len > minStart THEN	/* none or not total overlap */
		DO;
			aMemOverlap(37) = '*';		/* clear out the through address */
			aMemOverlap(38) = '*';
			aMemOverlap(39) = '*';
			aMemOverlap(40) = '*';
			/* if we are overlap put in the end of the last block */
			IF curSegFrag.len > 0 AND (minStart > 0  OR wrapped <> 0) THEN
				CALL binasc(minStart - 1, 16, '0', .aMemOverlap(37), 4);
		END;
		addCRLF = 0;
		IF mapSeen THEN	/* if MAP is being produced */
		DO;
			aAddresses(21) = alignNames(curSegFrag.flags AND AMASK);	/* add the align type */
			CALL printString(.aAddresses, size(aAddresses));	/* and print the address info */
			IF curSegFrag.seg >= SNAMED THEN				/* seg is named common */
			DO;
				CALL printString(.('/'), 1);			/* print the / */
				in$p = getCommonName(curSegFrag.seg);		/* look up the common name in the input file */
				CALL printString(.omfName.name, omfName.len);	/* print it and the closing / */
				CALL printString(.('/'), 1);
			END;
			ELSE							/* standard so used the canned names */
				CALL printString(.segNames(SHL(curSegFrag.seg, 3)), 8);	/* shl 3 is *8 */
		END;
		IF curSegFrag.start < minStart OR wrapped <> 0 THEN			/* emit any overlap notification */
		DO;
			addCRLF = TRUE;
			/* '  (MEMORY OVERLAP FROM XXXXH THROUGH XXXXH)'  values filled in above */
			CALL conAndPrint(.aMemOverlap, size(aMemOverlap));
		END;
		IF (curSegFrag.flags AND FWRAP0) <> 0 THEN				/* and if wrapped to 0 */
		DO;
			addCRLF = TRUE;
			/* '  (0 LENGTH SEGMENT WRAPPED AROUND TO 0000H)' */
			CALL conAndPrint(.a0LengthSegment, size(a0LengthSegment));
		END;
		IF addCRLF THEN							/* finish of any started line */
			CALL conAndPrint(.crlf, 2);
		ELSE IF MapSeen THEN
			CALL printcrlf;
		IF curSegFrag.start + curSegFrag.len = 0 AND curSegFrag.len > 0 THEN		/* we wrapped to 0 */
		DO;
			minStart = 0;
			wrapped = FWRAP0;
		END;
		ELSE IF wrapped = 0 THEN
			IF curSegFrag.start + curSegFrag.len > minStart THEN		/* update the minStart */
				minStart = curSegFrag.start + curSegFrag.len;
	END;	/* DO WHILE */
END printMemoryMap;






skipspc: PROCEDURE(pch) ADDRESS PUBLIC;
	DECLARE pch ADDRESS;
	DECLARE ch BASED pch BYTE;
	
	DO WHILE ch = ' ';
		pch = pch + 1;
	END;
	RETURN pch;
END skipspc;




END locate4;
