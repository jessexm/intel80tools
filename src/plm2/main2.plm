main2: DO;
$include(main2.ipx)

declare wAF54(*) address public initial(
	11Bh, 14Bh, 12Bh, 12Bh, 11Bh, 14Bh, 60h, 60h,
	62h, 62h, 5Bh, 62h, 0Bh, 1E4h, 1E7h, 1E8h,
	1EEh, 1F1h, 8Dh, 0CFh, 10Bh, 0Eh, 12h, 14h,
	0EBh, 0EBh, 0EBh, 0A9h, 9Ah, 96h, 0A1h, 69h,
	68h, 70h, 76h, 90h, 0EBh, 10Bh, 15Bh, 18Bh,
	1BBh, 19Bh, 17Bh, 16Bh, 58h, 19h, 20h, 27h,
	19h, 20h, 27h, 16h, 17h, 18h, 16h, 17h,
	18h, 0Ah, 38h, 3Eh, 67h, 2Ah, 6, 0Ch,
	1DEh, 80h, 43h, 45h, 47h, 1DBh, 49h, 0C9h,
	0CDh, 0CEh, 0B7h, 0BAh, 0BDh, 41h, 42h, 44h,
	46h, 48h, 4Ah, 4Bh, 4Ch, 41h, 42h, 44h,
	46h, 48h, 4Ah, 4Bh, 4Ch, 7Ch, 42h, 44h,
	46h, 48h, 48h, 46h, 44h, 42h, 7Ch, 42h,
	44h, 46h, 48h, 48h, 46h, 44h, 42h, 4Fh,
	42h, 44h, 46h, 48h, 4Ah, 4Dh, 4Eh, 57h,
	50h, 51h, 52h, 53h, 54h, 55h, 56h, 0C0h,
	0C3h, 0C6h, 0CFh, 1DCh, 0, 0	/* wB05C & wB05E assumed at end */
);

declare	tx2Buf(512) byte,
	tx1Buf(512) byte,
	blkCurInfo(20) address public,
	wB488(20) address public,
	wB4B0(20) address public,
	wB4D8(20) address public,
	extProcId(20) byte public,
	procChainNext(20) byte public,
	wB528(10) address public,
	wB53C(10) address public,
	tx2opc(255) byte public initial(T2$SEMICOLON, T2$LOCALLABEL, T2$SEMICOLON, T2$SEMICOLON),
	tx2Aux1b(255) byte public initial(12, 9),
	tx2Aux2b(255) byte public,
	tx2op1(255) address public,
	tx2op2(255) address public,
	tx2op3(255) address public initial(0, 0, 0, 0),
	tx2Auxw(255) address public initial(0, 1),
	bC045(9) byte public,
	bC04E(9) byte public,
	boC057(9) byte public,
	boC060(9) byte public,
	boC069(9) byte public,
	boC072(9) byte public,
	boC07B(9) byte public,
	wC084(9) address public,
	wC096(9) address public,
	bC0A8(9) byte public,
	bC0B1 byte public,
	bC0B2 byte public,
	bC0B3(2) byte public,
	bC0B5(2) byte public,
	bC0B7(2) byte public,
	bC0B9(2) byte public,
	bC0BB(2) byte public,
	bC0BD(2) byte public,
	bC0BF(2) byte public,
	bC0C1(2) byte public,
	bC0C3(125) byte public,
	bC140(125) byte public,
	bC1BD byte public initial (0),
	tx2qp byte public,
	bC1BF byte public initial(4),
	tx2qEnd byte public initial(4),
	pc address public initial(0),
	wC1C3 address public initial(0),
	wC1C5 address public initial(0),
	wC1C7 address public initial(0),
	blkSP byte public initial(0),
	blkOverCnt byte public initial(0),
	procCallDepth byte public initial(0),
	boC1CC byte public initial(0),
	boC1CD byte public,
	eofSeen byte public initial(0),
	wC1CF address public initial(0),
	curOp byte public,
	bC1D2 byte public,
	padC1D3 byte public,
	curExtProcId byte public initial(1),
	procChainId byte public initial(0),
	wC1D6 address public,
	boC1D8 byte public initial(0),
	bC1D9 byte public,
	cfrag1 byte public,
	bC1DB byte public,
	wC1DC(5) address public,
	bC1E6 byte public,
	buf$C1E7(34) byte public,
	bC209(*) byte public initial(4, 5, 3, 2, 0, 1),
	boC20F byte public initial(0);




DECLARE copyRight(*) BYTE DATA('(C) 1976, 1977, 1982 INTEL CORP');

	DECLARE finalise LABEL PUBLIC;

	sub$3F27: PROCEDURE;
		DECLARE emsg(*) BYTE DATA('COMPILER ERROR: INSUFFICIENT MEMORY FOR CODE GENERATION');
		botMem = .MEMORY + 256;
		if w3822 < botMem then
			call fatal(.emsg, length(emsg));
		call creatf(.tx1File, .tx1Buf, 512, 2);
		call creatf(.tx2File, .tx2Buf, 512, 1);
		call FILLX(10, .wC1DC, 0);
		blkCurInfo(0) = procInfo(1) + botInfo;
		programErrCnt = 0;
	end sub$3F27;


	sub$3F7D: PROCEDURE;
		curInfo$p = procInfo(1) + botInfo;
		call setDimension(pc);
		call setBaseVal(wC1C5);
		call fflush(.tx1File);
	end sub$3F7D;

	call sub$3F27;
	do while 1;
		call fillTx2Q;
		call sub$67A9;
		if tx2opc(4) = T2$EOF then
			goto finalise;
		call sub$689E;
		call sub$6BD6;
		call sub$A153;
	end;

	finalise:
		call sub$3F7D;
		call chain(.overlay3);
END;
