plm2c: DO;
$include(plm2c.ipx)


sub$6BD6: procedure public;
	declare (bC259, bC25A) byte;



	sub$6C54: procedure(arg1b);
	    declare arg1b byte;
	    if arg1b <> 0 then
		tx2Auxw(arg1b) = tx2Auxw(arg1b) + 1;  
	end;



	sub$6C73: procedure(arg1b);
	    declare arg1b byte;
	    if OPTIMIZE  then
		do while tx2qp - 1 > arg1b;
		    arg1b = arg1b + 1;
		    if tx2opc(arg1b) = curOp then
		    do;
			if tx2op1(arg1b) = tx2op1(tx2qp) then
			do;
			    if tx2op2(arg1b) = tx2op2(tx2qp) then
			    do;
				if tx2Aux1b(arg1b) = tx2Aux1b(tx2qp) then
				do;
				    if tx2op3(arg1b) <> 0ff00h then
				    do;
				    	tx2opc(tx2qp) = T2$OPTBACKREF;
				    	tx2op1(tx2qp) = arg1b;
				    	return;
				    end;
				end;
			    end;
			end;
		    end;
		end; 
	    if (bC1D2 and 0c0h) = 0 then
	    do;
		call sub$6C54(tx2op1(tx2qp));
		call sub$6C54(tx2op2(tx2qp));
	    end;
	    tx2op3(tx2qp) = tx2qp;
	end;


	sub$6D52: procedure;
	    declare boC25D byte;

	 	sub$6EAB: procedure(arg1w$p);
		    declare arg1w$p address;
		    declare arg1w based arg1w$p address;
		    if arg1w <> 0 then
		    do;
			if tx2opc(arg1w) = T2$OPTBACKREF then 
			    arg1w = tx2op1(arg1w);
		    end;
		end;

	


		sub$6EE1: procedure(arg1b);
		    declare arg1b byte;

			sub$6F20: procedure(arg1b);
			    declare arg1b byte;
			    declare i byte;
			    if (i := tx2opc(arg1b)) = T2$BASED then
				boC25D = 0ffh;
			    else if i = T2$BYTEINDEX or i = T2$WORDINDEX then
			    do;
				if tx2opc(tx2op2(arg1b)) <> T2$NUMBER then
				    boC25D = 0ffh;
				else
				do;
				    curInfo$p = tx2op1(tx2op1(arg1b));
				    if tx2op2(tx2op2(arg1b)) >= getDimension or testInfoFlag(F$AT) then
					boC25D = 0ffh;
				end;
			    end;
			    else if i = T2$VARIABLE then
			    do;
				curInfo$p = tx2op1(arg1b);
				if testInfoFlag(F$AT) then
				    boC25D = 0ffh;
			    end;
			end sub$6F20;

	/* sub$6EE1 */
		    boC25D = 0;
		    if tx2opc(arg1b) = T2$MEMBER then
		    do;
			call sub$6F20(tx2op1(arg1b));
			call sub$6F20(tx2op2(arg1b));
		    end;
		    else
			call sub$6F20(arg1b);
		end;





		sub$6FE2: procedure byte;
		    declare bC263 byte;

		    sub$7018: procedure(arg1b);
			declare arg1b byte;
			if tx2opc(arg1b) <> T2$CALL then
			    arg1b = tx2op3(arg1b);
			if arg1b <> 0 then
			    if arg1b > bC263 then
				bC263 = arg1b;
		    end;

		    if boC25D then
			bC263 = bC259;
		    else
			bC263 = bC25A;

		    call sub$7018(tx2op1(tx2qp));
		    call sub$7018(tx2op2(tx2qp));
		    return bC263;
		end;


		sub$7055: procedure;
			bsub$70BC: procedure(arg1b) byte;
			    declare arg1b byte;
			    call sub$6EE1(tx2op1(arg1b));
			    if boC25D then
				return TRUE;
			    if tx2op1(arg1b) = 0ach then
			    do;
				curInfo$p = tx2op1(tx2op1(arg1b));
				if testInfoFlag(F$AUTOMATIC) then
				    return TRUE;
			    end;
			    return FALSE;
			end;
		/* sub$7055 */
		    if bsub$70BC(tx2qp) then
			bC25A = tx2qp;
		    if tx2op3(tx2op1(bC259 := tx2qp)) <> 0ff00h then
			tx2op3(tx2op1(tx2qp)) = tx2qp;
		    call sub$6C54(tx2op1(tx2qp));
		    call sub$6C54(tx2op2(tx2qp));
		end;

	    call sub$6EAB(.tx2op1(tx2qp));
	    call sub$6EAB(.tx2op2(tx2qp));
	    if curOp = T2$STORE then
		call sub$7055;
	    else if procCallDepth > 0 then
	    do;
		call sub$6C54(tx2op1(tx2qp));
		call sub$6C54(tx2op2(tx2qp));
		if curOp = T2$CALL then
		    procCallDepth = procCallDepth - 1;  
		else if curOp = T2$MOVE or curOp = T2$CALLVAR then
		do;
		    procCallDepth = procCallDepth - 1;  
		    call sub$6EAB(.tx2op3(tx2qp));
		    call sub$6C54(tx2op3(tx2qp));
		end;
		else
		    tx2op3(tx2qp) = 0ff00h;
	    end;
	    else if curOp = T2$OUTPUT or curOp = T2$TIME then
	    do;
		call sub$6C54(tx2op1(tx2qp));
		call sub$6C54(tx2op2(tx2qp));
	    end;
	    else
	    do;
		tx2op3(tx2qp) = 0;
		call sub$6EE1(tx2qp);
		call sub$6C73(sub$6FE2);
		if curOp = T2$JMPFALSE then
		do;
		    if tx2opc(tx2qp - 1) = T2$NOT then
		    do;
			boC20F = TRUE;
			tx2op2(tx2qp) = tx2op1(tx2qp - 1);
			call sub$56A0(tx2qp, tx2qp - 1);
			tx2opc(tx2qp) = T2$SEMICOLON;
		    end;
		end;
	    end;
	end;






	sub$7111: procedure;
	    if procCallDepth > 0 then
		tx2op3(tx2qp) = 0ff00h;
	    else
	    do;
		tx2op3(tx2qp) = 0;
		if curOp = T2$VARIABLE then
		do;
		    curInfo$p = tx2op1(tx2qp);
		    if testInfoFlag(F$AT) then
			call sub$6C73(bC259);
		    else
			call sub$6C73(bC25A);
		end;
		else
		    call sub$6C73(bC25A);
	    end;
	end;

/* sub$6BD6 */
	bC259 = 4;
	bC25A = 4;
	do tx2qp = 4 to bC1BF - 1;
		tx2Auxw(tx2qp) = 0;
		curOp = tx2opc(tx2qp);
		bC1D2 = b5124(curOp);
		if (bC1D2 and 0c0h) = 0 then
			call sub$6D52;
		else if (bC1D2 and 0c0h) = 40h then
			call sub$7111;
		if curOp = T2$BEGCALL or curOp = T2$BEGMOVE then
			procCallDepth = procCallDepth + 1;  

	end;
end;
END;
