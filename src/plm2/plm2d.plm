plm2d: DO;
$nolist
declare lit literally 'literally',
	true lit '0ffh',
	false lit '0',
	boolean lit 'byte',
	cr lit '0dh',
	lf lit '0ah';

$include(:f3:data.inc)
$include(t2code.inc)
declare	tx2Buf(512) byte external,
	tx1Buf(512) byte external,
	blkCurInfo(20) address external,
	wB488(20) address external,
	wB4B0(20) address external,
	wB4D8(20) address external,
	extProcId(20) byte external,
	procChainNext(20) byte external,
	wB528(10) address external,
	wB53C(10) address external,
	tx2opc(255) byte external,
	tx2Aux1b(255) byte external,
	tx2Aux2b(255) byte external,
	tx2op1(255) address external,
	tx2op2(255) address external,
	tx2op3(255) address external,
	tx2Auxw(255) address external,
	bC045(9) byte external,
	bC04E(9) byte external,
	boC057(9) byte external,
	boC060(9) byte external,
	boC069(9) byte external,
	boC072(9) byte external,
	boC07B(9) byte external,
	wC084(9) address external,
	wC096(9) address external,
	bC0A8(9) byte external,
	bC0B1 byte external,
	bC0B2 byte external,
	bC0B3(2) byte external,
	bC0B5(2) byte external,
	bC0B7(2) byte external,
	bC0B9(2) byte external,
	bC0BB(2) byte external,
	bC0BD(2) byte external,
	bC0BF(2) byte external,
	bC0C1(2) byte external,
	bC0C3(125) byte external,
	bC140(126) byte external,
	tx2qp byte external,
	bC1BF byte external,
	tx2qEnd byte external,
	pc address external,
	wC1C3 address external,
	wC1C5 address external,
	wC1C7 address external,
	blkSP byte external,
	blkOverCnt byte external,
	procCallDepth byte external,
	boC1CC byte external,
	boC1CD byte external,
	eofSeen byte external,
	wC1CF address external,
	curOp byte external,
	bC1D2 byte external,
	padC1D3 byte external,
	curExtProcId byte external,
	procChainId byte external,
	wC1D6 address external,
	boC1D8 byte external,
	bC1D9 byte external,
	cfrag1 byte external,
	bC1DB byte external,
	wC1DC(5) address external,
	bC1E6 byte external,
	buf$C1E7(34) byte external,
	bC209(1) byte external,
	boC20F byte external,
	finalise label external;

/* data tables */
declare	b5112(1) byte external,
	b51E3(1) byte external,
	b5048(1) byte external,
	b5202(1) byte external,
	b5124(1) byte external,
	b50AD(1) byte external,
	b5221(1) byte external,
	w502A(1) address external;


sub$5748: procedure(arg1b) byte external; declare arg1b byte; end;
sub$5FBF: procedure(arg1b, arg2w$p, arg3w$p) external;
	declare arg1b byte, arg2w$p address, arg3w$p address; end;
sub$611A: procedure external; end;
sub$5F4B: procedure(arg1w, arg2w, arg3b, arg4b) external;
	declare arg1w address, arg2w address, arg3b byte, arg4b byte; end;


$list

sub$717B: procedure public;
	declare bC266 byte,
		(wC267, wC269, wC26B, wC26D) address,
		bC26F byte,
		p address,
		(bC272, bC273) byte;

	bsub$7254: procedure(arg1b, arg2w) byte;
	    declare arg1b byte, arg2w address;
	    if arg1b = 0 then
	    do;
		if tx2Aux2b(bC26F) <> 4 then
		    return FALSE;
	    end;
	    else if arg1b <> 3 then
	    do;
		if tx2Aux2b(bC26F) <> 8 then
		    return FALSE;
		if arg2w <> 0 then
		do;
		    if arg1b = 2 then
			return FALSE;
		    if arg1b = 4 then
		    do;
			if wC269 <> 0 then
			   return FALSE;
		    end;
		    else if arg1b = 5 then
		    do;
			if wC269 <> wC26D then
			   return FALSE;
		    end;
		end;
	    end;
	    else if arg2w = 4000h then
		    return FALSE;
	    return TRUE;
	end;


	sub$72F2: procedure address;
	    do case bC266;
		return wC267;
		return wC267 + wC26B;
		return wC267 - wC26B;
		return wC267 * wC26B;
		return wC267 / wC26B;
		return wC267 mod wC26B;
		return wC267 and wC26B;
		return wC267 or wC26B;
		return wC267 xor wC26B;
		return wC267 + wC26B;
		return wC267 + wC26B;
		return wC267 + wC26B + wC26B;
		return wC267 + wC26B;
		return -wC267;
		return not wC267;
		return low(wC267);
		return high(wC267);
		return wC267;
	    end;
	end;

	sub$73C5: procedure;
	    if curOp = T2$MEMBER and tx2Aux2b(tx2op1(tx2qp)) = 0ah then
	    do;
		bC272 = tx2Aux1b(tx2op2(tx2qp));
		bC273 = 0Ah;
	    end;
	    else 
		do case b5112(bC266) and 7;
		    do;
			bC272 = 0;
			bC273 = 8;
		    end;
		    do;
			if tx2Aux1b(tx2op1(tx2qp)) = 0 and tx2Aux1b(tx2op2(tx2qp)) = 0 then
			   bC272 = 0;
			else
			   bC272 = 1;
			bC273 = 8;
		    end;
		    do;
			bC272 = 1;
			bC273 = 8;
		    end;
		    do;
			bC272 = tx2Aux1b(tx2op1(tx2qp));
			bC273 = tx2Aux2b(tx2op1(tx2qp));
		    end;
		    do;
			bC272 = tx2Aux1b(tx2op2(tx2qp));
			bC273 = tx2Aux2b(tx2op2(tx2qp));
		    end;
		    do;
			bC272 = sub$5748(tx2Aux1b(tx2op2(tx2qp)));
			bC273 = 8;
		    end;
		end;
	    if wC269 = wC26D then
		curInfo$p = 0;
	    else if wC26D = 0  then
		curInfo$p = tx2op1(tx2op1(tx2qp));
	    else
		curInfo$p = tx2op1(tx2op2(tx2qp));
	end;

/* sub$717B */
	bC266 = curOp - 12h;
	bC26F = tx2op1(tx2qp);
	call sub$5FBF(bC26F, .wC267, .wC269);
	if bsub$7254(shr(b5112(bC266), 6), wC269) then
	do;
		bC26F = tx2op2(tx2qp);
		call sub$5FBF(bC26F, .wC26B, .wC26D);
		if bsub$7254(shr(b5112(bC266), 3) and 7h, wC26D) then
		do;
			call sub$611A;
			p = sub$72F2;
			call sub$73C5;
			if bC272 = 0 and bC273 = 8 then
				p = p and 0FFh;
			call sub$5F4B(p, curInfo$p, bC272, bC273);
			bC1D2 = b5124(curOp := tx2opc(tx2qp));
		end;
	end;
end;


sub$7550: procedure public;

	bsub$765B: procedure(arg1b, arg2b, arg3b) byte;
		declare arg1b byte, arg2b byte, arg3b byte,
			bC27A byte, (wC27B, wC27D) address,
			(bC27F, i) byte, p address;


		bsub$76E2: procedure(arg1b) byte;
			declare arg1b byte;
			if (bC27F and 40h) <> 0 then
			do;
				if tx2Aux1b(arg1b) = 1 then
					return TRUE;
				if tx2Aux1b(arg1b) = 3 then
					return TRUE;
				return FALSE;
			end;
			else if tx2Aux1b(arg1b) = 0 then
				return TRUE;
			else if tx2Aux1b(arg1b) = 2 then
				return TRUE;
			else if tx2Aux1b(arg1b) = 8 then
				return TRUE;
			else
				return FALSE;
		end;

		sub$7754: procedure;
			declare (i, j) byte;
			i = tx2qp + 1;
			do while tx2opc(i) = T2$OPTBACKREF and i < bC1BF;
				i = i + 1;  
			end;
			j = tx2qp;
			if tx2opc(i) = T2$STORE then
			do;
				if arg3b= tx2op1(i) then
				do;
					if tx2op2(i) = j then
					do;
						if tx2Auxw(j) = 1 then
						do;
							bC27A = 6;
							tx2opc(i) = T2$SEMICOLON;
							tx2Auxw(j) = 0;
							tx2Auxw(arg3b) = tx2Auxw(arg3b) - 1;  
						end;
					end;
				end;
			end;
		end;

		bsub$7801: procedure  byte;
			if wC27D <> 0 or (curOp < T2$BASED and tx2Aux2b(arg2b) <> 8) then
				return FALSE;
			if (bC27F and 20h) <> 0 then
				if not bsub$76E2(arg3b) then
					return FALSE;
			if (bC27F and 1) <> 0 then
				if bsub$76E2(arg2b) <> bsub$76E2(arg3b) then
					return FALSE;
			if (bC27F and 4) <> 0 then
			do;
				if (bC27F and 8) <> 0 then
					if wC27B <> 0 then
						return TRUE;
					else
						return FALSE;
				p = w502A(shr(b5048(arg1b), 3));
				if p <> wC27B then
					return FALSE;
				if (bC27F and 80h) <> 0 then
					call sub$7754;
				return 0FFh;
			end;
			if (bC27F and 40h) = 0 then
			do;
				p = w502A(shr(b5048(arg1b), 3));
				bC27A = wC27B mod p;
				return TRUE;
			end;
			else if wC27B <= 4 then
			do;
				bC27A = wC27B;
				return TRUE;
			end;
			else
				return FALSE;
		end;

		sub$7925: procedure;
			declare (i, j, k) byte;
			arg1b = arg1b - 1;
			i = b5221(arg1b) + bC27A;
			j = b5048(arg1b) and 3;
			if i = 0ADh then
			do;
				if j = 0 then
					wC27B = 0;
				call sub$611A;
				bC27F = 0;
				k = 1;
				if curOp <> T2$STAR then
				    if curOp <> T2$SLASH then
					if curOp <> T2$MOD then
					    if wC27B < 100h then
						if bsub$76E2(arg2b) then
						    if arg3b = 0 then
							k = 0;
						    else if bsub$76E2(arg2b) then
							k = 0;
				call sub$5F4B(wC27B, 0, k, 8);
			end;
			else
			do;
				if j = 1 then
				do;
					tx2op1(tx2qp) = arg3b;
					tx2Auxw(arg2b) = tx2Auxw(arg2b) - 1;  
				end;
				else
				do;
					if tx2op2(tx2qp) <> 0 then
						tx2Auxw(tx2op2(tx2qp)) = tx2Auxw(tx2op2(tx2qp)) - 1;  
					if (bC1D2 and 4) <> 0 then
					do;
						tx2op1(tx2qp) = tx2op2(1);
						if boC20F then
						do;
							i = 43h - i;
							boC20F = 0;
						end;
					end;
				end;
				tx2opc(tx2qp) = i;
				tx2op2(tx2qp) = 0;
			end;
			bC1D2 = b5124(curOp := i);
		end;

/* bsub$765B */
		call sub$5FBF(arg2b, .wC27B, .wC27D);
		bC27A = 0;
		i = TRUE;

		do while i;
			if (bC27F := b50AD(arg1b)) = 0ffh then
				return FALSE;
			if (bC27F and 10h) <> 0 then
			do;
				i = not bsub$76E2(arg2b);
				if (bC27F and 4) <> 0 and not i then
					i = not bsub$7801;
			end;
			else 
				i = not bsub$7801;
			arg1b = arg1b + 1;  
		end;
		call sub$7925;
		return TRUE;
	end bsub$765B;

/* sub$7550 */
	if curOp <= T2$GT then
	do;
		if tx2opc(tx2qp+1) = T2$JMPFALSE and tx2Auxw(tx2qp) = 1 then
		do;
			tx2opc(tx2qp + 1) = T2$JNZ;
			tx2op1(tx2qp + 1) = tx2op2(1);
			if boC20F then
			do;
				tx2op2(tx2qp + 1) = bC209(curOp);
				boC20F = 0;
			end;
			else
				tx2op2(tx2qp + 1) = curOp;
			tx2Auxw(tx2qp) = 0;
		end;
		else
			tx2opc(tx2qp), curOp = curOp + 26h;
	end;
	else if bsub$765B(b5202(curOp), tx2op2(tx2qp), tx2op1(tx2qp)) then
		;
	else if bsub$765B(b51E3(curOp), tx2op1(tx2qp), tx2op2(tx2qp)) then
			;
end;


end;
