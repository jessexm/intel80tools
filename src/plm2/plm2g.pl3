plm2g: DO;
$include(plm2g.ipx)

declare curParamCnt byte,
	bC2D1 byte,
	(bC2D2, bC2D3) byte,
	wC2D4 address;


findParamInfo: procedure(arg1b) public;
	declare arg1b byte;
	curInfo$p = blkCurInfo(blkSP);
	do while arg1b <> 0;
		call advNxtInfo;
		arg1b = arg1b - 1;  
	end;
end;



sub$9514: procedure public;
	if getType = ADDRESS$T then
	do;
		wC1DC(0) = bC2D1;
		call encodeFragData(CF$MOVMRPR);
		pc = pc + 3;
	end;
	else
	do;
		wC1DC(0) = bC2D1;
		call encodeFragData(CF$MOVMLR);
		pc = pc + 1;  
	end;
	if bC2D2 <> curParamCnt then
	do;
		call encodeFragData(CF$DCXH);
		pc = pc + 1;  
	end;
end;

sub$9560: procedure public;
	declare i byte;
	if (i := curParamCnt) = 1 then
		bC2D1 = 1;
	else
		bC2D1 = 2;
	do bC2D2 = 1 to curParamCnt;
		call findParamInfo(i);
		if bC2D2 = 2 then
			bC2D1 = 1;
		else if bC2D2 = 3 then
		do; 
			wC1DC(0) = 2;	/*  pop d */
			wC1DC(1) = 8;
			call encodeFragData(CF$POP);
			wC1DC(0) = 1;	/*  pop b */
			wC1DC(1) = 8;
			call encodeFragData(CF$POP);
			pc = pc + 2;
		end;
		else if bC2D2 > 3 then
		do;
			wC1DC(0) = 1;	/*  pop b */
			wC1DC(1) = 8;
			call encodeFragData(CF$POP);
			pc = pc + 1;  
		end;
		call sub$9514;
		i = i - 1;  
	end;
	if curParamCnt > 2 then
	do; 
		wC1DC(0) = 2;	/*  push d */
		wC1DC(1) = 8;
		call encodeFragData(CF$PUSH);
		pc = pc + 1;  
	end;
end;

sub$9624: procedure(arg1w) public;
	declare arg1w address;
	wC1DC(0) = 9;
	wC1DC(1) = arg1w;
	call encodeFragData(CF$6);
	pc = pc + 4;
end;


sub$9646: procedure(arg1w) public;
	declare arg1w address;
	if shr(arg1w, 1) + (arg1w and 1) <= 5 then
	do; 
		if arg1w then
		do;
			call encodeFragData(CF$DCXSP);
			pc = pc + 1;  
		end;
		do while arg1w > 1;
			wC1DC(0) = 3;	/*  push h */
			wC1DC(1) = 8;
			call encodeFragData(CF$PUSH);
			pc = pc + 1;  
			arg1w = arg1w - 2;
		end; 
	end;
	else
	do;
			call sub$9624(-arg1w);
			call encodeFragData(CF$SPHL);
			pc = pc + 1;  
	end;
end;


inxh: procedure public;
	wC1DC(0) = 3;
	call encodeFragData(CF$INX);
	pc = pc + 1;  
end;


opB: procedure(arg1b) public;
	declare arg1b byte;
	wC1DC(0) = 1;
	call encodeFragData(arg1b);
	pc = pc + 1;  
end;

opD: procedure(arg1b) public;
	declare arg1b byte;
	wC1DC(0) = 2;
	call encodeFragData(arg1b);
	pc = pc + 1;  
end;


sub$9706: procedure public;
	call inxh;
	if getType = ADDRESS$T then
	do;
		call opB(CF$MOVLRM);
		if bC2D3 = 1 then
			call opD(CF$MOVMLR);

		call inxh;
		call opB(CF$MOVHRM);
	end;
	else
	do;
		call opB(CF$MOVHRM);
		if bC2D3 = 1 then
			call opD(CF$MOVMLR);
		call inxh;
	end;
	if bC2D3 = 1 then
		call opD(CF$MOVMHR);
end;



movDEM: procedure public;
	call opD(CF$MOVRPM);
	pc = pc + 2;
end;


sub$975F: procedure public;
	wC1DC(0) = bC2D1;
	wC1DC(1) = 8;
	call encodeFragData(CF$PUSH);
	pc = pc + 1;  
	if getType = BYTE$T then
	do;
		call encodeFragData(CF$INXSP);
		pc = pc + 1;  
	end;
end;


sub$978E: procedure public;
	if (bC2D3 := curParamCnt) > 2 then
		call sub$9624(wC2D4);
	if curParamCnt = 1 then
		bC2D1 = 1;
	else
		bC2D1 = 2;
	do bC2D2 = 1 to curParamCnt;
		call findParamInfo(bC2D3);
		if bC2D2 > 3 then
			call sub$9706;
		else if bC2D2 = 3 then
		do;
			call movDEM;
			call sub$9706;
		end;
		else if getType = BYTE$T then
		do;
			wC1DC(0) = bC2D1;
			call encodeFragData(CF$MOVHRLR);
			pc = pc + 1;  
		end;
		call sub$975F;
		bC2D1 = 1;
		bC2D3 = bC2D3 - 1;  
	end;
end;


sub$981C: procedure public;
	declare (i, j) byte;
	curParamCnt = getParamCnt;
	if testInfoFlag(F$INTERRUPT) then
	do;
		do j = 0 to 3;
			wC1DC(0) = 3 - j;
			wC1DC(1) = 8;	/*  push h, push d, push b, push psw */
			call encodeFragData(CF$PUSH);
			pc = pc + 1;  
		end;
	end;
	if testInfoFlag(F$REENTRANT) then
	do;
		wC1C7 = getParentVal; /* or Size */;
		if curParamCnt > 0 then
		do;
			call findParamInfo(curParamCnt);
			wC2D4 = wC1C7 - getLinkVal - 1;
			if getType = ADDRESS$T then
				wC2D4 = wC2D4 - 1;  
			call sub$9646(wC2D4);
			call sub$978E;
		end;
		else
			call sub$9646(wC1C7);

		if curParamCnt > 2 then
			wC1C7 = wC1C7 + shl(curParamCnt - 2, 1);

		wC1C5 = 0;
	end;
	else
	do;
		if curParamCnt > 0 then
		do;
			call findParamInfo(curParamCnt);	/*  locate info for first param */
			if getType = ADDRESS$T then
				i = 1;
			else
				i = 0;
			wC1DC(0) = 3;
			wC1DC(1) = 0bh;
			wC1DC(2) = i;
			wC1DC(3) = curInfo$p - botInfo;	/*  info for first param */
			call encodeFragData(CF$7);
			call sub$9560;
			pc = pc + 3;
		end;
		wC1C7 = 0;
		if curParamCnt > 2 then
			wC1C5 = shl(curParamCnt - 2, 1);
		else
			wC1C5 = 0;
	end;
end;

sub$994D: procedure public;
	declare (i, j) byte;
	declare localLabels based localLabels$p(1) address,
		barray based w381E(1) byte,
		mwords based botMem(1) address;

	if curOp = T2$LABELDEF then
	do;
		boC1CC = 0;
		curInfo$p = tx2op1(tx2qp) + botInfo;
		call setLinkVal(pc);
	end;
	else if curOp = T2$LOCALLABEL then
	do;
		boC1CC = 0;
		localLabels(tx2op1(tx2qp)) = pc;
		barray(tx2op1(tx2qp)) = curExtProcId;
	end;
	else if curOp = T2$CASELABEL then
	do;
		localLabels(tx2op1(tx2qp)) = pc;
		barray(tx2op1(tx2qp)) = curExtProcId;
		if (w3822 - botMem)/2 >= wC1CF then
		do;
			mwords(wC1CF) = tx2op1(tx2qp);
			wC1CF = wC1CF + 1;  
		end;
		else
		do;
			call emitTopItem;
			call tx2SyntaxError(ERR202);	/*  LIMIT EXCEEDED: NUMBER OF */
						/*  ACTIVE CASES */
		end;
	end;
	else if curOp = T2$JMP or curOp = T2$JNC
	   or curOp = T2$JNZ or curOp = T2$GO$TO then
	do;
		i = tx2opc(tx2qp - 1);
		if i = T2$RETURN or i = T2$RETURNBYTE
		  or i = T2$RETURNWORD or i = T2$GO$TO then
			return;
		call sub$5795(0);
	end;
	else if curOp = T2$INPUT or (T2$SIGN <= curOp and curOp <= T2$CARRY) then
	do;
		bC0B7(0) = 0;
		bC0B7(1) = 0;
		bC0B5(0) = 8;
		bC0B5(1) = 8;
		call sub$597E;
		call sub$5D6B(0);
		bC045(0) = 0;
		bC04E(0) = tx2qp;
		boC057(0) = 0;
		bC0A8(0) = 0;
		tx2Aux1b(tx2qp) = 0;
		tx2Aux2b(tx2qp) = 9;
	end;
	else if curOp = T2$STMTCNT then
	do;
			j = tx2qp + 1;

			do while tx2opc(j) <> T2$STMTCNT and tx2opc(j) <> T2$EOF
			    and j < 0FFh;
				if (b5124(tx2opc(j)) and 20h) = 0 or tx2opc(j) = T2$MODULE then
					goto L9B8D;
				j = j + 1;  
			end;
			curOp = CF$134;
			tx2opc(tx2qp) = CF$134;
	end;
L9B8D:
	call emitTopItem;
	pc = pc + (b43F8(curOp) and 1fh);
end;
END;
