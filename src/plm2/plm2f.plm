plm2f: DO;
$nolist
declare lit literally 'literally',
	true lit '0ffh',
	false lit '0',
	boolean lit 'byte',
	cr lit '0dh',
	lf lit '0ah';

$include(:f3:data.inc)
$include(t2code.inc)
$include(:f3:info.inc)
$include(:f3:flags.inc)
declare
	CF$JMPTRUE lit '118',
	CF$MOVE$HL lit '103',
	CF$MOVMLR lit '20',
	CF$STA lit '60',
	CF$SHLD lit '59',
	CF$MOVMRP lit '62';

declare	tx2Buf(512) byte external,
	tx1Buf(512) byte external,
	blkCurInfo(20) address external,
	wB488(20) address external,
	wB4B0(20) address external,
	wB4D8(20) address external,
	extProcId(20) byte external,
	procChainNext(20) byte external,
	wB528(10) address external,
	wB53C(10) address external,
	tx2opc(255) byte external,
	tx2Aux1b(255) byte external,
	tx2Aux2b(255) byte external,
	tx2op1(255) address external,
	tx2op2(255) address external,
	tx2op3(255) address external,
	tx2Auxw(255) address external,
	bC045(9) byte external,
	bC04E(9) byte external,
	boC057(9) byte external,
	boC060(9) byte external,
	boC069(9) byte external,
	boC072(9) byte external,
	boC07B(9) byte external,
	wC084(9) address external,
	wC096(9) address external,
	bC0A8(9) byte external,
	bC0B1 byte external,
	bC0B2 byte external,
	bC0B3(2) byte external,
	bC0B5(2) byte external,
	bC0B7(2) byte external,
	bC0B9(2) byte external,
	bC0BB(2) byte external,
	bC0BD(2) byte external,
	bC0BF(2) byte external,
	bC0C1(2) byte external,
	bC0C3(125) byte external,
	bC140(126) byte external,
	tx2qp byte external,
	bC1BF byte external,
	tx2qEnd byte external,
	pc address external,
	wC1C3 address external,
	wC1C5 address external,
	wC1C7 address external,
	blkSP byte external,
	blkOverCnt byte external,
	procCallDepth byte external,
	boC1CC byte external,
	boC1CD byte external,
	eofSeen byte external,
	wC1CF address external,
	curOp byte external,
	bC1D2 byte external,
	padC1D3 byte external,
	curExtProcId byte external,
	procChainId byte external,
	wC1D6 address external,
	boC1D8 byte external,
	bC1D9 byte external,
	cfrag1 byte external,
	bC1DB byte external,
	wC1DC(5) address external,
	bC1E6 byte external,
	buf$C1E7(34) byte external,
	bC209(1) byte external,
	boC20F byte external,
	finalise label external;

sub$5679: procedure(arg1b) byte external; declare arg1b byte; end;
sub$5748: procedure(arg1b) byte external; declare arg1b byte; end;
sub$5FBF: procedure(arg1b, arg2w$p, arg3w$p) external;
	declare arg1b byte, arg2w$p address, arg3w$p address; end;
sub$597E: procedure external; end;
sub$61A9: procedure(arg1b) external; declare arg1b byte; end;
sub$63AC: procedure(arg1b) external; declare arg1b byte; end;
sub$5795: procedure(arg1w) external; declare arg1w address; end;
sub$5EE8: procedure external; end;
$include(:f3:tiflag.pex)
$include(:f3:gibsev.pex)
sub$6416: procedure(arg1b) external; declare arg1b byte; end;
sub$5B96: procedure(arg1b, arg2b) external; declare arg1b byte, arg2b byte; end;
sub$7A85: procedure external; end;
sub$7DA9: procedure external; end;
sub$611A: procedure external; end;
sub$5E66: procedure(arg1b) external; declare arg1b byte; end;
sub$84ED: procedure external; end;
enterBlk: procedure byte external; end;
emitTopItem: procedure external; end;
sub$981C: procedure external; end;
encodeFragData: procedure(arg1b) external; declare arg1b byte; end;
$include(:f3:silnkv.pex)
sub$5D6B: procedure(arg1bx) external; declare arg1bx byte; end;
tx2SyntaxError: procedure(arg1b) external; declare arg1b byte; end;
$include(:f3:gipid.pex)


declare b4D23(1) byte external,
	b4C45(1) byte external,
	b4CB4(1) byte external,
	b4FA3(1) byte external,
	b4A21(1) byte external,
	b46EB(1) byte external,
	w48DF(1) address external,
	w493d(1) address external,
	b43F8(1) byte external,
	wAF54(1) address external,
	b499B(1) byte external;


$list


sub$87CB: procedure public;
	declare (bC2A5, bC2A6, bC2A7, bC2A8) byte,
		(wC2A9, wC2AB, wC2AD) address;

	bsub$8861: procedure boolean;
		declare i byte;
		do wC1D6 = wC2AB to wC2AD;
			i = sub$5679(bC2A5);
			if 0 <= i and i <= 3 then
				return true;
			if 12 <= i and i <= 14 then
				return true;
		end;
		return false;
	end bsub$8861;


	sub$88C1: procedure;
		if bsub$8861 then
		do;
			do bC2A8 = 0 to 3;
				if bC04E(bC2A8) = bC2A6 then
				do;
					if bC045(bC2A8) = 0 or bC045(bC2A8) = 1
					   or bC045(bC2A8) = 6 then
					do;
						bC0B3(bC2A5) = bC045(bC2A8);
						bC0B5(bC2A5) = bC2A8;
						if bC0B5(1 - bC2A5) <> bC2A8 then
							return;
					end;
				end;
			end;
		end;
	end sub$88C1;

	sub$894A: procedure;
		if bC0B5(bC2A5) > 3 then
		do;
			do bC2A8 = 1 to 3;
				if bC04E(bC2A8) = bC2A6 then
				do;
					if bC045(bC2A8) = 2 or bC045(bC2A8) = 3 then
					do;
						bC0B3(bC2A5) = bC045(bC2A8);
						bC0B5(bC2A5) = bC2A8;
						if bC0B5(1 - bC2A5) <> bC2A8 then
							return;
					end;
				end;
			end;
		end;
	end sub$894A;


	sub$89D1: procedure;
		declare i byte;
		declare p address;
		if bC0B5(bC2A5) = 0Ah then
			wC2A9 = tx2op2(bC2A6);
		else if bC0B5(bC2A5) = 9 then
		do;
			wC2A9 = tx2op3(bC2A6);
			if ( not boC069(0) and boC072(0)) or bC0B1 > 0 or wC2A9 <> wC1C3 then
			do;
				i = bC0B1 + bC0B2;
				do p = wC2A9 to wC1C3;
					if bC140(p) <> 0 then
						i = i + 1;  
				end;
				if i < 4 then
					boC1D8 = true;
				else
					bC0B5(bC2A5) = 0Ah;
			end;
			wC2A9 = - shl(wC2A9, 1);
		end;
	end sub$89D1;

	sub$8A9C: procedure;
		declare (p, q) address;
		declare (i, j) byte, r address;
		if bC0B5(bC2A5) = 0Ah then
		do;
			p = wC2A9;
			q = 100h;
			i = 4;
			j = sub$5748(bC0B3(bC2A5));
		end;
		else if bC0B5(bC2A5) = 8 and bC0B3(bC2A5) = 1 then
		do;
			call sub$5FBF(bC0B7(bC2A5), .p, .q);
			i = 2;
			j = 1;
		end;
		else if bC0B5(bC2A5) = 4 and
		   (bC0B3(bC2A5) = 0 or bC0B3(bC2A5) = 8 or  not bsub$8861) then
		do;
			call sub$5FBF(bC0B7(bC2A5), .p, .q);
			i = 2;
			j = sub$5748(bC0B3(bC2A5));
		end;
		else
			return;

		do bC2A8 = 1 to 3;
			if boC069(bC2A8) then
			do;
				if bC0B7(0) = bC0B7(1) and curOp <> T2$STORE then
					if bC0B5(bC2A5) > 3 then
						bC0B5(bC2A5) = bC2A8;
			end;
			else if not boC072(bC2A8) and wC096(bC2A8) = q
				    and boC057(bC2A8) and 1 <= bC045(bC2A8)
				    and bC045(bC2A8) <= 6 then
			do;
				r = wC084(bC2A8) + bC0A8(bC2A8) - p;
				if r > 0ffh then
					r = -r;
				if r < i then
				do;
					bC0B5(bC2A5) = bC2A8;
					i = r;
				end;
			end;
		end;
		if bC0B5(bC2A5) <= 3 then
		do;
			bC2A8 = bC0B5(bC2A5);
			bC045(bC2A8), bC0B3(bC2A5) = j;
			bC04E(bC2A8) = bC0B7(bC2A5);
			bC0A8(bC2A8) = wC084(bC2A8) + bC0A8(bC2A8) - p;
			wC084(bC2A8) = p;
		end;
	end sub$8A9C;



	sub$8CF5: procedure;
		bC0B5(0) = 8;
		bC0B5(1) = 8;
		do bC2A5 = 0 to 1;
			if (bC2A6 := bC0B7(bC2A5)) = 0 then
			do;
				bC0B3(bC2A5) = 0Ch;
			end;
			else if (bC2A7 := tx2opc(bC2A6)) = T2$STACKPTR then
			do;
				bC0B3(bC2A5) = 0Ah;
			end;
			else if bC2A7 = T2$LOCALLABEL then
			do; 
				bC0B3(bC2A5) = 9;
			end;
			else
			do;
				bC0B3(bC2A5) = tx2Aux1b(bC2A6);
				bC0B5(bC2A5) = tx2Aux2b(bC2A6);
				call sub$88C1; 
				call sub$894A;/*  checked */
			end;
		end;
		do bC2A5 = 0 to 1;
			bC2A6 = bC0B7(bC2A5);
			call sub$597E;
			call sub$89D1;
			call sub$8A9C;
			call sub$61A9(bC2A5);
		end;
	end sub$8CF5;



	sub$8DCD: procedure;
		declare (h, i, j, k, m, n) byte;

		sub$8E7E: procedure(arg1b)  byte;
			declare arg1b byte;
			declare p address, i byte;

			if bC0B7(arg1b) = 0 or bC0B7(arg1b) = 1 then
				return 1;
			i = sub$5679(arg1b);
			return b4D23(p := bC0C1(arg1b) * 16 + i);
		end sub$8E7E;

		sub$8ECD: procedure(arg1b, arg2b);
			declare arg1b byte, arg2b byte;
			bC0B9(arg1b) = b4C45(arg2b);
			bC0BB(arg1b) = b4CB4(arg2b);
			bC0BD(arg1b) = b4FA3(arg2b);
		end sub$8ECD;

/* sub$8DCD */
		j = 198;
		do wC1D6 = wC2AB to wC2AD;
			k = sub$8E7E(0);
			m = sub$8E7E(1);
			n = b4C45(k) + b4C45(m) + (b43F8(b4A21(wC1D6)) and 1fh);
			if n < j then
			do;
				j = n;
				h = k;
				i = m;
				cfrag1 = b4A21(wC1D6);
				bC1D9 = b46EB(wC1D6);
				bC0BF(0) = sub$5679(0);
				bC0BF(1) = sub$5679(1);
			end;
		end;
		call sub$8ECD(0, h);
		call sub$8ECD(1, i);
	end sub$8DCD;



	sub$8F16: procedure;
		if bC0B7(0) <> 0 then
			call sub$63AC(bC0B5(0));

		if bC0B7(1) <> 0 then 
			call sub$63AC(bC0B5(1));

	end sub$8F16;


	sub$8F35: procedure;
		declare p address;
		if curOp = T2$STKARG or curOp = T2$STKBARG or curOp = T2$STKWARG then
		do;
			call sub$5795(-shl(wB53C(procCallDepth), 1));
			wB53C(procCallDepth) = wB53C(procCallDepth) + 1;  
			wC1C3 = wC1C3 + 1;  
		end;
		else if curOp = T2$CALL then
		do;
			call sub$5795(-shl(wB53C(procCallDepth), 1));
			curInfo$p = tx2op3(tx2qp);
			if testInfoFlag(F$EXTERNAL) then
				p = shl(wB53C(procCallDepth) + 1, 1);
			else
				p = shl(wB528(procCallDepth) + 1, 1) + getBaseVal;
			if p > wC1C5 then
				wC1C5 = p;
		end;
		else if curOp = T2$CALLVAR then
		do;
			call sub$5795(-shl(wB53C(procCallDepth), 1));
			if wC1C5 < shl(wC1C3, 1) then
				wC1C5 = shl(wC1C3, 1);
		end;
		else if curOp = T2$RETURN or curOp = T2$RETURNBYTE
		    or curOp = T2$RETURNWORD then
		do;
			boC1CD = 0ffh;
			call sub$5EE8;
		end;
		else if curOp = T2$JMPFALSE then
		do;
			call sub$5795(0);
			if boC20F then
			do;
				cfrag1 = CF$JMPTRUE;
				boC20F = 0;
			end;
		end;
		else if curOp = T2$63 then 
			call sub$5795(0);
		else if curOp = T2$MOVE then
		do;
			if wB53C(procCallDepth) <> wC1C3 then
			do;
				call sub$5795(-shl(wB53C(procCallDepth) + 1, 1));
				call sub$6416(3);
			end;
			if bC045(3) = 1 then
				cfrag1 = CF$MOVE$HL;
		end;
	end sub$8F35;


	sub$90EB: procedure;
		declare (p, q) address;
		declare (i, j, k) byte;

		sub$940D: procedure;
			do bC2A8 = 0 to 3;
				if bC04E(bC2A8) = bC0B7(0) then
					if bC045(bC2A8) < 2 or 5 < bC045(bC2A8) then
						bC04E(bC2A8) = 0;
			end;
		end;

		p = w48DF(bC1D9) * 16;
		q = w493D(bC1D9);
		k = 0;
		if curOp = T2$STORE then
		do;
			call sub$940D;
			if tx2Auxw(bC0B7(1)) = 0 then
			    if tx2Auxw(bC0B7(0)) > 0 then
				do;
					if cfrag1 = CF$MOVMLR or cfrag1 = CF$STA then
					do;
						bC045(bC0B5(1)) = 0;
						bC04E(bC0B5(1)) = bC0B7(0);
					end;
					else if cfrag1 = CF$SHLD or cfrag1 = CF$MOVMRP then
					do;
						bC045(bC0B5(1)) = 1;
						bC04E(bC0B5(1)) = bC0B7(0);
					end;
				end;
		end;
		else if T2$51 <= curOp and curOp <= T2$56 then
			call sub$940D;
		do bC2A8 = 5 to 8;
			i = shr(p, 13);
			j = shr(q, 12);
			p = shl(p, 3);
			q = shl(q, 4);
			if j <= 3 then
			do;
				call sub$5B96(j, bC2A8);
				if i = 1 then
					bC0A8(bC2A8) = bC0A8(bC2A8) + 1;  
				else if i = 2 then
				do;
					if bC045(bC2A8) = 0 then
					do;
						bC045(bC2A8) = 6;
					end;
					else
					do;
						bC045(bC2A8) = 1;
						boC057(bC2A8) = 0;
					end;
				end;
			end;
			else if j = 4 then
			do;
				boC057(k := bC2A8) = 0;
				if 0 < tx2Auxw(tx2qp) then
				do;
					bC04E(bC2A8) = tx2qp;
					bC045(bC2A8), tx2Aux1b(tx2qp) = shr(b43F8(cfrag1), 5);
					bC0A8(bC2A8) = 0;
				end;
				else
					bC04E(bC2A8) = 0;
			end;
			else if j = 5 then
			do;
				bC04E(bC2A8) = 0;
				wC096(bC2A8) = 0;
				bC0A8(bC2A8) = 0;
				boC057(bC2A8) = 0FFh;
				bC045(bC2A8) = 0;
				wC084(bC2A8) = i;
			end;
			else
			do;
				bC04E(bC2A8) = 0;
				boC057(bC2A8) = 0;
			end;
		end;
		if k = 0 and tx2Auxw(tx2qp) > 0 then
		do;
			do bC2A8 = 5 to 8;
				if bC04E(bC2A8) = 0 then 
					if not boC057(k := bC2A8) then
						goto break;
			end;
		break:
			if k <> 0 then
			do;
				bC04E(k) = tx2qp;
				boC057(k) = 0;
				bC045(k) = 0;
				tx2Aux1b(tx2qp) = 0;
				bC0A8(k) = 0;
			end;
		end;
		do bC2A8 = 0 to 3;
			call sub$5B96(bC2A8 + 5, bC2A8);
		end;
	end sub$90EB;

/* sub$87CB */
	bC0B7(0) = tx2op1(tx2qp);
	bC0B7(1) = tx2op2(tx2qp);
	wC2AB = wAF54(curOp);
	wC2AD = wC2AB + b499B(curOp) - 1;
	call sub$8CF5;

	do while 1;
		call sub$8DCD;	/*  OK */
		if bC0B9(0) = 0 then
			if bC0B9(1) = 0 then
				goto break;
		if boC1D8 then
			call sub$7A85;
		else
			call sub$7DA9;
	end;
break:
	call sub$8F16;
	call sub$611A;
	call sub$5E66(shr(w48DF(bC1D9), 12));
	call sub$8F35;
	call sub$84ED;
	call sub$90EB;
end sub$87CB;


sub$9457: procedure public;
	if enterBlk then
	do;
		wB488(procChainId) = pc;
		wB4B0(procChainId) = wC1C3;
		wB4D8(procChainId) = wC1C5;
		extProcId(procChainId) = curExtProcId;
		procChainNext(blkSP) = procChainId;
		procChainId = blkSP;
		curInfo$p, blkCurInfo(blkSP) = tx2op1(tx2qp) + botInfo;
		curExtProcId = getProcId;
		pc = 0;
		call emitTopItem;
		call sub$981C;
	end;
end;
end;
