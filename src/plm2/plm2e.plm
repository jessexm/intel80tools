plm2e: DO;
$nolist
declare lit literally 'literally',
	true lit '0ffh',
	false lit '0',
	boolean lit 'byte',
	cr lit '0dh',
	lf lit '0ah';

$include(:f3:data.inc)
$include(t2code.inc)
$include(:f3:info.inc)
$include(:f3:flags.inc)

declare CF$XCHG lit '14',
	CF$XTHL lit '5',
	CF$MOVLRHR lit '110',
	CF$3 lit '3',
	CF$67 lit '67',
	CF$68 lit '68',
	CF$DELAY lit '97',
	CF$171 lit '171',
	CF$174 lit '174';

declare	ERR214	lit '214';

declare	tx2Buf(512) byte external,
	tx1Buf(512) byte external,
	blkCurInfo(20) address external,
	wB488(20) address external,
	wB4B0(20) address external,
	wB4D8(20) address external,
	extProcId(20) byte external,
	procChainNext(20) byte external,
	wB528(10) address external,
	wB53C(10) address external,
	tx2opc(255) byte external,
	tx2Aux1b(255) byte external,
	tx2Aux2b(255) byte external,
	tx2op1(255) address external,
	tx2op2(255) address external,
	tx2op3(255) address external,
	tx2Auxw(255) address external,
	bC045(9) byte external,
	bC04E(9) byte external,
	boC057(9) byte external,
	boC060(9) byte external,
	boC069(9) byte external,
	boC072(9) byte external,
	boC07B(9) byte external,
	wC084(9) address external,
	wC096(9) address external,
	bC0A8(9) byte external,
	bC0B1 byte external,
	bC0B2 byte external,
	bC0B3(2) byte external,
	bC0B5(2) byte external,
	bC0B7(2) byte external,
	bC0B9(2) byte external,
	bC0BB(2) byte external,
	bC0BD(2) byte external,
	bC0BF(2) byte external,
	bC0C1(2) byte external,
	bC0C3(125) byte external,
	bC140(126) byte external,
	tx2qp byte external,
	bC1BF byte external,
	tx2qEnd byte external,
	pc address external,
	wC1C3 address external,
	wC1C5 address external,
	wC1C7 address external,
	blkSP byte external,
	blkOverCnt byte external,
	procCallDepth byte external,
	boC1CC byte external,
	boC1CD byte external,
	eofSeen byte external,
	wC1CF address external,
	curOp byte external,
	bC1D2 byte external,
	padC1D3 byte external,
	curExtProcId byte external,
	procChainId byte external,
	wC1D6 address external,
	boC1D8 byte external,
	bC1D9 byte external,
	cfrag1 byte external,
	bC1DB byte external,
	wC1DC(5) address external,
	bC1E6 byte external,
	buf$C1E7(34) byte external,
	bC209(1) byte external,
	boC20F byte external,
	finalise label external;


declare b52B5(1) byte external,
	b4C2D(1) byte external,
	b4C15(1) byte external,
	b528D(1) byte external,
	b5012(1) byte external,
	b4029(1) byte external,
	b43F8(1) byte external,
	b42F9(1) byte external,
	b413b(1) byte external,
	b4128(1) byte external,
	b425D(1) byte external,
	b3FCD(1) byte external,
	b418C(1) byte external,
	b4273(1) byte external;

encodeFragData: procedure(arg1b) external; declare arg1b byte; end;
sub$5B96: procedure(arg1b, arg2b) external; declare arg1b byte, arg2b byte; end;
sub$5C97: procedure(arg1b) external; declare arg1b byte; end;
sub$5C1D: procedure(arg1b) external; declare arg1b byte; end;
sub$597E: procedure external; end;
sub$61A9: procedure(arg1b) external; declare arg1b byte; end;
sub$6416: procedure(arg1b) external; declare arg1b byte; end;
sub$63AC: procedure(arg1b) external; declare arg1b byte; end;
sub$5D6B: procedure(arg1bx) external; declare arg1bx byte; end;
sub$636A: procedure(arg1b) external; declare arg1b byte; end;
sub$5FBF: procedure(arg1b, arg2w$p, arg3w$p) external;
	declare arg1b byte, arg2w$p address, arg3w$p address; end;
sub$5748: procedure(arg1b) byte external; declare arg1b byte; end;
sub$58F5: procedure(arg1b) external; declare arg1b byte; end;
sub$61E0: procedure(arg1b) external; declare arg1b byte; end;

$list

declare b7A81(4) byte data(3CH, 46H, 50H, 5AH);


sub$7A85: procedure public;
	declare (i, j) byte,
		bC28B(4) byte, bC28F byte,
		(k, m, n) byte;

	sub$7D32: procedure;
		call encodeFragData(CF$XCHG);
		pc = pc + 1;  
		call sub$5B96(3, 4);
		call sub$5B96(2, 3);
		call sub$5B96(4, 2);
	end;

	sub$7D54: procedure;

		wC1DC(0) = 0ah;
		wC1DC(1) = wC1C3;
		call encodeFragData(CF$XTHL);
		pc = pc + 1;  
		call sub$5C97(4);
		call sub$5C1D(3);
		call sub$5B96(4, 3);
	end;


	sub$7D7E: procedure(arg1b);
		declare arg1b byte;
		if arg1b <= 3 then 
			if bC28B(arg1b) < 0c8h then
				bC28B(arg1b) = bC28B(arg1b) + bC28F;
	end;

/* sub$7A85 */
	call sub$597E;
	do i = 0 to 3;
		if boC072(i) or boC069(i) then
			bC28B(i) = 0c8h;
		else if boC060(i) then
			bC28B(i) = b7A81(i) + 0fh;
		else
			bC28B(i) = b7A81(i);
	end;

	if shr(bC0C3(wC1C3), 4) <> 0bh and bC140(wC1C3) <> 0 then
		bC28B(0) = 0C8h;
	do m = 0 to 1;
		if bC0B7(m) <> 0 then
		do;
			if bC0B5(m) = 9 and bC140(wC1C3) = bC0B7(m) then
			do;
				k = m;
				bC28F = 0ceh;
				boC1D8 = 0;
			end;
			else
				bC28F = 32h;
			call sub$7D7E(b52B5(bC0BF(m)));
			call sub$7D7E(shr(b4C2D(bC0BD(m)), 5));
		end;
	end;

	n = 0c8h;
	do i = 0 to 3;
		if bC28B(i) <= n then
			n = bC28B(j := i);
	end;

	if n = 0C8h then
	do;
		if boC069(3) then
		do;
			call sub$7D32;
			if bC0B5(0) = 3 then
			do;
				bC0B5(0) = 2;
				call sub$61A9(0);
			end;
			else
			do;
				bC0B5(1) = 2;
				call sub$61A9(1);
			end;
		end;
		call sub$7D54;
		j = 3;
	end;
	else
		call sub$6416(j);

	if bC045(j) = 0bh then
	do;
		bC045(j) = 0;
		if j <> 0 and bC04E(j) <> 0 then
		do;
			wC1DC(0) = j;
			call encodeFragData(CF$MOVLRHR);
			pc = pc + 1;  
		end;
	end;
	if not boC1D8 then
	do;
		if bC0B5(1 - k) = 9 then
		do;
			if bC0B7(1 - k) = bC0B7(k) then
			do;
				bC0B5(1 - k) = j;
				bC0B3(1 - k) = bC045(j);
				call sub$61A9(1 - k);
			end;
			else
				boC1D8 = 0ffh;
		end;
		bC0B5(k) = j;
		bC0B3(k) = bC045(j);
		call sub$61A9(k);
	end;
end;





sub$7DA9: procedure public;
	declare (bC294, bC295, bC296, bC297, bC298, i) byte;

	sub$7F19: procedure;

		bsub$7FD9: procedure(arg1b) boolean;
			declare arg1b byte;
			if arg1b <= 3 then
				if bC0B5(bC296) = arg1b then
					return true;
			return false;
		end;

		do bC295 = 0 to 1;
			if bC0B7(bC295) <> 0 and bC0BB(bC295) <> 0 then
			do;
				if bC0BB(bC296 := 1 - bC295) <> 0 then
				do;
					if bsub$7FD9(shr(b4C2D(bC0BD(bC295)), 5)) 
					  or bsub$7FD9(b52B5(bC0BF(bC295))) then
						bC0BB(bC296) = 10 + bC0BB(bC296);
				end;
			end;
		end;

		if bC0BB(0) > bC0BB(1) then
			bC295 = 0;
		else
			bC295 = 1;

		bC296 = 1 - bC295;
		bC298 = bC0BD(bC295);
	end;



	sub$7FFC: procedure;
		if bC298 = 13h then
		do;
			if boC072(3) or boC069(3) then
				bC298 = 15h;
		end;
		else if bC298 = 14h then
		do;
			bC294 = 5 - bC297;
			if bC0B5(0) = bC0B5(1) then
				if bC0B3(bC295) = 0 then
					bC298 = 0Eh;
				else
					bC298 = 11h;
		end;
		else if bC298 = 8 then
		do;
			if tx2op1(bC0B7(bC295)) <> 0 then
			do;
				bC298 = 6;
				if bC294 = 0 then
					bC294 = 1;
			end;
		end;
	end;



	sub$8086: procedure;
		if 9 <= bC298 and bC298 <= 13 then
			call sub$63AC(bC297);

		if b4C2D(bC298) then
		do;
			if bC294 <> bC297 then 
				call sub$5D6B(bC294);
			else if 9 <= bC298 and bC298 <= 13 then
			do;
				bC0B5(bC295) = 9;
				call sub$597E;
				call sub$5D6B(bC294);
				bC0B5(bC295) = bC297;
				call sub$597E;
			end;
		end;
		else if bC298 = 15h then
		do;
			if boC069(3) then
				bC0B5(bC296) = 9;
		end;
		else if bC298 = 14h then
		do; 
			if bC0B5(bC296) = bC294 then
				bC0B5(bC296) = bC297;
		end;
	end;

	sub$8148: procedure(arg1b, arg2b);
		declare arg1b byte, arg2b byte;
		declare i byte;
		if arg2b = 0 then
			return;
		if arg2b = 1 or arg2b = 2 then
		do;
			if arg1b = 0 then
				wC1DC(bC1DB) = bC297;
			else
				wC1DC(bC1DB) = bC294;
			bC1DB = bC1DB + 1;  
		end;
		else if arg1b = 2 then
		do;
			wC1DC(bC1DB) = 8;
			bC1DB = bC1DB + 2;
		end;
		else if arg1b = 3 then
		do;
			wC1DC(bC1DB) = 0Ah;
			wC1DC(bC1DB+1) = wC1C3;
			bC1DB = bC1DB + 3;
		end;
		else
		do;
			i = bC1DB;
			call sub$636A(bC295);
		end;

	end;

	sub$8207: procedure;
		do case shr(b4C15(bC298), 4);
			do;
				call sub$5C97(bC294);
				wC1C3 = wC1C3 - 1;  
			end;
			do;
				call sub$5C97(4);
				call sub$5C1D(3);
				call sub$5B96(4, 3);
			end;
			do;
				boC057(bC294) = true;
				bC0A8(bC294) = 0;
				bC04E(bC294) = bC0B7(bC295);
				wC096(bC294) = 100h;
				if wC1DC(0) = 0Ah then
				do;
					wC084(bC294) = - shl(wC1DC(1), 1);
					if bC0C3(tx2op3(bC0B7(bC295))) = 0b0h then
						if bC298 = 5 then
						do;
							wC084(bC294) = wC084(bC294) - 1;  
							wC1DC(2) = wC1DC(2) + 1;  
						end;
				end;
				else
					wC084(bC294) = wC1DC(3) - shl(wC1C3, 1);
			end;
			do;
				boC057(bC294) = true;
				bC0A8(bC294) = 0;
				bC04E(bC294) = bC0B7(bC295);
				call sub$5FBF(bC04E(bC294), .wC084(bC294), .wC096(bC294));
			end;
			do;
				boC057(bC294) = 0;
				bC04E(bC294) = bC0B7(bC295);
				if bC0B3(bC295) = 4 or bC0B3(bC295) = 5 then
				do;
					bC0A8(bC294) = bC0C3(tx2op3(bC0B7(bC295))) and 0fh;
					if bC0A8(bC294) > 7 then
						bC0A8(bC294) = bC0A8(bC294) or  0f0h;
				end;
				else
					bC0A8(bC294) = 0;
			end;
			call sub$5B96(bC297, bC294);
			do;
				call sub$5B96(3, 4);
				call sub$5B96(2, 3);
				call sub$5B96(4, 2);
			end;
			;
		end;
	end;

	sub$841E: procedure;
		do case b4C15(bC298) and 0fh;
			;
			bC045(bC294) = 1;
			bC045(bC294) = 0;
			bC045(bC294) = 6;
			do;
				if bC0B5(bC295) <> 8 then
					bC045(bC294) = sub$5748(bC0B3(bC295));
				else if bC0B3(bC295) = 0 then
					bC045(bC294) = 6;
				else
					bC045(bC294) = bC0B3(bC295);
			end;
			do;
				bC045(bC294) = bC0B3(bC295) - 2;
				bC0A8(3) = bC0A8(3) + 1;  
			end;
		end;
	end;




/* sub$7DA9 */
	call sub$7F19;
	if bC298 = 17h then
		call sub$58F5(ERR214);
	else if bC298 = 16h then
	do;
		bC0C1(bC295) = bC0BF(bC295);
		bC0B3(bC295) = b528D(bC0C1(bC295));
		bC0B5(bC295) = b52B5(bC0C1(bC295));
	end;
	else if bC298 = 12h then
		boC1D8 = TRUE;
	else
	do;
		bC294 = shr(b4C2D(bC298), 5);
		if bC294 > 3 then
			bC294 = b52B5(bC0BF(bC295));
		bC297 = bC0B5(bC295);
		call sub$597E;
		call sub$7FFC;
		i = b5012(bC298);
		call sub$8086; 
		bC1DB = 0;
		call sub$8148(shr(b4C2D(bC298), 3) and 3, shr(b4029(i), 4) and 7);
		call sub$8148(shr(b4C2D(bC298), 1) and 3, shr(b4029(i), 1) and 7);
		call sub$8207;
		call sub$841E;
		bC0B3(bC295) = bC045(bC294);
		bC0B5(bC295) = bC294;
		call sub$61A9(0);
		call sub$61A9(1);
		call encodeFragData(i);
		pc = pc + (b43F8(i) and 01fh);


	end;
end;



sub$84ED: procedure public;
	declare i byte;
	declare helpers based helpers$p(1) address;

	sub$8683: procedure(arg1b) byte;
		declare arg1b byte;
		if bC0B5(0) = arg1b then
			return 1;
		else
			return 0;
	end;


	sub$8698: procedure(arg1b, arg2b);
		declare arg1b byte, arg2b byte;
		declare i byte;
		declare p address;
		do case arg1b;
			return;
			i = 0;
			i = 1;
			do;
				wC1DC(bC1DB) = 0Ah;
				wC1DC(bC1DB + 1) = wC1C3;
				bC1DB = bC1DB + 3;
				return;
			end;
			i = sub$8683(3);
			i = sub$8683(0);
			do;
				if arg2b = 7 then
				do;
					wC1DC(bC1DB) = 10h;
					wC1DC(bC1DB + 1) = tx2op3(tx2qp) - botInfo;
					bC1DB = bC1DB + 2;
				end;
				else
					call sub$61E0(tx2op3(tx2qp));
				return;
			end;
		end;
		if arg2b <= 3 then
			call sub$636A(i);
		else
		do;
			wC1DC(bC1DB) = arg2b + 9;
			if arg2b = 6 then
				wC1DC(bC1DB + 1) = tx2op2(1);
			else
				call sub$5FBF(bC0B7(i), .wC1DC(bC1DB+1), .p);
			bC1DB = bC1DB + 2;
		end;
	end;

/* sub$84ED */
	if cfrag1 > CF$3 then
	do;
		bC1DB = 0;
		call sub$8698(shr(b42F9(cfrag1), 4), shr(b4029(cfrag1), 4) and 7);
		if cfrag1 = CF$67 or cfrag1 = CF$68 then
			wC1DC(bC1DB - 1) = wC1DC(bC1DB - 1) + 2;
		call sub$8698(b42F9(cfrag1) and 0fh, shr(b4029(cfrag1), 1) and 7);
		call encodeFragData(cfrag1);
		pc = pc + (b43F8(cfrag1) and 01fh);
		if cfrag1 = CF$DELAY then
		do; 
			helpers(105) = 1;
			if wC1C5 < shl(wC1C3 + 1, 1) then
				wC1C5 = shl(wC1C3 + 1, 1);
		end;
		else if cfrag1 > CF$171 then
		do;
			i = b413B(cfrag1 - CF$174);
			i = b4128(i) + 11 * b425D(b4273(curOp));
			i = b3FCD(shr(b418C(i), 2)) + (b418C(i) and 3);
			helpers(i) = 1;
			if curOp = T2$SLASH or curOp = T2$MOD
			 or curOp = T2$44 then
			do;
				if wC1C5 < shl(wC1C3 + 2, 1) then
					wC1C5 = shl(wC1C3 + 2, 1);
			end;
			else if wC1C5 < shl(wC1C3 + 1, 1) then
					wC1C5 = shl(wC1C3 + 1, 1);
		end;
	end;
end;


END;
