plm2h: DO;
$nolist
declare lit literally 'literally',
	true lit '0ffh',
	false lit '0',
	boolean lit 'byte',
	cr lit '0dh',
	lf lit '0ah';

$include(:f3:data.inc)
$include(t2code.inc)
$include(:f3:info.inc)
$include(:f3:flags.inc)
declare ERR201 lit '201',
	ERR203 lit '203',
	CF$DW lit '21',
	CF$RET lit '27';

declare	tx2Buf(512) byte external,
	tx1Buf(512) byte external,
	blkCurInfo(20) address external,
	wB488(20) address external,
	wB4B0(20) address external,
	wB4D8(20) address external,
	extProcId(20) byte external,
	procChainNext(20) byte external,
	wB528(10) address external,
	wB53C(10) address external,
	tx2opc(255) byte external,
	tx2Aux1b(255) byte external,
	tx2Aux2b(255) byte external,
	tx2op1(255) address external,
	tx2op2(255) address external,
	tx2op3(255) address external,
	tx2Auxw(255) address external,
	bC045(9) byte external,
	bC04E(9) byte external,
	boC057(9) byte external,
	boC060(9) byte external,
	boC069(9) byte external,
	boC072(9) byte external,
	boC07B(9) byte external,
	wC084(9) address external,
	wC096(9) address external,
	bC0A8(9) byte external,
	bC0B1 byte external,
	bC0B2 byte external,
	bC0B3(2) byte external,
	bC0B5(2) byte external,
	bC0B7(2) byte external,
	bC0B9(2) byte external,
	bC0BB(2) byte external,
	bC0BD(2) byte external,
	bC0BF(2) byte external,
	bC0C1(2) byte external,
	bC0C3(125) byte external,
	bC140(126) byte external,
	tx2qp byte external,
	bC1BF byte external,
	tx2qEnd byte external,
	pc address external,
	wC1C3 address external,
	wC1C5 address external,
	wC1C7 address external,
	blkSP byte external,
	blkOverCnt byte external,
	procCallDepth byte external,
	boC1CC byte external,
	boC1CD byte external,
	eofSeen byte external,
	wC1CF address external,
	curOp byte external,
	bC1D2 byte external,
	padC1D3 byte external,
	curExtProcId byte external,
	procChainId byte external,
	wC1D6 address external,
	boC1D8 byte external,
	bC1D9 byte external,
	cfrag1 byte external,
	bC1DB byte external,
	wC1DC(5) address external,
	bC1E6 byte external,
	buf$C1E7(34) byte external,
	bC209(1) byte external,
	boC20F byte external,
	finalise label external;

sub$56A0: procedure(arg1b, arg2b) external; declare arg1b byte, arg2b byte; end;
sub$717B: procedure external; end;
sub$7550: procedure external; end;
sub$87CB: procedure external; end;
sub$994D: procedure external; end;
$include(:f3:gidtyp.pex)
$include(:f3:gipcnt.pex)
$include(:f3:adninf.pex)
$include(:f3:gitype.pex)
$include(:f3:tiflag.pex)
tx2SyntaxError: procedure(arg1b) external; declare arg1b byte; end;
encodeFragData: procedure(arg1b) external; declare arg1b byte; end;
enterBlk: procedure byte external; end;
exitBlk: procedure byte external; end;
emitTopItem: procedure external; end;
sub$5EE8: procedure external; end;
putTx1Byte: procedure(arg1b) external; declare arg1b byte; end;
putTx1Word: procedure(arg1w) external; declare arg1w address; end;
wrFragData: procedure external; end;
sub$5F4B: procedure(arg1w, arg2w, arg3b, arg4b) external;
	declare arg1w address, arg2w address, arg3b byte, arg4b byte; end;
sub$5E66: procedure(arg1b) external; declare arg1b byte; end;
sub$9457: procedure external; end;
sub$5795: procedure(arg1w) external; declare arg1w address; end;
$include(:f3:sibsev.pex)
$include(:f3:sidim.pex)
$include(:f3:gidim.pex)
sub$575E: procedure(arg1w) address external; declare arg1w address; end;

declare b5124(1) byte external,
	wAF54(1) address external,
	b44F7(1) byte external;

$list

declare b9BA8(2) byte data(12, 13),
	b9BAA(2) byte data(1, 2),
	b9BAC(2) byte data(12, 13),
	b9BAE(2) byte data(1, 2);

sub$9BB0: procedure public;

	bsub$9C33: procedure  byte;
		declare (i, j, k) byte;

		i = tx2op1(tx2qp);
		if (b5124(tx2opc(i)) and 0c0h) = 0 then
		do;
			if tx2Auxw(i) > 1 then
				return 0;
			if tx2op3(i) <> 0 then
				bC140(tx2op3(i)) = tx2qp;
		end;
		k = tx2Auxw(tx2qp);
		call sub$56A0(i, tx2qp);
		tx2Auxw(tx2qp) = k;
		tx2Auxw(i) = tx2Auxw(i) - 1;  
		do j = 0 to 3;
			if bC04E(j) = i then
				bC04E(j) = tx2qp;
		end;
		return true;
	end;


/* sub$9BB0 */
	bC0B7(0) = tx2op1(tx2qp);
	bC0B7(1) = tx2op2(tx2qp);
	if T2$DOUBLE <= curOp and curOp <= T2$ADDRESSOF then
		call sub$717B;
	if curOp <= T2$MEMBER then
	do;
		call sub$7550;
		if curOp = T2$65 then
			if bsub$9C33 then
				return;
	end;
	if (bC1D2 and 0c0h) = 0 then
	do;
		call sub$87CB;
		if curOp = T2$MOVE then
			procCallDepth = 0;
	end;
	else if (bC1D2 and 0c0h) = 80h then
		call sub$994D;
end;



sub$9D06: procedure public;
	declare (i, j, k) byte, pbyt address, m byte;
	declare byt based pbyt byte;

	if procCallDepth <= 10 then
	do;
		curInfo$p = tx2op3(tx2qp);
		i = getDataType;
		if i = 3 then
			wAF54(132) = 1;
		else
			wAF54(132) = 0;
		j, m = getParamCnt;
		pbyt = .b44F7(wAF54(132));
		k = 0;

		do while j > 0;
			call advNxtInfo;
			j = j - 1;
			if j < 2 then
			do;
				byt = rol(byt, 4) and 0f0h;
				if getType = ADDRESS$T then
					byt = byt or  b9BA8(k);
				else
					byt = byt or  b9BAA(k);
				k = 1;
			end;
		end;

		if m = 1 then
			byt = rol(byt, 4) and 0f0h;
		call sub$9BB0;
		wC1C3 = wB528(procCallDepth);
	end;
	procCallDepth = procCallDepth - 1;  
end;



sub$9DD7: procedure public;
	declare pb$C2EB address;
	declare byt based pb$C2EB byte;

	sub$9EAA: procedure(arg1b, arg2b);
		declare arg1b byte, arg2b byte;
		
		byt = rol(byt, 4) and 0f0h;
		if arg1b <> 0 then
			if tx2Aux1b(arg1b) = 0 then
				byt = byt or  b9BAE(arg2b);
			else
				byt = byt or  b9BAC(arg2b);
	end;

	declare i byte;

	if procCallDepth <= 10 then
	do;
		i = tx2op3(tx2qp);
		if tx2opc(i) = T2$VARIABLE then
		do;
			curInfo$p = tx2op1(i);
			if testInfoFlag(F$AUTOMATIC) then
				wAF54(133) = 3;
			else
				wAF54(133) = 4;
		end;
		else if tx2op3(i) = wB53C(procCallDepth) then
		do;
			wAF54(133) = 5;
			wB528(procCallDepth) = wB528(procCallDepth) - 1;  
		end;
		else
			wAF54(133) = 2;

		pb$C2EB = .b44F7(wAF54(133));
		call sub$9EAA(tx2op1(tx2qp), 0);
		call sub$9EAA(tx2op2(tx2qp), 1);
		call sub$9BB0;
		wC1C3 = wB528(procCallDepth);
	end;
	procCallDepth = procCallDepth - 1;  
end;




sub$9EF8: procedure public;
	procCallDepth = 1;
	call sub$9BB0;
	wB53C(procCallDepth) = wC1C3;
end;



sub$9F14: procedure public;
	if enterBlk then
		blkCurInfo(blkSP) = wC1CF;
end;


sub$9F2F: procedure public;
	declare (p, q) address;
	declare memwds based botMem(1) address;
	p, q = blkCurInfo(blkSP);
	if exitBlk then
	do;
		do while p < wC1CF;
			wC1DC(0) = 14;
			wC1DC(1) = memwds(p);
			call encodeFragData(CF$DW);
			pc = pc + 2;
			p = p + 1;  
		end;
		if wC1CF = q then
		do;
			call tx2SyntaxError(ERR201);	/*  Invalid DO CASE block, */
						/*  at least on case required */
			call emitTopItem;
		end;
		wC1CF = q;
	end;
end;



sub$9F9F: procedure public;
	if exitBlk then
	do;
		curInfo$p = blkCurInfo(procChainId);
		if not boC1CC then
		do;
			call sub$5EE8;
			call encodeFragData(CF$RET);
			pc = pc + 1;  
		end;
		if testInfoFlag(F$INTERRUPT) then
			wC1C5 = wC1C5 + 8;

		call setDimension(pc);
		call setBaseVal(wC1C5 + wC1C7);
		pc = wB488(procChainId := procChainNext(procChainId));
		bC1E6 = 0;
		call putTx1Byte(0a4h);
		call putTx1Word(blkCurInfo(procChainId) - botInfo);
		call putTx1Word(pc);
		call wrFragData;
		wC1C3 = wB4B0(procChainId);
		wC1C5 = wB4D8(procChainId);
		wC1C7 = 0;
		curExtProcId = extProcId(procChainId);
	end;
end;

sub$A072: procedure(arg1b) public;
	declare arg1b byte;
	declare p address;
	curInfo$p = tx2op1(tx2qp) + botInfo;
	p = getDimension - arg1b;
	if p < 100h then
		call sub$5F4B(p, 0, 0, 8);
	else
		call sub$5F4B(p, 0, 1, 8);
end;


sub$A0C4: procedure public;
	declare p address;
	p = sub$575E(tx2op1(tx2qp) + botInfo);
	if p < 100h then
		call sub$5F4B(p, 0, 0, 8);
	else
		call sub$5F4B(p, 0, 1, 8);
end;

sub$A10A: procedure public;
	procCallDepth = procCallDepth + 1;
	if procCallDepth <= 10 then
	do;
		call sub$5E66(0fh);
		wB528(procCallDepth) = wC1C3;
		wB53C(procCallDepth) = wC1C3;
	end;
	else if procCallDepth = 11 then
	do;
		call tx2SyntaxError(ERR203);	/*  LIMIT EXCEEDED: NESTING OF TYPED */
					/*  PROCEDURE CALLS */
		call emitTopItem;
	end;
end;




sub$A153: procedure public;
	sub$A266: procedure;
		declare i byte;

		boC1CD = 0;
		do i = 0 to 3;
			bC045(i) = 0ch;
			bC04E(i) = 0;
			boC057(i) = 0;
		end;
	end;

/* sub$A153 */
	call sub$A266;
	do tx2qp = 4 to bC1BF - 1;
		curOp = tx2opc(tx2qp);
		bC1D2 = b5124(curOp);
		do case shr(bC1D2, 6);
			do;
				if curOp = T2$CALL then
					call sub$9D06;
				else if curOp = T2$CALLVAR then
					call sub$9DD7;
				else if curOp = T2$BEGMOVE then
					call sub$9EF8;
				else
					call sub$9BB0;
			end;
			do;
				if curOp = T2$LENGTH then
					call sub$A072(0);
				else if curOp = T2$LAST then
					call sub$A072(1);
				else if curOp = T2$SIZE then
					call sub$A0C4;
			end;
			do;
				if curOp = T2$PROCEDURE then
					call sub$9457;
				else
					call sub$994D;
			end;
			do;
				if curOp = T2$CASE then
					call sub$9F14;
				else if curOp = T2$ENDCASE then
					call sub$9F2F;
				else if curOp = T2$ENDPROC then
					call sub$9F9F;
				else if curOp = T2$BEGCALL then
					call sub$A10A;
			end;
		end;

		tx2op3(tx2qp) = 0;
	end;
	call sub$5795(0);
	boC1CC = boC1CD;
end;




END;
