plm2h: DO;
$include(plm2h.ipx)

declare b9BA8(2) byte data(12, 13),
	b9BAA(2) byte data(1, 2),
	b9BAC(2) byte data(12, 13),
	b9BAE(2) byte data(1, 2);

sub$9BB0: procedure public;

	bsub$9C33: procedure  byte;
		declare (i, j, k) byte;

		i = tx2op1(tx2qp);
		if (b5124(tx2opc(i)) and 0c0h) = 0 then
		do;
			if tx2Auxw(i) > 1 then
				return 0;
			if tx2op3(i) <> 0 then
				bC140(tx2op3(i)) = tx2qp;
		end;
		k = tx2Auxw(tx2qp);
		call sub$56A0(i, tx2qp);
		tx2Auxw(tx2qp) = k;
		tx2Auxw(i) = tx2Auxw(i) - 1;  
		do j = 0 to 3;
			if bC04E(j) = i then
				bC04E(j) = tx2qp;
		end;
		return true;
	end;


/* sub$9BB0 */
	bC0B7(0) = tx2op1(tx2qp);
	bC0B7(1) = tx2op2(tx2qp);
	if T2$DOUBLE <= curOp and curOp <= T2$ADDRESSOF then
		call sub$717B;
	if curOp <= T2$MEMBER then
	do;
		call sub$7550;
		if curOp = T2$65 then
			if bsub$9C33 then
				return;
	end;
	if (bC1D2 and 0c0h) = 0 then
	do;
		call sub$87CB;
		if curOp = T2$MOVE then
			procCallDepth = 0;
	end;
	else if (bC1D2 and 0c0h) = 80h then
		call sub$994D;
end;



sub$9D06: procedure public;
	declare (i, j, k) byte, pbyt address, m byte;
	declare byt based pbyt byte;

	if procCallDepth <= 10 then
	do;
		curInfo$p = tx2op3(tx2qp);
		i = getDataType;
		if i = 3 then
			wAF54(132) = 1;
		else
			wAF54(132) = 0;
		j, m = getParamCnt;
		pbyt = .b44F7(wAF54(132));
		k = 0;

		do while j > 0;
			call advNxtInfo;
			j = j - 1;
			if j < 2 then
			do;
				byt = rol(byt, 4) and 0f0h;
				if getType = ADDRESS$T then
					byt = byt or  b9BA8(k);
				else
					byt = byt or  b9BAA(k);
				k = 1;
			end;
		end;

		if m = 1 then
			byt = rol(byt, 4) and 0f0h;
		call sub$9BB0;
		wC1C3 = wB528(procCallDepth);
	end;
	procCallDepth = procCallDepth - 1;  
end;



sub$9DD7: procedure public;
	declare pb$C2EB address;
	declare byt based pb$C2EB byte;

	sub$9EAA: procedure(arg1b, arg2b);
		declare arg1b byte, arg2b byte;
		
		byt = rol(byt, 4) and 0f0h;
		if arg1b <> 0 then
			if tx2Aux1b(arg1b) = 0 then
				byt = byt or  b9BAE(arg2b);
			else
				byt = byt or  b9BAC(arg2b);
	end;

	declare i byte;

	if procCallDepth <= 10 then
	do;
		i = tx2op3(tx2qp);
		if tx2opc(i) = T2$VARIABLE then
		do;
			curInfo$p = tx2op1(i);
			if testInfoFlag(F$AUTOMATIC) then
				wAF54(133) = 3;
			else
				wAF54(133) = 4;
		end;
		else if tx2op3(i) = wB53C(procCallDepth) then
		do;
			wAF54(133) = 5;
			wB528(procCallDepth) = wB528(procCallDepth) - 1;  
		end;
		else
			wAF54(133) = 2;

		pb$C2EB = .b44F7(wAF54(133));
		call sub$9EAA(tx2op1(tx2qp), 0);
		call sub$9EAA(tx2op2(tx2qp), 1);
		call sub$9BB0;
		wC1C3 = wB528(procCallDepth);
	end;
	procCallDepth = procCallDepth - 1;  
end;




sub$9EF8: procedure public;
	procCallDepth = 1;
	call sub$9BB0;
	wB53C(procCallDepth) = wC1C3;
end;



sub$9F14: procedure public;
	if enterBlk then
		blkCurInfo(blkSP) = wC1CF;
end;


sub$9F2F: procedure public;
	declare (p, q) address;
	declare memwds based botMem(1) address;
	p, q = blkCurInfo(blkSP);
	if exitBlk then
	do;
		do while p < wC1CF;
			wC1DC(0) = 14;
			wC1DC(1) = memwds(p);
			call encodeFragData(CF$DW);
			pc = pc + 2;
			p = p + 1;  
		end;
		if wC1CF = q then
		do;
			call tx2SyntaxError(ERR201);	/*  Invalid DO CASE block, */
						/*  at least on case required */
			call emitTopItem;
		end;
		wC1CF = q;
	end;
end;



sub$9F9F: procedure public;
	if exitBlk then
	do;
		curInfo$p = blkCurInfo(procChainId);
		if not boC1CC then
		do;
			call sub$5EE8;
			call encodeFragData(CF$RET);
			pc = pc + 1;  
		end;
		if testInfoFlag(F$INTERRUPT) then
			wC1C5 = wC1C5 + 8;

		call setDimension(pc);
		call setBaseVal(wC1C5 + wC1C7);
		pc = wB488(procChainId := procChainNext(procChainId));
		bC1E6 = 0;
		call putTx1Byte(0a4h);
		call putTx1Word(blkCurInfo(procChainId) - botInfo);
		call putTx1Word(pc);
		call wrFragData;
		wC1C3 = wB4B0(procChainId);
		wC1C5 = wB4D8(procChainId);
		wC1C7 = 0;
		curExtProcId = extProcId(procChainId);
	end;
end;

sub$A072: procedure(arg1b) public;
	declare arg1b byte;
	declare p address;
	curInfo$p = tx2op1(tx2qp) + botInfo;
	p = getDimension - arg1b;
	if p < 100h then
		call sub$5F4B(p, 0, 0, 8);
	else
		call sub$5F4B(p, 0, 1, 8);
end;


sub$A0C4: procedure public;
	declare p address;
	p = sub$575E(tx2op1(tx2qp) + botInfo);
	if p < 100h then
		call sub$5F4B(p, 0, 0, 8);
	else
		call sub$5F4B(p, 0, 1, 8);
end;

sub$A10A: procedure public;
	procCallDepth = procCallDepth + 1;
	if procCallDepth <= 10 then
	do;
		call sub$5E66(0fh);
		wB528(procCallDepth) = wC1C3;
		wB53C(procCallDepth) = wC1C3;
	end;
	else if procCallDepth = 11 then
	do;
		call tx2SyntaxError(ERR203);	/*  LIMIT EXCEEDED: NESTING OF TYPED */
					/*  PROCEDURE CALLS */
		call emitTopItem;
	end;
end;




sub$A153: procedure public;
	sub$A266: procedure;
		declare i byte;

		boC1CD = 0;
		do i = 0 to 3;
			bC045(i) = 0ch;
			bC04E(i) = 0;
			boC057(i) = 0;
		end;
	end;

/* sub$A153 */
	call sub$A266;
	do tx2qp = 4 to bC1BF - 1;
		curOp = tx2opc(tx2qp);
		bC1D2 = b5124(curOp);
		do case shr(bC1D2, 6);
			do;
				if curOp = T2$CALL then
					call sub$9D06;
				else if curOp = T2$CALLVAR then
					call sub$9DD7;
				else if curOp = T2$BEGMOVE then
					call sub$9EF8;
				else
					call sub$9BB0;
			end;
			do;
				if curOp = T2$LENGTH then
					call sub$A072(0);
				else if curOp = T2$LAST then
					call sub$A072(1);
				else if curOp = T2$SIZE then
					call sub$A0C4;
			end;
			do;
				if curOp = T2$PROCEDURE then
					call sub$9457;
				else
					call sub$994D;
			end;
			do;
				if curOp = T2$CASE then
					call sub$9F14;
				else if curOp = T2$ENDCASE then
					call sub$9F2F;
				else if curOp = T2$ENDPROC then
					call sub$9F9F;
				else if curOp = T2$BEGCALL then
					call sub$A10A;
			end;
		end;

		tx2op3(tx2qp) = 0;
	end;
	call sub$5795(0);
	boC1CC = boC1CD;
end;




END;
