ftrans.pex
# common literals
TRUE            '0FFh'
FALSE           '0'
CR              '0Dh'
LF              '0Ah'
ESC             '01Bh'
bool            'byte'
word            'address'
pointer         'address'
wpointer        'address'
CONSOLE$OUT     '0'
CONSOLE$IN      '1'
#
# protocol bytes
NUL             '0'
SOH             '1'
STX             '2'
ACK             '6'
NAK             '15h'
ETB             '17h'
# ISIS system calls
Close           P("word" conn,"wpointer" status$p)
Error           P(A errNum)
Exit            P
Open            P("wpointer" conn$p,"pointer" buf,"word" mode,"word" echo,"wpointer" status$p)
Read            P(A conn,A buff$p,A count,A actual$p,A status$p)
Seek            P(A conn,A mode,A block$p,A byte$p,A status$p)
Spath           P(A path$p,A info$p,A status$p)
Write           P(A aftn,A buf$ptr,A len,A status$ptr)
CSTS            PB
CI              PB

# ISIS directory stuff
DIRECT$T1	'status BYTE, file(6) BYTE, ext(3) BYTE, attrib BYTE'
DIRECT$T2	'eof$count BYTE, blk ADDRESS, hdr$blk ADDRESS'
DIRECT$T	'structure(DIRECT$T1, DIRECT$T2)'
FORMAT$ATTRIBUTE    '80h'

# UART flags
TXRDY           '1'
RXRDY           '2'
TXEMPTY         '4'
PE              '8'
OE              '16'
FE              '32'
SYNDET          '64'
DSR             '128'
RXERROR         '(PE + OE + FE)'

# UART ports
TTYC            '0F5h'
TTYS            '0F5h'
TTYI            '0F4h'
TTYO            '0F4h'

# UART mode flags
R64X            '11B'
R16X            '10B'
R1X             '01B'
SYNC            '00B'
CL8             '1100B'
CL7             '1000B'
CL6             '0100B'
CL5             '0000B'
PENB            '10000B'
PEVEN           '100000B'
ST2             '11000000B'
ST15            '10000000B'
ST1             '01000000B'

# UART command flags
TXEN            '1'
DTR             '2'
RXEN            '4'
SBCH            '8'
CLERR           '16'
RTS             '32'
USRST           '64'
ENHM            '128'

#  mode 1 stop bit, even parity, 8 bit char 16x clock
UMODE        '(ST1 + PEVEN + PENB + CL8 + R16X)'
#  command  RTS, error reset, receive enable, DTR, transmit enable
UCOMMAND     '(RTS + CLERR + RXEN + DTR + TXEN)'

# Interval Timer Ports and commands
CTR0P           '0F0h'
ITCP            '0F3h'
RLLM            '110000B'
MODE3           '000110B'

# common ISIS error codes
NOERROR         '0'
BADFILESPEC     '4'
BADDEVICE       '5'
NOSUCHFILE      '0Dh'
WRITEPROTECTED  '0Eh'
MISSINGFNAME    '17h'
MISSINGEXT      '1ch'
UNKNOWNDEV      '5'

# FTRANS error codes
NORESPONSE      '0F0h'
NOETB           '0F1h'
NOSTX           '0F2h'
CRC$ERROR        '0F4h'
TRANSFER$ERROR   '0F5h'
NOSLAVE         '0F8h'
NOMASTER        '0FAh'
NODATA          '0FDh'
PROTOCOL$ERROR       '0FFh'

# public procedures in source
MasterConnect         P
Deblank         P(A str)A
Dmeq            P(A dir$aftn,A search$arg,A initial$i$no,A dir$entry)A
DType           P(B drive)B
FileError       P(A status,A ptr,B callExit)
ForceUpper      P(A bufferPtr)
GetByte         PB
IoError         P(A fname)
Meq             P(A mPtr,A fptr)B
ParseCmdLine    P
PSeq            P("pointer" pstr1, "pointer" pstr2)"bool"
PutByte         P(B val)
GetFile       P
GetMultipleFiles     P
ReportError     P(A status)
ScanInteger     P(A str$p,A val$p,A status$p)A
PutBlock       P(B len, "pointer" buf$p)
PutFile        P
GetBlock         P(A buf$p)B
SlaveConnect         P
PutMultipleFiles         P
TestRange       P(B device,A ioBuffer$p)B
TransmissionError P
UnPath          P(A int,A ext)
Uppercase       P(B ch)B
WDelimit        P(A ptr)A
WPath           P(A pathNamePtr,A pn,A wc1)B
WriteCopied     P
WriteSpace      P

BUFFER$SIZE     '37000'
BLOCK$SIZE      '250'

# public variables in source
exitOpt           B
bufCnt          "word"
dirConn         "word"
dstName              A
ioBuffer        BS
ioStatus        "word"
isFrom          "bool"
isMaster        "bool"
masterFile      BS
protocol        B
readConn        "word"
slaveFile       BS
status          "word"
srcName           A
writeConn       "word"

ftrans.plm
Ftrans: do;
$include(ftrans.ipx)
declare
    copyright(*) byte data('(C) 1982 INTEL CORP'),
    signOnMsg(*) byte data(CR, LF, 'ISIS FTRANS   V1.'),
    completed(*) byte data(CR, LF, 'TRANSPORTING COMPLETED', CR, LF),
    aborted(*) byte data(CR, LF, 'TRANSPORT ABORTED', CR, LF),
    instruction(*) byte data('   +------------------------------------------------+', CR, LF,
                             '   |  Enter FTRANS commands at the Master Console   |', CR, LF,
                             '   +------------------------------------------------+', CR, LF),
    crlf(2) byte data(CR, LF);
    declare junk byte;


    SetSrcDst: procedure(src, dst);
        declare (src, dst) address;
        srcName = src;
        dstName = dst;
    end;

main:
    call Write(CONSOLE$OUT, .signOnMsg, 19, .status);
    call Write(CONSOLE$OUT, .protocol, 1, .status);
    call Write(CONSOLE$OUT, .crlf, 2, .status);
    call ParseCmdLine;
    if isMaster then
    do;    
        call MasterConnect;
        if isFrom then
        do;
            call SetSrcDst(.slaveFile(1), .masterFile(1));
            call PutBlock(15, srcName);
            call TransmissionError;
            if ioStatus <> 0 then
                call Exit;
            call PutBlock(15, dstName);
            call TransmissionError;
            if ioStatus <> 0 then
                call Exit;
            call GetMultipleFiles;
        end;
        else
        do;
            call SetSrcDst(.masterFile(1), .slaveFile(1));
            call PutMultipleFiles;
            call Close(dirConn, .status);
            call Close(readConn, .status);
            call TransmissionError;
        end;
    end;
    else
    do;
        call Write(CONSOLE$OUT, .instruction, 165, .status);
        exitOpt = 0; 
        do while not exitOpt;
            call SlaveConnect;
            if isFrom then
            do;
                call SetSrcDst(.slaveFile(1), .masterFile(1));
                junk = GetBlock(srcName);
                call PutByte(ETB);
                if ioStatus = NOERROR then
                do;
                    junk = GetBlock(dstName);
                    call PutByte(ETB);
                    if ioStatus = NOERROR then
                    do;
                        call PutMultipleFiles;
                        call Close(dirConn, .status);
                        call Close(readConn, .status);
                    end;
                end;
            end;
            else
            do;
                call SetSrcDst(.masterFile(1), .slaveFile(1));
                call GetMultipleFiles;
            end;
            call TransmissionError;
        end;
    end;
    if ioStatus = NOERROR then
        call Write(CONSOLE$OUT, .completed, 26, .status);
    else
        call Write(CONSOLE$OUT, .aborted, 21, .status);
    call Exit;
end;
cmdlin.plm
CmdLine: do;
$include(cmdlin.ipx)

declare
    cmdLine(128)    byte,
    cmdLineLen      word,
    cmdPtr          address, cmdCh based cmdPtr byte,
    tokStart        address,
    bitRate         word,
    exitToken(16)   byte,
    toFrom(16)      byte;

SyntaxError: procedure;
    declare syntaxMsg(*) byte data(
            CR, LF, 'SYNTAX ERROR',
            CR, LF, 'SYNTAX ==> FTRANS master-file {TO | FROM} slave-file [baudrate] [E | EXIT] <cr>',
            CR, LF);

    call Write(CONSOLE$OUT, .syntaxMsg, size(syntaxMsg), .status);
    call Exit;
end;

CmdDeblank: procedure;
    do while cmdCh = ' ';
        cmdPtr = cmdPtr + 1;
    end;
end;


getToken: procedure(pStr);
    declare pStr address, str based pStr(1) byte;

    str(0) = 0;
    call cmdDeblank;
    do while cmdCh = ':' or cmdCh = '.' or cmdCh = '*' or cmdCh = '?' or
            ('0' <= cmdCh and cmdCh <= '9') or
            ('A' <= cmdCh and cmdCh <= 'Z' and str(0) < 16);       /* possible error on length test */
       str(str(0) := str(0) + 1) = cmdCh;
        cmdPtr = cmdPtr + 1;
    end;
    if cmdCh <> ' ' and cmdCh <> CR then
        call syntaxError;
    str(str(0) + 1) = ' ';
    call cmdDeblank;
end;

declare sysFlag byte at(0FFFFh);

SetBitRateScaler:  procedure(scaler);
    declare scaler word;
    if sysFlag = 0 then     /* return if series I monitor */
        return;
    output(ITCP) = RLLM + MODE3;
    output(CTR0P) = low(scaler);
    output(CTR0P) = high(scaler);
end;

InitUart: procedure;
    declare junk byte;
    output(TTYC) = 0;       /* reset uart */
    output(TTYC) = 0;       /* handles sync mode + 2 sync chars */
    output(TTYC) = 0;       
    output(TTYC) = USRST;
    output(TTYC) = UMODE;
    output(TTYC) = UCOMMAND;
    junk = input(TTYI);     /* clear data port */
end;


SetBitRate: procedure;
    declare badBaud(*) byte data(
            CR, LF, 'ILLEGAL BAUD RATE',
            CR, LF, 'Legal Baudrates ==> 110, 150, 300, 600, 1200, 2400, 4800, 9600, 19200(default)',
            CR, LF);

    cmdPtr = ScanInteger(cmdPtr, .bitRate, .status);
    if status <> 0 then
        bitRate = 255;
    if bitRate = 110 then
        call SetBitRateScaler(698);
    else if bitRate = 150 then
        call SetBitRateScaler(512);
    else if bitRate = 300 then
        call SetBitRateScaler(256);
    else if bitRate = 600 then
        call SetBitRateScaler(128);
    else if bitRate = 1200 then
        call SetBitRateScaler(64);
    else if bitRate = 2400 then
        call SetBitRateScaler(32);
    else if bitRate = 4800 then
        call SetBitRateScaler(16);
    else if bitRate = 9600 then
        call SetBitRateScaler(8);
    else if bitRate = 19200 then
        call SetBitRateScaler(4);
    else
    do;
        call Write(CONSOLE$OUT, .badBaud, size(badBaud), .status);
        call Exit;
    end;
    call cmdDeblank;
end;


ParseCmdLine: procedure public;
    call Read(CONSOLE$IN, .cmdLine, 128, .cmdLineLen, .status);
    call ForceUpper(cmdPtr := .cmdLine);
    exitOpt = FALSE;
    isMaster = FALSE;
    bitRate = 255;      /* dummy bitRate used to check if user specified */
    call cmdDeblank;
    tokStart = cmdPtr;
    call getToken(.masterFile);
    if cmdCh = CR then  /* only one or no parameter */
    do; /* SLAVE mode */
        if '0' <= masterFile(1) and masterFile(1) <= '9' and masterFile(0) > 0 then
        do;                     /* its a number so rescan as bit rate */
            cmdPtr = tokStart;
            call SetBitRate;
        end;
        else if masterFile(0) > 0 then  /* non numeric parameter so bad syntax */
            call SyntaxError;
    end;
    else
        isMaster = TRUE;
    if isMaster then
    do;
        call getToken(.toFrom);     /* should be FROM or TO */
        call getToken(.slaveFile);  /* slave file name */
        do while cmdCh <> CR;       /* pick up any EXIT, E or bit rate parameters */
            if '0' <= cmdCh and cmdCh <= '9' and bitRate = 255 then
                call SetBitRate;
            else
            do;
                call getToken(.exitToken);
                if pSeq(.exitToken, .(4, 'EXIT')) or (pSeq(.exitToken, .(1, 'E')) and not exitOpt) then
                    exitOpt = TRUE;
                else
                    call SyntaxError;
            end;
        end;
        if pSeq(.toFrom, .(4, 'FROM')) then
            isFrom = TRUE;
        else if pSeq(.toFrom, .(2, 'TO')) then
            isFrom = FALSE;
        else
            call SyntaxError;
        if slaveFile(0) = 0 then
            call SyntaxError;
    end;
    if bitRate = 255 then
    do;
        bitRate = 19200;
        call SetBitRateScaler(4);
    end;
    call InitUart;
end;
end;

txbyte.plm
TxByte: do;
$include(txbyte.ipx)

declare
    protocol    byte public initial('0'),
    readConn    word public,
    writeConn   word public,
    dirConn     address public,
    dstName     address public,
    srcName     address public,
    status      word public,
    ioStatus    word public,
    exitOpt     byte public,
    unused      byte,
    isFrom      bool public,
    isMaster    bool public,
    masterFile(16) byte public,
    slaveFile(18)  byte public,
    timer       word public;

PutByte: procedure(val) public;
    declare val byte;
    do while (input(TTYS) and (TXEMPTY + TXRDY)) = 0;
    end;
    output(TTYO) = val;
end;


GetByte: procedure byte public;
    declare i word;

    if (input(TTYS) and RXRDY) <> 0 then   /* RxReady */
        return input(TTYI);

    timer = 0FFFFh;                     /* tries for ~ 36s assuming 5Mhz 8085 */

    do while (input(TTYS) and RXRDY) = 0 and timer <> 0;
        timer = timer - 1;
        do i = 1 to 12;
            if (input(TTYS) and RXRDY) <> 0 then
                return input(TTYI);
        end;
    end;
    if timer = 0 then
    do;
        call Write(CONSOLE$OUT, .(CR, LF, 'TIME OUT ERROR ON INPUT', CR, LF), 27, .status);
        call Exit;
    end;
    return input(TTYI);
end;
end;
txdata.plm
TransferData: do;
$include(txdata.ipx)
declare ii word;
declare ioCnt byte;
declare triesLeft byte;
declare startBuf address;
declare crc byte;

GetDataByte: procedure byte;
    if (input(TTYS) and RXRDY) <> 0 then
        return input(TTYI);

    do ii = 1 to 20000;         /* tries for ~ 750ms assuming 5Mhz 8085 */
        if (input(TTYS) and RXRDY) <> 0 then
            return input(TTYI);
    end;
    ioStatus = NODATA;
    return 1;
end;


GetBlock: procedure(buf$p) byte public;
    declare buf$p address, buf based buf$p (1) byte,
            rcvLen byte;
    triesLeft = 11;
    buf$p = buf$p - 1;  /* adjust as index is 1..rcvlen */
    
retry:
    do;
        ioStatus, crc = 0;
        call PutByte(STX);
        rcvLen = GetByte;
        do ioCnt = 1 to rcvLen;
            crc = crc + (buf(ioCnt) := GetDataByte);
        end;
        if crc + GetDataByte <> 0 then
            ioStatus = CRC$ERROR;
        if (input(TTYS) and RXERROR) <> 0 then
        do;
            ioStatus = TRANSFER$ERROR;
            output(TTYC) = UCOMMAND;
        end;
        call PutByte(ioStatus);
        if ioStatus <> 0 then
        do;
            triesLeft = triesLeft - 1;
            if triesLeft <> 0 then
            do;
                call Write(CONSOLE$OUT, .('#'), 1, .status);
                goto retry;
            end;
        end;
        call Write(CONSOLE$OUT, .('.'), 1, .status);
        return rcvLen;
    end;
end;

PutBlock: procedure(len, buf$p) public;
    declare len byte, buf$p address, ch based buf$p byte;
    startBuf = buf$p;
    triesLeft = 11;

retry:
    do;
        ii = BLOCK$SIZE;
        do while GetByte <> STX;
            if (ii := ii - 1) = 0 then
            do;
                ioStatus = NOSTX;
                return;
            end;
        end;
        call PutByte(len);
        ioStatus, crc = 0;
        buf$p = startBuf;
        do ioCnt = 1 to len;
            call PutByte(ch);
            crc = crc + ch;
            buf$p = buf$p + 1;
        end;
        call Write(CONSOLE$OUT, .('.'), 1, .status);
        call PutByte(-crc);
        if (ioStatus := GetByte) <> 0 then
        do;
            triesLeft = triesLeft - 1;
            if triesLeft <> 0 then
            do;
                call Write(CONSOLE$OUT, .('#'), 1, .status);
                goto retry;
            end;
            else
            do;
                ioStatus = TRANSFER$ERROR;
                return;
            end;
        end;
    end;
    if GetByte <> ETB then
        ioStatus = NOETB;
end;


GetFile: procedure public;
    declare readCnt byte, filling bool;

    readCnt = BLOCK$SIZE;
    do while readCnt <> 0;
        filling = TRUE;
        bufCnt = 0;
        do while filling;
            readCnt = GetBlock(.ioBuffer + bufCnt);
            if ioStatus <> 0 then
                return;
            bufCnt = bufCnt + readCnt;
            if readCnt = 0  or bufCnt > (BUFFER$SIZE - BLOCK$SIZE) then
                filling = FALSE;
            else
                call PutByte(ETB);
        end;
        call Write(writeConn, .ioBuffer, bufCnt, .ioStatus);
        call PutByte(ETB);
        if ioStatus <> 0 then
        do;
            call IoError(dstName);
            return;
        end;
    end;
end;


PutFile: procedure public;
    declare (toWrite, actual) word;

    actual = BUFFER$SIZE;
    do while actual = BUFFER$SIZE;
        call Read(readConn, .ioBuffer, BUFFER$SIZE, .actual, .ioStatus);
        if ioStatus <> 0 then
        do;
            call IoError(srcName);
            return;
        end;
        bufCnt = 0;
        do while actual <> bufCnt;
            if (toWrite := actual - bufCnt) > BLOCK$SIZE then
                toWrite = BLOCK$SIZE;
            call PutBlock(low(toWrite), .ioBuffer + bufCnt);
            if ioStatus <> 0 then
            do;
                call IoError(dstName);
                return;
            end;
            bufCnt = bufCnt + toWrite;
        end;
    end;
    call PutBlock(0, .ioBuffer);
end;
end;
ioBuf.plm
ioBuffer: do;
$include(ioBuf.ipx)
declare bufCnt word public,
        ioBuffer(BUFFER$SIZE) byte public;
end;
conect.plm
Connect: do;
$include(conect.ipx)

declare noNetwork(*) byte data(CR, LF, 'FAILED TO ESTABLISH NETWORK', CR, LF);
declare badConnect(*) byte data(CR, LF, 'CHECK CABLE AND/OR BAUD RATES', CR, LF);
declare incompatable(*) byte data(CR, LF, 'INCOMPATABLE VERSION NUMBERS', CR, LF);

declare (syncTriesLeft, iw) address,
        (ib, waitSync) byte;

SlaveConnect: procedure public;
retry:
    do;
        if (input(TTYS) and RXERROR) <> 0 then
            output(TTYC) = UCOMMAND;
        syncTriesLeft = 255;
x:  /* force sub optimal compiler code generation */
        waitSync = 255;
        ioStatus = NOERROR; 

        do while waitSync <> 0 and ioStatus = NOERROR;
            if (input(TTYS) and RXERROR) <> 0 then
                output(TTYC) = UCOMMAND;
            do while (input(TTYS) and RXRDY) = 0;
                if CSTS then 
                    if (CI and 7Fh) = ESC then
                        call Exit;
            end;
            waitSync = input(TTYI) xor SOH;    /* loop until SOH seen or timeout */
            if (syncTriesLeft := syncTriesLeft - 1) = 0 then
                ioStatus = NOMASTER;
        end;
        if ioStatus <> 0 then
        do;
            call Write(CONSOLE$OUT, .badConnect, size(badConnect), .status);
            goto retry;
        end;
        call PutByte(ACK);
        do while (ib := GetByte) = SOH;  /* gobble up any extra SOH */
        end;
        if ib <> ACK then
        do;
            call Write(CONSOLE$OUT, .noNetwork, size(noNetwork), .status);
            call PutByte(PROTOCOL$ERROR);
            goto retry;
        end;
        else
            call PutByte(STX);
        iw = GetBlock(.isFrom);
        call PutByte(ETB);          /* would be better to put in an else part of test below */
        if ioStatus <> 0 then
        do;
            call TransmissionError;
            call PutByte(PROTOCOL$ERROR);
            goto retry;
        end;

        iw = GetBlock(.exitOpt);
        call PutByte(ETB);          /* see comment above */
        if ioStatus <> 0 then
        do;
            call TransmissionError;
            call PutByte(PROTOCOL$ERROR);
            goto retry;
        end;

        iw = GetBlock(.ib);
        call PutByte(ETB);          /* see comment above */
        if ioStatus <> 0 then
        do;
            call TransmissionError;
            call PutByte(PROTOCOL$ERROR);
            goto retry;
        end; 
    end;
    if ib <> protocol then
    do;
        call Write(CONSOLE$OUT, .incompatable, size(incompatable), .status);
        call PutByte(NAK);
        call Exit;
    end;
    else
        call PutByte(ACK);
end;
  

MasterConnect: procedure public;
    syncTriesLeft = 10;
    ioStatus = NOERROR;
    waitSync = 0FFh;

    do while  waitSync <> 0 and ioStatus = NOERROR;
        iw = 5;

        do while (input(TTYS) and RXRDY) = 0 and ioStatus = NOERROR;
            call PutByte(SOH);
            do ib = 1 to 50;
                call time(100);
            end;
            if (iw := iw - 1) = 0 then
                ioStatus = NORESPONSE;
        end;
        if (input(TTYS) and RXRDY) <> 0 then
            waitSync = input(TTYI) xor ACK;
        if (syncTriesLeft := syncTriesLeft - 1) = 0 then
            ioStatus = NOSLAVE;
        else
            ioStatus = NOERROR;
    end;
    if ioStatus <> 0 then
    do;
        call Write(CONSOLE$OUT, .noNetwork, size(noNetwork), .status);
        call PutByte(NAK);
        call Exit;
    end;

    call PutByte(ACK);
    if GetByte <> STX then
    do;
        ioStatus = TRANSFER$ERROR;
        call TransmissionError;
    end;
    call PutBlock(1, .isFrom);
    if ioStatus <> 0 then
        call TransmissionError;

    call PutBlock(1, .exitOpt);
    if ioStatus <> 0 then
        call TransmissionError;

    call PutBlock(1, .protocol);
    if ioStatus <> 0 then
        call TransmissionError;

    if GetByte <> ACK then
    do;
        call Write(CONSOLE$OUT, .incompatable, size(incompatable), .status);
        call Exit;
    end;
end;
end;
multif.plm
MultipleFiles: do;
$include(multif.ipx)

declare junk address,
        isisDir(*) byte initial(':FX:ISIS.DIR '),
        (noFile, moreFiles) bool;

GetMultipleFiles: procedure public;
    if (ioStatus := GetByte) <> 0 then
    do;
        call IoError(.(' '));
        return;
    end;
    if (ioStatus := GetByte) <> 0 then
    do;
        if ioStatus = SOH then
            ioStatus = PROTOCOL$ERROR;
        call IoError(.isisDir + 4);
        return;
    end;
    moreFiles = TRUE;
    noFile = TRUE;
    do while moreFiles;
        if (moreFiles := GetByte) then
        do;
            junk = GetBlock(srcName);
            call PutByte(ETB);
            if ioStatus <> 0 then
                return;
            
            junk = GetBlock(dstName);
            call PutByte(ETB);
            if ioStatus <> 0 then
                return;
            if (ioStatus := GetByte <> 0) then
            do;
                call IoError(srcName);
                return;
            end;
            call OPEN(.writeConn, dstName, 2, 0, .ioStatus);
            call PutByte(ioStatus);
            call IoError(dstName);
            if ioStatus = WRITEPROTECTED then
                goto writeProtect;
            if iostatus <> 0 then
                return;

            call GetFile;
            call Close(writeConn, .status);
            if ioStatus <> 0 then
                return;
            call PutByte(status);
            if status <> 0 then
            do;
                ioStatus = status;
                call IoError(dstName);
                return;
            end;
            call writeCopied;

writeProtect:
            noFile = FALSE;
        end;
    end;
    if noFile then
    do;
        ioStatus = NOSUCHFILE;
        if isMaster then
            call IoError(srcName);
        else
            call IoError(.(' '));
    end;
end;



PutMultipleFiles: procedure public;
    declare name based dstName (1) byte;
    declare (dirEntry, maxDir) address,
            (wc1, wc2, drive, i) byte,
            (pn1, pn2, pn3) (10) byte,
            direct DIRECT$T;

    ioStatus = NOERROR;
    status = WPath(srcName, .pn1, .wc1);    /* parse src filename */
    if (drive := pn1(0)) > 5 then
        ioStatus = BADDEVICE;
    else if status <> 0 then
        ioStatus = status;
    else
    do;
        status = WPath(dstName, .pn2, .wc2);    /* parse dst filename */
        if pn2(0) > 5 then
            ioStatus = BADDEVICE;
        else if status = MISSINGFNAME then   /* missing filename */
        do;
            status = WPath(srcName, .pn2, .wc1);    /* initialise with src name */
            pn2(0) = name(2) - '0';         /* copy drive over */
            wc2 =0;                         /* just use wc1 flag */
        end;
        else
        do;
            /*
                check names are compatable as follows
                src ?    ok with dst ? or *
                src *    ok with dst *
                src null ok with dst char, null or *
            */
            do i = 0 to 9;
                if pn1(i) = '?' and (pn2(i) <> '?' and pn2(i) <> '*')
                   or (pn1(i) = '*' and pn2(i) <> '*')
                   or (pn1(i) = 0 and pn2(i) = '?') then
                    status = BADFILESPEC; /* incorrectly specified file */
            end;

            if status <> 0 then
                ioStatus = status;
        end;
    end;

    call PutByte(ioStatus);
    if ioStatus <> 0 then
    do;
        call IoError(.(' '));
        return;
    end;

    isisDir(2) = drive + '0';
    call Open(.dirConn, .isisDir, 1, 0, .ioStatus);
    call PutByte(ioStatus);
    if ioStatus <> 0 then
    do;
        call IoError(.isisDir);
        return;
    end;
    if DType(drive) = 4 then    /* Hard Disk */
        maxDir = 992;
    else
        maxDir = 200;

    moreFiles = TRUE;
    noFile = TRUE;
    pn1(0) = 0;
    dirEntry =  0;

    do while moreFiles;
        dirEntry = Dmeq(dirConn, .pn1, dirEntry, .direct);
        if dirEntry > maxDir then
        do;
            moreFiles = FALSE;
            call PutByte(moreFiles);
        end;
        else if (direct.attrib and FORMAT$ATTRIBUTE) = 0 or not wc1 then
        do;
            call PutByte(moreFiles);
            direct.status = drive;         /* convert to file name */
            call UnPath(.direct, srcName);

            if not wc2 and wc1 then        /* dst uses same name as src */
            do;
                direct.status = pn2(0);    /* convert to file name */
                call UnPath(.direct, dstName);
            end;
            else
            do;
                do i = 0 to 9;
                    if pn2(i) = '?' or pn2(i) = '*' then
                        pn3(i) = direct.file(i - 1);   /* pn2(0) will not be ? or * so ok */
                    else
                        pn3(i) = pn2(i);   /* create dstName based on pattern */
                end;
                call UnPath(.pn3, dstName);
            end;

            call PutBlock(15, srcName);
            if ioStatus <> 0 then
                return;

            call PutBlock(15, dstName);
            if ioStatus <> 0 then
                return;

            call Open(.readConn, srcName, 1, 0, .ioStatus);
            call PutByte(ioStatus);
            call IoError(srcName);
            if ioStatus <> 0 then
                return;

            ioStatus = GetByte;
            if ioStatus = SOH then
                ioStatus = 0FFh;

            call IoError(dstName);
            if ioStatus = WRITEPROTECTED then
                goto writeProtect;
            if ioStatus <> 0 then
                return;

            call PutFile;
            if ioStatus <> 0 then
                return;

            if (ioStatus := GetByte <> 0) then
            do;
                call IoError(dstName);
                return;
            end;
            call writeCopied;

writeProtect:
            call Close(readConn, .status);
            noFile = FALSE;
        end;
    end;
    if noFile then
    do;
        ioStatus = NOSUCHFILE;
        call IoError(srcName);
    end;
end;

end;
copied.plm
copied: do;
$include(copied.ipx)

WriteToSpace: procedure(ptr);
    declare ptr address, ch based ptr byte;
    do while ch <> ' ';
        call Write(CONSOLE$OUT, ptr, 1, .status);
        ptr = ptr + 1;
    end;
end;


WriteSpace: procedure public;
    call Write(CONSOLE$OUT, .(' '), 1, .status);
end;

WriteCopied: procedure public;
    declare (master, slave) address;

    if isFrom then 
    do;
        master = dstName;
        slave = srcName;
    end;
    else
    do;
        master = srcName;
        slave = dstName;
    end;

    call WriteToSpace(.(LF, CR, 'COPIED '));
    call WriteSpace;
    call WriteToSpace(master);
    call WriteSpace;
    if isFrom then
        call WriteToSpace(.('FROM '));
    else
        call WriteToSpace(.('TO '));
    call WriteSpace;
    call WriteToSpace(slave);
    call WriteToSpace(.(CR, LF, ' '));
end;
end;
ioerr.plm
IoError: do;
$include(ioerr.ipx)
declare txError(*) byte data(CR, LF, 'TRANSMISSION ERROR', CR, LF);
declare errMsg(*) byte data(CR, LF, 'ERROR==>');


IoError: procedure(fname) public;
    declare fname address;

    if ioStatus <> 0 and ioStatus < 0F0h then
    do;
        call Write(CONSOLE$OUT, .errMsg, size(errMsg), .status);
        call FileError(iostatus, fname, FALSE);
    end;
end;


TransmissionError: procedure public;
    if ioStatus >= 0F0h then
    do;
        call Write(CONSOLE$OUT, .txError, size(txError), .status);
        if isMaster then
            call Exit;
    end;
end;
end;
dtype.plm
DTYPE: DO;

Spath: procedure(path$p, info$p, status$p) external;
    declare (path$p, info$p, status$p) address;
end;

declare isisDrive(*) byte initial(':FX: ');

DType: procedure(drive) byte public;
    declare drive byte;
    declare status address, info(12) byte;

    if  drive > 9 then
        return 0;
    isisDrive(2) = drive + '0';
    call Spath(.isisDrive, .info, .status);
    return info(11);
end;
end;
ferror.plm
FILEERROR: DO;

write: procedure (conn, buff$p, count, actual$p) external;
    declare (conn, buff$p, count, actual$p) address;
end write;

exit: procedure external; end exit;

deblank: procedure(str) address external; declare str address; end;
WDelimit: procedure(ptr) address external; declare ptr address; end;
reporterror: procedure(status) external; declare status address; end;

declare OK literally '0';

FileError: procedure(status, ptr, callExit) public;
	declare (status, ptr) address;
	declare callExit byte;
	declare wrStatus address;

	if status <> OK then
	do;
		ptr = deblank(ptr);
		call write(0, .(' '), 1, .wrStatus);
		call write(0, ptr, WDelimit(ptr) - ptr, .wrStatus);
		call write(0, .(','), 1, .wrStatus);
		call reporterror(status);
		if callExit then
			call exit;
	end;
end;
end;
forupp.plm
FORCEUPPER: DO;
declare CR literally '0DH';

uppercase: procedure(ch) byte external; declare ch byte; end;

forceupper: procedure(bufferPtr) public;
	declare bufferPtr address, ch based bufferPtr byte;

	do while ch <> CR;
		ch = uppercase(ch);
		bufferPtr = bufferPtr + 1;
	end;
end;
end;
unpath.plm
UNPATH: DO;

declare devTab(*) byte data('F0F1F2F3F4F5TITO',
			     'VIVOI1O1TRHRR1R2',
			     'TPHPP1P2LPL1BBCICO',
			     'F6F7F8F9');

unpath:	procedure(int, ext) public;
	declare (int, ext) address;
	declare i byte;
	declare intName based int (1) byte;
	declare extName based ext (1) byte;

	extName(0) = ':';
	extName(1) = devTab(intName(0) + intName(0));
	extName(2) = devTab(intName(0) + intName(0) + 1);
	extName(3) = ':';	
	ext = ext + 4;
	do i = 0 to 5;
		if (extName(0) := intName(i + 1)) <> 0 then
			ext = ext + 1; 
	end;
	if intName(7) <> 0 then
	do;
		extName(0) = '.';
		ext = ext + 1;
	end;
	do i = 0 to 2;
		if (extName(0) := intName(i + 7)) <> 0 then
			ext = ext + 1; 

	end;
	extName(0) = ' ';
end;
end;
wpath.plm
WPath: DO;
uppercase: procedure(char) byte external;
	declare char byte;
end;

TestRange: procedure(device, ioBuffer$p) byte external;
	declare device byte, ioBuffer$p address;
end;

declare FALSE literally '0';
declare TRUE literally '0FFh';


declare lastPathNameParsed(15) byte;

/* the error return codes */
declare BADFILESPEC	literally '4';
declare UNKNOWNDEV	literally '5';
declare MISSINGFNAME	literally '17h';
declare MISSINGEXT	literally '1ch';
declare NOERROR		literally '0';

declare devTab(*) byte data('F0F1F2F3F4F5TITOVIVOI1O1',
			    'TRHRR1R2TPHPP1P2LPL1BBCICOF6F7F8F9');

WPath: procedure(pathNamePtr, pn, wc1) byte public;
	declare (pathNamePtr, pn, wc1) address;
	declare ptr address;
	declare	addr address, (hi, lo) byte at (.addr);
	declare	devPtr address, (nullName, pl, i) byte;
	declare pathName based pathNamePtr (1) byte;
	declare pnStr based pn (1) byte;
	declare wcFlag based wc1 byte;
	declare dev based devPtr address;
	declare ch based ptr byte;
	
	NonTerminator: procedure byte;
		return ('A' <= pathName(0) and pathName(0) <= 'Z') or
		       ('0' <= pathName(0) and pathName(0) <= '9') or
		       pathName(0) = '?' or pathName(0) = '*' or
		       ('a' <= pathName(0) and pathName(0) <= 'z');
	end;
	wcFlag = FALSE;
	devPtr = .devTab;
	do i = 0 to 9;
		pnStr(i) = 0;
	end;
	do while pathName(0) = ' ';
		pathNamePtr = pathNamePtr + 1;
	end;

	ptr = pathNamePtr;
	if pathName(0) = ':' then
	do;
		if pathName(3) <> ':' then
			return BADFILESPEC;	/* incorrectly specified file */
		pathNamePtr = pathNamePtr + 1;
		hi = Uppercase(pathName(0));
		pathNamePtr = pathNamePtr + 1;
		lo = Uppercase(pathName(0));
		pathNamePtr = pathNamePtr + 2;
		pnStr(0) = 0FFh;
		i = 0;
		do while i < 57;
			if dev = addr then
				pnStr(0) = shr(i, 1);
			i = i + 2;
			devPtr = devPtr + 2;
		end;
		if pnStr(0) = 0FFh then
			return UNKNOWNDEV;	/* unrecognized device pathName */
	end;
	nullName = TRUE;
	i = 1;
	do while i < 7;
		if NonTerminator then
		do;
			pnStr(i) = Uppercase(pathName(0));
			if pathName(0) = '*' then
				do while i < 7;
					wcFlag = TRUE;
					pnStr(i) = '*';
					i = i + 1;
				end;
			else if pathName(0) = '?' then
				wcFlag = TRUE;
			pathNamePtr = pathNamePtr + 1;
			nullName = FALSE;
		end;
		i = i + 1;
	end;
	if pathName(0) = '.' then
	do;
		pathNamePtr = pathNamePtr + 1;
		i = 7;
		do while i < 10;
			if NonTerminator then
			do;
				pnStr(i) = Uppercase(pathName(0));
				if pathName(0) = '*' then
					do while i < 10;
						wcFlag = TRUE;
						pnStr(i) = '*';
						i = i + 1;
					end;
				else if pathName(0) = '?' then
					wcFlag = TRUE;
				pathNamePtr = pathNamePtr + 1;
			end;
			i = i + 1;
		end;
	end;
	if TestRange(pnStr(0), 1) <= 9 and nullName then
		return MISSINGFNAME;	/*  missing filename */
	pl = 0FFh;
	do while ptr < pathNamePtr;
		lastPathNameParsed(pl := pl + 1) = ch;
		ptr = ptr + 1;
	end;
	if lastPathNameParsed(pl) = '.' then
		return MISSINGEXT;	/* missing extension */
	lastPathNameParsed(pl + 1) = ' ';
	if NonTerminator or pathName(0) = '.' or pathName(0) = ':' then
		return BADFILESPEC;	/* incorrectly specified file */
	return NOERROR;
end;
end;
pseq.asm
        name pseq
        public pseq
; pSeq: procedure(str1, str2) public; (str1, str2) address; end;
; compare two pascal style strings being the same
        cseg
pSeq:
        xchg
        mov     e, m
        inr     e

cmplop:
        ldax    b
        cmp     m
        jnz     neq
        inx     h
        inx     b
        dcr     e
        jnz     cmplop
        mvi     a, 0FFh
        ret

neq: 
        xra     a
        ret
        end;

scanin.plm
scanInteger: do;
declare word literally 'address';
declare NOERROR literally '0';

ScanInteger: procedure(str$p, val$p, status$p) address public;
    declare (str$p, val$p, status$p) address;
    declare val based val$p word;
    declare status based status$p byte;
    declare (scanPtr, pastNum$p, endNum$p) address;
    declare ch based scanPtr byte;
    declare (i, radix, digit) byte;
    declare curVal word;

    declare hexDigits(16) byte data('0123456789ABCDEF');

    status = NOERROR;
    scanPtr = str$p;    
    do while '0' <= ch and ch <= '9' or 'A' <= ch and ch <= 'F';
        scanPtr = scanPtr + 1;
    end;

    pastNum$p = (endNum$p := scanPtr) + 1;
    if ch = 'H' then
        radix = 16;
    else if ch = 'O' or ch = 'Q' then
        radix = 8;
    else
    do;
        endNum$p, scanPtr = (pastNum$p := scanPtr) - 1;
        if ch = 'B' then
            radix = 2;
        else
        do;
            radix = 10;
            if ch <> 'D' then
                endNum$p = endNum$p + 1;
        end;
    end;    
    scanPtr = str$p;
    val = 0;
    do while scanPtr < endNum$p;
        do i = 0 to 15; 
            if ch = hexDigits(i) then
                digit = i;
        end;
        if digit >= radix then
            goto err;
        curVal = val;
        do i = 1 to radix - 1;
            val = val + curVal;
            if carry then
                goto err;
        end;
        val = val + digit;
        if carry then
            goto err;
        else
            scanPtr = scanPtr + 1;
    end;
    return pastNum$p;

err:
    status = 0ffh;
    return pastNum$p;
end;
end;
dmeq.plm
DMEQ: DO;
declare TRUE	literally '0FFH',
	FALSE	literally '0';

read: procedure (conn, buff$p, count, actual$p, status$p) external;
    declare (conn, buff$p, count, actual$p, status$p) address;
end read;

seek: procedure (conn, mode, block$p, byte$p, status$p) external;
    declare (conn, mode, block$p, byte$p, status$p) address;
end seek;

meq: procedure(A, B) byte external ; declare (A,B) address; end;

/* should return a word as per requirement, code loads hl and l */
Dmeq: procedure (dir$aftn, search$arg, initial$i$no, dir$entry) byte public;
    declare (dir$aftn, search$arg, initial$i$no, dir$entry) address;
    declare (byteNo, blockNo, actual, status) address;
    declare (pad, searching) byte;
    declare dirFlag based dir$entry byte;

	blockNo = 0;
	byteNo = initial$i$no * 16;
	call seek(dir$aftn, 2, .blockNo, .byteNo, .status);

	searching = TRUE;
	do while searching;
		call read(dir$aftn, dir$entry, 16, .actual, .status);
		searching = not meq(search$arg, dir$entry);
		initial$i$no = initial$i$no + 1;
		if dirFlag = 7Fh or actual = 0 then
		do;
			initial$i$no = 0FFFFh;
			searching = FALSE;
		end;
	end;
		
	return initial$i$no;
end;
end;
dblank.plm
DEBLANK: DO;
deblank: procedure(ptr) address public;
	declare ptr address, c based ptr byte;

	do while (c = ' ');
		ptr = ptr + 1;
	end;
	return ptr;
end;
end;
meq.plm
MEQ: DO;

meq: procedure(mPtr, fptr) byte public;
	declare (mPtr, fptr) address;
	declare m based mPtr (10) byte;
	declare f based fptr (10) byte;
	declare i byte;

	do i = 0 to 9;
		if m(i) = '?' then
		do;
			if f(i) = 0 then
				return 0;
		end;
		else if m(i) <> '*' then
		do;
			if m(i) <> f(i) then
				return 0;
		end;
	end;
	return 0ffh;
end;
end;

reperr.plm
REPORTERROR: DO;

error: procedure(errNum) external; declare errNum address; end;

write: procedure(aftn, buf$ptr, len, status$ptr) external;
   declare (aftn, buf$ptr, len, status$ptr) address;
end write;

declare CR	literally '0dh';
declare LF	literally '0ah';

reporterror: procedure(errNum) public;
	declare errNum address;
	declare numberBuffer(3) byte;
	declare (i, status) address;
 
	declare msg(*) byte DATA(0, 0,
		2, 'ILLEGAL AFTN ARGUMENT', 0,
		4, 'INCORRECTLY SPECIFIED FILE', 0,
		5, 'UNRECOGNIZED DEVICE NAME', 0,
		6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
		8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
		9, 'DISK DIRECTORY FULL', 0,
		0AH, 'NOT ON SAME DISK', 0,
		0BH, 'FILE ALREADY EXISTS', 0,
		0CH, 'FILE IS ALREADY OPEN', 0,
		0DH, 'NO SUCH FILE', 0,
		0EH, 'WRITE PROTECTED', 0,
		11H, 'NOT A DISK FILE', 0,
		12H, 'ILLEGAL ISIS COMMAND', 0,
		13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
		14H, 'ATTEMPTED BACK SEEK TOO FAR', 0,
		15H, 'CAN''T RESCAN', 0,
		16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
		17H, 'MISSING FILENAME', 0,
		19H, 'ILLEGAL ECHO FILE', 0,
		1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
		1BH, 'ILLEGAL SEEK COMMAND', 0,
		1CH, 'MISSING EXTENSION', 0,
		1FH, 'CAN''T SEEK ON WRITE ONLY FILE', 0,
		20H, 'CAN''T DELETE OPEN FILE', 0,
		23H, 'SEEK PAST EOF', 0,
		0C9H, 'UNRECOGNIZED SWITCH', 0,
		0CAH, 'UNRECOGNIZED DELIMITER', 0,
		0CBH, 'INVALID SYNTAX', 0,
		0CCH, 'PREMATURE EOF', 0,
		0CEH, 'ILLEGAL DISKETTE LABEL', 0,
		0D0H, 'CHECKSUM ERROR', 0,
		0D1H, 'RELO FILE SEQUENCE ERROR', 0,
		0D2H, 'INSUFFICIENT MEMORY', 0,
		0D3H, 'RECORD TOO LONG', 0,
		0D4H, 'ILLEGAL RELO RECORD', 0,
		0D5H, 'FIXUP BOUNDS ERROR', 0,
		0D6H, 'ILLEGAL SUBMIT PARAMETER', 0,
		0D7H, 'ARGUMENT TOO LONG', 0,
		0D8H, 'TOO MANY PARAMETERS', 0,
		0D9H, 'OBJECT RECORD TOO SHORT', 0,
		0DAH, 'ILLEGAL RECORD FORMAT', 0,
		0DBH, 'PHASE ERROR', 0,
		0EAH, 'CANNOT FORMAT FROM TARGET DRIVE', 0,
		0EBH, 'NON-DISK DEVICE', 0
		);


	if errNum <> 0 then
	do;
		i = 0;
		do while i < size(msg);
			if errNum = msg(i) and msg(i + 1) <> 0 then
			do;
				i = i + 1;
				call write(0, .(' '), 1, .status);
				do while msg(i) <> 0;
					call write(0, .msg(i), 1, .status);
					i = i + 1;
				end;
				call write(0, .(CR, LF), 2, .status);
				return;
			end;
			else
			do;
				do while msg(i) <> 0;
					i = i + 1;
				end;
				i = i + 1;
			end;
		end;
	call error(errNum);
	end;
end;
end;
trange.plm
TESTRANGE: DO;

FileError: procedure(status, ptr, callExit) external;
	declare (status, ptr) address, callExit byte;
end;

ReportError: procedure(status) external; declare status address; end;

Exit: procedure external; end exit;

declare TRUE literally '0ffh';

TestRange: procedure(device, ioBuffer$p) byte public;
	declare device byte, ioBuffer$p address;

	if device >= 25 then	/* diskdrive 6-9 */
		device = device - 19;	/* bring disks together */
	else if device > 5 then		/* shift others above disks */
		device = device + 4;

	if device <=  9 or ioBuffer$p = 1 then
		return device;
	if ioBuffer$p <> 0 then
		call FileError(0EBh, ioBuffer$p, TRUE);
	else
	do;
		call ReportError(0EBh);
		call exit;
	end;
end;
end;
upcase.plm
UPPERCASE: DO;
uppercase: procedure(char) byte public;
	declare char byte;
	if char < 'a' then
		return char;
	if char > 'z' then
		return char;
	return char and 0dfh;
end;
end;
wdlmt.plm
WDELIMIT: DO;

wdelimit: procedure(ptr) address public;
	declare ptr address;
	declare ch based ptr byte;

	do while ch = ':' or ch = '.' or ch = '*' or ch = '?' or
		  ('0' <= ch and ch <= '9') or ('A' <= ch and ch <= 'Z');
		ptr = ptr + 1;
	end;
	return ptr;
end;
end;

