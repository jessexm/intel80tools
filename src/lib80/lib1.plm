
lib1: DO;
$include(lib1.ipx)

DECLARE errstrs(*) BYTE DATA(
	0,0,
	2,'ILLEGAL AFTN ARGUMENT',0,
	4,'INCORRECTLY SPECIFIED FILE',0,
	5,'UNRECOGNIZED DEVICE NAME',0,
	6,'ATTEMPT TO WRITE TO INPUT DEVICE',0,
	8,'ATTEMPT TO READ FROM OUTPUT DEVICE',0,
	10,'NOT ON SAME DISK',0,
	11,'FILE ALREADY EXISTS',0,
	12,'FILE IS ALREADY OPEN',0,
	13,'NO SUCH FILE',0,
	14,'WRITE PROTECTED',0,
	17,'NOT A DISK FILE',0,
	18,'ILLEGAL ISIS COMMAND',0,
	19,'ATTEMPTED SEEK ON NON-DISK FILE',0,
	20,'ATTEMPTED BACK SEEK TOO FAR',0,
	21,'CAN''T RESCAN',0,
	22,'ILLEGAL ACCESS MODE TO OPEN',0,
	23,'MISSING FILENAME',0,
	25,'ILLEGAL ECHO FILE',0,
	26,'ILLEGAL ATTRIBUTE IDENTIFIER',0,
	27,'ILLEGAL SEEK COMMAND',0,
	28,'MISSING EXTENSION',0,
	31,'CAN''T SEEK ON WRITE ONLY FILE',0,
	32,'CAN''T DELETE OPEN FILE',0,
	35,'SEEK PAST EOF',0,
	201,'UNRECOGNIZED CONTROL',0,
	202,'UNRECOGNIZED DELIMITER',0,
	203,'INVALID SYNTAX',0,
	204,'PREMATURE EOF',0,
	206,'ILLEGAL DISKETTE LABEL',0,
	208,'CHECKSUM ERROR',0,
	209,'RELO FILE SEQUENCE ERROR',0,
	210,'INSUFFICIENT MEMORY',0,
	211,'RECORD TOO LONG',0,
	212,'ILLEGAL RELO RECORD',0,
	213,'FIXUP BOUNDS ERROR',0,
	214,'ILLEGAL SUBMIT PARAMETER',0,
	215,'ARGUMENT TOO LONG',0,
	216,'TOO MANY PARAMETERS',0,
	217,'OBJECT RECORD TOO SHORT',0,
	218,'ILLEGAL RECORD FORMAT',0,
	219,'PHASE ERROR',0,
	220,'NO EOF',0,
	221,'SEGMENT TOO LARGE',0,
	222,'UNRECOGNIZED RECORD TYPE',0,
	223,'BAD FIXUP RECORD',0,
	224,'BAD RECORD SEQUENCE',0,
	225,'INVALID MODULE NAME',0,
	226,'MODULE NAME TOO LONG',0,
	227,'LEFT PARENTHESIS EXPECTED',0,
	228,'RIGHT PARENTHESIS EXPECTED',0,
	229,'UNRECOGNIZED CONTROL',0,
	230,'DUPLICATE SYMBOL IN INPUT',0,
	233,'''TO'' EXPECTED',0,
	235,'NOT LIBRARY',0,
	232,'UNRECOGNIZED COMMAND',0,
	238,'ILLEGAL STACK CONTENT RECORD',0,
	239,'NO MODULE HEADER RECORD',0,
	240,'PROGRAM EXCEEDS 64K',0);

DECLARE debugLog BYTE INITIAL (0FFh);
DECLARE debugConn ADDRESS INITIAL(0);

skipAFN: PROCEDURE(path$p) ADDRESS;
	DECLARE path$p ADDRESS;
	DECLARE ch BASED path$p BYTE;

	do while 1;
		path$p = pastFileName(path$p);
		if ch = '*' or ch = '?' then
			path$p = path$p + 1;
		else
			return path$p;
	end;
end;

writeErrStr: PROCEDURE(errCode) PUBLIC;
	DECLARE errCode ADDRESS;
	DECLARE junk(3) BYTE;
	DECLARE i ADDRESS;
	DECLARE status ADDRESS;

	IF errCode <> 0 THEN
	DO;
	    i = 0;
	    DO WHILE i < LENGTH(errStrs);
		IF errCode = errStrs(i) AND errStrs(i + 1) <> 0 THEN
		DO;
			i = i + 1;
			CALL write(0, .(' '), 1, .status);
			DO WHILE errStrs(i) <> 0;
				CALL write(0, .errStrs(i), 1, .status);
				i = i + 1;
			END;
			CALL write(0, .(CR, LF), 2, .status);
			RETURN;
		END;
		ELSE DO;
			DO WHILE errStrs(i) <> 0;
				i = i + 1;
			END;
			i = i + 1;
		END;
            END;
	    CALL error(errCode);	/* pass to ISIS */
	END;

end;



fileStatusChk: PROCEDURE(errCode, path$p, isFatal) PUBLIC;
	DECLARE (errCode, path$p) ADDRESS, isFatal BYTE;
	DECLARE fstatus ADDRESS;

	if errCode <> 0 then
	do;
		path$p = skipspc(path$p);
		call Write(0, .(' '), 1, .fstatus);
		call Write(0, path$p, skipAFN(path$p) - path$p, .fstatus);
		call Write(0, .(','), 1, .fstatus);
		call writeErrStr(errCode);
		goto reset;
	end;
end;

log: PROCEDURE(buf, cnt) PUBLIC;
	DECLARE (buf, cnt) ADDRESS;

	call Write(0, buf, cnt, .status);
	/* code cannot be reached as nothing modifies debugConn
	   looks like debug code to log the data into another file
           debugConn is the fileid and debugLog is the log on /off
	*/
	if debugConn <> 0 and debugLog then
		call Write(debugConn, buf, cnt, .status);
end;

logCRLF: PROCEDURE(buf, cnt) PUBLIC;
	DECLARE (buf, cnt) ADDRESS;

	call log(buf, cnt);
	call log(.(CR, LF), 2);
end;


fatal: PROCEDURE(err) PUBLIC;
	DECLARE err BYTE;
	call fileStatusChk(err, argFilename, 0FFH);
	call exit;
end;

illegalRecord: PROCEDURE PUBLIC;
	call fileStatusChk(ERR218, argFilename, 0FFH);	/* ILLEGAL RECORD FORMAT */
end;


DECLARE memTop ADDRESS PUBLIC,
	heapTop ADDRESS PUBLIC;


allocUp: PROCEDURE(cnt) ADDRESS PUBLIC;
	DECLARE cnt address;

	if memTop - heapTop >= cnt then
	do;
		heapTop = heapTop + cnt;
		return heapTop - cnt;
	end;
	call writeErrStr(ERR210);	/* INSUFFICIENT MEMEORY */
	goto reset;
end;




allocDown: PROCEDURE(cnt) ADDRESS PUBLIC;
	DECLARE cnt address;

	if memTop - heapTop >= cnt then
		return (memTop := memTop - cnt);
	call writeErrStr(ERR210);	/* INSUFFICIENT MEMEORY */
	goto reset;
end;

DECLARE fileHead ADDRESS PUBLIC,
	file$p ADDRESS PUBLIC;


statusChk: PROCEDURE(conn$b, status$p);
	DECLARE conn$b BYTE, status$p ADDRESS;
	DECLARE status BASED status$p ADDRESS;
	DECLARE file BASED file$p FILE$T;

	if status = 0 then
		return;

	file$p = .fileHead;
	do while (file$p := file.link) <> 0;
		if file.conn = conn$b and file.isopen then
		do;
			call fileStatusChk(status, file.path$p, 0);
			goto reset;
		end;
	end;
end;





openFile: PROCEDURE(conn$p, path$p, access, echo, status$p) PUBLIC;
	DECLARE (conn$p, path$p, access, echo, status$p) ADDRESS;
	DECLARE status BASED status$p ADDRESS;
	DECLARE head BASED fileHead FILE$T;
	DECLARE file BASED file$p FILE$T;
	DECLARE conn BASED conn$p BYTE;

	call open(conn$p, path$p, access, echo, status$p);
	if status <> 0 then
	do;
		call fileStatusChk(status, path$p, 0);
		goto reset;
	end;

	file$p = allocUp(6);
	file.link = fileHead;
	fileHead = file$p;
	file.path$p = path$p;	
	file.isopen = 0FFH;
	file.conn = conn;
end;

closeFile: PROCEDURE(conn, status$p) PUBLIC;
	DECLARE (conn, status$p) ADDRESS;
	DECLARE status BASED status$p ADDRESS;
	DECLARE file BASED file$p FILE$T;

	call close(conn, status$p);	/* close on ISIS */

	/* clear down the connection on the file list */
	file$p = .fileHead;
	do while (file$p := file.link) <> 0;
		if file.conn = conn then	/* found the file */
		do;
			file.isopen = 0;
			call fileStatusChk(status, file.path$p, 0FFH);	
		end;
	end;
end;


readFile: PROCEDURE(conn, buff$p, count, actual$p, status$p) PUBLIC;
	DECLARE (conn, buff$p, count, actual$p, status$p) ADDRESS;

	call read(conn, buff$p, count, actual$p, status$p);
	call statusChk(conn, status$p);
end;

writeFile: PROCEDURE(conn, buff$p, count, status$p) PUBLIC;
	DECLARE (conn, buff$p, count, status$p) ADDRESS;

	call write(conn, buff$p, count, status$p);
	call statusChk(conn, status$p);
end;


seekFile: PROCEDURE (conn, mode, block$p, byte$p, status$p) PUBLIC;
	DECLARE (conn, mode, block$p, byte$p, status$p) ADDRESS;

	call seek(conn, mode, block$p, byte$p, status$p);
	call statuschk(conn, status$p);
end;

deleteFile: PROCEDURE(path$p, status$p) PUBLIC;
	DECLARE (path$p, status$p) ADDRESS;
	DECLARE status BASED status$p ADDRESS;

	call delete(path$p, status$p);
	if status <> 0 then
	do;
		call fileStatusChk(status, path$p, 0);
		goto reset;
	end;
end;

renameFile: PROCEDURE(old$p, new$p, status$p) PUBLIC;
	DECLARE (old$p, new$p, status$p) ADDRESS;
	DECLARE status BASED status$p ADDRESS;

	call Rename(old$p, new$p, status$p);
	if status <> 0 then
	do;	
		call fileStatusChk(status, old$p, 0);
		goto reset;
	end;
end;

DECLARE curRec LIBREC$T PUBLIC,
	savedRec LIBREC$T PUBLIC;

/* EXTERNALS */

openLib: PROCEDURE PUBLIC;
	call openFIle(.inConn, argFilename, 1, 0, .status);
	curRec.bytesLeft = 0;
end;

getRecordBytes: PROCEDURE(count, buf$p) PUBLIC;
	DECLARE  (count, buf$p) ADDRESS;
	DECLARE buf BASED buf$p(1) BYTE;

	call readFile(inConn, buf$p, count, .actual, .status);
	if actual <> count or count > curRec.bytesLeft then
		call fileStatusChk(ERR217, argFilename, 0FFH);
	
	curRec.bytesLeft = curRec.bytesLeft - count;
	do while count <> 0;
		curRec.crc = curRec.crc + buf(count := count - 1);
	end;
end;


readChkCRC: PROCEDURE PUBLIC;
	DECLARE recByte BYTE;

	call getRecordBytes(1, .recByte);
	if curRec.crc <> 0 then
		call fileStatusCHk(ERR208, argFilename, 0FFH);	/* CHECKSUM ERROR */
end;


/* skip current record if one being processed */

skipCurRec: PROCEDURE PUBLIC;
	if curRec.bytesLeft = 1 then
		call readChkCRC;
	else
		call seekFile(inConn, 3, .(0, 0), .curRec.bytesLeft, .status);
	curRec.bytesLeft = 0;
end;


prepRecord: PROCEDURE PUBLIC;
	call skipCurRec; 	/* skip current record if one being processed */
	call seekFile(inConn, 0, .curRec.curBlk, .curRec.curByte, .status);
	curRec.bytesLeft = 3;	/* 3 bytes for rectype and record length */
	curRec.crc = 0;		/* reset crc */
	call getRecordBytes(3, .curRec.type);
	curRec.bytesLeft = curRec.len;	/* correct the length using the record length */
end;

acceptRecord: PROCEDURE(type) PUBLIC;
	DECLARE type BYTE;

	call prepRecord;
	if curRec.type <> type then
		call fatal(ERR218);	/* ILLEGAL RECORD FORMAT */
end;

getName: PROCEDURE(buf) PUBLIC;
	DECLARE buf ADDRESS;
	DECLARE len BASED buf BYTE;

	call getRecordBytes(1, buf);

	if len > 31 then
		call illegalRecord;

	call getRecordBytes(len, buf + 1);
end;


skipModule: PROCEDURE PUBLIC;
	do while curRec.type <> OBJEND;
		call prepRecord;
	end;
	call skipCurRec;	/* skip the OBJ end as well */
end;

libSeek: PROCEDURE(mode$b, blkByte$p) PUBLIC;
	DECLARE mode$b BYTE, blkByte$p ADDRESS;

	call seekFile(inConn, mode$b, blkByte$p, blkByte$p + 2, .status);
	if mode$b = 2 then
		curRec.bytesLeft = 0;
	return;
end;


saveCurPos: PROCEDURE PUBLIC;
	DECLARE i BYTE;
	DECLARE w$cur(1) ADDRESS AT (.curRec);
	DECLARE w$save(1) ADDRESS AT (.savedRec);

	call libSeek(0, .curRec.posBlk);
	do i = 0 to 6;
		w$save(i) = w$cur(i);
	end;
end;


restoreCurPos: PROCEDURE PUBLIC;
	DECLARE i BYTE;
	DECLARE w$cur(1) ADDRESS AT (.curRec);
	DECLARE w$save(1) ADDRESS AT (.savedRec);

	call libSeek(2, .savedRec.posBlk);
	do i = 0 to 6;
		w$cur(i) = w$save(i);
	end;
end;

swapCurSavedRec: PROCEDURE PUBLIC;
	DECLARE i BYTE;
	DECLARE tmp ADDRESS;
	DECLARE w$cur(1) ADDRESS AT (.curRec);
	DECLARE w$save(1) ADDRESS AT (.savedRec);

	call libSeek(0, .curRec.posBlk);	
	tmp = curRec.bytesLeft;
	call libSeek(2, .savedRec.posBlk);
	curRec.bytesLeft = tmp;
	do i = 0 to 6;
		tmp = w$cur(i);
		w$cur(i) = w$save(i);
		w$save(i) = tmp;
	end;
end;


hash: PROCEDURE(pstr) BYTE PUBLIC;
	DECLARE pstr ADDRESS;
	DECLARE str BASED pstr (1) BYTE;
	DECLARE (i, j) BYTE;

	j = 0;
	DO i = 0 TO str(0);
		j = ROR(j, 1) XOR str(i);
	END;
	RETURN j mod 128;
END hash;

lookupSymbol: PROCEDURE(modName$p, hash$p) BYTE PUBLIC;
	DECLARE (modName$p, hash$p) ADDRESS;
	DECLARE curSym$p ADDRESS,
		symbol ADDRESS,
		i BYTE;
	DECLARE curSym BASED curSym$p SYMBOL$T;
	DECLARE name BASED modName$p(1) BYTE;
	DECLARE symName BASED symbol(1) BYTE;
	DECLARE rethash based hash$p ADDRESS;

	/* using hashing find the start of the symbol chain */
	curSym$p = .hashTable(hash(modName$p));

	/* scan the chain looking for a match */
	do while curSym.link <> 0;
		curSym$p = curSym.link;
		symbol = .curSym.symLen;

		do i = 0 to name(0);
			if symName(i) <> name(i) then
				goto outerloop;
		end;
		rethash = curSym$p;	
		return 0ffh;	/* found it */
outerloop:
	end;
	rethash = curSym$p;
	return 0;		/* not found */
end;

DECLARE lineHead	ADDRESS,
	curLine$p	ADDRESS PUBLIC,
	lookAhead$p		ADDRESS PUBLIC,
	lookAheadLen		BYTE PUBLIC,
	token$p	ADDRESS PUBLIC,
	tokLen	BYTE PUBLIC,
	junk1		BYTE,
	inModuleList	BYTE PUBLIC;


libError: PROCEDURE(err) PUBLIC;
	DECLARE err BYTE;
	DECLARE line$p ADDRESS;
	DECLARE s ADDRESS;
	DECLARE curLine BASED curLine$p LINE$T;
	DECLARE line BASED line$p LINE$T;

	s = token$p + tokLen;	/* assumes these are set up correctly, doesn't always seem to be correct */
	call writeErrStr(err);
	line$p = lineHead;

	/*
		print out lines that are in the chain before this one
		basically s will not be in the range of the line pointed
		to by line$p
	*/
	do while s < line$p or line$p + line.len + 4 < s;
		call Write(0, .line.text, line.len, .status);
		line$p = line.next;
	end;
	/* this logic looks flawed I suspect the else clause is generally taken */
	/* would be reasonable if curLine.len was used */
	if s > curLine$p  and curLine$p + 5 + curLine.next > s then
		call Write(0, .curLine.text, s - .curLine.text, .status);
	else
		call Write(0, .line.text, s - .line.text, .status);

	call Write(0, .('#', CR, LF), 3, .status);
	goto reset;
end;

getTokenLen: PROCEDURE(str) ADDRESS;
	DECLARE str ADDRESS;
	DECLARE junk BYTE;
	DECLARE tmp ADDRESS;
	DECLARE ch BASED str BYTE;

	if ch = CR then
		return 0;

	if inModuleList then
	do;
		if ch < '?' or ch > 'Z' then
			call libError(ERR225);	/* INVALID MODULE NAME */

		tmp = str;

		do while ((ch >= '0' AND ch <= '9') or (ch <= 'Z' and ch >= '?' AND (str - tmp < 33)));
			str = str + 1;
		end;

		if str - tmp > 32 then
			call libError(ERR226);	/* MODULE NAME TOO LONG */

		return str - tmp;
	end;
	if ch = '(' then
		return 1;
	else if ch = ')' then
		return 1;
	else if ch = ',' then
		return 1;
	tmp = pastFileName(str) - str;
	if tmp > 0 then
		return tmp;
	else
		call libError(ERR203);	/* INVALID SYNTAX */
end;




getline: PROCEDURE;
	DECLARE curLine BASED curLine$p LINE$T;
	DECLARE curLine$a BASED curLine$p(1) BYTE;
	DECLARE lookAhead BASED lookAhead$p(1) BYTE;
	DECLARE i BYTE;

loop:
	/* allocate a line buffer and insert into the chain */
	curLine.next = allocDown(126);
	curLine$p = curLine.next;
	curLine.next = 0;
	/* read line and convert to upper case */
	call Read(1, .curLine.text, 122, .curLine.len, .status);
	do i = 4 to 125;	/* 4 is offset of text in line structure */
		if curLine$a(i) >= 'a' AND curLine$a(i) <= 'z' then
			curLine$a(i) = curLine$a(i) - 20H;	/* convert to upper case */
	end;

	if tokLen = 0 then			/* initialise token if first one */
		token$p = .curLine.text;
	lookAhead$p = skipspc(.curLine.text);
	/* check line with just & on it */
	if lookAhead(0) = '&' then
	do;
		/* make sure nothing after the & */
		lookAhead$p = skipspc(lookAhead$p + 1);
		if lookAhead(0) <> CR THEN
			call libError(ERR203);	/* INVALID SYNTAX */
		/* prompt user and get another line */
		call Write(0, .('**'), 2, .status);
		/* note potentially wasteful on memory as this line buffer could be reused */
		/* loop could be to the read call */
		goto loop;
	end;
	lookAheadLen = getTokenLen(lookAhead$p);
end;

getToken: PROCEDURE PUBLIC;
	DECLARE lookAhead BASED lookAhead$p(1) BYTE;
	token$p = lookAhead$p;		/* record latest token */
	tokLen = lookAheadLen;
	/* track in / out of module list */
	if lookAhead(0) = ')' then
		inModuleList = 0;	/* no longer in module list */
	lookAhead$p = skipspc(lookAhead$p + lookAheadLen);
	/* continuation line ? */
	if lookAhead(0) = '&' then
	do;
		lookAhead$p = skipspc(lookAhead$p + 1);
		/* can't be anything other than blanks after the & */
		if lookAhead(0) <> CR then
		do;
			token$p = lookAhead$p;	/* point to the error character */
			/* this code is flawed as tokLen will be wrong for libError */
			call libError(ERR203);	/* INVALID SYNTAX */
		end;
		/* get another line */
		call Write(0, .('**'), 2, .status);
		call getline;
	end;
	lookAheadLen = getTokenLen(lookAhead$p);
end;


matchToken: PROCEDURE(cha$p, len) BYTE PUBLIC;
	DECLARE cha$p ADDRESS, len BYTE;
	DECLARE cha BASED cha$p(1) BYTE;
	DECLARE token BASED token$p(1) BYTE;

	DECLARE i BYTE;

	if tokLen <> len then
		return 0;
	if len = 0 then
		return 0FFh;

	do i = 0 to len - 1;
		if cha(i) <> token(i) then
			return 0;
	end;
	return 0FFh;
end; 	


matchLookAhead: PROCEDURE(cha$p, len) BYTE PUBLIC;
	DECLARE cha$p ADDRESS, len BYTE;
	DECLARE cha BASED cha$p(1) BYTE;
	DECLARE lookAhead BASED lookAhead$p(1) BYTE;

	DECLARE i BYTE;

	if lookAheadLen <> len then
		return 0;
	if len = 0 then
		return 0FFh;
	do i = 0 to len - 1;
		if cha(i) <> lookAhead(i) then
			return 0;
	end;
	return 0FFh;
end;

getCmd: PROCEDURE PUBLIC;
		inModuleList, junk1, tokLen = 0;
		lineHead = 0;		/* no line chain */
		curLine$p = .lineHead;
		call getline;		/* get first line token and lookAhead token */
		call getToken;
end;

end;
