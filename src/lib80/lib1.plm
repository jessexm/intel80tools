
lib1: DO;

$INCLUDE(lib.lit)
/* EXTERNALS */
pastFileName: PROCEDURE(pch) ADDRESS EXTERNAL;
	DECLARE pch ADDRESS;
end;
skipSpc: PROCEDURE(pch) ADDRESS EXTERNAL;
	DECLARE pch ADDRESS;
end;

DECLARE reset LABEL EXTERNAL,
	status ADDRESS EXTERNAL,
	curCmdArg ADDRESS EXTERNAL,
	curConn ADDRESS EXTERNAL,
	actual	ADDRESS EXTERNAL,
	hashTable(1) ADDRESS EXTERNAL;



DECLARE errstrs(*) BYTE DATA(
	0,0,
	2,'ILLEGAL AFTN ARGUMENT',0,
	4,'INCORRECTLY SPECIFIED FILE',0,
	5,'UNRECOGNIZED DEVICE NAME',0,
	6,'ATTEMPT TO WRITE TO INPUT DEVICE',0,
	8,'ATTEMPT TO READ FROM OUTPUT DEVICE',0,
	10,'NOT ON SAME DISK',0,
	11,'FILE ALREADY EXISTS',0,
	12,'FILE IS ALREADY OPEN',0,
	13,'NO SUCH FILE',0,
	14,'WRITE PROTECTED',0,
	17,'NOT A DISK FILE',0,
	18,'ILLEGAL ISIS COMMAND',0,
	19,'ATTEMPTED SEEK ON NON-DISK FILE',0,
	20,'ATTEMPTED BACK SEEK TOO FAR',0,
	21,'CAN''T RESCAN',0,
	22,'ILLEGAL ACCESS MODE TO OPEN',0,
	23,'MISSING FILENAME',0,
	25,'ILLEGAL ECHO FILE',0,
	26,'ILLEGAL ATTRIBUTE IDENTIFIER',0,
	27,'ILLEGAL SEEK COMMAND',0,
	28,'MISSING EXTENSION',0,
	31,'CAN''T SEEK ON WRITE ONLY FILE',0,
	32,'CAN''T DELETE OPEN FILE',0,
	35,'SEEK PAST EOF',0,
	201,'UNRECOGNIZED CONTROL',0,
	202,'UNRECOGNIZED DELIMITER',0,
	203,'INVALID SYNTAX',0,
	204,'PREMATURE EOF',0,
	206,'ILLEGAL DISKETTE LABEL',0,
	208,'CHECKSUM ERROR',0,
	209,'RELO FILE SEQUENCE ERROR',0,
	210,'INSUFFICIENT MEMORY',0,
	211,'RECORD TOO LONG',0,
	212,'ILLEGAL RELO RECORD',0,
	213,'FIXUP BOUNDS ERROR',0,
	214,'ILLEGAL SUBMIT PARAMETER',0,
	215,'ARGUMENT TOO LONG',0,
	216,'TOO MANY PARAMETERS',0,
	217,'OBJECT RECORD TOO SHORT',0,
	218,'ILLEGAL RECORD FORMAT',0,
	219,'PHASE ERROR',0,
	220,'NO EOF',0,
	221,'SEGMENT TOO LARGE',0,
	222,'UNRECOGNIZED RECORD TYPE',0,
	223,'BAD FIXUP RECORD',0,
	224,'BAD RECORD SEQUENCE',0,
	225,'INVALID MODULE NAME',0,
	226,'MODULE NAME TOO LONG',0,
	227,'LEFT PARENTHESIS EXPECTED',0,
	228,'RIGHT PARENTHESIS EXPECTED',0,
	229,'UNRECOGNIZED CONTROL',0,
	230,'DUPLICATE SYMBOL IN INPUT',0,
	233,'''TO'' EXPECTED',0,
	235,'NOT LIBRARY',0,
	232,'UNRECOGNIZED COMMAND',0,
	238,'ILLEGAL STACK CONTENT RECORD',0,
	239,'NO MODULE HEADER RECORD',0,
	240,'PROGRAM EXCEEDS 64K',0);

DECLARE unk$643C BYTE INITIAL (0FFh);
DECLARE word$643D ADDRESS INITIAL(0);

skipAFN: PROCEDURE(path$p) ADDRESS;
	DECLARE path$p ADDRESS;
	DECLARE ch BASED path$p BYTE;

	do while 1;
		path$p = pastFileName(path$p);
		if ch = '*' or ch = '?' then
			path$p = path$p + 1;
		else
			return path$p;
	end;
end;

writeErrStr: PROCEDURE(errCode) PUBLIC;
	DECLARE errCode ADDRESS;
	DECLARE junk(3) BYTE;
	DECLARE i ADDRESS;
	DECLARE status ADDRESS;

	IF errCode <> 0 THEN
	DO;
	    i = 0;
	    DO WHILE i < LENGTH(errStrs);
		IF errCode = errStrs(i) AND errStrs(i + 1) <> 0 THEN
		DO;
			i = i + 1;
			CALL write(0, .(' '), 1, .status);
			DO WHILE errStrs(i) <> 0;
				CALL write(0, .errStrs(i), 1, .status);
				i = i + 1;
			END;
			CALL write(0, .(0DH, 0AH), 2, .status);
			RETURN;
		END;
		ELSE DO;
			DO WHILE errStrs(i) <> 0;
				i = i + 1;
			END;
			i = i + 1;
		END;
            END;
	    CALL error(errCode);	/* pass to ISIS */
	END;

end;



fileStatusChk: PROCEDURE(errCode, path$p, isFatal) PUBLIC;
	DECLARE (errCode, path$p) ADDRESS, isFatal BYTE;
	DECLARE fstatus ADDRESS;

	if errCode <> 0 then
	do;
		path$p = skipspc(path$p);
		call Write(0, .(' '), 1, .fstatus);
		call Write(0, path$p, skipAFN(path$p) - path$p, .fstatus);
		call Write(0, .(','), 1, .fstatus);
		call writeErrStr(errCode);
		goto reset;
	end;
end;

sub$5097: PROCEDURE(buf, cnt) PUBLIC;
	DECLARE (buf, cnt) ADDRESS;

	call Write(0, buf, cnt, .status);
	if word$643D <> 0 and unk$643C then
		call Write(word$643D, buf, cnt, .status);
end;

sub$50DC: PROCEDURE(buf, cnt) PUBLIC;
	DECLARE (buf, cnt) ADDRESS;

	call sub$5097(buf, cnt);
	call sub$5097(.(0dh, 0ah), 2);
end;


fatal: PROCEDURE(err) PUBLIC;
	DECLARE err BYTE;
	call fileStatusChk(err, curCmdArg, 0FFH);
	call exit;
end;

illegalRecord: PROCEDURE PUBLIC;
	call fileStatusChk(ERR218, curCmdArg, 0FFH);	/* ILLEGAL RECORD FORMAT */
end;


DECLARE memTop ADDRESS PUBLIC,
	heapTop ADDRESS PUBLIC;


allocUp: PROCEDURE(cnt) ADDRESS PUBLIC;
	DECLARE cnt address;

	if memTop - heapTop >= cnt then
	do;
		heapTop = heapTop + cnt;
		return heapTop - cnt;
	end;
	call writeErrStr(ERR210);	/* INSUFFICIENT MEMEORY */
	goto reset;
end;




allocDown: PROCEDURE(cnt) ADDRESS PUBLIC;
	DECLARE cnt address;

	if memTop - heapTop >= cnt then
		return (memTop := memTop - cnt);
	call writeErrStr(ERR210);	/* INSUFFICIENT MEMEORY */
	goto reset;
end;

DECLARE headPtr ADDRESS PUBLIC,
	curPtr ADDRESS PUBLIC;


statusChk: PROCEDURE(conn$b, status$p);
	DECLARE conn$b BYTE, status$p ADDRESS;
	DECLARE status BASED status$p ADDRESS;
	DECLARE file BASED curPtr LIST$T;

	if status = 0 then
		return;

	curPtr = .headPtr;
	do while (curPtr := file.link) <> 0;
		if file.conn = conn$b and file.isopen then
		do;
			call fileStatusChk(status, file.path$p, 0);
			goto reset;
		end;
	end;
end;





openFile: PROCEDURE(conn$p, path$p, access, echo, status$p) PUBLIC;
	DECLARE (conn$p, path$p, access, echo, status$p) ADDRESS;
	DECLARE status BASED status$p ADDRESS;
	DECLARE head BASED headPtr LIST$T;
	DECLARE entry BASED curPtr LIST$T;
	DECLARE conn BASED conn$p BYTE;

	call open(conn$p, path$p, access, echo, status$p);
	if status <> 0 then
	do;
		call fileStatusChk(status, path$p, 0);
		goto reset;
	end;

	curPtr = allocUp(6);
	entry.link = headPtr;
	headPtr = curPtr;
	entry.path$p = path$p;	
	entry.isopen = 0FFH;
	entry.conn = conn;
end;

closeFile: PROCEDURE(conn, status$p) PUBLIC;
	DECLARE (conn, status$p) ADDRESS;
	DECLARE status BASED status$p ADDRESS;
	DECLARE entry BASED curPtr LIST$T;

	call close(conn, status$p);
	curPtr = .headPtr;

	do while (curPtr := entry.link) <> 0;
		if entry.conn = conn then	/* found the file */
		do;
			entry.isopen = 0;
			call fileStatusChk(status, entry.path$p, 0FFH);	
		end;
	end;
end;


readFile: PROCEDURE(conn, buff$p, count, actual$p, status$p) PUBLIC;
	DECLARE (conn, buff$p, count, actual$p, status$p) ADDRESS;

	call read(conn, buff$p, count, actual$p, status$p);
	call statusChk(conn, status$p);
end;

writeFile: PROCEDURE(conn, buff$p, count, status$p) PUBLIC;
	DECLARE (conn, buff$p, count, status$p) ADDRESS;

	call write(conn, buff$p, count, status$p);
	call statusChk(conn, status$p);
end;


seekFile: PROCEDURE (conn, mode, block$p, byte$p, status$p) PUBLIC;
	DECLARE (conn, mode, block$p, byte$p, status$p) ADDRESS;

	call seek(conn, mode, block$p, byte$p, status$p);
	call statuschk(conn, status$p);
end;

deleteFile: PROCEDURE(path$p, status$p) PUBLIC;
	DECLARE (path$p, status$p) ADDRESS;
	DECLARE status BASED status$p ADDRESS;

	call delete(path$p, status$p);
	if status <> 0 then
	do;
		call fileStatusChk(status, path$p, 0);
		goto reset;
	end;
end;

renameFile: PROCEDURE(old$p, new$p, status$p) PUBLIC;
	DECLARE (old$p, new$p, status$p) ADDRESS;
	DECLARE status BASED status$p ADDRESS;

	call Rename(old$p, new$p, status$p);
	if status <> 0 then
	do;	
		call fileStatusChk(status, old$p, 0);
		goto reset;
	end;
end;

DECLARE curRec STRUCTURE(LIBREC$T1, LIBREC$T2) PUBLIC,
	savedRec STRUCTURE(LIBREC$T1, LIBREC$T2) PUBLIC;

/* EXTERNALS */

openLib: PROCEDURE PUBLIC;
	call openFIle(.curConn, curCmdArg, 1, 0, .status);
	curRec.bytesLeft = 0;
end;

getRecordBytes: PROCEDURE(count, buf$p) PUBLIC;
	DECLARE  (count, buf$p) ADDRESS;
	DECLARE buf BASED buf$p(1) BYTE;

	call readFile(curConn, buf$p, count, .actual, .status);
	if actual <> count or count > curRec.bytesLeft then
		call fileStatusChk(ERR217, curCmdArg, 0FFH);
	
	curRec.bytesLeft = curRec.bytesLeft - count;
	do while count <> 0;
		curRec.crc = curRec.crc + buf(count := count - 1);
	end;
end;


readChkCRC: PROCEDURE PUBLIC;
	DECLARE recByte BYTE;

	call getRecordBytes(1, .recByte);
	if curRec.crc <> 0 then
		call fileStatusCHk(ERR208, curCmdArg, 0FFH);	/* CHECKSUM ERROR */
end;


/* skip current record if one being processed */

skipCurRec: PROCEDURE PUBLIC;
	if curRec.bytesLeft = 1 then
		call readChkCRC;
	else
		call seekFile(curConn, 3, .(0, 0), .curRec.bytesLeft, .status);
	curRec.bytesLeft = 0;
end;


prepRecord: PROCEDURE PUBLIC;
	call skipCurRec; 	/* skip current record if one being processed */
	call seekFile(curConn, 0, .curRec.curBlk, .curRec.curByte, .status);
	curRec.bytesLeft = 3;
	curRec.crc = 0;
	call getRecordBytes(3, .curRec.type);
	curRec.bytesLeft = curRec.len;
end;

acceptRecord: PROCEDURE(type) PUBLIC;
	DECLARE type BYTE;

	call prepRecord;
	if curRec.type <> type then
		call fatal(ERR218);	/* ILLEGAL RECORD FORMAT */
end;

getName: PROCEDURE(buf) PUBLIC;
	DECLARE buf ADDRESS;
	DECLARE len BASED buf BYTE;

	call getRecordBytes(1, buf);

	if len > 31 then
		call illegalRecord;

	call getRecordBytes(len, buf + 1);
end;


sub$5566: PROCEDURE PUBLIC;
	do while curRec.type <> 4;
		call prepRecord;
	end;
	call skipCurRec;
end;

libSeek: PROCEDURE(mode$b, blkByte$p) PUBLIC;
	DECLARE mode$b BYTE, blkByte$p ADDRESS;

	call seekFile(curConn, mode$b, blkByte$p, blkByte$p + 2, .status);
	if mode$b = 2 then
		curRec.bytesLeft = 0;
	return;
end;


saveCurPos: PROCEDURE PUBLIC;
	DECLARE i BYTE;
	DECLARE w$cur(1) ADDRESS AT (.curRec);
	DECLARE w$save(1) ADDRESS AT (.savedRec);

	call libSeek(0, .curRec.posBlk);
	do i = 0 to 6;
		w$save(i) = w$cur(i);
	end;
end;


restoreCurPos: PROCEDURE PUBLIC;
	DECLARE i BYTE;
	DECLARE w$cur(1) ADDRESS AT (.curRec);
	DECLARE w$save(1) ADDRESS AT (.savedRec);

	call libSeek(2, .savedRec.posBlk);
	do i = 0 to 6;
		w$cur(i) = w$save(i);
	end;
end;

swapCurSavedRec: PROCEDURE PUBLIC;
	DECLARE i BYTE;
	DECLARE tmp ADDRESS;
	DECLARE w$cur(1) ADDRESS AT (.curRec);
	DECLARE w$save(1) ADDRESS AT (.savedRec);

	call libSeek(0, .curRec.posBlk);	
	tmp = curRec.bytesLeft;
	call libSeek(2, .savedRec.posBlk);
	curRec.bytesLeft = tmp;
	do i = 0 to 6;
		tmp = w$cur(i);
		w$cur(i) = w$save(i);
		w$save(i) = tmp;
	end;
end;


hash: PROCEDURE(pstr) BYTE PUBLIC;
	DECLARE pstr ADDRESS;
	DECLARE str BASED pstr (1) BYTE;
	DECLARE (i, j) BYTE;

	j = 0;
	DO i = 0 TO str(0);
		j = ROR(j, 1) XOR str(i);
	END;
	RETURN j mod 128;
END hash;

sub$56D3: PROCEDURE(modName$p, hash$p) BYTE PUBLIC;
	DECLARE (modName$p, hash$p) ADDRESS;
	DECLARE curHashPtr ADDRESS,
		symbol ADDRESS,
		i BYTE;
	DECLARE curHash BASED curHashPtr STRUCTURE(HASH$T);
	DECLARE name BASED modName$p(1) BYTE;
	DECLARE symName BASED symbol(1) BYTE;
	DECLARE rethash based hash$p ADDRESS;

	curHashPtr = .hashTable(hash(modName$p));

	do while curHash.link <> 0;
		curHashPtr = curHash.link;
		symbol = .curHash.symLen;

		do i = 0 to name(0);
			if symName(i) <> name(i) then
				goto outerloop;
		end;
		rethash = curHashPtr;	
		return 0ffh;
outerloop:
	end;
	rethash = curHashPtr;
	return 0;
end;

DECLARE word$64D6	ADDRESS,
	lineChain	ADDRESS PUBLIC,
	ptrToken	ADDRESS PUBLIC,
	tokLen		BYTE PUBLIC,
	ptrPrevToken	ADDRESS PUBLIC,
	preTokLen	BYTE PUBLIC,
	junk1		BYTE,
	inModuleList	BYTE PUBLIC;


libError: PROCEDURE(err) PUBLIC;
	DECLARE err BYTE;
	DECLARE word$64E3 ADDRESS;
	DECLARE word$64E5 ADDRESS;
	DECLARE line BASED lineChain LINE$T;
	DECLARE s64E3 BASED word$64E3 LINE$T;

	WORD$64E5 = ptrPrevToken + preTokLen;
	call writeErrStr(err);
	word$64E3 = word$64D6;

	do while word$64E5 < word$64E3 or word$64E3 + s64E3.len + 4 < word$64E5;
		call Write(0, .s64E3.text, s64E3.len, .status);
		word$64E3 = s64E3.link;
	end;
	if word$64E5 > lineChain  and lineChain + 5 + line.link > word$64E5 then
		call Write(0, .line.text, word$64E5 - .line.text, .status);
	else
		call Write(0, .s64E3.text, word$64E5 - .s64E3.text, .status);

	call Write(0, .('#', 0dh, 0ah), 3, .status);
	goto reset;
end;

getTokenLen: PROCEDURE(str) ADDRESS;
	DECLARE str ADDRESS;
	DECLARE junk BYTE;
	DECLARE tmp ADDRESS;
	DECLARE ch BASED str BYTE;

	if ch = 0Dh then
		return 0;

	if inModuleList then
	do;
		if ch < '?' or ch > 'Z' then
			call libError(ERR225);	/* INVALID MODULE NAME */

		tmp = str;

		do while ((ch >= '0' AND ch <= '9') or (ch <= 'Z' and ch >= '?' AND (str - tmp < 33)));
			str = str + 1;
		end;

		if str - tmp > 32 then
			call libError(ERR226);	/* MODULE NAME TOO LONG */

		return str - tmp;
	end;
	if ch = '(' then
		return 1;
	else if ch = ')' then
		return 1;
	else if ch = ',' then
		return 1;
	tmp = pastFileName(str) - str;
	if tmp > 0 then
		return tmp;
	else
		call libError(ERR203);	/* INVALID SYNTAX */
end;




getline: PROCEDURE;
	DECLARE line BASED lineChain LINE$T;
	DECLARE lineA BASED lineChain(1) BYTE;
	DECLARE tokenCH BASED ptrToken BYTE;
	DECLARE i BYTE;

loop:
	line.link = allocDown(126);
	lineChain = line.link;
	line.link = 0;
	call Read(1, .line.text, 122, .line.len, .status);
	do i = 4 to 125;	/* 4 is offset of text in line structure */
		if lineA(i) >= 'a' AND lineA(i) <= 'z' then
			lineA(i) = lineA(i) - 20H;	/* convert to upper case */
	end;

	if preTokLen = 0 then
		ptrPrevToken = .line.text;
	ptrToken = skipspc(.line.text);
	if tokenCH = '&' then
	do;
		ptrToken = skipspc(ptrToken + 1);
		if tokenCH <> 0dh THEN
			call libError(ERR203);	/* INVALID SYNTAX */
		call Write(0, .('**'), 2, .status);
		goto loop;
	end;
	toklen = getTokenLen(ptrToken);
end;

getToken: PROCEDURE PUBLIC;
	DECLARE tokenCH BASED ptrToken BYTE;
	ptrPrevToken = ptrToken;
	preTokLen = tokLen;
	if tokenCH = ')' then
		inModuleList = 0;	/* no longer in module list */
	ptrToken = skipspc(ptrToken + tokLen);
	if tokenCH = '&' then
	do;
		ptrToken = skipspc(ptrToken + 1);
		if tokenCH <> CR then
		do;
			ptrPrevToken = ptrToken;
			call libError(ERR203);	/* INVALID SYNTAX */
		end;

		call Write(0, .('**'), 2, .status);
		call getline;
	end;
	tokLen = getTokenLen(ptrToken);
end;


preTokenEqu: PROCEDURE(str, len) BYTE PUBLIC;
	DECLARE str ADDRESS, len BYTE;
	DECLARE stra BASED str(1) BYTE;
	DECLARE prea BASED ptrPrevToken(1) BYTE;

	DECLARE i BYTE;

	if preTokLen <> len then
		return 0;
	if len = 0 then
		return 0FFh;

	do i = 0 to len - 1;
		if stra(i) <> prea(i) then
			return 0;
	end;
	return 0FFh;
end; 	


tokenEqu: PROCEDURE(str, len) BYTE PUBLIC;
	DECLARE str ADDRESS, len BYTE;
	DECLARE stra BASED str(1) BYTE;
	DECLARE toka BASED ptrToken(1) BYTE;

	DECLARE i BYTE;

	if tokLen <> len then
		return 0;
	if len = 0 then
		return 0FFh;
	do i = 0 to len - 1;
		if stra(i) <> toka(i) then
			return 0;
	end;
	return 0FFh;
end;

getCmd: PROCEDURE PUBLIC;
		inModuleList, junk1, preTokLen = 0;
		word$64D6 = 0;		/* no line chain */
		lineChain = .word$64D6;
		call getline;		/* get first line and token */
		call getToken;
end;

end;
