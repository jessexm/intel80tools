
LIB: DO;

$INCLUDE(lib.lit)

DECLARE
	actual		ADDRESS PUBLIC,
	status		ADDRESS PUBLIC,
	outConn	ADDRESS,
	libOutFile	ADDRESS,
	inConn		ADDRESS PUBLIC,
	argFilename	ADDRESS PUBLIC,
	argHead		ADDRESS,
	argChain	ADDRESS,
	moduleHead	ADDRESS,
	module$p	ADDRESS;

DECLARE hashTable(128) ADDRESS PUBLIC,
	hashptr	ADDRESS,	/* probably hash item */
	junk1 ADDRESS INITIAL(0),
	junk2(4)	BYTE,
	libModuleCnt ADDRESS,
	addCnt BYTE,
	moduleName(33) BYTE,
	zeroBlk ADDRESS INITIAL(0),
	zeroByte ADDRESS INITIAL(0),
	junk3 ADDRESS INITIAL(10),
	one ADDRESS INITIAL(1),
	copyBuf(1028) BYTE,
	recBlk ADDRESS,
	recByt	ADDRESS,
	outCRC	BYTE,
	outRecLen ADDRESS;

DECLARE
	copyright(*) BYTE DATA ('(C) 1976, 1977 INTEL CORP'),
	aIsisIiLibraria(*) BYTE DATA ('ISIS-II LIBRARIAN V2.1', CR, LF),
	aNotFound(*) BYTE DATA ('): NOT FOUND'),
	aPublicSymbolAl(*) BYTE DATA (' - PUBLIC SYMBOL ALREADY IN LIBRARY'),
	initLibContent(*) BYTE DATA (LIBHDR, 7, 0, 0, 0, 0, 0, 0Ah, 0, 0C3h,
				     NAMES, 1, 0, 0D7h,
				     LIBLOC, 1, 0, 0D9h,
				     LIBDICT, 1, 0, 0D5h,
				     ENDFILE, 1, 0, 0F1h);


/* EXTERNALS */
DECLARE token$p ADDRESS EXTERNAL,
	fileHead ADDRESS EXTERNAL,
	file$p	ADDRESS EXTERNAL,
	curRec STRUCTURE(LIBREC$T1, LIBREC$T2) EXTERNAL,
	lookAhead$p ADDRESS EXTERNAL,
	tokLen BYTE EXTERNAL,
	inModuleLIst BYTE EXTERNAL,
	memTop ADDRESS EXTERNAL,
	heapTop ADDRESS EXTERNAL;

writeFile: PROCEDURE(conn, buff$p, count, status$p) EXTERNAL;
	DECLARE (conn, buff$p, count, status$p) ADDRESS;
end;

readFile: PROCEDURE(conn, buff$p, count, actual$p, status$p) EXTERNAL;
	DECLARE (conn, buff$p, count, actual$p, status$p) ADDRESS;
end;

seekFile: PROCEDURE (conn, mode, block$p, byte$p, status$p) EXTERNAL;
	DECLARE (conn, mode, block$p, byte$p, status$p) ADDRESS;
end;

skipSpc: PROCEDURE(pch) ADDRESS EXTERNAL;
	DECLARE pch ADDRESS;
end;

closeFile: PROCEDURE(conn, status$p) EXTERNAL;
	DECLARE (conn, status$p) ADDRESS;
end;
openFile: PROCEDURE(conn$p, path$p, access, echo, status$p) EXTERNAL;
	DECLARE (conn$p, path$p, access, echo, status$p) ADDRESS;
end;

renameFile: PROCEDURE(old$p, new$p, status$p) EXTERNAL;
	DECLARE (old$p, new$p, status$p) ADDRESS;
end;

deleteFile: PROCEDURE(path$p, status$p) EXTERNAL;
	DECLARE (path$p, status$p) ADDRESS;
end;

log: PROCEDURE(buf, cnt) EXTERNAL;
	DECLARE (buf, cnt) ADDRESS;
end;

logCRLF: PROCEDURE(buf, cnt) EXTERNAL;
	DECLARE (buf, cnt) ADDRESS;
end;
pastFileName: PROCEDURE(pch) ADDRESS EXTERNAL;
	DECLARE pch ADDRESS;
end;
allocUp: PROCEDURE(cnt) ADDRESS EXTERNAL;
	DECLARE cnt address;
end;
getToken: PROCEDURE EXTERNAL; end;

liberror: PROCEDURE(err) EXTERNAL;
	DECLARE err BYTE;
end;
getRecordBytes: PROCEDURE(count, buf$p) EXTERNAL;
	DECLARE  (count, buf$p) ADDRESS;
end;

readChkCRC: PROCEDURE EXTERNAL; end;

getName: PROCEDURE(buf) EXTERNAL;
	DECLARE buf ADDRESS;
end;

lookupSymbol: PROCEDURE(modName$p, hash$p) BYTE EXTERNAL;
	DECLARE (modName$p, hash$p) ADDRESS;
end;

fatal: PROCEDURE(err) EXTERNAL;
	DECLARE err BYTE;
end;

prepRecord: PROCEDURE EXTERNAL; end;

libSeek: PROCEDURE(mode$b, blkByte$p) EXTERNAL;
	DECLARE mode$b BYTE, blkByte$p ADDRESS;
end;

matchLookAhead: PROCEDURE(str, len) BYTE EXTERNAL;
	DECLARE str ADDRESS, len BYTE;
end;

acceptRecord: PROCEDURE(type) EXTERNAL;
	DECLARE type BYTE;
end;

openLib: PROCEDURE EXTERNAL; end;

matchToken: PROCEDURE(str, len) BYTE EXTERNAL;
	DECLARE str ADDRESS, len BYTE;
end;
getCmd: PROCEDURE EXTERNAL; end;

skipModule: PROCEDURE EXTERNAL; end;
saveCurPos: PROCEDURE EXTERNAL; end;
restoreCurPos: PROCEDURE EXTERNAL; end;
swapCurSavedRec: PROCEDURE EXTERNAL; end;
writeErrStr: PROCEDURE(errCode) EXTERNAL;
	DECLARE errCode BYTE;	/* note inconsistent but code expects this */
end;

fileStatusChk: PROCEDURE(errCode, path$p, isFatal) EXTERNAL;
	DECLARE (errCode, path$p) ADDRESS, isFatal BYTE;
end;

skipCurRec: PROCEDURE EXTERNAL; end;



DECLARE token based token$p(1) BYTE;
DECLARE file BASED file$p FILE$T;
DECLARE arg BASED argChain ARG$T;
DECLARE module BASED module$p STRUCTURE(MODULE$T1, MODULE$T2);
DECLARE reset LABEL PUBLIC;


writeBuf: PROCEDURE(count, buf$p);
	DECLARE (count, buf$p) ADDRESS;
	DECLARE i ADDRESS;
	DECLARE buf BASED buf$p(1) BYTE;
	call writeFile(outConn, buf$p, count, .status);
	count = count - 1;	/* adjust for 0 based offset */
	do i = 0 to count;
		outCRC = outCRC + buf(i);
	end;
	outRecLen = outRecLen + 1 + count;
end writeBuf;

outRecInit: PROCEDURE(recLen);
	DECLARE recLen ADDRESS;
	outCRC = 0;
	/* record where start of record is */
	call SeekFile(outConn, 0, .recBlk, .recByt, .status);
	/* write type and length */
	call writeBuf(1, .curRec.type);
	call writeBuf(2, .recLen);
	outRecLen = 1;
end;


writeName: PROCEDURE(name$p);
	DECLARE name$p address;
	DECLARE name BASED name$p(1) BYTE;

	call writeBuf(name(0) + 1, name$p);
end;

writeCRC: PROCEDURE;
	outCRC = -outCRC;
	call writeFile(outConn, .outCRC, 1, .status);
end;


fixupLen: PROCEDURE;
	DECLARE (savblk, savbyt) ADDRESS;

	call seekFile(outConn, 0, .savblk, .savbyt, .status);	/* where we are */
	call seekFile(outConn, 2, .recBlk, .recByt, .status);	/* start of record */
	call seekFile(outConn, 3, .zeroByte, .one, .status);	/* offset of length */
	call writeBuf(2, .outRecLen);				/* the 2 byte length */
	call seekFile(outConn, 2, .savblk, .savbyt, .status);	/* back to where we were */
end;

DECLARE lib$tmp(*) BYTE INITIAL(':  :LIB.TMP ');

createTmpFile: PROCEDURE(path$p);
	DECLARE path$p ADDRESS;
	DECLARE path BASED path$p(1) BYTE;

	lib$tmp(1) = 'F';	/* assume temp is on F0 */
	lib$tmp(2) = '0';
	path$p = skipspc(path$p);
	if path(0) = ':' then
	do;
		lib$tmp(1) = path(1);
		lib$tmp(2) = path(2);
	end;
	libOutFile = .lib$tmp;
	call delete(.lib$tmp, .status);
	call openFile(.outConn, .lib$tmp, 3, 0, .status);
end;



replaceLib: PROCEDURE(path$p);
	DECLARE path$p ADDRESS;
	
	call closeFile(outConn, .status);
	call closeFile(inConn, .status);
	call deleteFile(path$p, .status);
	call renameFile(libOutFile, path$p, .status);
end;


modNotFound: PROCEDURE;
	DECLARE s ADDRESS;
	DECLARE module BASED module$p STRUCTURE(MODULE$T1, MODULE$T2);
	DECLARE arg BASED argChain ARG$T;

	s = arg.name;
	call log(.('  '), 2);	/* "  " */
	call log(s, pastFileName(skipspc(s)) - s);	/* emit the file name */
	call log(.('('), 1);	/* ( */
	call log(.module.name, module.nameLen);	/* and the module name */
	call logCRLF(.aNotFound, 12); /* ): NOT FOUND */
end;


lookupModule: PROCEDURE BYTE PUBLIC;
	DECLARE (i, found) BYTE;
	DECLARE module BASED module$p STRUCTURE(MODULE$T1, MODULE$T2);
	DECLARE module$a BASED module$p(1) BYTE;
	DECLARE arg BASED argChain ARG$T;

	found = 0;
	module$p = .arg.modules;	/* chase down the list of modules requested */
	do while module.link <> 0;
 
		module$p = module.link;
		found = 0FFH;		/* assume found */
	
		/* compare names */	
		do i = 0 to moduleName(0);
			if moduleName(i) <> module$a((i + 8) - 1) THEN
				found = 0;
		end;
		if found then
			return found;
	end;
	return found;
end;




chainModules: PROCEDURE;
	moduleHead = 0;
	module$p = .moduleHead;
	argChain = .argHead;

	do while arg.link <> 0;
		argChain = arg.link;
		module.link = arg.modules;
		/* seek to the end of the module list */
		do while module.link <> 0;
			module$p = module.link;
		end;
	end;
end;


getFileAndModuleNames: PROCEDURE;
	DECLARE arg BASED argChain ARG$T;
	DECLARE lookAhead BASED lookAhead$p(1) BYTE;
	DECLARE token BASED token$p(1) BYTE;
	DECLARE module BASED module$p STRUCTURE(MODULE$T1, MODULE$T2);
	DECLARE module$a BASED module$p(1) BYTE;
	DECLARE i BYTE;

	call getToken;
	/* add another arg entry to the chain */
	arg.link = allocUp(6);
	argChain = arg.link;
	arg.link = 0;
	module$p = .arg.modules;
	arg.name = token$p;
	if lookAhead(0) = '(' then	/* add the list of modules if present */
	do;
		inModuleList = 0FFH;
		call getToken;

		do while token(0) = '(' or token(0) = ',';
			inModuleList = 0;	/* already seen the file name, so we should get ( , or ) */
			call getToken;
			inModuleList = 0FFH;	/* assume we are going to get another module */
			module.link = allocUp(tokLen + 8);
			module$p = module.link;
			module.link = 0;
			module.found = 0;
			module.nameLen = tokLen;
			/* add the module name */
			do i = 0 to tokLen - 1;
				module$a(8+i) = token(i); 	
			end;
			call getToken;
		end;
		if token(0) <> ')' then
			call libError(ERR228);	/* RIGHT PARENTHESIS EXPECTED */
	end;
	module.link = 0;	
	inModuleList = 0;
end;


getxfield: PROCEDURE ADDRESS;
	DECLARE b BYTE;
	call getRecordBytes(1, .b);
	return .b;
end;	


xfieldSize: PROCEDURE(arg1) ADDRESS;
	DECLARE arg1 ADDRESS;
	return 1;
end;


sub$3C80: PROCEDURE(arg1w, arg2w) BYTE;
	DECLARE (arg1w, arg2w) ADDRESS;
	DECLARE b1 BASED arg1w BYTE;
	DECLARE b2 BASED arg2w BYTE;

	return b1 = b2;
end;



sub$3C98: PROCEDURE(arg1w, arg2w);
	DECLARE (arg1w, arg2w) ADDRESS;
	DECLARE b1 BASED arg1w BYTE;
	DECLARE b2 BASED arg2w BYTE;
	b2 = b1;
end;


sub$3CAD: PROCEDURE(arg1w);
	DECLARE arg1w ADDRESS;
	call writeBuf(1, arg1w);
end;

copyRestRec: PROCEDURE;
	DECLARE cnt ADDRESS;
	do while curRec.bytesLeft > 1;
		if curRec.bytesLeft > 1028 then
			cnt = 1028;
		else
			cnt = curRec.bytesLeft - 1;
		call getRecordBytes(cnt, .copyBuf);
		call writeBuf(cnt, .copyBuf);
	end;
	call readChkCRC;
	call writeCRC;
end;


addModule: PROCEDURE(addName);
	DECLARE addName BYTE;
	DECLARE module BASED module$p STRUCTURE(MODULE$T1, MODULE$T2);
	DECLARE xfield ADDRESS, offset ADDRESS, tmpByte BYTE, objNameLen BYTE;
	DECLARE junk(4) BYTE;	/* safety net for getRecordBytes */
	DECLARE symbol BASED hashptr STRUCTURE(SYMBOL$T);
	DECLARE symbol$a BASED hashptr(1) BYTE;

	addCnt = addCnt + 1;
	call outRecInit(curRec.len);
	call getRecordBytes(1, .objNameLen);
	if addName then
	do;
		/* get to the end of the current list of modules */
		do while module.link <> 0;
			module$p = module.link;
		end;

		module.link = allocUp(objNameLen + 8);
		module$p = module.link;
		module.link = 0;
		module.found = 0FFh;
	end;

	/* record location */
	module.blk = recBlk;
	module.byt = recByt;
	/* set the name */
	module.nameLen = objNameLen;
	call getRecordBytes(objNameLen, .module.name);
	call writeBuf(objNameLen + 1, .module.nameLen);
	/* copy the header to the new file */
	call copyRestRec;
	call prepRecord;

	do while curRec.type <> OBJEND;	/* loop over all of this module */
		call outRecInit(curRec.len);
		if  curRec.Type = PUBLICS  then
		do;
			call getRecordBytes(1, .tmpByte);	/* copy segid */
			call writeBuf(1, .tmpByte);

			do while curRec.bytesLeft > 1;
				call getRecordBytes(2, .offset); /* symbol entry offset */
				call getName(.moduleName);
				xfield = getxfield;
				/* check for duplicate public symbols */
				if lookupSymbol(.moduleName, .hashptr) then
					call fatal(ERR230);	/* DUPLICATE SYMBOL IN INPUT */

				/* create the symbol entry */
				symbol.link =  allocUp(moduleName(0) + 7);	/* sizeof symbol entry */
				hashPtr = symbol.link;
				symbol.link = 0;
				symbol.curCmd = argFilename;
				symbol.moduleCnt = libModuleCnt;
				do objNameLen = 0 to moduleName(0);
					symbol$a(6+objNameLen) = moduleName(objNameLen);	
				end;

				/* write the offset, name and xfield */
				call writeBuf(2, .offset);
				call writeBuf(moduleName(0)+1, .moduleName);
				call writeBuf(xfieldSize(xfield), xfield);
			end;
		end;
		/* copy the rest of the record and prep for the next loop */
		call copyRestRec;
		call prepRecord;
	end;	/* of while */
	
	/* copy the objend record */
	call outRecInit(curRec.len);
	call copyRestRec;
	/* keep tally for the new library */
	libModuleCnt = libModuleCnt + 1;
end;


finaliseLib: PROCEDURE(buf) PUBLIC;
	DECLARE buf ADDRESS;
	/* write the end of file marker */
	curRec.type = ENDFILE;
	call outRecInit(1);
	call writeCRC;
	/* rewind the output file */
	call seekFile(outConn, 2, .zeroByte, .zeroByte, .status);
	call libSeek(2, .zeroBlk);	/* rewind the input */
	call prepRecord;		/* pick up the original lib header */
	call outRecInit(curRec.len);	/* write the start out */
	call writeBuf(2, .libModuleCnt); /* write the module count */
	call writeBuf(4, buf);		/* write the module offset */
	call writeCRC;			/* and CRC */
end;


addCmd:	PROCEDURE;
	DECLARE lookAhead BASED lookAhead$p(1) BYTE;
	DECLARE hashItem BASED hashptr STRUCTURE(SYMBOL$T);
	DECLARE module$a BASED module$p(1) BYTE;

	DECLARE blkIdx		ADDRESS,
		byteIdx		ADDRESS,
		addLibHdr	LIBHDR$T,
		oldLibHdr 	LIBHDR$T,
		inLibConn 	ADDRESS,
		junk1		ADDRESS,
		j 	ADDRESS,
		libFileName	ADDRESS,
		junk2		ADDRESS,
		chunk		BYTE,
		found	BYTE;

	/* utility procedure to copy data from in to out */
	copyFileBytes: PROCEDURE(cnt);
		DECLARE cnt ADDRESS;

		call readFile(inConn, .copyBuf, cnt, .actual, .status);
		if actual < cnt then
			call fatal(ERR204);	/* PREMATURE EOF */

		call writeFile(outConn, .copyBuf, cnt, .status);
	end;

	DECLARE i	BYTE,
		nameIdx	ADDRESS,
		addBlk	ADDRESS,
		addByt	ADDRESS,
		junk3(4)	BYTE,
		locFields(4)	BYTE,	/* used to copy the location data over */
		group	ADDRESS,
		k	BYTE,
		n	ADDRESS;



	call getFileAndModuleNames;

	/* loop if more */
	do while lookAhead(0) = ',';
		call getToken;
		call getFileAndModuleNames;
	end;

	/* need a TO */
	if not matchLookAhead(.('TO'),2) THEN	/* "TO" */
		call libError(ERR233);	/* 'TO' EXPECTED */

	call getToken;	/* waste the TO */
	libFileName = lookAhead$p;	/* pick up filename to create */
	call getToken;
	if lookAhead(0) <> CR then	/* check this is the end */
		call libError(ERR203);	/* INVALID SYNTAX */

	call createTmpFile(libFileName);
	/* open the existing file */
	call openFile(.inLibConn, libFileName, readOnly, 0, .status);
	inConn = inLibConn;
	argFilename = libFileName;
	curRec.bytesLeft = 0;
	call acceptRecord(LIBHDR);
	call getRecordBytes(6, .oldLibHdr);
	call readChkCRC;
	libModuleCnt = oldLibHdr.modCnt;
	blkIdx, byteIdx = 0;
	call libSeek(2, .zeroBlk);	/* rewind */
	/*
	   copy all the existing module over i.e. until the NAMES record
	   the algorithm copies up to 1024 bytes at a time shrinking to smaller
	   blocks if there are less bytes
	*/
	chunk = 8;
	do while chunk > 0;		/* continue while there are blocks */
		if oldLibHdr.idxBlk - blkIdx >= chunk then
		do;
			call copyFileBytes(chunk * 128);
			blkIdx = blkIdx + chunk;
		end;
		else
			chunk = shr(chunk,1);	/* shrink the chunk size */
	end;

	call copyFileBytes(oldLibHdr.idxByte); /* copy remaining bytes */

	call acceptRecord(NAMES);
	addCnt = 0;

	/* scan all of the files to add */
	argChain = .argHead;
	do while arg.link <> 0;
		argChain = arg.link;
		argFilename = arg.name;
		call openLib;
		call prepRecord;
		if curRec.type = LIBHDR then	/* library to add? */
		do;
			call getRecordBytes(6, .addLibHdr);	/* load the 'add file' module header */
			call readChkCRC;	/* check ok */
			if arg.modules = 0 then /* adding all of the library */
			do;
				module$p = .arg.modules;
				call prepRecord;
				do while curRec.type = OBJHDR;
					call addModule(0FFh);
					call prepRecord;
				end;
			end;
			else
			do;
				nameIdx = 0;
				/* find the names record */
				call libSeek(2, .addLibHdr.idxBlk);
				call acceptRecord(NAMES);

				do while curRec.bytesLeft > 1;	/* process the names record */
					call getName(.moduleName);
					
					found = 0;
					module$p = .arg.modules;
					do while module.link <> 0 and not found;
						found = 0FFh;
						module$p = module.link;
						do i = 0 to moduleName(0);
							if moduleName(i) <> module$a(8 + i - 1) then
								found = 0;
						end;
						module.found = module.found or found;
					end;

					if found then	/* record the index into the locations */
						module.blk = nameIdx;
					nameIdx = nameIdx + 1;
				end;

				call acceptRecord(LIBLOC);
				call saveCurPos;	/* position of the locations block/byte number */
				module$p = .arg.modules;

				do while module.link <> 0;
					module$p = module.link;
					if not module.found then
						call modNotFound;
					else
					do;
						/* convert the name index into a block / byte offset */
						addByt = module.blk * 4;
						addBlk = shl(shr(module.blk, 14), 9);
						call restoreCurPos;	/* get to start of locations */
						call libSeek(3, .addBlk);	/* index into them */
						call getRecordBytes(4, .module.blk);	/* set the real block/byte */
					end;
				end;

				/* scan over the modules */
				module$p = .arg.modules;
				do while module.link <> 0;
					module$p = module.link;
					if module.found then
					do;
						/* locate the OBJHDR */
						call libSeek(2, .module.blk);
						call acceptRecord(OBJHDR);
						call addModule(0);
					end;
				end;
			end;
		end;
		else if curRec.type = OBJHDR then	/* standard object file to add */
		do;
			if arg.modules <> 0 then	/* user thought it was a library */
				call fatal(ERR235);	/* NOT LIBRARY */

			module$p = .arg.modules;

			do while curRec.type = OBJHDR;
				call addModule(0FFh);
				call prepRecord;
			end;
			if curRec.type <> ENDFILE then
				call fatal(ERR224);	/* BAD RECORD SEQUENCE */
		end;
		else
			call fatal(ERR224);	/* BAD RECORD SEQUENCE */

		call closeFile(inConn, .status);
	end;

	call chainModules;
	inConn = inLibConn;
	argFilename = libFileName;
	curRec.bytesLeft = 0;
	/* locate the old library NAMES record */
	call libSeek(2, .oldLibHdr.idxBlk);
	call acceptRecord(NAMES);
	call outRecInit(0);

	/* read in the names */
	do while curRec.bytesLeft > 1;
		call getName(.moduleName);
		call writeBuf(moduleName(0) + 1, .moduleName);
		module$p = .moduleHead;
		/* check there is not a duplicate module */
		do while module.link <> 0;
			module$p = module.link;
			do j = 0 to moduleName(0);
				if moduleName(j) <> module$a((j + 8) - 1) then
					goto outerloop;
			end;
			call log(.moduleName(1), moduleName(0));
			call logCRLF(.(' - ATTEMPT TO ADD DUPLICATE MODULE NAME'), 22h);
			goto reset;
	outerloop:
		end;
	end;

	/* scan the modules end emit all of the module names needed */

	module$p = .moduleHead;

	do while module.link <> 0;
		module$p = module.link;
		if module.found then
			call writeBuf(module.nameLen + 1, .module.nameLen);
	end;

	call fixupLen;	/* fix the names record length & write CRC */
	call writeCRC;
	/* record in the header where the NAMES record is located */
	oldLibHdr.idxBlk = recBlk;
	oldLibHdr.idxByte = recByt;
	/* prep the lib locations record */
	call acceptRecord(LIBLOC);
	call outRecInit(libModuleCnt * 4 + 1);

	/* copy the original library locations information over */
	do while curRec.bytesLeft > 1;
		call getRecordBytes(4, .locFields);
		call writeBuf(4, .locFields);
	end;

	/* now add the new locations */
	module$p = .moduleHead;

	do while module.link <> 0;
		module$p = module.link;
		if module.found then
			call writeBuf(4, .module.blk);

	end;

	call writeCRC;

	call acceptRecord(LIBDICT);
	call outRecInit(0);

	/* copy the existing dictionary checking that the new publics added don't
	   already exist
	*/
	do while curRec.bytesLeft > 1;
		call getName(.moduleName);
		if moduleName(0) = 0 then
			group = group + 1;
		else if lookupSymbol(.moduleName, .hashptr) then
		do;
			call log(.moduleName(1), moduleName(0));
			call logCRLF(.aPublicSymbolAl, 23h);
			goto reset;
		end;

		call writeName(.moduleName);
	end;

	/* if there are modules then add any new ones */
	if libModuleCnt <> 0 then
		do n = oldLibHdr.modCnt to libModuleCnt - 1;
			/* search the hashtable */
			do k = 0 to 127;
				hashptr = .hashTable(k);
				do while hashItem.link <> 0;
					hashptr = hashItem.link;
					/* is this the correct module number */
					if hashItem.moduleCnt = n then
						call writeBuf(hashItem.symLen + 1, .hashItem.symLen);
				end;
			end;
			/* write the module separator */
			call writeBuf(1, .zeroByte);
		end;

	call skipCurRec; /* ignore the rest of the LIBDICT in the original */
	call fixupLen;	/* fixup the LIBDICT len */
	call writeCRC;	/* and make the CRC work */
	call finaliseLib(.oldLibHdr.idxBlk);
	call replaceLib(libFileName);
end;




deleteCmd: PROCEDURE;
	DECLARE lookAhead BASED lookAhead$p(1) BYTE;
	DECLARE tmpLibHdr LIBHDR$T, junk$6429 ADDRESS,
		nothingToDelete BYTE, (junk$642C, delmod$p) ADDRESS;
	DECLARE modules BASED module$p STRUCTURE(MODULE$T1, MODULE$T2);
	DECLARE delmod BASED delmod$p STRUCTURE(MODULE$T1, MODULE$T2);	/* actually on start of structure */


	call getFileAndModuleNames;
	if lookAhead(0) <> CR then
		call libError(ERR203);	/* INVALID SYNTAX */

	if arg.modules = 0 then		/* nothing to do !! */
		call libError(ERR203);	/* INVALID SYNTAX */

	argFilename = arg.name;
	call openLib;
	call acceptRecord(LIBHDR);
	call getRecordBytes(6, .tmpLibHdr);	/* read in the existing header */
	call readChkCRC;			/* check not corrupt */
	call libSeek(2, .tmpLibHdr.idxBlk);	/* seek to names module */
	call acceptRecord(NAMES);

	delmod$p = .moduleHead;
	do while curRec.bytesLeft > 1;		/* pull in all the names */
		call getName(.moduleName);
		delmod.link = allocUp(7);		/* allocate a module entry */
		delmod$p = delmod.link;
		if (delmod.found := lookupModule) then	/* set the flag is this is one to delete */
			module.found = 0FFH;		/* and flagged as found in the user list */
		else
			libModuleCnt = libModuleCnt + 1;

	end;
	delmod.link = 0;
	call readChkCRC;		/* check for good OMF */

	nothingToDelete = 0FFh;
	module$p = .arg.modules;

	do while modules.link <> 0;	/* check we found at least one of the user's modules */
		module$p = module.link;
		if not modules.found then
			call modNotFound;
		else
			nothingToDelete = 0;
	end;

	if nothingToDelete then
		goto reset;

	call createTmpFile(argFilename);
	call libSeek(2, .zeroBlk);	/* rewind library */
	call acceptRecord(LIBHDR);
	call outRecInit(curRec.len);	/* write the LIBHDR type and record length */
	call copyRestRec;		/* copy the rest of the record */

	/* copy the objmodules unless delete requested */
	delmod$p = .moduleHead;
	do while delmod.link <> 0;
		delmod$p = delmod.link;
		call acceptRecord(OBJHDR);
		if delmod.found then	/* one to delete */
			call skipModule;
		else			
		do;			/* record where this module is going */
			call seekFile(outConn, 0, .delmod.blk, .delmod.byt, .status);

			/* copy until we get an end of module */
			do while curRec.type <> OBJEND;
				call outRecInit(curRec.len);
				call copyRestRec;
				call prepRecord;
			end;
			/* copy the OBJEND record */
			call outRecInit(curRec.len);
			call copyRestRec;
		end;
	end;

	/* copy only the none deleted NAME record entries */
	delmod$p = .moduleHead;
	call acceptRecord(NAMES);
	call outRecInit(0);

	do while delmod.link <> 0;
		delmod$p = delmod.link;
		call getName(.moduleName);
		if not delmod.found then
			call writeName(.moduleName);
	end;

	call fixupLen;
	call writeCRC;
	tmpLibHdr.idxBlk = recBlk;	/* save where the NAMES record is */
	tmpLibHdr.idxByte = recByt;

	/* scan included modules writing the locations */
	delmod$p = .moduleHead;
	call acceptRecord(LIBLOC);
	call outRecInit(0);

	do while delmod.link <> 0;
		delmod$p = delmod.link;
		if not delmod.found then
			call writeBuf(4, .delmod.blk);
	end;

	call fixupLen;
	call writeCRC;

	/* scan included modules writing the dictionary */
	delmod$p = .moduleHead;
	call acceptRecord(LIBDICT);
	call outRecInit(0);

	do while delmod.link <> 0;
		delmod$p = delmod.link;
		call getName(.moduleName);
		
		do while moduleName(0) <> 0;	/* copy the module names if needed */
			if not delmod.found then
				call writeName(.moduleName);

			call getName(.moduleName);
		end;

		/* terminate with a 0 if the group is included */
		if not delmod.found then
			call writeBuf(1, .zeroByte);

	end;

	call fixupLen;
	call writeCRC;
	call finaliseLib(.tmpLibHdr.idxBlk);	/* endfile & header update */
	call replaceLib(argFilename);		/* replace the library */
end;


createCmd: PROCEDURE;
	DECLARE lookAhead BASED lookAhead$p(1) BYTE;

	call getToken;
	if lookAhead(0) <> CR then		/* should have no other data */
		call libError(ERR203);	/* INVALID SYNTAX */

	argFilename = token$p;	/* try to open library */
	call Open(.inConn, argFilename, readOnly, 0, .status);
	if status = 0 then	/* if error then assume doesn't exist so ok */
	do;
		call closeFile(inConn, .status);
		call fileStatusChk(0E7h, argFilename, 0FFh);	/* error 231 not defined !!! */
	end;
	call closeFile(inConn, .status);
	call openFile(.outConn, argFilename, writeOnly, 0, .status);
	/* initialise with a minimal content */
	call writeFile(outConn, .initLibContent, 26, .status);
	call closeFile(outConn, .status);
end;



listCmd: PROCEDURE;
	DECLARE arg BASED argChain ARG$T;
	DECLARE token BASED token$p(1) BYTE;
	DECLARE lookAhead BASED lookAhead$p(1) BYTE;

	DECLARE listPublics	BYTE,
		listThisModule	BYTE,
		newLibHdr	LIBHDR$T;

	outName: PROCEDURE(leadSpaces,name$p);
		DECLARE leadSpaces BYTE, name$p ADDRESS;
		DECLARE len BASED name$p BYTE;

		call writeFile(outConn, .('      '), leadSpaces, .status);
		call writeFile(outConn, name$p + 1, len, .status);
		call writeFile(outConn, .(CR, LF), 2, .status);	/* crlf */
	end;


	/* collect the users list of libraries */
	call getFileAndModuleNames;		/* add the name to the chain and get any module list */
	do while lookAhead(0) = ',';
		call getToken;
		call getFileAndModuleNames;
	end;

	libOutFile = .(':CO: ');		/* assume console output */
	if matchLookAhead(.('TO'), 2) then
	do;
		call getToken; 	/* get the filename  to lookAhead */
		call getToken; 	/* and again to get to token */
		libOutFile = token$p;
	end;

	call getToken;	/* lookAhead to token */
	if (listPublics := matchToken(.('PUBLICS'), 7)) then
		call getToken;

	if token(0) <> CR then	/* should be it */
		call libError(ERR203);	/* INVALID SYNTAX */

	call openFile(.outConn, libOutFile, 2, 0, .status);
	argChain = .argHead;

	do while ((argChain := arg.link) <> 0);	/* loop through the files */
		argFilename = arg.name;
		call openLib;
		/* header line "  file\n\n" */
		call writeFile(outConn, .('  '), 2, .status);
		call writeFile(outConn, argFilename, pastFileName(argFilename) - argFilename, .status);
		call writeFile(outConn, .(CR, LF), 2, .status);

		call acceptRecord(LIBHDR);
		call getRecordBytes(6, .newLibHdr);	/* read module count, block number and byte number */
		call readChkCRC;			/* check not corrupt */
		call libSeek(2, .newLibHdr.idxBlk);	/* seek to the names */
		call acceptRecord(NAMES);		/* check we get the names */
		if listPublics then
		do;
			call saveCurPos;		/* save where we are */
			call acceptRecord(LIBLOC);	/* check locations and dictionary exist */
			call acceptRecord(LIBDICT);
			call swapCurSavedRec;
		end;

		do while curRec.bytesLeft > 1;		/* scan the names until the CRC */
			call getName(.moduleName);	/* get the name */
			if arg.modules = 0 then		/* listing all ? */
				listThisModule = 0FFH;
			else
				listThisModule = lookupModule;	/* no so check if needed */

			if listThisModule then		/* list name with 4 leading spaces */
				call outName(4, .moduleName);

			if listPublics then
			do;
				call swapCurSavedRec;	/* get to dictionary current location*/
				call getName(.moduleName);

				do while moduleName(0) <> 0;	/* scan the names until the end of the group */
					if listThisModule then	/* emit name with 6 leading spaces if required */
						call outName(6, .moduleName);

					call getName(.moduleName);
				end;
				call swapCurSavedRec;	/* back to where we were and save the current dictionary location */
			end;
		end;
		call closeFile(inConn, .status);	/* close the library */
	end;
	/* close the listing file */
	call closeFile(outConn, .status);
end;



DECLARE i BYTE;

start:
		call Write(0, .aIsisIiLibraria, 24, .status);
		call Read(1, .MEMORY, 122, .actual, .status); 	/* flush cmdline */

		goto main;


reset:	
		file$p = .fileHead;

		do while ((file$p := file.link) <> 0);
			if file.isopen then
				call Close(file.conn, .status);
		end;

main:
	do while(1);
		libModuleCnt = 0;		/* reset key vars and memory usage */
		heapTop = .MEMORY;
		memTop = memCk;
		file$p = .fileHead;
		file.link = 0;
		argChain = .argHead;
		arg.link = 0;
		moduleHead = 0;
		module$p = .moduleHead;
		do i = 0 to 127;
			hashTable(i) = 0;
		end;

		call Write(0, .('*'), 1, .status);
		call getCmd;
		if matchToken(.('EXIT'), 4) then
			call Exit;
		else if matchToken(.('ADD'), 3) then
			call addCmd;
		else if matchToken(.('CREATE'), 6) then
			call createCmd;
		else if matchToken(.('LIST'), 4) then
			call listCmd;
		else if matchToken(.('DELETE'), 6) then
			call deleteCmd;
		else if token(0) = CR then
			;
		else
			call writeErrStr(ERR232);	/* UNRECOGNIZED COMMAND */
	end;

end;

