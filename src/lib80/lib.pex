lit             'literally'
/* user types */
SYMBOL$T        'STRUCTURE(SYMBOL$T1)'
SYMBOL$T1       'link ADDRESS, curCmd ADDRESS, moduleCnt ADDRESS, symLen BYTE, symbol(1) BYTE'

LIBHDR$T        'STRUCTURE(modCnt ADDRESS, idxBlk ADDRESS, idxByte ADDRESS)'

LIBREC$T        'STRUCTURE(LIBREC$T1,LIBREC$T2)'
LIBREC$T1       'crc BYTE, type BYTE, len ADDRESS, bytesLeft ADDRESS'
LIBREC$T2       'curBlk ADDRESS, curByte ADDRESS, posBlk ADDRESS, posByte ADDRESS'

ARG$T           'STRUCTURE(link ADDRESS, modules ADDRESS, name ADDRESS)'

MODULE$T        'STRUCTURE(MODULE$T1,MODULE$T2)'
MODULE$T1       'link ADDRESS, blk ADDRESS, byt ADDRESS'
MODULE$T2       'found BYTE, nameLen BYTE, name(1) BYTE'

FILE$T          'STRUCTURE(link ADDRESS, path$p ADDRESS, isopen BYTE, conn BYTE)'

LINE$T          'STRUCTURE(next ADDRESS, len ADDRESS, text(1) BYTE)'

/* ERRORCODES */
ERR2            '2'	/* ILLEGAL AFTN ARGUMENT */
ERR4            '4'	/* INCORRECTLY SPECIFIED FILE */
ERR5            '5'	/* UNRECOGNIZED DEVICE NAME */
ERR6            '6'	/* ATTEMPT TO WRITE TO INPUT DEVICE */
ERR8            '8'	/* ATTEMPT TO READ FROM OUTPUT DEVICE */
ERR10           '10'	/* NOT ON SAME DISK */
ERR11           '11'	/* FILE ALREADY EXISTS */
ERR12           '12'	/* FILE IS ALREADY OPEN */
ERR13           '13'	/* NO SUCH FILE */
ERR14           '14'	/* WRITE PROTECTED */
ERR17           '17'	/* NOT A DISK FILE */
ERR18           '18'	/* ILLEGAL ISIS COMMAND */
ERR19           '19'	/* ATTEMPTED SEEK ON NON-DISK FILE */
ERR20           '20'	/* ATTEMPTED BACK SEEK TOO FAR */
ERR21           '21'	/* CAN'T RESCAN */
ERR22           '22'	/* ILLEGAL ACCESS MODE TO OPEN */
ERR23           '23'	/* MISSING FILENAME */
ERR25           '25'	/* ILLEGAL ECHO FILE */
ERR26           '26'	/* ILLEGAL ATTRIBUTE IDENTIFIER */
ERR27           '27'	/* ILLEGAL SEEK COMMAND */
ERR28           '28'	/* MISSING EXTENSION */
ERR31           '31'	/* CAN'T SEEK ON WRITE ONLY FILE */
ERR32           '32'	/* CAN'T DELETE OPEN FILE */
ERR35           '35'	/* SEEK PAST EOF */
ERR201          '201'	/* UNRECOGNIZED CONTROL */
ERR202          '202'	/* UNRECOGNIZED DELIMITER */
ERR203          '203'	/* INVALID SYNTAX */
ERR204          '204'	/* PREMATURE EOF */
ERR206          '206'	/* ILLEGAL DISKETTE LABEL */
ERR208          '208'	/* CHECKSUM ERROR */
ERR209          '209'	/* RELO FILE SEQUENCE ERROR */
ERR210          '210'	/* INSUFFICIENT MEMORY */
ERR211          '211'	/* RECORD TOO LONG */
ERR212          '212'	/* ILLEGAL RELO RECORD */
ERR213          '213'	/* FIXUP BOUNDS ERROR */
ERR214          '214'	/* ILLEGAL SUBMIT PARAMETER */
ERR215          '215'	/* ARGUMENT TOO LONG */
ERR216          '216'	/* TOO MANY PARAMETERS */
ERR217          '217'	/* OBJECT RECORD TOO SHORT */
ERR218          '218'	/* ILLEGAL RECORD FORMAT */
ERR219          '219'	/* PHASE ERROR */
ERR220          '220'	/* NO EOF */
ERR221          '221'	/* SEGMENT TOO LARGE */
ERR222          '222'	/* UNRECOGNIZED RECORD TYPE */
ERR223          '223'	/* BAD FIXUP RECORD */
ERR224          '224'	/* BAD RECORD SEQUENCE */
ERR225          '225'	/* INVALID MODULE NAME */
ERR226          '226'	/* MODULE NAME TOO LONG */
ERR227          '227'	/* LEFT PARENTHESIS EXPECTED */
ERR228          '228'	/* RIGHT PARENTHESIS EXPECTED */
ERR229          '229'	/* UNRECOGNIZED CONTROL */
ERR230          '230'	/* DUPLICATE SYMBOL IN INPUT */
ERR232          '232'	/* UNRECOGNIZED COMMAND */
ERR233          '233'	/* 'TO' EXPECTED */
ERR235          '235'	/* NOT LIBRARY */
ERR238          '238'	/* ILLEGAL STACK CONTENT RECORD */
ERR239          '239'	/* NO MODULE HEADER RECORD */
ERR240          '240'	/* PROGRAM EXCEEDS 64K */

/* enum FILEIO */
readOnly        '1'
writeOnly       '2'
readWrite       '3'
/* omf records */
OBJHDR          '2'
OBJEND          '4'
OBJDATA         '6'
ENDFILE         '0Eh'
PUBLICS         '16h'
LIBLOC          '26h'
NAMES           '28h'
LIBDICT         '2Ah'
LIBHDR          '2Ch'

/* MISC */
CR              '0dh'
LF              '0ah'

/* ISIS sys codes */
IOPEN           '0'
ICLOSE          '1'
IDELETE         '2'
IREAD           '3'
IWRITE          '4'
ISEEK           '5'
ILOAD           '6'
IRENAME         '7'
ICONSOL         '8'
IEXIT           '9'
IATTRIB         '10'
IRESCAN         '11'
IERROR          '12'
IWHOCON         '13'
ISPATH          '14'

$file(isis1.plm)
close           P(A conn,A status$p)
delete          P(A path$p,A status$p)
error           P(A error$num)
exit            P

$file(isis2.plm)
open            P(A conn$p,A path$p,A access,A echo,A status$p)
read            P(A conn,A buff$p,A count,A actual$p,A status$p)
rename          P(A old$p,A new$p,A status$p)
seek            P(A conn,A mode,A block$p,A byte$p,A status$p)
write           P(A conn,A buff$p,A count,A status$p)

$file(isisa.asm)
isis            P(B type,A parameter$ptr)
memck           PA

$file(lib.plm)
actual          A
argFilename     A
hashTable       AS
inConn          A
reset           L
status          A
finaliseLib     P(A buf)
lookupModule    PB
arg             "ARG$T"..argChain
file            "FILE$T"..file$p
module          "MODULE$T"..module$p
token           BS..token$p

$file(lib1.plm)
curLine$p       A
curRec          "LIBREC$T"
fileHead        A
file$p          A
heapTop         A
inModuleList    B
lookAheadLen    B
lookAhead$p     A
memTop          A
savedRec        "LIBREC$T"
token$p         A
tokLen          B
acceptRecord    P(B type)
allocDown       P(A cnt)A
allocUp         P(A cnt)A
closeFile       P(A conn,A status$p)
deleteFile      P(A path$p,A status$p)
fatal           P(B err)
fileStatusChk   P(A errCode,A path$p,B isFatal)
getCmd          P
getName         P(A buf)
getRecordBytes  P(A count,A buf$p)
getToken        P
hash            P(A pstr)B
illegalRecord   P
libError        P(B err)
libSeek         P(B mode$b,A blkByte$p)
log             P(A buf,A cnt)
logCRLF         P(A buf,A cnt)
lookupSymbol    P(A modName$p,A hash$p)B
matchLookAhead  P(A cha$p,B len)B
matchToken      P(A cha$p,B len)B
openFile        P(A conn$p,A path$p,A access,A echo,A status$p)
openLib         P
prepRecord      P
readChkCRC      P
readFile        P(A conn,A buff$p,A count,A actual$p,A status$p)
renameFile      P(A old$p,A new$p,A status$p)
restoreCurPos   P
saveCurPos      P
seekFile        P(A conn,A mode,A block$p,A byte$p,A status$p)
skipCurRec      P
skipModule      P
swapCurSavedRec P
writeErrStr     P(A errCode)
writeFile       P(A conn,A buff$p,A count,A status$p)

$file(lib3.plm)
pastFileName    P(A ch$p)A
skipSpc         P(A ch$p)A

$file(lib4.plm)
binasc          P(A num,B base,B padch,A cha$p,B width)
