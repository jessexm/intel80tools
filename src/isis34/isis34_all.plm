isis34.pex
# common control characters
CONTROL$E	'5',
BELL		'7',
BS		'8',
CR		'0dh'
LF		'0ah'
CONTROL$P	'10h'
CONTROL$Q	'11h'
CONTROL$R	'12h'
CONTROL$S	'13h'
CONTROL$X	'18h'
CONTROL$Z	'1ah'
ESC		'1bh'
DELKEY		'7fh'

# boolean literals
BOOLEAN		'BYTE'
TRUE		'0ffh'
FALSE		'0'

# console literals
AFTN$CONSOL$IN	'7'
AFTN$CONSOL$OUT	'6'
READ$MODE	'1'
WRITE$MODE	'2'

# seek options
SEEK$RETURN	'0'
SEEK$BACKWARD	'1'
SEEK$ABS	'2'
SEEK$FORWARD	'3'
SEEK$EOF	'4'

# common types
DCB$T		'structure(iocw BYTE, ioins BYTE, nsec BYTE, tadr BYTE, sadr BYTE, buf ADDRESS)'

# error codes
OK	'0'	/* No error detected. */
NO$FREE$BUFFER	'1'	/* Insufficient space in buffer area for a required buffer. */
BAD$AFT$NO	'2'	/* AFTN does not specify an open file. */
AFT$FULL	'3'	/* Attempt to open more than 6 files simultaneously. */
BAD$PATH	'4'	/* Illegal pathname specification. */
BAD$DEVICE	'5'	/* Illegal or unrecognized device specification */
CANT$WRITE	'6'	/* Attempt to write to a file open for input. */
DISK$FULL	'7'	/* Operation aborted: insufficient disk space. */
CANT$READ	'8'	/* Attempt to read from a file open for output. */
DIRECTORY$FULL	'9'	/* No more room in disk directory. */
DIFFERENT$DISK	'10'	/* Pathnames do not specify the same disk. */
MULTIDEFINED	'11'	/* Cannot rename file; name already in use. */
ALREADY$OPEN	'12'	/* Attempt to open a file already open. */
NO$SUCH$FILE	'13'	/* No such file. */
WRITE$PROTECT	'14'	/* Attempt to open for writing or to delete or rename a write-protected file. */
ISIS$OVERWRITE	'15'	/* Attempt to load into ISIS-II area or buffer area. */	
BAD$LOAD$FORMAT	'16'	/* Illegal format record. */	
NON$DISK$FILE	'17'	/* Attempt to rename/delete a non-disk file. */	
BAD$COMMAND	'18'	/* Unrecognized system call. */	
NON$DISK$SEEK	'19'	/* Attempt to seek on a non-disk file. */	
LONG$BACK$SEEK	'20'	/* Attempt to seek backward past beginning of a file */	
CANT$RESCAN	'21'	/* Attempt to rescan a non-lined file. */	
BAD$ACCESS	'22'	/* Illegal ACCESS parameter to OPEN or access mode impossible for file specified. */	
NULL$FILENAME	'23'	/* No filename specified for a disk file. */		
DISK$IO$ERROR	'24'	/* Disk error (see below). */		
BAD$ECHO	'25'	/* Incorrect specification of echo file to OPEN */	
BAD$ATTRIB	'26'	/* Incorrect SWID argument in ATTRIB system call */		
BAD$SEEK$ARG	'27'	/* Incorrect MODE argument in SEEK system call. */		
NULL$EXTENSION	'28'	/* Null file extension. */
CONSOLE$EOF	'29'	/* End of file on console input. */
DRIVE$NOT$READY	'30'	/* Drive not ready. */
SEEK$ON$WRITE	'31'	/* Attempted seek on write-only (output) file. */
CANT$DELETE	'32'	/* Can't delete an open file. */
BAD$PARAMETER	'33'	/* Illegal system call parameter. */
BAD$RETSW	'34'	/* Bad RETSW argument to LOAD. */
SEEK$PAST$EOF	'35'	/* Attempt to extend a file opened for input by seeking past end-of-file */

WARNING		'0'
MESSAGE		'1'
ABORT		'2'
CMSK		'0fch'

# attributes
INVISIBLE$ATTRIBUTE	'1'
SYSTEM$ATTRIBUTE	'2'
WRITEP$ATTRIBUTE	'4'
FORMAT$ATTRIBUTE	'80h'

# access mode
ACCESS$READ	'1'
ACCESS$WRITE	'2'


# OMF record types
R$MODHDR	'2'
R$MODEND	'4'
R$CONTENT	'6'
R$LINENO	'8'
R$EOF		'0EH'
R$ANCESTOR	'10H'
R$LOCALS	'12H'
R$PUBLICS	'16H'
R$EXTNAMES	'18H'
R$EXTREF	'20H'
R$RELOC		'22H'
R$INTERSEG	'24H'
R$LIBLOCS	'26H'
R$LIBNAMES	'28H'
R$LIBDICT	'2AH'
R$LIBHDR	'2CH'
R$COMDEF	'2EH'

$file(aft.plm)
AFT$BOTTOM	'6'
AFT$CONSOLE	'7'
AFT$PROTECT	'12'
AFT$LAST	'13'
CI$AFT		'1'
CO$AFT		'0'
F0DEV		'0'
F1DEV		'1'
F2DEV		'2'
F3DEV		'3'
F4DEV		'4'
F5DEV		'5'
CIDEV		'23'
CODEV		'24'
BBDEV		'22'
AFT$T1		'empty BYTE, device BYTE, access BYTE, edit BYTE, lbuf ADDRESS'
AFT$T2		'dbuf ADDRESS, pbuf ADDRESS, data$ptr BYTE, i$no ADDRESS, ptr$ptr BYTE'
AFT$T3		'eofcnt BYTE, ptr$change BYTE, data$change BYTE, blk ADDRESS, blk$seq ADDRESS'
AFT$T4		'ptr$blk ADDRESS, hdr$blk ADDRESS, data$blk$count ADDRESS, dbuf$read BYTE'
AFT$T		'structure(AFT$T1, AFT$T2, AFT$T3, AFT$T4)'
a$access$p      A
a$blk$count$p   A
a$blk$seqno$p   A
a$data$blk$p    A
a$data$change$p A
a$data$ptr$p    A
a$dbuf$p        A
a$dbuf$read$p   A
a$dev$p         A
a$edit$p        A
a$empty$p       A
a$eof$data$ptr$p A
aft             "AFT$T"(18)
a$hdr$blk$p     A
a$i$no$p        A
a$lbuf$p        A
a$pbuf$p        A
a$ptr$blk$p     A
a$ptr$change$p  A
a$ptr$ptr$p     A
datum$base      A
pointer$base    A
aft$window      P(B slot$number)
get$aft$slot    PB
a$empty		B..a$empty$p
a$device	B..a$dev$p
a$access	B..a$access$p
a$edit		B..a$edit$p
a$dbuf          A..a$dbuf$p
a$lbuf		A..a$lbuf$p
a$pbuf          A..a$pbuf$p
a$data$ptr	B..a$data$ptr$p
a$i$no		A..a$i$no$p
a$ptr$ptr	B..a$ptr$ptr$p
a$eof$data$ptr	B..a$eof$data$ptr$p
a$ptr$change	B..a$ptr$change$p
a$data$change	B..a$data$change$p
a$blk$count	A..a$blk$count$p
a$blk$seqno	A..a$blk$seqno$p
a$ptr$blk	A..a$ptr$blk$p
a$hdr$blk	A..a$hdr$blk$p
a$data$blk	A..a$data$blk$p
a$dbuf$read	B..a$dbuf$read$p

BLINK		'0'
FLINK		'1'
links		A(64)..pointer$base

$file(alloc.plm)
current$bitmap  B
free$block      P(B diskNum,A trackSector)
get$block       P(B diskNum)A
map$read        P
map$write       P(B diskNum)

$file(attrib.plm)
attrib          P(A file$ptr,A swid,"BOOLEAN" value)

$file(buffer.plm)
buffer$table    BS
clear$buf       P(A buf$address)
get$buf         PA
pack$aft$buf    PA
return$buf      P(A buf$address)

$file(close.plm)
close           P(B aftn)

$file(consol.plm)
alt$cidev       B
cold$cidev      B
cur$consol$in   BS
cur$consol$out  BS
console         P(A infile,A outfile)
whocon          P(B aftn,A bufferloc)

$file(delete.plm)
del             P(B disknum)
delete          P(A pathname)

$file(direct.plm)
DIRECT$T1	'empty BOOLEAN, file(6) BYTE, ext(3) BYTE, attrib BYTE'
DIRECT$T2	'eof$count BYTE, blk ADDRESS, hdr$blk ADDRESS'
DIRECT$T	'structure(DIRECT$T1, DIRECT$T2)'
direct          "DIRECT$T"
direct$i$no     B
dir$clos        P(B aftn)
dlook           P(A fn)"BOOLEAN"

$file(disk2.asm)
dk$cflg		P(B drive)B
dk$stat		PB
r$type		PB
r$byte		PB
strt$io		P(A iopb)

$file(diskio.plm)
CMD$RECAL	'3'
CMD$READ	'4'
CMD$WRITE	'6'
absio		P(B command,B disk,A block,A buffer$ptr)
absRead		P(A block, A buffer$ptr)
absWrite	P(A block, A buffer$ptr)
dk$cf$tb	B(10)
dkcont		B
diskio		P(B drive, A iopb)


$file(error.plm)
c$dk$sat        A
debug$Toggle    B
errdrv          B
global$severity B
err             P(B severity,B error$type)
warn            P(B errcode)

$file(exit.plm)
# rename of plm to asm 6 char name
close$all	'clsall'
cli             BS
clsall          P(B aft$start)
exit            P

$file(isis.plm)
userStatus$p    A
isis            P(B command,A parameter$block)
userStatus      A..userStatus$p

$file(jmpto.asm)
jmpto		P(A entry,A stack)

$file(load.plm)
load            P(A pathname,A bias,A retsw,A entry$p)

$file(loc62.asm)
usrSP		A
usrStk		B
sysStk		B
CI		PB
CO		P(B val)
CSTS		PB
IOCHK		PB
IOSET		P(B val)
LO		P(B val)
PO		P(B val)
RI		PB

$file(memck.asm)
memck		PA

$file(open.plm)
open            P(A pathname,A access$mode,A lined$aft)B

$file(path.plm)
pn              BS
pn2             BS
path            P(A pathname,A pn$p)B
xpath           P(A p1,A p2)

$file(rename.plm)
rename          P(A old$file,A new$file)
$file(reboot.plm)
reboot		P
$file(rescan.plm)
rescan          P(B aftn)

$file(rw.plm)
adjust$eof      P
chk$eof         P
lined           P(B aftn,A buffer,A count,A actual$p)
read            P(B aftn,A buffer,A count,A actual$p)
save$data$blk	P
write           P(B aftn,A buffer,A count)

$file(seek.plm)
rewind          P
save$pointer$block P
seek            P(B aftn,A mode,A blockptr,A byteptr)

$file(trap.asm)
trap		P

$file(unpath.plm)
unpath          P(A pathname$p,A pn$p)

$file(upper.plm)
toupper		P(B char)B

loc62.asm
	name isis40
	public	usrSP
	public	usrStk
	public	sysstk

	public	IOCHK		; bios entry points
	public	IOSET
	public	CI
	public	RI
	public	CO
	public	PO
	public	LO
	public	CSTS

	extrn	isis

	ASEG
CI	equ	0F803H
RI	equ	0F806H
CO	equ	0F809H
PO	equ	0F80CH
LO	equ	0F80FH
CSTS	equ	0F812H
IOCHK	equ	0F815H
IOSET	equ	0F818H


	CSEG			; this will be located @3Eh
	db	3,4		; isis version
	jmp	isis


	DSEG
	ds	1
usrSP:	ds	2
	db	0c7h,0c7h,0c7h,0c7h,0c7h
	db	0c7h,0c7h,0c7h,0c7h,0c7h
	db	0c7h,0c7h,0c7h,0c7h,0c7h
	db	0c7h,0c7h,0c7h,0c7h,0c7h
	db	0c7h,0c7h,0c7h,0c7h,0c7h
	db	0c7h,0c7h,0c7h,0c7h,0c7h
	db	0c7h,0c7h
sysstk:
	db	0c7h,0c7h,0c7h,0c7h,0c7h
	db	0c7h,0c7h,0c7h
usrstk:

	end

jmpto.asm
	name	jmpto
	public	jmpto
	cseg
jmpto:				; bc = entry point, de = stack
	xchg
	sphl			; set stack
	mov	h, b		; goto entry point
	mov	l, c
	pchl

	end
isis.plm
isis:
do;
$include(isis.ipx)

DECLARE copyRight(*) BYTE DATA('(C)1978INTELCORP'),
	retParamIdx(*) BYTE DATA( 5, 2, 2, 5, 4, 5, 5, 3, 3, 1, 4, 2, 2, 3, 3), 
	paramType(5) ADDRESS DATA(1000111110001010B,	/* bit set if parameter needs to check for */
				  1111001100111110B,	/* address below MEMORY (3000H) */
				  1100001101000000B,
				  0000100001110000B,
				  0000000011010010B);


DECLARE userStatus$p ADDRESS PUBLIC;
DECLARE userStatus BASED userStatus$p ADDRESS;

isis: PROCEDURE(command, parameter$block) PUBLIC;
	DECLARE command BYTE, parameter$block ADDRESS;
	DECLARE param BASED parameter$block (5) ADDRESS;
	DECLARE i BYTE;
	DECLARE sysParam(6) ADDRESS;	/* parameters - parameter 0 not used */
	DECLARE param1 ADDRESS AT (.sysParam(1)),
		param2 ADDRESS AT (.sysParam(2)),
		param3 ADDRESS AT (.sysParam(3)),
		param4 ADDRESS AT (.sysParam(4)),
		param5 ADDRESS AT (.sysParam(5));

	aft$check: PROCEDURE;
		DECLARE aftn ADDRESS AT (.sysParam(1));
		aftn = aftn + AFT$BOTTOM;
		if aftn >= AFT$LAST+1 OR aftn < AFT$BOTTOM then
			call warn(BAD$AFT$NO);
	end;

	usrSP = STACKPTR;
	STACKPTR = .usrStk;	/* defined in loc62.asm */

	if command = 'D' then
		call diskio(param(0), param(1));
	else
	do;
		do i = 0 to 4;
			if shr(paramType(i), command + 1) then /* check if an address parameter */
				if (param(i) < .MEMORY) then
					call err(ABORT, BAD$PARAMETER);
			sysParam(i+1) = param(i);
		end;

		userStatus$p = sysParam(retParamIdx(command));	/* get the return status address */
		userStatus = 0;
		global$severity = 0;
		if command >= 15 then		/* MAX$COMMAND */
			call err(ABORT, BAD$COMMAND);
		do case command;
		do;		/* 0 - OPEN */
			DECLARE aftn$value BASED param1 ADDRESS;
			aftn$value = 0FFh;
			aftn$value = open(param2, param3, param4);	/* file, access, mode */
		end;
		do;		/* 1 - CLOSE */
			call aft$check;
			call aft$window(param1);
			if a$empty then
				call warn(BAD$AFT$NO);
			if param1 >= 8 then
				call close(param1);
		end;
		call delete(param1);	/* 2 - DELETE - file */
		do;			/* 3 - READ */
			call aft$check;
			if aft(param1).edit = 0 then
				call read(param1, param2, param3, param4);	/* aftn, buffer, count, actual */
			else
				call lined(param1, param2, param3, param4);	/* aftn, buffer, count, actual */
		end;
		do;			/* 4 - WRITE */
			call aft$check;
			call write(param1, param2, param3);	/* aftn, buffer, count */
		end;
		do;			/* 5 - SEEK */
			call aft$check;
			call seek(param1, param2, param3, param4);	/* aftn, mode, blockp, bytep */
		end;
		call load(param1, param2, param3, param4);	/* 6 - SEEK - file, base, retsw, entry */
		call rename(param1, param2);		/* 7 - RENAME - file1, file2 */
		do;
			global$severity = 2;
			call console(param1, param2);		/* 8 - CONSOLE - file1, file2 */
		end;
		call exit;				/* 9 - EXIT */
		call attrib(param1, param2, param3);	/* 10 - ATTRIB - file, swid, swvalue */
		do;			/* 11 - RESCAN */
			call aft$check;
			call rescan(param1);		/* aftn */
		end;
		call err(MESSAGE, param1);	/* 12 - ERROR - MESSAGE, errnum */ 
		call whocon(param1, param2);	/* 13 - WHOCON - aftn, buffer */
		userStatus = path(param1, param2);	/* 14 - PATH - file, buffer */
		end;
	end;
	STACKPTR = usrSP;
end;
end;
eof

aft.plm
aft:
do;

$include(aft.ipx)

DECLARE	aft$current BYTE INITIAL(0ffh);
DECLARE	pointer$base ADDRESS PUBLIC,
	datum$base ADDRESS PUBLIC,
	a$empty$p ADDRESS PUBLIC,
	a$dev$p ADDRESS PUBLIC,
	a$access$p ADDRESS PUBLIC,
	a$edit$p ADDRESS PUBLIC,
	a$lbuf$p ADDRESS PUBLIC,
	a$dbuf$p ADDRESS PUBLIC,
	a$data$ptr$p ADDRESS PUBLIC,
	a$i$no$p ADDRESS PUBLIC,
	a$pbuf$p ADDRESS PUBLIC,
	a$ptr$ptr$p ADDRESS PUBLIC,
	a$eof$data$ptr$p ADDRESS PUBLIC,
	a$ptr$change$p ADDRESS PUBLIC,
	a$data$change$p ADDRESS PUBLIC,
	a$blk$count$p ADDRESS PUBLIC,
	a$blk$seqno$p ADDRESS PUBLIC,
	a$ptr$blk$p ADDRESS PUBLIC,
	a$hdr$blk$p ADDRESS PUBLIC,
	a$data$blk$p ADDRESS PUBLIC,
	a$dbuf$read$p ADDRESS PUBLIC;

declare a$dbuf based a$dbuf$p  address;
declare a$pbuf based a$pbuf$p  address;

DECLARE aft(14) STRUCTURE (
		empty	BYTE,
		device	BYTE,
		access	BYTE,
		edit	BYTE,
		lbuf	ADDRESS,
		dbuf	ADDRESS,
		pbuf	ADDRESS,
		data$ptr BYTE,
		i$no	ADDRESS,
		ptr$ptr	BYTE,
		eofcnt	BYTE,
		ptr$change BYTE,
		data$change BYTE,
		blk ADDRESS,
		blk$seq	ADDRESS,
		ptr$blk	ADDRESS,
		hdr$blk	ADDRESS,
		data$blk$count ADDRESS,
		dbuf$read BYTE) PUBLIC INITIAL(
			0, 0, 3, 0, 0, 0, 0, 80h, 0, 0, 80h, 0, 0, 19h, 0, 101h, 101h, 102h, 0,
			0, 1, 3, 0, 0, 0, 0, 80h, 0, 0, 80h, 0, 0, 19h, 0, 101h, 101h, 102h, 0,
			0, 2, 3, 0, 0, 0, 0, 80h, 0, 0, 80h, 0, 0, 19h, 0, 101h, 101h, 102h, 0,
			0, 3, 3, 0, 0, 0, 0, 80h, 0, 0, 80h, 0, 0, 19h, 0, 101h, 101h, 102h, 0,
			0, 4, 3, 0, 0, 0, 0, 80h, 0, 0, 80h, 0, 0, 19h, 0, 101h, 101h, 102h, 0,
			0, 5, 3, 0, 0, 0, 0, 80h, 0, 0, 80h, 0, 0, 19h, 0, 101h, 101h, 102h, 0,
			0FFh, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0FFh, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0FFh, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0FFh, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0FFh, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0FFh, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0FFh, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0FFh, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);			

aft$window: PROCEDURE(slot$number) PUBLIC;
	DECLARE slot$number BYTE;

	if aft$current <> slot$number then
	do;	
		a$empty$p = .aft(aft$current := slot$number).empty;
		a$dev$p = a$empty$p + 1;
		a$access$p = a$dev$p + 1;
		a$edit$p = a$access$p + 1;
		a$lbuf$p = a$edit$p + 1;
		a$data$ptr$p = a$lbuf$p + 6;
		a$i$no$p = a$data$ptr$p + 1;
		a$ptr$ptr$p = a$i$no$p + 2;
		a$eof$data$ptr$p = a$empty$p + 14;
		a$ptr$change$p = a$eof$data$ptr$p + 1;
		a$data$change$p = a$ptr$change$p + 1;
		a$blk$count$p = a$data$change$p + 1;
		a$blk$seqno$p = a$blk$count$p + 2;
		a$ptr$blk$p = a$blk$seqno$p + 2;
		a$hdr$blk$p = a$ptr$blk$p + 2;
		a$data$blk$p = a$hdr$blk$p + 2;
		a$dbuf$read$p = a$data$blk$p + 2;
	end;
	a$dbuf$p = .aft(slot$number).dbuf;
	a$pbuf$p = a$dbuf$p + 2;
	pointer$base = a$pbuf;
	datum$base = a$dbuf;

end;


get$aft$slot: PROCEDURE BYTE PUBLIC;
	DECLARE i BYTE;

	do i = AFT$BOTTOM to AFT$LAST;
		if aft(i).empty then
			return i;
	end;
	call err(ABORT, AFT$FULL);
end;
end;
eof;

attrib.plm
attrib:
do;
	
$include(attrib.ipx)

declare pad byte;

attrib:	PROCEDURE(file$ptr, swid, value) PUBLIC;
	DECLARE (file$ptr, swid) address, value byte;
	DECLARE mask(*) BYTE DATA (INVISIBLE$ATTRIBUTE,
                                   SYSTEM$ATTRIBUTE,
                                   WRITEP$ATTRIBUTE,
                                   FORMAT$ATTRIBUTE);

	if swid > 4 then
		call warn(BAD$ATTRIB);
	call xpath(file$ptr, .pn);
	if pn(0) > 5 then
		call warn(NON$DISK$FILE);
	call aft$window(pn(0));
	if not dlook(.pn) then
		call warn(NO$SUCH$FILE);
	direct.attrib = direct.attrib or mask(low(swid));
	if not value then
		direct.attrib = direct.attrib and (not mask(low(swid)));
	call dir$clos(pn(0));
end;
end;
eof;

close.plm
close:
do;
$include(close.ipx)



DECLARE	caseMap(*) BYTE DATA (0,0,0,0,0,0,		/* F0-F5 */
			      1,2,1,2,1,2,1,1,1,1,	/* TI, TO, VI, VO, I1, O1, TR, HR, T1, T2 */
			      3,3,3,3,4,4,1,1,1);	/* TP, HP, P1, P2, LP, L1, BB, CI, CO */

DECLARE t$eof	BYTE,			/* not used */
	zero	ADDRESS INITIAL(0),
	bytes	ADDRESS INITIAL(0);

close: PROCEDURE(aftn) PUBLIC;
	DECLARE aftn BYTE;
	DECLARE i byte;

	call aft$window(aftn);
	if a$empty then
		return;
	if a$edit <> 0 then
		call return$buf(a$lbuf);
	do case caseMap(a$device);
		do;	/* 0 - disk */
			if a$data$change then
				call abswrite(a$data$blk, a$dbuf);
			if a$ptr$change then
				call abswrite(a$ptr$blk, a$pbuf);

			call return$buf(a$pbuf);
			call return$buf(a$dbuf);
			if a$access >= 2 then
			do;
				call adjust$eof;
				call map$write(a$device);
				aft(a$device).dbuf = a$dbuf;		/* let device use returned buffers */
				aft(a$device).pbuf = a$pbuf;
				call aft$window(a$device);
				call rewind;		/* get to dir header */
				bytes = aft(aftn).i$no * 16;
				call seek(a$device, SEEK$ABS, .zero, .bytes);	/* seek to file entry */
				call read(a$device, .direct, 16, .i);		/* read the dir entry */
				direct.eof$count = aft(aftn).eofcnt;
				direct.blk = aft(aftn).blk;
				bytes = .aft(0).blk - .aft(0).empty - 1;
				call seek(a$device, 1, .zero, .bytes);
				call dir$clos(a$device);
			end;
		end;
		;	/* 1 */
		;	/* 2 */
		do i = 0 to 119;	/* 3 output 120 nulls */
			call write(aftn, .(0), 1);
		end;
		;	/* 4 */
	end;
	aft(aftn).empty = TRUE;
end;	
end;
eof
consol.plm
consol:
DO;
$include(consol.ipx)

declare pad byte;
DECLARE cur$consol$in  (12) BYTE PUBLIC,
	cur$consol$out (12) BYTE PUBLIC;

DECLARE	cold$consol$in(5)  BYTE INITIAL(':XI: '),
	cold$consol$out(5) BYTE INITIAL(':XO: ');

DECLARE	cold$start$flag BOOLEAN INITIAL (TRUE);

DECLARE (cold$cidev, alt$cidev) BYTE PUBLIC;

console: PROCEDURE(infile, outfile) PUBLIC;
	DECLARE (infile, outfile) ADDRESS;
	DECLARE instring based infile BYTE,
		outstring based outfile BYTE;
	DECLARE temp BYTE;
	DECLARE tdrv(2) BYTE DATA ('TV');	/* T or V is 1st letter of device name */
	DECLARE initio BYTE AT (6);

	if cold$start$flag then
	do;
	  cold$consol$in(1), cold$consol$out(1) = tdrv(initio and 1);
	  infile = .cold$consol$in;
	  outfile = .cold$consol$out;
	end;
	
	global$severity = ABORT;
	call xpath(outfile, .pn);
	if pn(0) <> CODEV then
	do;
	  call close(AFTN$CONSOL$OUT);
	  temp = open(outfile, WRITE$MODE, FALSE);
	  call xpath(outfile, .cur$consol$out);
	end;
	call xpath(infile, .pn);
	if pn(0) <> CIDEV then 
	do;
	  call close(AFTN$CONSOL$IN);
	  temp = open(infile, READ$MODE, 100h);
	  if cold$start$flag then
	    cold$cidev = aft(AFTN$CONSOL$IN).device;
	  alt$cidev = cold$cidev;
	  call xpath(infile, .cur$consol$in);
	end;
	cold$start$flag = FALSE;
end;


whocon:	PROCEDURE(aftn, bufferloc) PUBLIC;
	DECLARE aftn BYTE;
	DECLARE bufferloc ADDRESS;
	DECLARE nameloc ADDRESS;

	nameloc = .cur$consol$out;
	if aftn then
	    nameloc = .cur$consol$in;
	call unpath(nameloc, bufferloc);
end;
end;
eof
delete.plm
delete:
DO;
$include(delete.ipx)

declare pad byte;

del: PROCEDURE(disknum) PUBLIC;
    DECLARE disknum BYTE;
    declare (aftn, i) byte;
    DECLARE blockno ADDRESS DATA (0);
    DECLARE byteno ADDRESS DATA(16 /* size(DIRECT) */);
    DECLARE temp ADDRESS;
    DECLARE buf based TEMP (64) ADDRESS;

    /* internal delete routing
	disknum = F0DEV .. F5DEV
	direct must contain the directory entry for an existing file or disk.
	aft slot for the appropriate directory must have buffers;
	and these buffers must be setup for directory reading and
	writing. These buffers will be clobbered
    */


     direct.empty = TRUE;
     call aft$window(aftn := disknum);
     call write(aftn, .direct, size(direct));
     call absio(CMD$WRITE, disknum, a$data$blk, a$dbuf);
     call seek(aftn, SEEK$BACKWARD, .blockno, .byteno);
     temp = a$dbuf;	/* temp -> a buffer we not exists based a$dbuf$p */
     do while direct.hdr$blk <> 0;
	call free$block(disknum, direct.hdr$blk);
	call absio(CMD$READ, disknum, direct.hdr$blk, temp);
	direct.hdr$blk = buf(FLINK);
	do i = 2 to 63;
	    if buf(i) <> 0 then
		call free$block(disknum, buf(i));
	end;
     end;
     call absio(CMD$READ, disknum, a$data$blk, a$dbuf);	/* last 2 based vars */
     call map$write(disknum);
end;


delete: PROCEDURE(pathname) PUBLIC;
	DECLARE pathname ADDRESS;
	declare i byte;

	call xpath(pathname, .pn);
	if pn(0) > F5DEV then
	    call warn(NON$DISK$FILE);
	call aft$window(pn(0));
	if not dlook(.pn) then
	    call warn(NO$SUCH$FILE);
	if (direct.attrib and (WRITEP$ATTRIBUTE or FORMAT$ATTRIBUTE)) <> 0 then
	    call warn(WRITE$PROTECT);
	do i = AFT$BOTTOM to AFT$LAST;
	    call aft$window(i);
	    if (not a$empty) and (a$device = pn(0)) and (a$i$no = direct$i$no) then
		call warn(CANT$DELETE);	
	end;
	call del(pn(0));
end;
end;
eof
diskio.plm
diskio: do;
$include(diskio.ipx)

declare rdy$mask(4) byte data(1, 2, 20h, 40h);

declare pad byte;
declare absDcb DCB$T initial(80h, 0, 1, 0, 0, 0);
declare dk$cf$tb(6) byte public;
declare dkcont byte public;
declare recal$dcb structure(iocw byte, ioins byte, nsec byte, tadr byte, sadr byte)
		            initial(80h, CMD$RECAL, 1, 0, 0);

diskio: procedure(drive, iopb) public;
    declare drive byte, iopb address;
    declare dcb BASED iopb DCB$T;
    declare temp address, (temp2, temp1) byte at(.temp),
	    (try, ival) byte;

    ival = input(0FCh);
    output(0fch) = ival or 2;
    recal$dcb.ioins = CMD$RECAL;
    recal$dcb.sadr = 0;
    if (dkcont := dkcflg(drive)) and drive then
    do;
	dcb.ioins = dcb.ioins or 30h;
	dcb.sadr = dcb.sadr or 20h;
        recal$dcb.ioins = 33h;
        recal$dcb.sadr = 20h;
    end;

    if dkcont = 80h then
    do;
	dcb.ioins = dcb.ioins or shl(drive, 4);
        recal$dcb.ioins = shl(drive, 4) or 3;
    end;
    do try = 0 to 10;
	do while (dkstat and 4) <> 0;
	    temp1 = r$type;
	    temp1 = r$byte;
        end;
	temp1 = (drive and 1) + 1;
	if dkcont = 80h then
		temp1 = rdyMask(drive);	
	if (dkstat and temp1) = 0 then
		call err(ABORT, DRIVE$NOT$READY);
	call strt$io(iopb);
	temp1 = r$type;
	if (temp2 := r$byte) = 0 then
	do;
		output(0FCh) = ival;
		return;
	end;
	call strt$io(.recal$dcb);
     end;
     errDrv = drive;
     c$dk$sat = temp;
     call err(ABORT, DISK$IO$ERROR);
end;
	
absio: procedure(cmd, disk, block, buffer) public;
    declare (cmd, disk) byte, (block, buffer) address;

    absDcb.ioins = cmd;
    absDcb.tadr = high(block);
    absDcb.sadr = low(block);
    absDcb.buf = buffer;
    call diskio(disk, .absDcb);
end;

absRead: procedure(block, buffer) public;
     declare (block, buffer) address;
     call absio(CMD$READ, a$device, block, buffer);
end;

absWrite: procedure(block, buffer) public;
    declare (block, buffer) address;
    call absio(CMD$WRITE, a$device, block, buffer);
end;
end;
eof

error.plm
error:
do;
$include(error.ipx)


DECLARE	pad ADDRESS,	/* padding to align to isis.bin */
	debug$Toggle BYTE PUBLIC,
	global$severity BYTE PUBLIC,
	c$dk$sat ADDRESS PUBLIC;

DECLARE	msg1(7) BYTE INITIAL(CR, LF, 'ERROR'),
	msg2(4) BYTE, /* error number goes here */
	msg3(9) BYTE INITIAL(' USER PC '),
	msg4(4) BYTE, /* user pc in hex goes here */
	msg5(7) BYTE INITIAL(CR, LF, 'FDCC='),
	msg6(4) BYTE, /* drive status goes here */
	msg7(7) BYTE INITIAL(CR, LF, 'DRIVE'),
	errdrv	BYTE PUBLIC, /* drive goes here */
	msg8(5) BYTE INITIAL('   ', CR, LF);


DECLARE	initio BYTE AT (6);

err: PROCEDURE(severity, error$type) PUBLIC;
	DECLARE (severity, error$type, i, imax) BYTE;
	DECLARE pc BASED usrSP ADDRESS;

	num: PROCEDURE(value, base, bufaddr);
		DECLARE value ADDRESS, base BYTE, bufaddr ADDRESS;
		DECLARE buf based bufaddr(4) BYTE;
		DECLARE (div, digit) ADDRESS, (i, asciiOffset) BYTE;
		do i = 1 to 4;
			asciiOffset = '0';
			div = value / base;
			digit = value - div * base;
			if digit > 9 then
				asciiOffset = '7';
			buf(4 - i) = digit + asciiOffset;
			value = div;
		end;
		do i = 0 to 2;
			if buf(i) = '0' then
				buf(i) = ' ';
			else
				goto done;
		end;
	done:
	end;


	if (severity := severity or global$severity) <> WARNING then
	do;
		call num(error$type, 10, .msg2);
		call num(pc, 16, .msg4);	
		call ioset((iochk AND CMSK) OR (initio AND 3));
		imax = 25;	/* number of characters in normal error message */
		if error$type = DISK$IO$ERROR then
		do;
			imax = 47;
			call num(c$dk$sat, 16, .msg6);
			call num(errDrv, 10, .errDrv);
		end;
		do i = 0 to imax;
			call co(msg1(i));
		end;
	end;
	else
	do;
		userStatus = error$type;
		STACKPTR = usrSP;
	end;
	if severity >= ABORT then
	do;
		if debug$toggle then
			call trap;	/* trap to monitor */
		call reboot;
	end;
end;


warn: PROCEDURE(errcode) PUBLIC;
	DECLARE errcode BYTE;
	call err(WARNING, errcode);
end;

end;
eof;

exit.plm
exit:
do;
$include(exit.ipx)

DECLARE cli(*) BYTE PUBLIC DATA('ISIS.CLI ');

exit: PROCEDURE PUBLIC;
	declare i byte;
	do i = AFT$CONSOLE + 1 to AFT$LAST;
		call close(i);
	end;
	call map$write(current$bitmap);
	current$bitmap = 0ffh;
	call load(.cli, 0, 1, 0);
end exit;
end;
eof

load.plm
load:
do;
$include(load.ipx)


load: PROCEDURE(pathname, bias, retsw, entry$p) PUBLIC;
	DECLARE (pathname, bias, retsw, entry$p) ADDRESS;
	DECLARE entry BASED entry$p ADDRESS;
	DECLARE (aftn, i, retsw$b) BYTE;
	DECLARE record STRUCTURE(type BYTE, length ADDRESS);
	DECLARE modend STRUCTURE(modtype BYTE, segid BYTE, load$addr ADDRESS);
	DECLARE content STRUCTURE(segid BYTE, load$addr ADDRESS) AT (.modend);
	DECLARE checksum BYTE AT (.modend); 
	DECLARE actual ADDRESS, pad ADDRESS;
	DECLARE blockno ADDRESS, user$bottom ADDRESS, buffer$top ADDRESS;

	bounds$test: PROCEDURE(addr, len);
		DECLARE (addr, len) ADDRESS;
		if addr >= 18h AND addr <= 3fh AND addr + len <= 40h then
			return;
		if user$bottom > addr then
			user$bottom = addr;	/* first address will update this if applicable */
		if buffer$top > addr OR addr + len  < addr then
			call err(ABORT, ISIS$OVERWRITE);
	end;

	blockno = 0;
	user$bottom = 0ffffh;
	if retsw > 2 then
		call warn(BAD$RETSW);

	aftn = AFT$BOTTOM +  open(pathname, 1, 0);	/* open$read */
	if (retsw$b := retsw) <> 0 then
		user$bottom = memck;
	buffer$top = pack$aft$buf;
	do while TRUE;
		call read(aftn, .record, 3, .actual);	/* read record type and length */
		if actual < 3 OR record.type >= R$RELOC OR record.type then	/* short, relocate or odd type */
			call err(ABORT, BAD$LOAD$FORMAT);
		if record.type > R$CONTENT then
			call seek(aftn, SEEK$FORWARD, .blockno, .record.length);	/* skip record */
		else
		do;
			do case shr(record.type,1);
			call err(ABORT, BAD$LOAD$FORMAT);	/* case 0 */
			call seek(aftn, SEEK$FORWARD, .blockno, .record.length);	/* case 1 - R$MODHDR skip */
			do;	/* case 2 - R$MODEND */
				call read(aftn, .modend, size(modend), .actual);
				modend.load$addr = modend.load$addr + bias;
				if modend.modtype = 1 then		/* system */
					call bounds$test(modend.load$addr, 0);
				else
					modend.load$addr = 0;
				call close(aftn);
				user$bottom = user$bottom AND 0ff80h;
				do i = 0 to 18;
					buffer$table(i) = buffer$table(i) AND 0FEh; /* assume available or in use */
					if user$bottom <= .MEMORY(shl(DOUBLE(i), 7)) then
						buffer$table(i) = 1;	/* not available */
				end;
				if retsw$b = 0 then
				do;
					entry = modend.load$addr;
					return;
				end;
				if retsw$b = 1 then
				do;
					debug$toggle = FALSE;
					call jmpto(modend.load$addr, usrSP + 2);	/* wastes the return address */
				end;
				STACKPTR = memck;	
				entry$p = STACKPTR;
				entry = modend.load$addr;
				debug$toggle = TRUE;
				call trap;
			end;
			do;	/* case 3 - R$CONTENT */
				call read(aftn, .content, 3, .actual);
				if content.segId <> 0 then
					call err(ABORT, BAD$LOAD$FORMAT);
				record.length = record.length - 4;		/* don't include header and crc */
				content.load$addr = content.load$addr + bias;
				call bounds$test(content.load$addr, record.length);
				call read(aftn, content.load$addr, record.length, .actual);
				if actual < record.length then
					call err(ABORT, BAD$LOAD$FORMAT);
				call read(aftn, .checksum, 1, .actual);
			end;
			end;	/* of case */
		end;	/* of else */
	end;
end;
end;
eof

open.plm
open:
do;
$include(open.ipx)

DECLARE supportedAccess(*) BYTE DATA(3, 3, 3, 3, 3, 3, 1, 2,
				     1, 2, 1, 2, 1, 1, 1, 1,
				     2, 2, 2, 2, 2, 2, 3, 1, 2);

declare pad byte;

open: PROCEDURE(pathname, access$mode, lined$aft) BYTE PUBLIC;
	DECLARE (pathname, access$mode, lined$aft) ADDRESS;
	DECLARE (aftn, reqAccess, found, temp, i) BYTE;
	DECLARE temp$buf ADDRESS;
	DECLARE bytes BASED temp$buf (128) BYTE;
	DECLARE addr BASED temp$buf (64) ADDRESS;

	warn1: procedure(errCode);
		declare errCode byte;

		if a$edit <> 0 then
			call return$buf(a$lbuf);
		call warn(errCode);
	end;

	warn2: procedure(errCode);
		declare errCode byte;

		call return$buf(a$dbuf);
		call return$buf(a$pbuf);
		call warn1(errCode);
	end;

	if access$mode > 3 or (reqAccess := access$mode) = 0 then
		call warn(BAD$ACCESS);
	call xpath(pathname, .pn);
	if (i := supportedAccess(pn(0))) <> 3 then
		if i <> reqAccess then
			call warn(BAD$ACCESS);
	if pn(0) = CIDEV then
		return CI$AFT;
	if pn(0) = CODEV then
		return CO$AFT;
	call aft$window(aftn := get$aft$slot);
	a$access = reqAccess;
	a$edit = 0;
	if lined$aft <> 0 then
	do;
		a$edit = AFT$BOTTOM + low(lined$aft);
		if aft(a$edit).access <> 2 OR (a$access AND 1) = 0 then
			call warn(BAD$ECHO);

		temp$buf, a$lbuf = get$buf;
		bytes(0) = LF;
		addr(63) = 0ff00h;
		bytes(125) = TRUE;
	end;

	if (a$device := pn(0)) <= F5DEV then
	do;
		found = dlook(.pn);
		call aft$window(aftn);
		if found then
			do i = AFT$BOTTOM TO AFT$LAST;
				if not aft(i).empty then
					if aft(i).i$no = direct$i$no and aft(i).device = pn(0) then
						call warn1(ALREADY$OPEN);
			end;
		a$i$no = direct$i$no;
		a$dbuf = get$buf;
		a$pbuf = get$buf;
		if reqAccess = 1 then
		do;
			if not found then
				call warn2(NO$SUCH$FILE);
			a$hdr$blk = direct.hdr$blk;
			a$blk$count = direct.blk;
			a$eof$data$ptr = direct.eof$count;
			call rewind;
		end;
		else
		do;
			if not found then
			do;
				if direct$i$no = 0ffh then
					call warn2(DIRECTORY$FULL);
				direct.blk = 0;
				direct.eof$count = 128;
				direct.attrib = 0;
			end;
			if (direct.attrib and (WRITEP$ATTRIBUTE OR FORMAT$ATTRIBUTE)) <> 0 then
				call warn2(WRITE$PROTECT);

			if reqAccess = 2 and found then
			do;
				call del(a$device);
				call aft$window(aftn);
				direct.blk = 0;
				direct.eof$count = 128;
			end;
			a$eof$data$ptr = direct.eof$count;
			a$blk$count = direct.blk;
			if not (temp := reqAccess = 3 and found) then
			do;
				direct.hdr$blk = get$block(a$device);
			end;
			a$hdr$blk = direct.hdr$blk;
			direct.empty = 0;
			do i = 0 to 8;
				direct.file(i) = pn(i + 1);
			end;
			if reqAccess = 3 and not found then
				direct.attrib = 0;
			call dir$clos(a$device);
			call aft$window(aftn);
			call rewind;
			if not temp then
			do;
				call clear$buf(a$pbuf);
				call map$write(a$device);
				call abswrite(a$hdr$blk, a$pbuf);
			end;
		end;
	end;
	else if a$device <> BBDEV then
	do;
		do i = AFT$BOTTOM to AFT$LAST;
			if not aft(i).empty then
				if a$device = aft(i).device then
					call warn1(ALREADY$OPEN);
		end;
		if a$device >= 10h and a$device <= 13h then
			do i = 1 to 120;
				a$empty = FALSE;
				call write(aftn, .(0), 1);
			end;
		
	end;
	a$empty = FALSE;
	return aftn - AFT$BOTTOM;
end;
end;
eof

path.plm
path:
do;
$include(path.ipx)

/*
	Abstract

	This is the module that understands the syntax of
	pathnames, and parses them

	Module Organisation

	The module contains the following components:

	1. 2 Global arrays, 'pn' and 'pn2', either of which is
	   sufficient to contain the 'internal form' of a pathname.
	   These are provided here for the convenient transitory
	   use by such subroutines as open, rename, delete etc.
	   The are not directly used by 'path'
	2. The byte procedure 'path', which converts a legal pathname
	   into internal form, returning an error number for the
	   type of pathname found. (0 means legal pathname, other
	   numbers indicates syntax errors in pathname.)
	3. The procedure 'xpath', whose only reason for existence is
	   to reduce the space used for calls to 'path' throughout
	   the program; it reduces code to test the result from
	   path and optionally call err, to a single point in the
	   program.
*/ 

/*
	Although accessed as a byte array the path structur has the format
	STRUCTURE(devNo BYTE, name(6) BYTE, ext(3) BYTE, devType BYTE, drvType BYTE)
*/

DECLARE deviceNames(25) STRUCTURE(name ADDRESS, type BYTE) DATA(
		'F0', 3, 'F1', 3, 'F2', 3, 'F3', 3,
		'F4', 3, 'F5', 3, 'TI', 0, 'TO', 1,
		'VI', 0, 'VO', 1, 'I1', 0, 'O1', 1,
		'TR', 0, 'HR', 0, 'R1', 0, 'R2', 0,
		'TP', 1, 'HP', 1, 'P1', 1, 'P2', 1,
		'LP', 1, 'L1', 1, 'BB', 2, 'CI', 0,
		'CO', 1);

DECLARE pn(12) BYTE PUBLIC, pn2(12) BYTE PUBLIC;
	
path: PROCEDURE(pathname, pn$p) BYTE PUBLIC;
	DECLARE (pathname, pn$p) ADDRESS;
	DECLARE pn BASED pn$p (12) BYTE;	/* byte version of path structure */
	DECLARE pathCh BASED pathname BYTE;	/* char of pathname points to */
	DECLARE pathArray BASED pathname (1) BYTE;
	DECLARE devname ADDRESS, (second, first) BYTE AT (.devname);
	DECLARE null$name BYTE;
	DECLARE i BYTE;




	non$terminate: PROCEDURE BOOLEAN;
		return (pathCh >= 'A' AND pathCh <= 'Z')
		    OR (pathCh >= '0' AND pathCh <= '9')
		    OR (pathCh >= 'a' AND pathCh <= 'z');
	end;

	do i = 0 to last(pn);	/* clear pn */
		pn(i) = 0;
	end;
	do while pathCh = ' ';	/* skip leading space */
		pathname = pathname + 1;
	end;
	if pathCh = ':' then
	do;
		pn(0) = 0FFH;
		if pathArray(3) <> ':' then
			return BAD$PATH;
		pathname = pathname + 1;	/* past ':' */
		first = toupper(pathCh);
		pathname = pathname + 1;
		second = toupper(pathCh);
		pathname = pathname + 2;

		do i = 0 to last(deviceNames);
			if deviceNames(i).name = devname then
				pn(0) = i;	/* save device number */
		end;
		if pn(0) = 0ffh then
			return BAD$DEVICE;
	end;
	pn(11) = 0FFh;
	pn(10) = deviceNames(pn(0)).type;
	if pn(10) = 3 then /* random access device */
		pn(11) = dk$cf$tb(pn(0));

	null$name = TRUE;
	i = 1;
	do while i < 7;
		if non$terminate then
		do;
			pn(i) = toupper(pathCh);
			pathname = pathname + 1;
			null$name = FALSE;
		end;
		i = i + 1;
	end;
	if pathCh = '.' then
	do;
		pathname = pathname + 1;
		do while i < 10;
			if non$terminate then
			do;
				pn(i) = toupper(pathCh);
				pathname = pathname + 1;
			end;
			i = i + 1;
		end;
		if pn(7) = 0 then
			return NULL$EXTENSION;
	end;
	if pn(0) <= F5DEV and null$name then
		return NULL$FILENAME;
	if non$terminate  OR pathCh = '.' OR pathCh = ':' then
		return BAD$PATH;
	return OK;
end;

xpath: PROCEDURE(p1, p2) PUBLIC;
	DECLARE (p1, p2) ADDRESS;
	DECLARE status ADDRESS;

	if (status := path(p1, p2)) <> 0 then
		call warn(status);
end;
end;
unpath.plm
unpath: do;
$include(unpath.ipx)
declare deviceNames(*) byte data('F0F1F2F3F4F5TITOVIVOI1O1TRHRR1R2TPHPP1P2LPL1BBCICO');

unpath: PROCEDURE(pathname$p, pn$p) PUBLIC;
	DECLARE (pathname$p, pn$p) ADDRESS;
	DECLARE pathname BASED pathname$p (12) BYTE;
	DECLARE pn BASED pn$p (12) BYTE;
	DECLARE i BYTE;

	pn(0) = ':';
	pn(1) = deviceNames(pathname(0) + pathname(0));
	pn(2) = deviceNames(pathname(0) + pathname(0) + 1);
	pn(3) = ':';
	pn$p = pn$p + 4;
	do i = 0 to 5;	/* copy file name */
		if (pn(0) := pathname(i + 1)) <> 0 then
			pn$p = pn$p + 1;
	end;
	if pathname(7) <> 0 then
	do;
		pn(0) = '.';
		pn$p = pn$p + 1;
	end;
	do i = 0 to 2;
		if (pn(0) := pathname(i + 7)) <> 0 then
			pn$p = pn$p + 1;
	end;
	pn(0) = ' ';
end;

end;
eof

rename.plm
rename:
do;
$include(rename.ipx)

declare pad byte;

rename: PROCEDURE(old$file, new$file) PUBLIC;
	DECLARE (old$file, new$file) ADDRESS;
	DECLARE i BYTE;
	DECLARE already$exists BOOLEAN;
	

	call xpath(old$file, .pn2);
	call xpath(new$file, .pn);
	if pn(0) > F5DEV then
		call warn(NON$DISK$FILE);
	if pn(0) <> pn2(0) then
		call warn(DIFFERENT$DISK);
	call aft$window(pn(0));
	/* If new$file already exists and old$file does not existi,
	   then we want ot give the old$file error message.
	   However, dlook(new$file) should precede dlook(old$file)
	   this is because pointer variables should be left pointing to
	   the old file upon exit from this procedure */
	already$exists = dlook(.pn);
	if NOT dlook(.pn2) then
		call warn(NO$SUCH$FILE);
	if (direct.attrib and (WRITEP$ATTRIBUTE OR FORMAT$ATTRIBUTE)) <> 0 then
		call warn(WRITE$PROTECT);
	if already$exists then
		call warn(MULTIDEFINED);
	do i = 0 to 8;
		direct.file(i) = pn(i + 1);
	end;
	call dir$clos(a$device);
end;
end;
eof

rescan.plm
rescan:
DO;

$include(rescan.ipx)

declare pad byte;

rescan: PROCEDURE(aftn) PUBLIC;
	DECLARE aftn BYTE;
	DECLARE temp ADDRESS, bytes BASED temp(128) BYTE,
			      addr BASED temp(64) ADDRESS;

	call aft$window(aftn);
	temp = a$lbuf;
	if a$edit <> 0 AND NOT bytes(125) then
		addr(63) = 0;	/* lptr = 0, in$mode = false */
	else
		call warn(CANT$RESCAN);
end;
end;
eof

rw.plm
rw:
do;

$include(rw.ipx)


DECLARE	MAXLL	LITERALLY	'122';	/* maximum line length */

DECLARE iobyteMasks(*) BYTE DATA(0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FCh, 0FCh, 0FCh, 0FCh,
				 0FCh, 0FCh, 0F3h, 0F3h, 0F3h, 0F3h, 0CFh, 0CFh, 0CFh, 0CFh,
				 3Fh, 3Fh, 0FFh, 0FFh, 0FFh);

DECLARE iobyteFlags(*) BYTE DATA(0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
				 3, 3, 0, 4, 8, 0Ch, 0, 10h, 20h,
				 30h, 80h, 0C0h, 0, 0, 0);

DECLARE readCtrl(*) BYTE DATA(0, 0, 0, 0, 0, 0, 1, 0FFh, 1, 0FFh, 1,
			      0FFh, 2, 2, 2, 2, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh);

DECLARE writeCtrl(*) BYTE DATA(0, 0, 0, 0, 0, 0, 0FFh, 1, 0FFh, 1,
			      0FFh, 1, 0FFh, 0FFh, 0FFh, 0FFh,
			      2, 2, 2, 2, 3, 3, 4, 0FFh, 0FFh);

DECLARE specialChars(*) byte DATA(0, DELKEY, CONTROL$Z, CONTROL$R, CONTROL$X, CR, LF, ESC, CONTROL$E, CONTROL$P);


DECLARE	pad byte,
	count$diff ADDRESS,
	adp$dif BYTE PUBLIC,
	eof$dif BYTE,
	b2C62 BYTE,
	create BYTE,
	newptrblk ADDRESS,
	iostat BYTE;
	

chk$eof: PROCEDURE PUBLIC;
	if a$access = ACCESS$READ then
	do;
		a$blk$seqno = a$blk$count;
		a$data$ptr = a$eof$data$ptr;
		call WARN(SEEK$PAST$EOF);

	end;
end;

adjust$eof: PROCEDURE PUBLIC;
	if ((a$eof$data$ptr < a$data$ptr AND a$blk$seqno = a$blk$count) OR a$blk$seqno > a$blk$count) then
	do;
		call chk$eof;
		a$blk$count = a$blk$seqno;
		a$eof$data$ptr = a$data$ptr;
	end;
end;

subDEB: procedure;
	if a$data$blk <> 0 then
		return;
	a$ptr$change = TRUE;
	links(a$ptr$ptr), a$data$blk = get$block(a$device);

	if a$access = 3 and not b2C62 and not a$dbuf$read then
	do;
		call clear$buf(a$dbuf);
		call abswrite(a$data$blk, a$dbuf);
		a$dbuf$read = TRUE;
	end;
end;

save$data$blk: PROCEDURE PUBLIC;
	if a$data$change then
	do;
		call abswrite(a$data$blk, a$dbuf);
		a$data$change = FALSE;
	end;
end;

rw: PROCEDURE(aftn, buffer, count, actual$p, reading);
	DECLARE aftn BYTE, (buffer, count, actual$p) ADDRESS, reading BYTE;
	DECLARE actual BASED actual$p ADDRESS;
	DECLARE (work$buf, temp) ADDRESS;
	DECLARE newlinks BASED temp (64) ADDRESS;
	DECLARE bufCh based buffer byte, datum based datum$base (1) byte;;

	actual = 0;

	do while count > actual;
		if a$blk$count <= a$blk$seqno AND reading AND a$data$ptr = a$eof$data$ptr then
			return;
		if a$data$ptr = 128  or a$data$ptr = 0 then
		do;
			call save$data$blk;
			if a$data$ptr = 128 then
			do;
				a$dbuf$read = FALSE;
				a$ptr$ptr = a$ptr$ptr + 1;
				a$blk$seqno = a$blk$seqno + 1;
				a$data$ptr = 0;
			end;
			if a$ptr$ptr = 64 then
			do;
				create = FALSE;
				if links(FLINK) = 0 then
				do;
					create = TRUE;
					newptrblk = get$block(a$device);
					links(FLINK) = newptrblk;	
					a$ptr$change = TRUE;
					call clear$buf(a$dbuf);
					temp = a$dbuf;
					newlinks(0) = a$ptr$blk;	/* save forward link */
					call map$write(a$device);
					call abswrite(newptrblk, a$dbuf);
				end;

				call save$pointer$block;
				if create then
				do;
					call clear$buf(a$pbuf);
					temp = a$pbuf;
					newlinks(0) = a$ptr$blk;
				end;
				else
				do;
					call absread(newptrblk := links(FLINK), a$pbuf);
				end;
				a$ptr$blk = newptrblk;
				a$ptr$ptr = 2;
				a$dbuf$read = FALSE;
			end;
			a$data$blk = links(a$ptr$ptr);
			if (b2C62 := (count - actual) >= 128 and (not reading or a$blk$seqno < a$blk$count)) then
			do;
				actual = actual + (a$data$ptr := 128);
				buffer = (work$buf := buffer) + 128;
			end;	
			else
				work$buf = a$dbuf;
			if reading then
			do;
				if a$data$blk = 0 then
					call clear$buf(work$buf);
				else
					call absread(a$data$blk, work$buf);
				if not b2C62 then
					a$dbuf$read = TRUE;
			end;
			else
			do;
				call subDEB;
				if b2C62 then
					call abswrite(a$data$blk, work$buf);
			end;
		end;

		if a$data$ptr <> 128 then
		do;
			if not a$dbuf$read then
			do;
				a$data$blk = links(a$ptr$ptr);
				if a$data$blk = 0 then
					call clear$buf(a$dbuf);
				else
					call absread(a$data$blk, a$dbuf);
				a$dbuf$read = TRUE;
			end;

			adp$dif = 128 - a$data$ptr;
			if a$blk$count <= a$blk$seqno AND reading then
			do;
				eof$dif = a$eof$data$ptr - a$data$ptr;
				if adp$dif > eof$dif then
					adp$dif = eof$dif;
			end;
			if not reading then
			do;
				a$data$change = TRUE;
				call subDEB;
			end;
			
			countdiff = count - actual;
			if adp$dif > count$diff then	/* check if more in buffer than needed */
				adp$dif = count$diff;


			actual = actual + adp$dif;
			do while adp$dif <> 0;
				adp$dif = adp$dif - 1;
				if reading then
					bufCh = datum(a$data$ptr);
				else
					datum(a$data$ptr) = bufCh;
				a$data$ptr = a$data$ptr + 1;
				buffer = buffer + 1;
			end;	
		end;
	end; /* of do while */
	call adjust$eof;
end;



non$disk$select: PROCEDURE;
	/*
	   set logical file assignments to use monitor routines
	   for doing byte at a time I/O devices
	*/
	iostat = iochk;
	call ioset((iostat and iobyteMasks(a$device)) or iobyteFlags(a$device));
end;


read: PROCEDURE(aftn, buffer, count, actual$p) PUBLIC;
	DECLARE aftn BYTE, (buffer, count, actual$p) ADDRESS;
	DECLARE actual BASED actual$p ADDRESS;
	DECLARE bytes BASED buffer BYTE;

	actual = 0;
	call aft$window(aftn);
	if a$empty then
		call warn(BAD$AFT$NO);

	if (a$access AND 1) = 0 then	/* not read */
		call warn(CANT$READ);

	call non$disk$select;
	if a$device <= F5DEV then
		call rw(aftn, buffer, count, actual$p, TRUE);
	else if a$device <> BBDEV then
		do while actual <> count;
			if readCtrl(a$device) then
				bytes = ci;
			else
			do;
				bytes = ri;
				if CARRY then
					goto done;
			end;
			buffer = buffer + 1;
			actual = actual + 1;
		end;
done:
	call ioset(iostat);
end;



write: PROCEDURE(aftn, buffer, count) PUBLIC;
	DECLARE aftn byte, (buffer, count) ADDRESS;
	DECLARE bytes BASED buffer BYTE;
	DECLARE actual ADDRESS, i BYTE;

	call aft$window(aftn);
	if (a$access and 2) = 0 or a$empty then
		call warn(CANT$WRITE);
	if a$device = BBDEV then
		return;
	call non$disk$select;

	do while count <> 0;
		do case writeCtrl(a$device);
		do;		/* case 0 */
			call rw(aftn, buffer, count, .actual, FALSE);
			return;
		end;
		do;		/* case 1 */
			call CO(bytes);
			if csts then
			do;
				i = 255;
				do while (i := i - 1) <> 0;
				end;

				if csts then
					if (ci AND 7fh) = CONTROL$S then
						do while (ci AND 7fh) <> CONTROL$Q;
						end;

			end;
		end;
		call po(bytes);		/* case 2 */
		call lo(bytes);		/* case 3 */
		end;

		count = count - 1;
		buffer = buffer + 1;
	end;
	call ioset(iostat);
end;



lined: PROCEDURE(aftn, buffer, count, actual$p) PUBLIC;
	DECLARE aftn BYTE, (buffer, count, actual$p) ADDRESS;
	DECLARE actual BASED actual$p ADDRESS;
	DECLARE lbuf ADDRESS,
		in$mode BYTE,
		lit$mode BYTE,
		lptr BYTE,
		char BYTE,
		i BYTE,		/* note read clobbers selector as well */
		selector BYTE;
	DECLARE obuf BASED buffer (1) BYTE;
	DECLARE bytes BASED lbuf (128) BYTE;
	DECLARE addr BASED lbuf (64) ADDRESS;


	echo: PROCEDURE(char);		/* nested sub of lined */
		DECLARE char BYTE;
		call write(a$edit, .char, 1);
		call aft$window(aftn);
	end;

	lit$mode = FALSE;
	lbuf = aft(aftn).lbuf;
	lptr = bytes(126);
	in$mode = bytes(127);

	do while in$mode;
		call read(aftn, .char, 1, .i);
		if i = 0 then
		do;
			if aftn = AFT$CONSOLE then	/* 11 */
				call err(ABORT, CONSOLE$EOF);
			else
				char = CONTROL$Z;
		end;
		bytes(125) = FALSE;
		char = char AND 7fh;
		if char <> LF then
			call echo(bytes(lptr) := char);

		selector = 0;
		do i = 0 to 9;
			if char = specialChars(i) then
				selector = i;
		end;	
		selector = selector and not lit$mode;
		lit$mode = FALSE;
		do case selector;
			lptr = lptr + 1;	/* case 0 - normal */
			do;			/* case 1, rubout */
				if lptr <> 0 then
				do;
					call echo(bytes(lptr := lptr - 1));
				end;
				else
					call echo(BELL);
			end;
			do;			/* case 2 - control-Z */
				actual = 0;
				bytes(125) = TRUE;
				addr(63) = 0ff00h;
				call echo(CR);
				call echo(LF);
				return;
			end;
			do;			/* case 3 - control-R */
				call echo(CR);
				call echo(LF);
				call write(aft(aftn).edit, lbuf, lptr);
			end;
			do;			/* case 4 - control-X */
				lptr = 0;
				call echo('#');
				call echo(CR);
				call echo(LF);
			end;
			do;			/* case 5 - CR */
				bytes(lptr := lptr + 1) = LF;
				call echo(LF);
				in$mode = FALSE;
				lptr = 0;
			end;
			do;			/* case 6 - LF */
				if lptr <> 0 then
				do;
					call echo(bytes(lptr) := char);
					in$mode = FALSE;
					lptr = 0;
				end;
			end;
			do;			/* case 7 -  ESC */
				call echo(0);
				call echo('$');
				in$mode = FALSE;
				lptr = 0;
			end;
			do;			/* case 8 - Control-E */
				if aftn = AFT$CONSOLE then
				do;
					i = aft(AFT$CONSOLE).device;
					aft(AFT$CONSOLE).device = alt$cidev;
					alt$cidev = i;
					call echo('^');
					call echo('E');
				end;
			end;
			lit$mode = TRUE;	/* case 8 - control-P */
		end; /* of case */
		if lptr = 122 then
		do;
			in$mode = FALSE;
			lptr = 0;
		end;
	end;

	actual = 0;
	do while actual < count and not in$mode;
		if lptr < MAXLL then	/* 122 */
		do;
			if (obuf(actual) := bytes(lptr)) = LF OR bytes(lptr) = ESC then
			do;
				in$mode = TRUE;
				lptr = -1;
			end;

			actual = actual + 1;
			lptr = lptr + 1;
		end;
		else
		do;
			in$mode = TRUE;
			lptr = 0;
		end;
	end;
	bytes(126) = lptr;
	bytes(127) = in$mode;
end;



end;
eof
seek.plm
seek:
do;
$include(seek.ipx)

declare pad byte;

save$pointer$block: PROCEDURE PUBLIC;
	if a$ptr$change then
	do;
		call map$write(a$device);
		call abswrite(a$ptr$blk, a$pbuf);
		a$ptr$change = FALSE;
	end;
end;

rewind:	PROCEDURE PUBLIC;
	a$data$ptr = 128;
	a$ptr$ptr = 1;
	a$blk$seqno = 0;
	a$ptr$change = FALSE;
	a$data$change = FALSE;
	a$data$blk = 0;
	call absread(a$ptr$blk := a$hdr$blk, a$pbuf);
	a$dbuf$read = FALSE;
end;

seek: PROCEDURE(aftn, mode, blockptr, byteptr) PUBLIC;
	DECLARE aftn BYTE, (mode, blockptr, byteptr) ADDRESS;
	DECLARE lowMode BYTE AT (.mode);
	DECLARE blk BASED blockptr ADDRESS, byt BASED byteptr ADDRESS;
	DECLARE plusMinus ADDRESS,
		orig$byte ADDRESS, lo$byte BYTE AT (.orig$byte),
		blockno ADDRESS, temp ADDRESS, forward BYTE;

	if mode > SEEK$EOF then
		call warn(BAD$SEEK$ARG);
	call aft$window(aftn);
	if a$empty then
		call warn(BAD$AFT$NO);

	if a$device = BBDEV then
		return;

	if a$device > F5DEV then
		call warn(NON$DISK$SEEK);

	if a$access = WRITE$MODE then	/* 2 */
		call warn(SEEK$ON$WRITE);

	if lowMode = SEEK$RETURN then	/* 0 - SEEK$RETURN */
	do;
		byt = a$data$ptr;	
		if (blk := a$blk$seqno - 1) = 0FFFFh then
		do;
			blk, byt = 0;
		end;
		return;
	end;
	
	blockno = (blk AND 07fffh) + shr((orig$byte := byt), 7);
	lo$byte = lo$byte and 7fh;
	if lowMode = SEEK$EOF then
	do;
		lowMode = SEEK$ABS;
		lo$byte = a$eof$data$ptr;
		if (blockno := a$blk$count - 1) = 0FFFFh then
		do;
			blockno, lo$byte = 0;
		end;
	end;
	if lowMode = SEEK$ABS then
	do;
		if blockno <> 0 or a$blk$seqno <> 0 or lo$byte <> 0 then
		do;
			blockno = blockno + 1;
		end;
		else
			lo$byte = 128;
		lowMode = SEEK$BACKWARD;
		if blockno > a$blk$seqno then
		do;
			lowMode = SEEK$FORWARD;
			blockno = blockno - a$blk$seqno;
		end;
		else if blockno < a$blk$seqno then
			blockno = a$blk$seqno - blockno;
		else
		do;
			blockno = 0;
			if lo$byte > a$data$ptr then
				lowMode = SEEK$FORWARD;	/* seek within block */
		end;
	end;
	else
	do;
		if lowMode = SEEK$BACKWARD then
			lo$byte = a$data$ptr -lo$byte;
		else
			lo$byte = a$data$ptr + lo$byte;

		if lo$byte > 128 then
		do;
			blockno = blockno + 1;
			lo$byte = lo$byte - 128;
		end;
	end;
	a$data$ptr = lo$byte;
	if (forward := lowMode = SEEK$FORWARD) then
		call adjust$eof;

	do while blockno > 0;
		call save$data$blk;
		a$dbuf$read = FALSE;
		blockno = blockno - 1;
		if forward then
		do;
			plusMinus = 1;
			if a$ptr$ptr = 63 then
			do;
				if (temp := links(FLINK)) = 0 then
				do;
					call chk$eof;
					links(FLINK), temp = get$block(a$device);
					a$ptr$change = TRUE;
					call save$pointer$block;
					call clear$buf(a$pbuf);
					links(BLINK) = a$ptr$blk;
					call abswrite(temp, a$pbuf);
				end;
				else
				do;
					call save$pointer$block;
					call absread(temp, a$pbuf);
				end;
				a$ptr$blk = temp;
				a$ptr$ptr = 1;
			end;
		end;
		else if a$data$ptr = 128 then
		do;
			plusMinus = 0;
			a$data$ptr = 0;
		end;
		else
		do;
			plusMinus = 0FFFFH;	/* -1 */
			if a$ptr$ptr - 1 < 2 then 
				if links(BLINK) <> 0 then
				do;
					call save$pointer$block;
					a$ptr$ptr = 64;
					call absread((a$ptr$blk := links(BLINK)), a$pbuf);
				end;
				else
				do;
					a$ptr$ptr = 1;
					a$blk$seqno = 0;
					goto done;
			
				end;
		end;
		a$blk$seqno = a$blk$seqno + plusMinus;
		call adjust$eof;
		a$ptr$ptr = a$ptr$ptr + low(plusMinus);
	end;

done:
	if a$blk$seqno = 0 AND a$data$ptr <> 128 then
	do;
		a$data$ptr = 128;
		call warn(LONG$BACK$SEEK);
	end;
end;
end;
eof
alloc.plm
alloc:
do;
$include(alloc.ipx)

DECLARE	bitmapBuffer(128) BYTE,
	current$bitmap BYTE PUBLIC INITIAL(0ffh),
	map$change BYTE INITIAL(FALSE),
	baseTrackSector ADDRESS,
	baseSector BYTE AT (.baseTrackSector),
	baseTrack BYTE AT (.baseTrackSector + 1),
	bitmapIndex ADDRESS,
	lowBitMapIndex BYTE AT (.bitmapIndex),
	map$dcb DCB$T INITIAL(80h, 4, 1, 2, 2, .bitmapBuffer),
	current$part BYTE INITIAL(0ffh),
	base$part BYTE INITIAL(0),
	next$part BYTE INITIAL(0),
	bitmapByte$p ADDRESS INITIAL(0),
	(lowBitmapByte$p, highBitmapByte$p) BYTE AT (.bitmapByte$p),
	bitmapByte BASED bitmapByte$p BYTE,
	bitmapBit BYTE,
	command BYTE,
	disk BYTE,
	sectorsPerTrack BYTE;


mapio:	PROCEDURE;
	map$change = FALSE;
	map$dcb.ioins = command;	/* set up command */
	map$dcb.sadr = current$part + 2;
	call diskio(disk, .map$dcb);
end;


map$write: PROCEDURE(diskNum) PUBLIC;
	DECLARE diskNum BYTE;

	command = CMD$WRITE;	
	disk = diskNum;
	if  disk = current$bitmap AND map$change then
		call mapio;
end;

		

map$read: PROCEDURE PUBLIC;
	DECLARE temp BYTE;

	temp = disk <> current$bitmap;
	if current$part <> next$part or temp then
	do;
		if temp then
		do;
			base$part = 0;
			bitmapIndex = 0;
			baseTrackSector = 1;
		end;
		temp = disk;
		call map$write(current$bitmap);
		disk = temp;
		command = CMD$READ;
		current$part = next$part;
		current$bitmap = disk;
		call mapio;
	end;
end;


get$block: PROCEDURE(diskNum) ADDRESS PUBLIC;
	DECLARE diskNum BYTE;
	DECLARE trackSector ADDRESS,
		sector BYTE AT (.trackSector),
		track BYTE AT (.trackSector + 1);

	disk = diskNum;
	sectorsPerTrack = 26;
	if dk$cf$tb(disk) = 1 then
		sectorsPerTrack = 52;

	next$part = base$part;
	if disk <> current$bitmap then
		next$part = 0;
	call map$read;
	bitmapBit = ror(1, lowBitmapIndex and 7);
	do track = baseTrack TO 76;
		do sector = baseSector TO sectorsPerTrack;
			bitmapByte$p = .bitmapBuffer(SHR(bitmapIndex, 3));
			if bitmapByte = 0ffh  AND bitmapBit then	/* no free entry */
			do;
				bitmapIndex = bitmapIndex + 8;
				sector = sector + 7;			/* the do loop adds 1 */
				if sector > sectorsPerTrack then
				do;
					sector = sector - sectorsPerTrack;
					track = track + 1;
					if track > 76 then	
						goto full;
				end;
			end;
			else
			do;
				if ((bitmapBit := ROR(bitmapBit, 1)) AND bitmapByte) = 0 then	/* found a slot */
				do;
					map$change = TRUE;
					bitmapByte = bitmapByte OR bitmapBit;
					base$part = current$part;
					return (baseTrackSector := trackSector);
				end;
				bitmapIndex = bitmapIndex + 1;
			end;
			if bitmapIndex > 03ffh then
			do;
				next$part = current$part + 1;
				call map$read;
				bitmapIndex = 0;
			end;
		end;
		baseSector = 1;	
	end;
full:
	call err(ABORT, DISK$FULL);
end;


free$block: PROCEDURE(diskNum, trackSector) PUBLIC;
	DECLARE disknum BYTE, trackSector ADDRESS;
	DECLARE (sector, track) BYTE AT (.trackSector);
	DECLARE temp BYTE;

	disk = disknum;
	sectorsPerTrack = 26;
	if dk$cf$tb(disk) = 1 then
		sectorsPerTrack = 52;

	bitmapByte$p = track * sectorsPerTrack + sector - 1;
	next$part = shr(highBitmapByte$p, 2);
	if bitmapByte$p < bitmapIndex + shl(double(base$part),10) then
	do;
		base$part = next$part;
		bitmapIndex = bitmapByte$p AND 03ffh;
		baseTrackSector = trackSector;
	end;
	call map$read;
	temp = lowBitmapByte$p;
	bitmapByte$p = .bitmapBuffer(shr(bitmapByte$p and 03ffh, 3));
	bitmapByte = bitmapByte AND not ROR(80h, temp and 7);
	map$change = TRUE;
end;
end;
eof

buffer.plm
buffer:
DO;

/*
	ABSTRACT
		This module contains routines for obtaining, clearing
		releasing and packing buffers of 128 bytes each.

	MODULE ORGANISATION
		This module contains an llocation table ('buffer$table') and
		4 subroutines
		Buffers are allocted in RAM, starting at ".MEMORY" and
		working upwards (to the user's program origin point).
		'buffer$table' contains 19 entries, allowing maximum buffer
		usage for 6 open files (all lined input files, 3 buffers each),
		plus 1 buffer for the console.

	INVARIANTS
		Each entry in 'buffer$table' is initialised to '0'; legal
		values are 0, 1 and 2 with the following meanings
		0 - corresponding buffer is available, but not allocated.
		1 - corresponding buffer is not available, because it is
		    in the current user RAM area
		2 - corresponding buffer is in use.

		Entries change when buffes are obtained or released (via
		get$buf and return$buf), or when then user's program origin
		point is changed (by making a call to the 'load' subroutine).
*/

$include(buffer.ipx)

declare pad byte;

DECLARE buffer$table(19) BYTE PUBLIC INITIAL(0,0,0,0,0,0,0,0,0,0,
					     0,0,0,0,0,0,0,0,0);
clear$buf: PROCEDURE(buf$address) PUBLIC;
	DECLARE buf$address ADDRESS;
	DECLARE buffer BASED buf$address (128) BYTE;
	declare i byte;

	do i = 0 to 127;
		buffer(i) = 0;
	end;
end;

return$buf: PROCEDURE(buf$address) PUBLIC;
	DECLARE buf$address ADDRESS;

	buffer$table(shr(buf$address - .MEMORY, 7)) = 0;
end;


get$buf: PROCEDURE ADDRESS PUBLIC;
	declare i byte;

	do i = 0 to last(buffer$table);
		if buffer$table(i) = 0 then
		do;
			buffer$table(i) = 2;
			return .MEMORY + shl(DOUBLE(i), 7);
		end;
	end;
	call err(ABORT, NO$FREE$BUFFER);	/* 1 */
end;

/*
	ABSTRACT
		This routine reassigns buffer space and moves buffer
		contents as necessary, to ensure that there is no unused
		buffer space below the area occupied by the highest buffer
		in use.


	RETURNS
		The address of the first (lowest) byte in the first
		(lowest) unallocated buffer. THis information is the "top of
		buffer area" described in the mds-dos operator's manual.

	DESCRIPTION
		For every AFT entry which is a currently assigned
		buffer address, the buffer is returned (using 'return$buf')
		and is replace by a new buffer (using 'get$buf'). If the new
		buffer is a different one than the one returned, then the
		data from the old is moved into the new.
*/



pack$aft$buf: PROCEDURE ADDRESS PUBLIC;
	DECLARE (i, j, index) BYTE;
	DECLARE buffer$top ADDRESS;
	DECLARE bptr ADDRESS, bufadr BASED bptr ADDRESS;
	DECLARE new$badr ADDRESS, new$datum BASED new$badr(128) BYTE,
		old$badr ADDRESS, old$datum BASED old$badr(128) BYTE;

	buffer$top = .MEMORY;
	do i = AFT$BOTTOM to AFT$LAST;
		if not aft(i).empty then
		do index = 0 to 2;
			bptr = .aft(i).pbuf - index * 2;
			j = shr(bufadr - .MEMORY, 7);
			if j <= last(buffer$table) and buffer$table(j) = 2 then
			do;
				old$badr = bufadr;
				call return$buf(old$badr);
				new$badr = getbuf;
				if buffer$top < new$badr then
					buffer$top = new$badr;
				if new$badr <> old$badr then
				do;
					do j = 0 to 127;
						new$datum(j) = old$datum(j);
					end;
					bufadr = new$badr;
				end;
			end;
		end;	/* of loop to handle each buffer p, d, l */
	end;	/* of look to traverse aft */
	return buffer$top + 128;
end;
end;
eof

direct.plm
direct:
do;

/*
	ABSTRACT
		All knowledge about the format and location of a diskette
		directory is contained by this module

	Module organisation
		The module contains a data adara, which normally contains
		the information from a single entry in a diskette directory
		and the procedures dir$close and dlook

	Invariants
		On every diskette, the directory file is partitioned into
		'entries' containing 16 bytes of data each.
		The various byte- and address-variables within an entry are
		given descriptive names (see the structure 'direct' below).
		at all times, teh following must be true:

		1.  direct.empty = false => the entry contains meaningful data
		2.  (direct.empty = true(0ffh)) => the directory slot is empty.
		3.  (direct.empty = true(07fh)) => the directory slot and all
		further directory slots are empty;
*/

$include(direct.ipx)

declare pad byte;

DECLARE	direct structure (
	empty	    BOOLEAN,	/* flag to indicate whether directory entry is used */
	file(6)	    BYTE,	/* file name */
	ext(3)	    BYTE,	/* extension */
	attrib	    BYTE,	/* file attributes */
	eof$count   BYTE,	/* character count, last data block */
	blk   	    ADDRESS,	/* number of block in file */
	hdr$blk	    ADDRESS)	/* address of first pointer block */
	PUBLIC;

DECLARE	direct$i$no byte PUBLIC;	/* directory entry pointer */



dir$clos: PROCEDURE(aftn) PUBLIC;
	DECLARE aftn BYTE;

	/*
	    This procedure assumes that aftwindow has been called
	    correctly setting up the appropriate directory slot
	    and that teh dbuffer and pbuffer have correct data
	    but need not be returned to the pool
	*/

	call write(aftn, .direct, size(direct));
	if a$dbuf$read then
		call abswrite(a$data$blk, a$dbuf);	/* both based vars */
end;


dlook: PROCEDURE(fn) BOOLEAN PUBLIC;
	DECLARE fn ADDRESS;
	DECLARE blockno ADDRESS DATA(0);
	DECLARE rcount BYTE;
	/* The location at (rcount + 1) is modified by the procedure read,
	   hence byteno must always follow the declaration of rcount
	*/
	DECLARE byteno ADDRESS;
	DECLARE array based fn(12) BYTE;
	DECLARE (i, aftn) BYTE;
	declare dnum address;
	DECLARE return$value BOOLEAN;

	/*
	  This procedure is used to lookup a file name in a
	  disk directory. The device number of the disk
	  is contained in fn(0), the six characters of the
	  file name are in fn(1) through fn(6), and the
	  three characters of the file extension are in
	  fn(7) through fn(9)

	  The procedure returns 'TRUE' if the file is found,
	  with direct$i$no pointing to the entry of the file in the
	  directory

	  otherwise, the procedure returns 'FALSE', and direct$i$no points
	  at a blank slot in the directory. The directory marker is
	  adjusted so taht it points at the beginning of the entry
	  pointed to by direct$i$no.

	  If the directory is full, direct$i$no = 0ffh
	*/
	aft(aftn := a$device).dbuf = get$buf;
	aft(aftn).pbuf = get$buf;

	call aft$window(aftn);
	call rewind;
	direct$i$no = 0ffh;
	rcount = 1;
	dnum = 0;
	direct.empty, return$value = 0;

	do while rcount <> 0 and direct.empty <> 7fh;
		call read(aftn, .direct, 16, .rcount);
		if direct.empty then
		do;
			if direct$i$no = 0ffh then
				direct$i$no = dnum;
		end;
		else
		do;
			do i = 1 to 9;
			    if array(i) <> direct.file(i - 1) then
				goto skip;
			end;
			direct$i$no = dnum;
			return$value = 0ffh;
			rcount = 0;
		end;
skip:		dnum = dnum + 1;

	end;

	if direct$i$No <> 0ffh then
	do;
		byteno = direct$i$no * size(direct);
		call seek(aftn, SEEK$ABS, .blockno, .byteno);
	end;
	call return$buf(a$dbuf);
	call return$buf(a$pbuf);
	return return$value;
end;
end;
eof

disk2.asm
	CSEG
	public	dkstat	; dk$stat
	public  dkcflg	; dk$cflg
	public	rtype	; r$type
	public	rbyte	; r$byte
	public	strtio	; strt$io
	extrn	dkcont	; disk controller
	extrn	dkcftb	; dk$cf$tb

IOCDR1	equ	0F821h
IOCCOM	equ	0F841h
IOCDR2	equ	0F844h

; controller
NOCONT	equ	0
CONT1	equ	1
CONT2	equ	3
CONTIN	equ	8	; integrated single density

; and their IO port bases (ISD handled separately)
BASE1	equ	78h
BASE2	equ	88h
BASEHD	equ	68h


; IOC INTERFACE COMMANDS
IOCS	equ	0c1h		; IOC INPUT DBB STATUS PORT
IOCC	equ	0c1h		; IOC OUTPUTY CONTROL COMMAND PORT
IOCI	equ	0c0h		; IOC INPUT DATA (FROM DBB) PORT
IOCO	equ	0c0h		; IOC OUTPUT DATA (TO DBB) PORT
F0	equ	00000100B	; FLAG 0 - SLAVE IS BUSY, MASTER IS LOCKED OUT
IBF	equ	00000010B	; SLAVE INPUT BUFFER IS FULL
OBF	equ	00000001B	; SLAVE OUTPUT BUFFER IS FULL
WPBC	equ	15h		; write parameter block command
WPCC	equ	16h		; write parameter block command continuation
WDBC	equ	17h		; write data block command
WDCC	equ	18h		; reserved
RDBC	equ	19h		; read data block command
RDCC	equ	1ah		; reserved
RRSTS	equ	1bh		; read result status command
RDSTS	equ	1ch		; read device status command

; PSEUDO INTERRUPT INSTRUCTIONS
DISABL	equ	0dh		; disable interrupts
ENABL	equ	05h		; enable interrupts
CPUC	equ	0ffh		; port for these instructions

; DISK INSTRUCTIONS
SEEK	equ	1		; seek instruction
FORMAT	equ	2		; format instruction
RECAL	equ	3		; recalibrate instruction
READ	equ	4		; read data instruction
VERIFY	equ	5		; verify crc instruction
WRITE	equ	6		; write data instruction
WRITED	equ	7		; write deleted data instruction

; Layout of the I/O parameter block (IOPB)
;	Only the first five bytes of the IOPB are transmitted to the ISD
;	IOCW	BYTE	channel word
;	IOINS	BYTE	diskette instruction
;	NSEC	BYTE	number of sectors
;	TADR	BYTE	track address
;	SADR	BYTE 	sector address
;	BUF	ADDRESS	buffer address

dkstat:	lda	dkcont
	cpi	0
	rz			; not present
	cpi	CONTIN
	jnz	dkst1		; jump if not isd
	mvi	b, RDSTS	; use bios to get ISD status
	call	IOCDR1
	ret

dkst1:	cpi	CONT2
	jnz	dkst2
	in	BASE2		; controller 2
	ret

dkst2:	in	BASE1		; controller 1
	ret


rtype:	lda	dkcont
	cpi	CONTIN
	jnz	type1		; jump if not isd
	mvi	a,0		; no result type for ISD
	ret

type1:	cpi	CONT2
	jnz	type2
	in	BASE2 + 1	; controller 2
	ret

type2:	in	BASE1 + 1	; controller 1
	ret



rbyte:
	lda	dkcont
	cpi	CONTIN
	jnz	rbyte1		; jump if not isd
	mvi	b, RRSTS	; isd use bios
	call	IOCDR1
	ret

rbyte1:	cpi	CONT2
	jnz	rbyte2
	in	BASE2 + 3	; controller 2
	ret

rbyte2:	in	BASE1 + 3	; controller 1
	ret



dkcflg:	mvi	b,0
	lxi	h,dkcftb
	dad	b
	mov	a,m
	cpi	0
	rz
	cpi	3
	jz	dkt8
	cpi	1
	jz	dkt80
	mov	a,c
	cpi	2
	jnc	dkt3
	mvi	a,1
	ret

dkt3:	mvi	a,3
	ret

dkt8:	mvi	a,8
	ret

dkt80:	mvi	a,80h
	ret

strtio:	lda	dkcont
	cpi	CONTIN
	jnz	strt1		; not isd
	call	isddr		; use standard code
	ret

strt1:	cpi	CONT2
	jnz	strt2
	mov	a, c		; controller 2
	out	BASE2 + 1
	mov	a, b
	out	BASE2 + 2
	jmp	wait

strt2:	mov	a, c		; controller 1
	out	BASE1 + 1
	mov	a, b
	out	BASE1 + 2

wait:	call	dkstat		; wait till i/o done
	ani	4
	jz	wait
	ret

; code is a direct lift from the Intellec series II interface document

;***************************************************************
;* PROCEDURE NAME = ISDDR (IHTEGRATED SINGLE DENSITY DISK DRIVER)
;* PROCESS: TRANSMIT THE IOPB; ONE BYTE AT A TIME, TO THE ISD
;* 	    IF THE INSTRUCTION TO THE OISK IS A OATA TRAHSFER
;*	    (I E READ DATA, FORMAT, WRITE DATA, WRITE DELETED
;*	    DATA) THEN TRAHSFER THE DATA. ONE BYTE AT A TIME
;*	    TO/FROH THE ISD
;* IHPUT:   B-REG COHTAIHS MSB OF IOPB
;*	    C-REG COHTAIHS LSB OF IOPB
;* OUTPUT:  THE IOPB IS TRANSMITTED TO THE ISD DATA IS TRANSFERED
;*	    TO/FROM THE ISD AS REQUIRED
;***************************************************************

isddr:
	push	b		; save the iopb
	inx	b
	ldax	b		; test ioins
	cpi	READ
	jnz	isd1		; jump if not read
	pop	h		; get the iobp
	push	h		; save again
	inx	h
	inx	h
	mov	d, m		; d = number of sectors
	pop	h
	push	d		; save the number of sectors
	call	triopb		; issue the command
	inx	h		; get the buffer address into hl
	mov	e, m
	inx	h
	mov	d, m
	xchg
	mvi	b, RDBC		; issue the read data block command
	call	IOCCOM
	pop	d		; recover the number of sectors	

rdlp1:
	mvi	e, 128		; read a sector (128 bytes)

rdlp2:
	in	IOCS		; wait for byte available
	ani	F0 or IBF or OBF
	cpi	OBF		; test for slave done; somethign for the master
	jnz	rdlp2		; loop until slave is ready
	in	IOCI		; get the byte from the DBB
	mov	m, a		; save to buffer
	inx	h
	dcr	e		; loop for one sector
	jnz	rdlp2
	dcr	d		; loop for number of sectors
	jnz	rdlp1
	mvi	a, ENABL		; enable interrupts
	out	CPUC
	ret
	;----------------------------------------------------------------------
isd1:				; here if not a read so test for
	cpi	FORMAT		; FORMAT, WRITE pr WRITED 
	jz	isd2
	cpi	WRITE
	jz	isd2
	cpi	WRITED
	jnz	isd3		; must be a SEEK, RECALB or VERIFY

isd2:
	pop	h		; recover iopb
	push	h		; save again
	inx	h
	mov	a, m
	cpi	FORMAT
	inx	h
	jz	isd2a		; don't use sector count for format
	mov	c, m		; pick up sector count
	jmp	isd2b

isd2a:
	mvi	c, 1		; format has only single sector

isd2b:
	inx	h
	inx	h
	inx	h
	mov	e, m
	inx	h
	mov	d, m
	xchg			; hl = buffer
	mvi	b, WDBC		; load wite data block command
	call	IOCCOM		; output the command
	call	iocrdy		; wait till slave is idle
	mov	a, c		; number of sectors to be written
	out	IOCO

wrlp1:
	push	psw
	mvi	d, 128		; sector length

wrlp2:
	call	iocrdy		; wait will slave is idle
	mov	a, m		; write the data byte
	out	IOCO
	inx	h		; advance buffer
	dcr	d
	jnz	wrlp2
	pop	psw		; number of sectors
	dcr	a
	jnz	wrlp1		; loop till all written
	mvi	a, ENABL	; enable interrupts
	out	CPUC

isd3:
	pop	h		; hl = iopb
	call	triopb		; send the iopb
	ret

;------
iocrdy:	in	IOCS		; get the status
	ani	F0 or OBF or IBF; look till ready
	jnz	iocrdy
	ret

;***************************************************************
;* Procedure name: TRIOPB (transmit IOPB to ISD)
;* Process: Transmit the IOPB to the 8271 integrated single density
;*	    controller this procedure is called only bu procedure ISDDR
;* Input: HL contains address of the IOPB
;* Output: Transmit the IOPB
;*	   HL points to SADR of IOPB
;* Modified: A, FLAGS, B, C, D, HL
; *
;***************************************************************
triopb:				; transfer$iopb$to$isd
	mov	c, m		; the iocw 
	mvi	b, WPBC		; issue first byte
	call	IOCDR2
	mvi	d, 4		; send the remaining 4 bytes

trloop:
	inx	h		
	mov	c, m
	mvi	b, WPCC
	call	IOCDR2
	dcr	d
	jnz	trloop

trwait:	call	dkstat		; see if the bit indicating operation
	ani	4		; compete is set
	jz	trwait		; loop until done
	ret

	end;

trap.asm

	CSEG
	public	trap
trap:			; exit via mds monitor
	pop	h	; waste the return address
	jmp	0
	end

memck.asm
	CSEG
	public	memck
memck:		
	call	0F81BH
	mov	h, b
	mov	l, a
	ret

	end

reboot.plm
reboot: do;
$include(reboot.ipx)

declare bootLoad DCB$T data(80h, 4, 26, 0, 1, .MEMORY);

reboot: PROCEDURE PUBLIC interrupt 1;
	declare i byte;
	stackptr = .sysstk;
	do i = AFT$BOTTOM to AFT$LAST;
		call close(i);
	end;
	call diskio(0, .bootLoad);
	call jmpto(.MEMORY, stackptr);
end;
end;
upper.plm
toupper: do;
toupper: PROCEDURE(ch) BYTE public;
	DECLARE ch BYTE;
	if ch < 'a' then
		return ch;
	if ch > 'z' then
		return ch;
	return ch AND 0DFh;
end;
end;
